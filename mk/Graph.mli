(*s: Graph.mli *)
(*s: type [[Graph.node]] *)
type node = {
  (* usually a filename *)
  name: string;

  (* mutable because this field can be adjusted later in check_ambiguous
   * and vacuous.
   * Note that this field was called 'prereqs' before, but virtual rules
   * without any prereq still have an arc (with an empty dest,
   * and a recipe), so 'arcs' is a better field name.
   *)
  mutable arcs: arc list;
  (*s: [[Graph.node]] other fields *)
  (* None for inexistent files (and virtual targets).
   * mutable because it will be updated once the target is generated
   * (or when we discover a target is a virtual node).
   *)
  mutable time: float option;
  (*x: [[Graph.node]] other fields *)
  mutable state: build_state;
  (*x: [[Graph.node]] other fields *)
  (* used only for check_cycle for now *)
  mutable visited: bool;
  (*x: [[Graph.node]] other fields *)
  (* used for vacuous *)
  mutable probable: bool;
  (*x: [[Graph.node]] other fields *)
  mutable is_virtual: bool;
  (*e: [[Graph.node]] other fields *)
}
(*e: type [[Graph.node]] *)

(*s: type [[Graph.arc]] *)
  and arc = {
    (* note that because the graph of dependencies is a DAG, multiple
     * arcs may point to the same node. 
     *)
    dest: node option;
    (*s: [[Graph.arc]] other fields *)
    (* what we need from the rule to execute a recipe (and report errors) *)
    rule: Rules.rule_exec;
    (*e: [[Graph.arc]] other fields *)
  }
(*e: type [[Graph.arc]] *)
(*s: type [[Graph.build_state]] *)
  and build_state = 
    | NotMade
    | BeingMade
    | Made
(*e: type [[Graph.build_state]] *)

(*s: type [[Graph.t]] *)
type t = node (* the root *)
(*e: type [[Graph.t]] *)

(*s: signature [[Graph.hnodes]] *)
val hnodes : (string, node) Hashtbl.t
(*e: signature [[Graph.hnodes]] *)

(*s: signature [[Graph.build_graph]] *)
(* !will also modify hnode! *)
val build_graph : string (* target *) -> Rules.rules -> t
(*e: signature [[Graph.build_graph]] *)

(*s: signature [[Graph.update]] *)
(* update time of node once the target node has been generated by a job *)
val update : node -> unit
(*e: signature [[Graph.update]] *)

(*s: signature [[Graph.check_cycle]] *)
(* internals *)
val check_cycle : t -> unit
(*e: signature [[Graph.check_cycle]] *)

(*s: signature [[Graph.check_ambiguous]] *)
(* will also adjust the graph *)
val check_ambiguous : t -> unit
(*e: signature [[Graph.check_ambiguous]] *)

(* internals *)
(*s: signature [[Graph.dump_graph]] *)
(* output graphviz dot file *)
val dump_graph : t -> unit
(*e: signature [[Graph.dump_graph]] *)

(*e: Graph.mli *)
