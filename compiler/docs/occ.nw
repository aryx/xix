\documentclass[12pt]{report}

\input{latex/Packages}
\input{latex/Config}
\input{latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:

%thx to this manual, I better understand 5c/compiler:

%history LP-ization:


\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 C Compiler [[5c]]
}\\
ARM (32 bits) edition\\
OCaml edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Ken Thompson and Yoann Padioleau
}


\maketitle 

\hrule
\begin{quote}
Copyright \copyright{} 2025 Yoann Padioleau \\
Permission is granted to copy, distribute and/or modify this document,
except all the source code it contains, under the terms of the GNU Free
Documentation License, Version 1.3.
\end{quote}
\hrule

\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup

%******************************************************************************
\chapter{Introduction}
%******************************************************************************

#include "Intro.nw"

\section{Code organization}

\section{Software architecture}

\section{Book structure}

%###############################################################################

%******************************************************************************
\chapter{Core Data Structures}
%******************************************************************************

%toc: tokens -> AST -> Typed AST + env -> ASM -> serialized object file

\section{Tokens}

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Constants and identifiers *)*/
/*(*-----------------------------------------*)*/
%token <Ast.loc * string> TName TTypeName
%token <Ast.loc * string * Type.integer_type> TIConst
%token <Ast.loc * string * Type.float_type> TFConst
%token <Ast.loc * string * Type.t> TString
@

% TName vs TTypeName! subtle and problematic! C not context-free!
% need global to remember context

% TString Type.t ??

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Keywords *)*/
/*(*-----------------------------------------*)*/
%token <Ast.loc> Tvoid  Tchar Tshort Tint Tlong  Tdouble Tfloat  
%token <Ast.loc> Tsigned Tunsigned
%token <Ast.loc> Tstruct Tunion Tenum
%token <Ast.loc> Ttypedef
%token <Ast.loc> Tconst Tvolatile  Trestrict Tinline
%token <Ast.loc> Tauto Tstatic Textern Tregister
%token <Ast.loc> Tif Telse  Twhile Tdo  Tfor  Tbreak Tcontinue  Treturn Tgoto
%token <Ast.loc> Tswitch Tcase Tdefault
%token <Ast.loc> Tsizeof
@

% classic: types, qualifiers, storage, stmts, and misc

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Operators *)*/
/*(*-----------------------------------------*)*/
%token <Ast.loc> TPlus TMinus  TMul TDiv TMod
%token <Ast.loc> TEq TEqEq TBang TBangEq
%token <Ast.loc> TAnd TOr TXor TAndAnd TOrOr
%token <Ast.loc> TTilde
%token <Ast.loc> TPlusPlus TMinusMinus
%token <Ast.loc> TInf TSup  TInfEq TSupEq
%token <Ast.loc> TInfInf TSupSup
%token <Ast.loc * Ast.arithOp> TOpEq
@

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Punctuation *)*/
/*(*-----------------------------------------*)*/
%token <Ast.loc> TOPar TCPar  TOBrace TCBrace TOBra TCBra
%token <Ast.loc> TComma TSemicolon 
%token <Ast.loc> TArrow TDot TQuestion TColon
@

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Misc *)*/
/*(*-----------------------------------------*)*/
%token TSharp
%token EOF
@
% TSharp special for cpp preprocessor, see \ref{chap:preprocessing}

\section{Abstract syntax tree} %%: [[Node]]

\subsection{Location and other basic types}

<<type [[Ast.loc]]>>=
(* global linenumber after preprocessing *)
type loc = Location_cpp.loc
@
% See chapter{chap:preprocessing} again.

\subsection{Names and namespaces}

<<type [[Ast.name]]>>=
type name = string
@

<<type [[Ast.blockid]]>>=
(* for scope *)
type blockid = int (* same than Type_.blockid, repeated here for clarity *)
@

<<type [[Ast.fullname]]>>=
(* A fully resolved and scoped name. 
 * 5c uses a reference to a symbol in a symbol table to fully qualify a name.
 * Instead, I use a unique blockid and an external hash or environment that
 * maps this fullname to the appropriate information.
 * I think it offers a better separation of concerns.
 * 
 * 'name' below can be a gensym'ed name for anonymous struct/union/enum.
 *)
type fullname = name * blockid (* same than Type_.fullname *)
@

<<type [[Ast.idkind]]>>=
(* Used in globals.ml/lexer.mll/parser.mly to recognize typedef identifiers.
 * Could be moved in a separate naming.ml, but not worth it for just two types.
 *)
type idkind =
  | IdIdent
  | IdTypedef
  | IdEnumConstant
@

<<global [[Globals.hids]]>>=
(* to recognize typedefs in the lexer *)
let hids: (string, Ast.idkind) Hashtbl.t = 
  Hashtbl.create 101
@
% see section{section:typedef-trick}


<<type [[Ast.tagkind]]>>=
(* to manage the scope of tags *)
type tagkind =
  | TagStruct
  | TagUnion
  | TagEnum
@
% TagEnum is different from EnumConstant! it's to allow 'enum xx'
% as types (but nobody uses that? or enum tag considered a typedef alias?)

<<function [[Ast.tagkind_of_su]]>>=
let tagkind_of_su = function
  | Type.Struct -> TagStruct
  | Type.Union -> TagUnion
@

\subsection{Types}

<<type [[Ast.typ]]>>=
(* What are the differences between typ below and Type.t? 
 * - typedef expansion is not done here
 * - constant expressions are not resolved yet 
 *  (those expressions can involve enum constants which will be resolved later).
 * Again, I think it offers a better separation of concerns.
 * 
 * Note that 'type_' and 'expr' are mutually recursive (because of const_expr).
 * todo: qualifier type
 *)
type typ = {
  t: type_bis;
  t_loc: loc;
}
@

<<type [[Ast.type_bis]]>>=
  and type_bis = 
  | TBase of Type.t (* only the Basic stuff *)
  | TPointer of typ
  | TArray of const_expr option * typ
  | TFunction of function_type

  | TStructName of Type.struct_kind * fullname
  (* In C an enum is really like an int. However, we could do
   * extended checks at some point to do more strict type checking! 
   *)
  | TEnumName of fullname
  | TTypeName of fullname
@
% Type.t later
% function_type later

\subsection{Expressions}

<<type [[Ast.expr]]>>=
and expr = { 
  e: expr_bis;
  e_loc: loc;
  <<[[Ast.expr]] other fields>>
}
@

<<type [[Ast.expr_bis]]>>=
  and expr_bis = 
  (* Note that characters are transformed in Int at parsing time; no need Char *)
  | Int of string * Type.integer_type
  | Float of string * Type.float_type
  (* codegen: converted to Id after typechecking *)
  | String of string * Type.t (* always array of chars for now, no unicode *)

  (* Global, local, parameter, enum constant (can be scoped), function.
   * Not that the storage, type, usage of ids is computed later and stored
   * in external hashtbl.
   * codegen: Id converted to Int when the fullname refers to a enum constant 
   *)
  | Id of fullname

  | Call of expr * argument list

  (* should be a statement really *)
  | Assign of assignOp * expr * expr

  (* codegen: converted to pointer arithmetic, *(x+y) *)
  | ArrayAccess of expr * expr (* x[y] *)
  (* codegen: converted to pointer offset access *)
  | RecordAccess of expr * name (* x.y *)
  (* codegen: converted to RecordAccess, ( *x ).y *)
  | RecordPtAccess of expr * name (* x->y,  and not x.y!! *)

  (* less: bool (* explicit cast (xcast) *) *)
  | Cast of typ * expr

  | Postfix of expr * fixOp
  | Prefix of fixOp * expr
  (* contains GetRef and Deref!! pointers!  *)
  | Unary of unaryOp * expr
  | Binary of expr * binaryOp * expr

  | CondExpr of expr * expr * expr
  (* 'x, y', but really should be a statement, and could be removed.
   * I think mostly used in 'for(...;...;...)' 
   *)
  | Sequence of expr * expr

  (* codegen: converted to Int *)
  | SizeOf of (expr, typ) Either_.t

  (* should appear only in a variable initializer, or after GccConstructor *)
  | ArrayInit of (const_expr option * expr) list
  | RecordInit of (name * expr) list
  (* gccext: kenccext: *)
  | GccConstructor  of typ * expr (* always an ArrayInit (or RecordInit?) *)
@

<<type [[Ast.argument]]>>=
and argument = expr
@

<<type [[Ast.const_expr]]>>=
(* Because we call the preprocessor first, the remaining cases
 * where const_expr is not a constant are basic arithmetic expressions
 * like 2 < < 3, or enum constants.
 *)
and const_expr = expr
@

<<type [[Ast.unaryOp]]>>=
  and unaryOp  = 
    (* less: could be lifted up; those are really important operators *)
    | GetRef | DeRef 
    (* codegen: converted to binary operation with 0 (-x => 0-x) *)
    | UnPlus |  UnMinus 
    (* codegen: converted to -1 ^ x *)
    | Tilde 
    | Not 
@

<<type [[Ast.assignOp]]>>=
  and assignOp = SimpleAssign | OpAssign of arithOp
@

<<type [[Ast.fixOp]]>>=
  and fixOp    = Dec | Inc
@

<<type [[Ast.binaryOp]]>>=
  and binaryOp = Arith of arithOp | Logical of logicalOp
@

<<type [[Ast.arithOp]]>>=
       and arithOp   = 
         | Plus | Minus 
         | Mul | Div | Mod
         | ShiftLeft | ShiftRight 
         | And | Or | Xor
@

<<type [[Ast.logicalOp]]>>=
       and logicalOp = 
         | Inf | Sup | InfEq | SupEq 
         | Eq | NotEq 
         | AndLog | OrLog
@

\subsection{Statements}

<<type [[Ast.stmt]]>>=
type stmt = {
  s: stmt_bis;
  s_loc: loc;
}
@
% no need for type field here, stmt have no type (well it's 'unit' really)

<<type [[Ast.stmt_bis]]>>=
  and stmt_bis = 
  | ExprSt of expr
  (* empty statement is simply Block [] *)
  | Block of stmt list

  (* else is optional and represented as an empty Block *)
  | If of expr * stmt * stmt

  (* expr must have an integer type; it can not be a pointer like in a If *)
  | Switch of expr * case_list

  | While of expr * stmt
  | DoWhile of stmt * expr
  | For of (expr option, var_decl list) Either_.t * 
           expr option * 
           expr option * 
           stmt

  | Return of expr option
  (* no argument to continue or break as in PHP *)
  | Continue | Break

  (* labels have a function scope, so no need to use 'fullname' here *)
  | Label of name * stmt
  | Goto of name

  (* should occur only in Switch *)
  | Case of expr * stmt
  | Default of stmt

  | Var of var_decl
@

<<type [[Ast.case_list]]>>=
(* Can we have a specific case type? It is hard in C because they mix labels
 * and 'case' a lot (see the code in the lexer of 5c).
 *)
and case_list = stmt
@
% ugly? move Case/Default out? 

\subsection{Declarations and definitions}

<<type [[Ast.toplevel]]>>=
type toplevel =
  | StructDef of struct_def
  | TypeDef of type_def
  | EnumDef of enum_def
  (* globals, but also extern decls and prototypes *)
  | VarDecl of var_decl
  | FuncDef of func_def
@

<<type [[Ast.toplevels]]>>=
type toplevels = toplevel list
@

<<type [[Ast.program]]>>=
type program = toplevels * Location_cpp.location_history list
@

\subsubsection{Variables}

<<type [[Ast.var_decl]]>>=
and var_decl = {
  v_name: fullname;
  v_loc: loc;
  v_storage: Storage.t option;
  v_type: typ;
  v_init: initialiser option;
}
@

<<type [[Ast.initialiser]]>>=
 (* can have ArrayInit and RecordInit here in addition to other expr *)
 and initialiser = expr
@

\subsubsection{Functions}

<<type [[Ast.func_def]]>>=
type func_def = {
  (* functions have a global scope; no need for fullname here *)
  f_name: name;
  f_loc: loc;
  (* everything except Param or Auto *)
  f_storage: Storage.t option;
  f_type: function_type;
  (* always a Block *)
  f_body: stmt;
}
@

<<type [[Ast.function_type]]>>=
 and function_type = (typ * (parameter list * bool (* var args '...' *)))
@
% saw already in Ast.type_bis

<<type [[Ast.parameter]]>>=
  and parameter = {
    (* When part of a prototype, the name is not always mentionned, hence
     * the option below.
     * 
     * I use 'fullname' here for consistency; parameters are treated like,
     * locals, so we can have below simply 'Id of fullname' and have 
     * no differences between accessing a local or a parameter.
     *)
    p_name: fullname option;
    p_loc: loc;

    p_type: typ;
  }
@


\subsubsection{Structures and unions}

<<type [[Ast.struct_def]]>>=
(* struct and union *)
type struct_def = {
  su_name: fullname;
  su_loc: loc;
  su_kind: Type.struct_kind;
  (* todo: bitfield annotation *)
  su_flds: field_def list;
}
@

<<type [[Ast.field_def]]>>=
  (* Not the same than var_decl; fields have no storage and can have bitflds.*)
  and field_def = { 
   (* kenccext: anonymous structure element get an artificial field name
    * (see is_gensymed()) 
    *)
    fld_name: name;
    fld_loc: loc;
    fld_type: typ;
  }
@

\subsubsection{Enumerations}

<<type [[Ast.enum_def]]>>=
type enum_def = { 
  (* this name is rarely used; C programmers rarely write 'enum Foo x;' *)
  enum_name: fullname;
  enum_loc: loc;
  enum_constants: enum_constant list;
}
@

<<type [[Ast.enum_constant]]>>=
  and enum_constant = {
  (* we also need to use 'fullname' for constants, to scope them *)
    ecst_name: fullname;
    ecst_loc: loc;
    ecst_value: const_expr option;
  }
@

\subsubsection{Type aliases}

<<type [[Ast.type_def]]>>=
type type_def = { 
  typedef_name: fullname;
  typedef_loc: loc;
  typedef_type: typ;
}
[@@deriving show]
@


\section{Type system}

%trans: seen AST of a type, but then here different. Type system.
% ex of difference: const_expr are resolved!

<<type [[Type.t]]>>=
(* The C type system.
 *
 * There is no Typedef below. The typechecker expands typedefs. 
 * There is no Enum either because variables using enum 
 * (as in 'enum Foo x;') gets their type expanded to an integer type.
 *
 * less: put qualifier here?
 * todoext: Bool! with strict bool checking. 
 * todoext: Enum of fullname with stricter checking.
 *)
type t =
  | Void
  | I of integer_type
  | F of float_type
  | Pointer of t
  (* Why not unsugar Array to Pointer? Because the type system checks 
   * for some array incompatibilities. int[2] != int[3].
   * However, the Array type usually gets converted to Pointer
   * during typechecking.
   *)
  | Array of int option * t
  | Func of t * t list * bool (* varargs '...' *)
  | StructName of struct_kind * fullname
@

<<[[Ast.expr]] other fields>>=
(* properly set during typechecking in typecheck.ml *)
e_type: Type.t;
@


<<type [[Type.integer_type]]>>=
  and integer_type = integer_kind * sign
@

<<type [[Type.integer_kind]]>>=
    and integer_kind = 
    | Char
    | Short
    | Int
    | Long
    | VLong
@

<<type [[Type.sign]]>>=
    and sign = Signed | Unsigned
@

<<type [[Type.float_type]]>>=
  and float_type = 
  | Float
  | Double
@

<<type [[Type.struct_kind]]>>=
 and struct_kind = Struct | Union
@

<<type [[Type.qualifier]]>>=
type qualifier = 
  | Volatile
  | Const
  (* less: unsupported: | Restrict | Inline *)
@

<<type [[Type.structdef]]>>=
(* note that the field can be gensym'ed for anonymous struct/union elements *)
(* todo: bitfield *)
type structdef = (string * t) list
@


<<constant [[Type.int]]>>=
let int = I (Int, Signed)
@

<<constant [[Type.long]]>>=
let long = I (Long, Signed)
@
% int vs long! subtle! but on 64 bits arch long is actually 64 bits!
% so in goken they actually did lots of s/long/int32 to fix it
% because the previous assumption that long was 32 bits was now wrong.

<<type [[Type.blockid]]>>=
type blockid = int
@

<<type [[Type.fullname]]>>=
type fullname = string * blockid
@

\section{Storage class}%[[Storage_class]]

<<type [[Storage.t]]>>=
(* No Typedef here, because a typedef is not a storage! *) 
type t =
  | Local  (* local *)
  | Param  (* parameter *)
  | Extern (* public global defined elsewhere *)
  | Global (* public global defined here *)
  | Static (* Private global less: could rename Private *)
  (* less:  | Inline? | Register? | ExternRegister? *)
@


%%\section{Node and type attributes}

%%\section{[[Sym]]bols and [[hash]] table}
%%\subsection{[[Sym]]}
%%\subsection{[[hash]]}
%%\subsection{[[slookup()]] and [[lookup()]]}
%%\subsection{Identifier symbols}
%%\subsection{Tag symbols}
%%\subsection{Other symbols}
%%\section{Declarations, namespaces, and scope}%%: [[Decl]]

\section{Frontend result: typed entities}

%TODO: Typecheck.result? with alt: Frontend.result ?

<<type [[CLI.frontend_result]]>>=
@

<<type [[Typecheck.idinfo]]>>=
type idinfo = {
    typ: Type.t;
    sto: Storage.t;
    loc: Location_cpp.loc;
    (* typed initialisers (fake expression for function definitions) *)
    ini: Ast.initialiser option;
  }
@



\section{Backend result: assembly instructions}

% see Ast_Asm.ml and Ast_asm5.ml in \book{Assembler} (and also \book{Linker}).


%******************************************************************************
\chapter{Main functions}
%******************************************************************************
\label{chap:main}

\section{[[main()]]}

<<toplevel [[Main._1]]>>=
let _ = 
  Cap.main (fun (caps : Cap.all_caps) ->
     let argv = CapSys.argv caps in
     Exit.exit caps 
        (Exit.catch (fun () -> 
            CLI.main caps argv))
  )
@


<<type [[CLI.caps]]>>=
(* Need:
 * - open_in: for argv derived file but also for #include'd files
 *   because 5c does its own preprocessing
 * - open_out for -o object file or 5.argv[0]
 * - env: for INCLUDE (for cpp)
 *)
type caps = < Cap.open_in; Cap.open_out; Cap.env >
@

<<signature [[CLI.main]]>>=
(* entry point (can also raise Exit.ExitCode) *)
val main: <caps; ..> ->
  string array -> Exit.t
@

<<function [[CLI.main]]>>=
let main (caps : <caps; ..>) (argv : string array) : Exit.t =

  let arch = 
    match Filename.basename argv.(0) with
    | "o5c" -> Arch.Arm
    | "ovc" -> Arch.Mips
    | s -> failwith (spf "arch could not detected from argv0 %s" s)
  in

  let thechar = Arch.thechar arch in
  let thestring = Arch.thestring arch in

  let usage = 
    spf "usage: %s [-options] file.c" argv.(0)
  in

  (* in *)
  let args = ref [] in
  (* out *)
  let outfile = ref "" in

  (* for cpp *)
  let include_paths : Fpath.t list ref = ref [] in
  let macro_defs = ref [] in

  (* Ansi Posix Environment for plan9 *)
  let ape = ref false in 

  let level = ref (Some Logs.Warning) in
  (* for debugging *)
  let action = ref "" in
  let backtrace = ref false in

  let options = [
    "-o", Arg.Set_string outfile,
    " <file> place output (an object) in file";

    "-D", Arg.String (fun s ->
      let (var, val_) = 
        if s =~ "\\(.*\\)=\\(.*\\)"
        then Regexp_.matched2 s
        else (s, "1")
      in
      macro_defs := (var, val_)::!macro_defs
    ), " <name=def> (or just <name>) define name for preprocessor";
    "-I", Arg.String (fun s ->
      include_paths := Fpath.v s::!include_paths
    ), " <dir> add dir as a path to look for '#include <file>' files";
    "-ape", Arg.Set ape,
    " ";

    "-w", Arg.Set Flags.warn,
    " enable warnings";
    "-werror", Arg.Set Flags.warnerror,
    " warnings generate error exceptions";

    "-S", Arg.Set Flags.dump_asm,
    " dump the generated assembly";

    "-e", Arg.Set Flags_cpp.debug_include, " ";
    "-f", Arg.Set Flags_cpp.debug_line, " ";
    "-m", Arg.Set Flags_cpp.debug_macros, " ";

    "-v", Arg.Unit (fun () -> level := Some Logs.Info),
     " verbose mode";
    "-verbose", Arg.Unit (fun () -> level := Some Logs.Info),
    " verbose mode";
    "-debug", Arg.Unit (fun () -> level := Some Logs.Debug),
    " guess what";
    "-quiet", Arg.Unit (fun () -> level := None),
    " ";

    (* pad: I added long names for those options *)
    "-debug_include", Arg.Set Flags_cpp.debug_include, " ";
    "-debug_line",      Arg.Set Flags_cpp.debug_line, " ";
    "-debug_macros",    Arg.Set Flags_cpp.debug_macros, " ";

    (* pad: I added that *)
    "-test_parser", Arg.Unit (fun () -> action := "-test_parser"), " ";

    (* pad: I added that *)
    "-dump_tokens", Arg.Set Flags.dump_tokens,
    " dump the tokens as they are generated";
    "-dump_ast", Arg.Set Flags.dump_ast,
    " dump the parsed AST";
    "-dump_typed_ast", Arg.Set Flags.dump_typed_ast,
    " dump the typed AST";
    "-dump_asm", Arg.Set Flags.dump_asm,
    " dump the generated assembly";

    (* pad: I added that *)
    "-backtrace", Arg.Set backtrace,
    " dump the backtrace after an error";
  ] |> Arg.align
  in
  (try
    Arg.parse_argv argv options (fun t -> 
      args := t::!args
    ) usage;
  with
  | Arg.Bad msg -> UConsole.eprint msg; raise (Exit.ExitCode 2)
  | Arg.Help msg -> UConsole.print msg; raise (Exit.ExitCode 0)
  );
  Logs_.setup !level ();
  Logs.info (fun m -> m "assembler ran from %s" (Sys.getcwd()));

  (* less: process the old style -Dname=val and -Idir attached *)

  (* to test and debug components of mk *)
  if !action <> "" then begin 
    do_action caps thestring !action (List.rev !args); 
    raise (Exit.ExitCode 0 )
  end;

  try 
    (match !args, !outfile with
    | [], "" -> 
        Arg.usage options usage;
        Exit.Code 1
    | [cfile], outfile ->
        let base = Filename.basename cfile in
        let system_paths : Fpath.t list =
          (try CapSys.getenv caps "INCLUDE" |> Str.split (Str.regexp "[ \t]+")
          with Not_found ->
            [spf "/%s/include" thestring; 
             "/sys/include";
            ] |> (fun xs -> if !ape then "/sys/include/ape"::xs else xs)
          ) |> Fpath_.of_strings
        in
        
        let outfile : Fpath.t = 
          (if outfile = ""
          then
            if base =~ "\\(.*\\)\\.c"
            then Regexp_.matched1 base ^ (spf ".%c" thechar)
            else base ^ (spf ".%c" thechar)
          else outfile
          ) |> Fpath.v
        in
        let conf = Preprocessor.{
          defs = !macro_defs;
          (* this order? *)
          paths = system_paths @ List.rev !include_paths;
          dir_source_file = Fpath.v (Filename.dirname cfile);
        }
        in
        outfile |> FS.with_open_out caps (fun chan ->
          compile caps conf arch (Fpath.v cfile) chan
        );
        Exit.OK
    | _ -> 
      (* stricter: *)
        failwith 
          "compiling multiple files at the same time is not supported; use mk"
    )
  with exn ->
    if !backtrace
    then raise exn
    else 
      (match exn with
      | Failure s -> 
          (* useful to indicate that error comes from 5c? *)
          Error.errorexit (spf "%cc: %s" thechar s)
      | Location_cpp.Error (s, loc) ->
          (* less: could use final_loc_and_includers_of_loc loc *)
          let (file, line) = Location_cpp.final_loc_of_loc loc in
          Error.errorexit (spf "%s:%d %s" !!file line s)
      (* ocaml-light: | Check.Error err | Typecheck.Error err | Eval_const.Error err | Codegen5.Error err  *)
      | Check.Error err -> Error.errorexit (Check.string_of_error err)
      | Typecheck.Error err -> Error.errorexit (Check.string_of_error err)
      | Eval_const.Error err -> Error.errorexit (Check.string_of_error err)
      | Codegen5.Error err -> Error.errorexit (Check.string_of_error err)
      | _ -> raise exn
      )
@


\section{Arguments processing}

\section{[[compile()]]}

<<signature [[CLI.compile]]>>=
(* main algorithm; works by side effect on outfile *)
val compile: < Cap.open_in; .. > ->
  Preprocessor.conf -> Arch.t -> Fpath.t (* infile *) -> Chan.o (* outfile *) ->
  unit
@

<<function [[CLI.compile]]>>=
let compile (caps : < Cap.open_in; ..>) (conf : Preprocessor.conf) (arch : Arch.t) (infile : Fpath.t) (outfile : Chan.o) : unit =
  match arch with
  | Arch.Arm -> compile5 caps conf infile outfile
  | _ -> 
   failwith (spf "TODO: arch not supported yet: %s" (Arch.thestring arch))
@

<<function [[CLI.compile5]]>>=
let compile5 (caps : < Cap.open_in; ..>) (conf : Preprocessor.conf)
    (infile : Fpath.t) (outfile : Chan.o) =
  let tast : Typecheck.typed_program = frontend caps conf infile in
  backend5 tast outfile
@

\section{Frontend}


<<function [[CLI.frontend]]>>=
let frontend (caps : < Cap.open_in; .. >) (conf : Preprocessor.conf) (infile : Fpath.t) : Typecheck.typed_program =

  let ast = Parse.parse caps conf infile in

  (* debug *)
  if !Flags.dump_ast
  then Logs.app (fun m -> m "%s" (Dumper_.s_of_any (Ast.Program ast)));

  (* use/def checking, unused entity, redefinitions, etc. *)
  Check.check_program ast;
  (* typedef expansion, type and storage resolution, etc. *)
  let typed_program : Typecheck.typed_program = 
    Typecheck.check_and_annotate_program ast 
  in
  
  (* debug *)
  if !Flags.dump_typed_ast
  then begin 
    typed_program.ids |> Hashtbl.iter (fun k v ->
      match v.Typecheck.sto with
      | Storage.Global | Storage.Static ->
        Logs.app (fun m -> m "%s" (Ast.unwrap k));
        Logs.app (fun m -> m "%s" (Dumper_.s_of_any (Ast.FinalType v.Typecheck.typ)));
      | _ -> ()
    );
    typed_program.funcs |> List.iter (fun func ->
      Logs.app (fun m -> m "%s" (Dumper_.s_of_any_with_types (Ast.Toplevel (Ast.FuncDef func))))
    );
  end;
  typed_program
@

\section{Backend}

<<function [[CLI.backend5]]>>=
let backend5 (tast : Typecheck.typed_program)  (chan : Chan.o) : unit =
  (* todo: Rewrite.rewrite *)
  let (asm, _locs) = Codegen5.codegen tast in

  if !Flags.dump_asm
  then begin
    let pc = ref 0 in
    asm |> List.iter (fun (instr, _loc) ->
      (* less: use a assembly pretty printer instead? easier to debug? 5c -S *)
      let v = Meta_ast_asm5.vof_line instr in
      Logs.app (fun m -> m  "%2d: %s" !pc (OCaml.string_of_v v));
      incr pc;
    );
  end;
  Object_file.save Arch.Arm (asm, !Location_cpp.history) chan
@

<<signature [[Codegen5.codegen]]>>=
(* can raise Error *)
val codegen: 
  Typecheck.typed_program ->  Ast_asm5.program
@

%%\section{[[gclean()]]}

%%\section{Initializations}
%%\subsection{[[tinit()]]}
%%\subsection{[[cinit()]]}
%%\subsection{[[ginit()]]}
%%\subsection{[[arginit()]]}

%******************************************************************************
%%\chapter{Input}
%******************************************************************************
%%\section{Files management: [[iostack]]}
%%\section{Buffer management: [[fi]]}
%%\section{[[GETC()]]}

%******************************************************************************
%alt:\chapter{Frontend}
%******************************************************************************

%******************************************************************************
\chapter{Lexing}
%******************************************************************************
\label{chap:lexing}


\section{Overview}

<<Lexer.mll>>=
{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Regexp_.Operators

open Parser
module A = Ast
module L = Location_cpp
module T = Type

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Limitations compared to 5c:
 *  - no L"" and L'' unicode strings or unicode characters
 *  - no \x hexadecimal escape sequence in strings or characters
 *  - no unicode identifier
 *  - no typestr
 *    (seems dead extension anyway)
 *  - no signof
 * 
 * todo: handle big numbers here? or let later phases do that?
 *  check for overflow, truncation, sign-extended character constant, etc
 *  see yyerror and warn in Compiler.nw
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Lexer.error]]>>
<<function [[Lexer.loc]]>>
<<function [[Lexer.inttype_of_suffix]]>>
<<function [[Lexer.floattype_of_suffix]]>>
(* dup: lexer_asm5.mll *)
<<function [[Lexer.code_of_escape_char]]>>
(* dup: lexer_asm5.mll *)
<<function [[Lexer.string_of_ascii]]>>
<<function [[Lexer.char_]]>>
}

(*****************************************************************************)
(* Regexps aliases *)
(*****************************************************************************)
<<constant [[Lexer.space]]>>
<<constant [[Lexer.letter]]>>
<<constant [[Lexer.digit]]>>
<<constant [[Lexer.oct]]>>
<<constant [[Lexer.hex]]>>

(*****************************************************************************)
(* Main rule *)
(*****************************************************************************)
<<rule [[Lexer.token]]>>

(*****************************************************************************)
(* String rule *)
(*****************************************************************************)
<<rule [[Lexer.string]]>>

(*****************************************************************************)
(* Character rule *)
(*****************************************************************************)
<<rule [[Lexer.char]]>>

(*****************************************************************************)
(* Comment rule *)
(*****************************************************************************)

(* dup: lexer_asm5.mll *)
<<rule [[Lexer.comment]]>>
@

%%\section{[[yylex()]]}
%%\section{Peek, seek, and look ahead}


<<rule [[Lexer.token]]>>=
rule token = parse
  (* ----------------------------------------------------------------------- *)
  (* Spacing/comments *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] space/comment cases>>

  (* ----------------------------------------------------------------------- *)
  (* Symbols *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] symbol cases>>

  (* ----------------------------------------------------------------------- *)
  (* Numbers *)
  (* ----------------------------------------------------------------------- *)
  (* dup: lexer_asm5.mll *)
  <<[[Lexer.token]] number cases>>

  (* ----------------------------------------------------------------------- *)
  (* Chars/Strings *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] chars/strings cases>>

  (* ----------------------------------------------------------------------- *)
  (* Keywords and identifiers *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] keywords/identifiers cases>>

  (* ----------------------------------------------------------------------- *)
  (* CPP *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] cpp cases>>

  (* ----------------------------------------------------------------------- *)
  | eof { EOF }
  | _ (*as c*)   { let c = char_ lexbuf in
                   error (spf "unrecognized character: '%c'" c) }
@

<<function [[Lexer.error]]>>=
let error s =
  raise (L.Error (spf "Lexical error: %s" s, !L.line))
@


<<[[Lexer.token]] cpp cases>>=
(* See ../macroprocessor/lexer_cpp.mll *)
| "#" { TSharp }
@


<<function [[Lexer.loc]]>>=
let loc () = !L.line
@


<<function [[Lexer.char_]]>>=
(* needed only because of ocamllex limitations in ocaml-light
 * which does not support the 'as' feature.
 *)
let char_ lexbuf =
  let s = Lexing.lexeme lexbuf in
  String.get s 0
@

\section{Comments and spaces}

<<constant [[Lexer.space]]>>=
let space = [' ''\t']
@

<<[[Lexer.token]] space/comment cases>>=
| [' ''\t']+    { token lexbuf }
| "//" [^'\n']* { token lexbuf }
| "/*"          { comment lexbuf }

| '\n'          { incr Location_cpp.line; token lexbuf }
@

<<rule [[Lexer.comment]]>>=
and comment = parse
  | "*/"          { token lexbuf }
  | [^ '*' '\n']+ { comment lexbuf }
  | '*'           { comment lexbuf }
  | '\n'          { incr Location_cpp.line; comment lexbuf }
  | eof           { error "eof in comment" }
@

\section{Keywords and identifiers}

<<constant [[Lexer.letter]]>>=
let letter = ['a'-'z''A'-'Z']
@
<<constant [[Lexer.digit]]>>=
let digit = ['0'-'9']
@

<<[[Lexer.token]] keywords/identifiers cases>>=
| (letter | '_') (letter | digit | '_')* {
    let s = Lexing.lexeme lexbuf in
    match s with
    | "static" -> Tstatic (loc()) 
    | "extern" -> Textern (loc())
    (* we could forbid those constructs; they are not really useful *)
    | "auto" -> Tauto (loc()) 
    | "register" -> Tregister (loc())

    | "const" -> Tconst (loc()) | "volatile" -> Tvolatile (loc())
    | "inline" -> Tinline (loc()) | "restrict" -> Trestrict (loc())

    | "void" -> Tvoid (loc())
    | "char" -> Tchar (loc()) | "short" -> Tshort (loc()) 
    | "int"  -> Tint  (loc()) | "long"  -> Tlong  (loc())
    | "float"  -> Tfloat  (loc()) | "double"   -> Tdouble   (loc())

    | "signed" -> Tsigned (loc()) | "unsigned" -> Tunsigned (loc())

    | "struct" -> Tstruct (loc()) | "union" -> Tunion (loc()) 
    | "enum" -> Tenum (loc())
    | "typedef" -> Ttypedef (loc())

    | "if" -> Tif (loc()) | "else" -> Telse (loc())
    | "while" -> Twhile (loc()) | "do" -> Tdo (loc()) | "for" -> Tfor (loc())
    | "break" -> Tbreak (loc()) | "continue" -> Tcontinue (loc())
    | "switch" -> Tswitch (loc()) 
    | "case" -> Tcase (loc()) | "default" -> Tdefault (loc())
    | "return" -> Treturn (loc()) | "goto" -> Tgoto (loc())

    | "sizeof" -> Tsizeof (loc())
    (* less: USED/SET here? or manage via symbol table *)

    | _ ->
      if Hashtbl.mem Globals.hids s
      then 
        (* typedef trick, because ambiguity in C grammar *)
        (match Hashtbl.find Globals.hids s with
        | A.IdIdent | A.IdEnumConstant -> TName (loc(), s)
        | A.IdTypedef -> TTypeName (loc(), s)
        )
      else TName (loc(), s)
}
@

\subsection{Unicode identifiers}

\subsection{Typedef trick}
\label{section:typedef-trick}

\section{Operators}

<<[[Lexer.token]] symbol cases>>=
| "+" { TPlus (loc()) } | "-" { TMinus (loc()) }
| "*" { TMul  (loc()) } | "/" { TDiv   (loc()) } | "%" { TMod (loc()) }

| "&"  { TAnd  (loc()) }  | "|"  { TOr     (loc()) } | "^" { TXor (loc()) }
| "<<" { TInfInf (* TLsh *) (loc()) } | ">>" { TSupSup (* TRsh *) (loc()) }
| "~"  { TTilde  (loc()) }

| "&&" { TAndAnd (loc()) } | "||" { TOrOr (loc()) }
| "!"  { TBang   (loc()) }

| "++" { TPlusPlus (loc()) } | "--" { TMinusMinus (loc()) }

| "="  { TEq   (loc()) }
| "==" { TEqEq (loc()) }  | "!=" { TBangEq (loc()) }

| "+=" { TOpEq (loc(), A.Plus) } | "-=" { TOpEq (loc(), A.Minus) }
| "*=" { TOpEq (loc(), A.Mul) }  | "/=" { TOpEq (loc(), A.Div) }
| "%=" { TOpEq (loc(), A.Mod) }
| "&=" { TOpEq (loc(), A.And) }        | "|="  { TOpEq (loc(), A.Or) }
| "^=" { TOpEq (loc(), A.Xor) }
| ">>="{ TOpEq (loc(), A.ShiftRight) } | "<<=" { TOpEq (loc(), A.ShiftLeft) }

| "<"  { TInf   (loc()) } | ">"  { TSup   (loc()) }
| "<=" { TInfEq (loc()) } | ">=" { TSupEq (loc()) }

| "(" { TOPar   (loc()) } | ")" { TCPar   (loc()) }
| "{" { TOBrace (loc()) } | "}" { TCBrace (loc()) }
| "[" { TOBra   (loc()) } | "]" { TCBra   (loc()) }
           
| ","  { TComma (loc()) } | ";"  { TSemicolon (loc()) }
| "->" { TArrow (loc()) }
| "."  { TDot   (loc()) }
| "?"  { TQuestion (loc()) }
| ":"  { TColon    (loc()) }
@

\section{Numbers}

<<[[Lexer.token]] number cases>>=
| "0"  (oct+ (*as s*)) (['U''u']? (*as unsigned*)) (['L''l']* (*as long*))
    { let (s, unsigned, long) = 
         let s = Lexing.lexeme lexbuf in
         s =~ "0\\([0-7]+\\)\\([Uu]?\\)\\([Ll]*\\)" |> ignore;
         Regexp_.matched3 s
      in
      TIConst(loc(), "0o" ^ s, inttype_of_suffix unsigned long)}
| "0x" (hex+ (*as s*))  (['U''u']? (*as unsigned*)) (['L''l']* (*as long*))
    { let (s, unsigned, long) = 
         let s = Lexing.lexeme lexbuf in
         s =~ "0x\\([0-9A-Fa-f]+\\)\\([Uu]?\\)\\([Ll]*\\)" |> ignore;
         Regexp_.matched3 s
      in
      TIConst(loc(), "0x" ^ s, inttype_of_suffix unsigned long)}
| "0x" { error "malformed hex constant" }
| (['0'-'9'] digit*) (*as s*) (['U''u']? (*as unsigned*)) (['L''l']* (*as long*))
    { let (s, unsigned, long) = 
         let s = Lexing.lexeme lexbuf in
         s =~ "\\([0-9]+\\)\\([Uu]?\\)\\([Ll]*\\)" |> ignore;
         Regexp_.matched3 s
      in
      TIConst (loc(), s, inttype_of_suffix unsigned long)}

(* stricter: I impose some digit+ after '.' and after 'e' *)
| ((digit+ | digit* '.' digit+) (['e''E'] ('+' | '-')? digit+)?) (*as s*)
    (['F''f']* (*as float*))
   { let (s, float) =
        let s = Lexing.lexeme lexbuf in
        s =~ "\\([^Ff]+\\)\\([Ff]*\\)$" |> ignore;
        Regexp_.matched2 s
      in
      TFConst (loc(), s, floattype_of_suffix float) }

(* special regexp for better error message *)
| (digit+ | digit* '.' digit+) ['e''E'] ('+' | '-')?
   { error "malformed fp constant exponent" }
@



\subsection{Decimals}

%%\subsection{[[convvtox()]]}

\subsection{Hexadecimals and octals}

<<constant [[Lexer.oct]]>>=
let oct = ['0'-'7']
@

<<constant [[Lexer.hex]]>>=
let hex = (digit | ['A'-'F''a'-'f'])
@


\subsection{Unsigned numbers}

<<function [[Lexer.inttype_of_suffix]]>>=
let inttype_of_suffix sign size =
  let sign =
    match String.lowercase_ascii sign with
      | "" -> T.Signed
      | "u" -> T.Unsigned
      | s -> error (spf "Impossible: wrong sign suffix: %s" s)
  in
  match String.lowercase_ascii size with
  | "" -> T.Int, sign
  | "l" -> T.Long, sign
  | "ll" -> T.VLong, sign
  | s -> error (spf "Impossible: wrong int size suffix: %s" s)
@

\subsection{Long numbers}

\subsection{Floats}

<<function [[Lexer.floattype_of_suffix]]>>=
let floattype_of_suffix s =
  match String.lowercase_ascii s with
  | "" -> T.Double
  | "f" -> T.Float
  | s -> error (spf "Impossible: wrong float size suffix: %s" s)
@

\section{Characters}

<<[[Lexer.token]] chars/strings cases>>=
(* converting characters in integers *)
| "'" { TIConst (loc(), spf "%d" (char lexbuf), (T.Char, T.Signed)) }
@

<<rule [[Lexer.char]]>>=
and char = parse
  | "''"                            { Char.code '\'' }
  (* less: 5c allows up to 8 octal number when in L'' mode *)
  | "\\" ((oct oct? oct?) (*as s*)) "'" 
      { let s = Lexing.lexeme lexbuf |>
           String_.drop_prefix 1 |> String_.drop_suffix 1
        in
        int_of_string ("0o" ^ s) }
  | "\\" (['a'-'z' '\\' '\''] (*as c*)) "'"       
      { let c = String.get (Lexing.lexeme lexbuf) 1 in
        code_of_escape_char c }
  | '\\' '\n' { char lexbuf }
  | [^ '\\' '\'' '\n'] (*as c*)  "'"    
      { let c = String.get (Lexing.lexeme lexbuf) 0 in
        Char.code c }
  | '\n' { error "newline in character" }
  | eof  { error "end of file in character" }
  | _    { error "missing '" }
@


\subsection{Escaping characters}

<<function [[Lexer.code_of_escape_char]]>>=
let code_of_escape_char c =
  match c with
  | 'n' -> Char.code '\n' | 'r' -> Char.code '\r' 
  | 't' -> Char.code '\t' | 'b' -> Char.code '\b' 

  (* compatibility with plan 9 C code? *)
  | 'f' -> Logs.err (fun m -> m "unknown \\f"); 0x00
  (* could be removed, special 5c escape char *)
  | 'a' -> 0x07 | 'v' -> 0x0b 

  | '\\' | '\'' | '"' -> Char.code c 
  (* stricter: we disallow \ with unknown character *)
  | _ -> error "unknown escape sequence"
@

\subsection{Unicode characters}

\section{Strings}

<<[[Lexer.token]] chars/strings cases>>=
| '"' { TString (loc(), string lexbuf, T.Array (None, T.I (T.Char,T.Signed)))}
@

<<rule [[Lexer.string]]>>=
and string = parse
  | '"' { "" }
  | "\\" ((oct oct oct) (*as s*))
      { let s = Lexing.lexeme lexbuf |> String_.drop_prefix 1 in
        let i = int_of_string ("0o" ^ s) in string_of_ascii i ^ string lexbuf }
  | "\\" (['a'-'z' '\\' '"'] (*as c*)) 
      { let c = String.get (Lexing.lexeme lexbuf) 1 in
        let i = code_of_escape_char c in string_of_ascii i ^ string lexbuf  }
  (* strings can contain newline! but they must be escaped before *)
  | '\\' '\n' { "\n" ^ string lexbuf }
  | [^ '\\' '"' '\n']+   
      { let x = Lexing.lexeme lexbuf in x ^ string lexbuf }
  | '\n' { error "newline in string" }
  | eof  { error "end of file in string" }
  | _    { error "undefined character in string" }
@

<<function [[Lexer.string_of_ascii]]>>=
let string_of_ascii i =
  String.make 1 (Char.chr i)
@

\subsection{Unicode strings}

%******************************************************************************
\chapter{Parsing}
%******************************************************************************
\label{chap:parsing}

\section{Overview}

<<signature [[Parse.parse]]>>=
(* will call cpp internally first *)
val parse: 
  < Cap.open_in; .. > -> Preprocessor.conf -> Fpath.t -> Ast.program
@

% but see later in \ref{chap:preprocessing}. For now let's simplify
% and assume no cpp:

<<signature [[Parse.parse_no_cpp]]>>=
(* internals *)
val parse_no_cpp:
  Chan.i -> Ast.program
@

<<function [[Parse.parse_no_cpp]]>>=
let parse_no_cpp (chan : Chan.i) =
  L.line := 1;
  let lexbuf = Lexing.from_channel chan.ic in
  (try 
      Parser.prog Lexer.token lexbuf, []
    with Parsing.Parse_error ->
        failwith (spf "Syntax error: line %d" !L.line)
  )
@



<<Parser.mly>>=
%{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast
module T = Type
module L = Location_cpp

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* The original 5c does many things during parsing; Instead, we 
 * do the minimum here. We just return a very simple AST.
 * 
 * Limitations compared to 5c (and sometimes also to ANSI C or C11):
 *  - no support for old style parameter declaration
 *    (obsolete practice anyway)
 *  - impose a certain order for the storage, qualifier, and type
 *    (everybody follow this convention anyway)
 *  - no implicit single 'signed' means 'signed int'. 
 *    Signed has to have an explicit int-type after.
 *  - sure? forbid definitions (typedefs, struct, enum) not at toplevel
 *    (confusing anyway?)
 *    (but then would no need blockid for those, or just for nested struct def)
 *  - forbid typedefs inside forexpr
 *    (who uses that anyway?)
 *  - can not mix qualified and not qualified elements in initializers lists
 * 
 * todo: 
 *  - add qualifiers in AST
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Parser.error]]>>
<<function [[Parser.mk_e]]>>
<<function [[Parser.mk_t]]>>
<<function [[Parser.mk_st]]>>


(* 'defs' contains things we lift up in the AST (struct defs, enums, typedefs).
 * Note that we tag those defs with a blockid, so there is no escape-scope
 * problem.
 *)
let defs =
  ref []

let get_and_reset x =
  let v = !x in
  x := [];
  v

(* to manage scope (used notably to recognize typedefs in the lexer) *)
type env = {
  (* there are mainly two namespaces in C: one for ids and one for tags *)
  ids:  (string, idkind * Ast.blockid) Hashtbl.t;
  tags: (string, tagkind * Ast.blockid) Hashtbl.t;

  mutable block: Ast.blockid;

  mutable ids_scope:  (string list) list;
  mutable tags_scope: (string list) list;
  mutable block_scope: Ast.blockid list;

}
(* alt: could have a recursive environment with 'parent: env;' and so
 * we could remove the need for those xxx_scope.
 * we would need then a lookup_id and lookup_tag that would
 * possibly look in the parent field.
 *)

(* Should we warn if 'id' already declared? No, because at the toplevel
 * it is ok to redeclare the same variable or prototype.
 * So better to do those checks in another phase (in check.ml and typecheck.ml).
 *)
let add_id env id idkind =
  Hashtbl.add Globals.hids id idkind;
  Hashtbl.add env.ids id (idkind, env.block);
  match env.ids_scope with
  | xs::xss -> env.ids_scope <- (id::xs)::xss
  | [] -> env.ids_scope <- [[id]]

let add_tag env tag tagkind =
  Hashtbl.add env.tags tag (tagkind, env.block);
  match env.tags_scope with
  | xs::xss -> env.tags_scope <- (tag::xs)::xss
  | [] -> env.tags_scope <- [[tag]]



let env = {
  ids = Hashtbl.create 101;
  tags = Hashtbl.create 101;
  block = 0;
  
  ids_scope = [];
  tags_scope = [];
  block_scope = [];
}

(* a few builtins.
 * less: 5c manages USED/SET at a lower level; they are lexical keywords
 * and they are in the AST with special nodes (OUSED/OSET)
 *)
let _ =
  add_id env "USED" IdIdent;
  add_id env "SET" IdIdent;
  ()

let block_counter = ref 0

(* for anonymous struct/union/enum and structure elements *)
let gensym_counter = ref 0
let gensym () =
  incr gensym_counter;
  spf "|sym%d|" !gensym_counter


let new_scope env =
  incr block_counter;
  env.block_scope <- env.block :: env.block_scope;
  env.block <- !block_counter;
  env.ids_scope <- []::env.ids_scope;
  env.tags_scope <- []::env.tags_scope;
  ()

let pop_scope env =
  (match env.block_scope, env.ids_scope, env.tags_scope with
  | x::xs, ys::yss, zs::zss -> 
      env.block <- x;
      env.block_scope <- xs;
      ys |> List.iter (fun id ->
        Hashtbl.remove env.ids id;
        Hashtbl.remove Globals.hids id;
      );
      zs |> List.iter (fun tag -> 
        Hashtbl.remove env.tags tag
      );
      env.ids_scope <- yss;
      env.tags_scope <- zss;
  | _ -> raise (Impossible "pop empty declaration stack, grammar wrong")
  )
  (* less: return an optional list of instructions at some point *)

%}

/*(*************************************************************************)*/
/*(*1 Tokens *)*/
/*(*************************************************************************)*/
<<Parser tokens>>

/*(*************************************************************************)*/
/*(*1 Priorities *)*/
/*(*************************************************************************)*/
<<Parser tokens priorities>>

/*(*************************************************************************)*/
/*(*1 Rules type declaration *)*/
/*(*************************************************************************)*/
<<Parser type declarations>>
%start prog

%%
<<Parser grammar>>
@

<<function [[Parser.error]]>>=
let error s =
  raise (L.Error (spf "Syntax error: %s" s, !L.line))
@

<<function [[Parser.mk_e]]>>=
let mk_e e loc = { e = e; e_loc = loc; e_type = T.Void }
@
<<function [[Parser.mk_t]]>>=
let mk_t t loc = { t = t; t_loc = loc }
@
<<function [[Parser.mk_st]]>>=
let mk_st st loc = { s = st; s_loc = loc }
@

\section{Grammar overview}

<<Parser grammar>>=
/*(*************************************************************************)*/
/*(*1 Program *)*/
/*(*************************************************************************)*/
prog: prog1 EOF   { $1 }

prog1:
 |  /*(*empty*)*/ { [] }
 | prog1 xdecl    { $1 @ $2 }

/*(*************************************************************************)*/
/*(*1 Declarations *)*/
/*(*************************************************************************)*/

/*(*-----------------------------------------*)*/
/*(*2 External declarators *)*/
/*(*-----------------------------------------*)*/

xdecl: 
 | storage_and_type        TSemicolon 
     { (* stricter: *)
       if !defs = [] 
       then error "declaration without any identifier";
       get_and_reset defs;
     }
 | storage_and_type xdlist TSemicolon 
     { (* less: could suggest to separate struct/enum def from vardecl *)
       get_and_reset defs @
       ($2 |> List.map (fun (((id, loc), typ2), init) ->
          let (sto_or_typedef, typ1) = $1 in
          let typ = typ2 typ1 in
          (match sto_or_typedef, init with
          | Left sto, _ -> 
              add_id env id IdIdent;
              VarDecl { v_name = (id, env.block (* 0 *));
                        v_loc = loc;
                        v_type = typ;
                        v_storage = sto;
                        v_init = init;
                      }
          (* stricter: clang also reports this, but not 5c *)
          | Right (), Some _ ->
              error "initializer with typedef"
          | Right (), None ->
              add_id env id IdTypedef;
              TypeDef { typedef_name = (id, env.block); 
                        typedef_loc = loc; 
                        typedef_type = typ; 
                      }
          )
        )) 
     }

 | storage_and_type_xdecor block_no_new_scope
     { let ((id, loc), ft, sto) = $1 in
       pop_scope env;
       [ FuncDef { f_name = id;
                   f_loc = loc;
                   f_type = ft;
                   f_body = $2;
                   f_storage = sto; 
                 }
       ]
     }

storage_and_type_xdecor: storage_and_type xdecor
    { (* stricter: *)
      if !defs <> []
      then error "move struct or typedef definition outside the function";
      let ((id, loc), typ2) = $2 in
      let (sto_or_typedef, typ1) = $1 in
      let typ = typ2 typ1 in
      (match typ.t, sto_or_typedef with
      | TFunction (ret, (params, varargs)), Left sto -> 
          (* add in global scope the function name *)
          add_id env id IdIdent;
          (* add in new scope the parameters *)
          new_scope env;
          let params = params |> List.map (fun p ->
            match p.p_name with
            | Some (id, _) -> 
                add_id env id IdIdent;
                { p with p_name = Some (id, env.block) }
            | None -> p
          )
          in
          let ft = (ret, (params, varargs)) in
          ((id, loc), ft, sto)
      (* stricter: *)
      | TFunction _, Right _ ->
          error "a function definition can not be a type definition"
      (* stricter: it could be TTypeName that resolves to a TFunction, but 
       * I resolve typedefs later so I have to forbid it here, and it is
       * confusing anyway as you can not see the parameter.
       *)
      | _, _ -> error "not a function type"
      )
    }

xdlist:
 | xdecor          { [$1, None] }
 | xdecor TEq init { [$1, Some $3] }

 | xdlist TComma xdlist { $1 @ $3 }


/*(*-----------------------------------------*)*/
/*(*2 Automatic declarators *)*/
/*(*-----------------------------------------*)*/

adecl:
 | storage_and_type        TSemicolon 
     { if !defs = [] 
       then error "declaration without any identifier";
       (* stricter: *)
       error "move struct or typedef definitions to the toplevel";
       (* TODO? could allow at least structdef and just return [] here *)
     }

 | storage_and_type adlist TSemicolon 
     { (* stricter: *)
       if !defs <> [] 
       then error "move struct or typedef definitions to the toplevel";
       (* less: could factorize code with xdecl *)
       ($2 |> List.map (fun (((id, loc), typ2), init) ->
          let (sto_or_typedef, typ1) = $1 in
          let typ = typ2 typ1 in
          (match sto_or_typedef with
          | Left sto -> 
              add_id env id IdIdent;
              mk_st (Var { v_name = (id, env.block);
                           v_loc = loc;
                           v_type = typ;
                           v_storage = sto;
                           v_init = init;
                         }) loc
          (* stricter: *)
          | Right () -> error "typedefs not at the toplevel are forbidden"
          )
       ))
     }

adlist: xdlist { $1 }

/*(*************************************************************************)*/
/*(*1 Statements *)*/
/*(*************************************************************************)*/

block: tobrace slist tcbrace { mk_st (Block $2) $1 }

tobrace: TOBrace { new_scope env; $1 }
tcbrace: TCBrace { pop_scope env; $1 } 

block_no_new_scope: TOBrace slist TCBrace { mk_st (Block $2) $1 }

slist:
 | /*(*empty*)*/ { [] }
 | slist adecl   { $1 @ $2 }
 | slist stmnt   { $1 @ [$2] }

stmnt: 
 | ulstmnt        { $1 }
 | labels ulstmnt { $1 $2 }



ulstmnt: 
 | cexpr TSemicolon { mk_st (ExprSt $1) $2 }
 /*(* used when do for(...) ; to have an empty statement *)*/
 |       TSemicolon { mk_st (Block []) $1 }

 | block { $1 }

 | Tif TOPar cexpr TCPar stmnt %prec LOW_PRIORITY_RULE 
     { 
       if $5.s = Block []
       then Error.warn "empty if body" $5.s_loc;
       mk_st (If ($3, $5, mk_st (Block[]) $1)) $1
     }
 | Tif TOPar cexpr TCPar stmnt Telse stmnt 
     { 
       if $5.s = Block []
       then Error.warn "empty if body" $5.s_loc;
       if $7.s = Block []
       then Error.warn "empty else body" $7.s_loc;
       mk_st (If ($3, $5, $7)) $1
     }
 /*(* stricter: I impose a block, not any stmnt *)*/
 | Tswitch TOPar cexpr TCPar block 
     { (* less: generate (0:int - (0:int - x)) *)
       mk_st (Switch ($3, $5)) $1
     }

 | Twhile TOPar cexpr TCPar stmnt                { mk_st (While ($3, $5)) $1 }
 | Tdo stmnt Twhile TOPar cexpr TCPar TSemicolon { mk_st (DoWhile ($2, $5)) $1 }
 | tfor TOPar forexpr TSemicolon zcexpr TSemicolon zcexpr TCPar stmnt
     { pop_scope env;
       mk_st (For ($3, $5, $7, $9)) $1
     }

 | Treturn zcexpr TSemicolon { mk_st (Return $2) $1 }
 | Tbreak TSemicolon         { mk_st Break $1 }
 | Tcontinue TSemicolon      { mk_st Continue $1 } 
 | Tgoto tag TSemicolon      { mk_st (Goto (snd $2)) $1 }

tag: 
 | TName     { $1 }
 | TTypeName { $1 }


tfor: Tfor { new_scope env; $1 }

forexpr: 
 | zcexpr 
     { Left $1 }
 | storage_and_type adlist 
     { Right 
         (* less: could factorize code with xdecl *)
         ($2 |> List.map (fun (((id, loc), typ2), init) ->
          let (sto_or_typedef, typ1) = $1 in
          let typ = typ2 typ1 in
          (match sto_or_typedef with
          | Left sto -> 
            add_id env id IdIdent;
            { v_name = (id, env.block);
              v_loc = loc;
              v_type = typ;
              v_storage = sto;
              v_init = init;
            }
          (* stricter: *)
          | Right _ -> error "typedefs inside 'for' are forbidden"
          )
       ))
     }

labels:
 | label        { (fun st -> $1 st)  }
 | labels label { (fun st -> $1 ($2 st)) }

label:
 /*(* less: not tag here? can not conflict with typedef? *)*/
 | TName      TColon  { (fun st -> mk_st (Label (snd $1, st)) $2)  }
 | Tcase expr TColon  { (fun st -> mk_st (Case ($2, st)) $3) }
 | Tdefault   TColon  { (fun st -> mk_st (Default st) $2) }

/*(*************************************************************************)*/
/*(*1 Expressions *)*/
/*(*************************************************************************)*/

expr:
 | xuexpr { $1 }

 | expr TPlus expr   { mk_e (Binary ($1, Arith Plus, $3)) $2 }
 | expr TMinus expr  { mk_e (Binary ($1, Arith Minus, $3)) $2 }
 | expr TMul expr    { mk_e (Binary ($1, Arith Mul, $3)) $2 }
 | expr TDiv expr    { mk_e (Binary ($1, Arith Div, $3)) $2 }
 | expr TMod expr    { mk_e (Binary ($1, Arith Mod, $3)) $2 }

 | expr TAnd expr    { mk_e (Binary ($1, Arith And, $3)) $2 }
 | expr TXor expr    { mk_e (Binary ($1, Arith Xor, $3)) $2 }
 | expr TOr expr     { mk_e (Binary ($1, Arith Or, $3)) $2 }

 | expr TSupSup expr { mk_e (Binary ($1, Arith ShiftRight, $3)) $2 }
 | expr TInfInf expr { mk_e (Binary ($1, Arith ShiftLeft , $3)) $2 }

 | expr TAndAnd expr { mk_e (Binary ($1, Logical AndLog, $3)) $2 }
 | expr TOrOr expr   { mk_e (Binary ($1, Logical OrLog, $3)) $2 }

 | expr TEqEq expr   { mk_e (Binary ($1, Logical Eq, $3)) $2 }
 | expr TBangEq expr { mk_e (Binary ($1, Logical NotEq, $3)) $2 }

 | expr TInf expr    { mk_e (Binary ($1, Logical Inf, $3)) $2 }
 | expr TSup expr    { mk_e (Binary ($1, Logical Sup, $3)) $2 }
 | expr TInfEq expr  { mk_e (Binary ($1, Logical InfEq, $3)) $2 }
 | expr TSupEq expr  { mk_e (Binary ($1, Logical SupEq, $3)) $2 }


 | expr TEq expr     { mk_e (Assign (SimpleAssign, $1, $3)) $2 }
 | expr TOpEq expr   { mk_e (Assign (OpAssign (snd $2), $1, $3)) (fst $2) }

 | expr TQuestion cexpr TColon expr { mk_e (CondExpr ($1, $3, $5)) $2 }

xuexpr:
 | uexpr { $1 }

 | TOPar qualifier_and_type abdecor TCPar xuexpr  { mk_e (Cast ($3 $2, $5)) $1 }

uexpr:
 | pexpr { $1 }

 | TPlus xuexpr  { mk_e (Unary (UnPlus, $2)) $1 }
 | TMinus xuexpr { mk_e (Unary (UnMinus, $2)) $1 }

 | TBang xuexpr  { mk_e (Unary (Not, $2)) $1 }
 | TTilde xuexpr { mk_e (Unary (Tilde, $2)) $1 }

 | TMul xuexpr  { mk_e (Unary (DeRef, $2)) $1 }
 | TAnd xuexpr  { mk_e (Unary (GetRef, $2)) $1 }

 | TPlusPlus xuexpr   { mk_e (Prefix (Inc, $2)) $1 }
 | TMinusMinus xuexpr { mk_e (Prefix (Dec, $2)) $1 } 

pexpr:
 | TOPar cexpr TCPar { $2 }

 /*(* less: could do implicit declaration of unknown function *)*/
 | pexpr TOPar zelist TCPar { mk_e (Call ($1, $3)) $2 }
 /*(* stricter: was cexpr, but ugly to allow cexpr here *)*/
 | pexpr TOBra expr TCBra  { mk_e (ArrayAccess ($1, $3)) $2 }
 /*(* we could unsugar here RecordPtAccess; instead we do it in typecheck.ml*)*/
 | pexpr TDot tag   { mk_e (RecordAccess ($1, snd $3)) $2 }
 | pexpr TArrow tag { mk_e (RecordPtAccess ($1, snd $3)) $2 } 

 | TName   
     { let (loc, id) = $1 in
       try 
         let (idkind, blockid) = Hashtbl.find env.ids id in
         assert (idkind <> IdTypedef);
         mk_e (Id (id, blockid)) loc
       with Not_found ->
         (* stricter: if caller is Call, still forbid implicit decl of func! *)
         error (spf "name not declared: %s" id)
         (*Id ($1, 0)*)
     }

 | TIConst { let (loc, a,b) = $1 in mk_e (Int (a,b))    loc } 
 | TFConst { let (loc, a,b) = $1 in mk_e (Float (a,b))  loc }
 | string  { let (loc, a,b) = $1 in mk_e (String (a,b)) loc }

 | pexpr TPlusPlus   { mk_e (Postfix ($1, Inc)) $2 }
 | pexpr TMinusMinus { mk_e (Postfix ($1, Dec)) $2 } 

 | Tsizeof TOPar qualifier_and_type abdecor TCPar 
     { mk_e (SizeOf (Right ($4 $3))) $1 }
 | Tsizeof uexpr 
     { mk_e (SizeOf (Left $2)) $1 }

cexpr:
 | expr { $1 }
 | cexpr TComma cexpr { mk_e (Sequence ($1, $3)) $2 }


string:
 | TString        { $1 }
 | string TString 
     { let (loc1, s1,t1) = $1 in let (_loc2, s2,t2) = $2 in
       (* stricter: better error message, 5c just says "syntax error" *)
       if t1 <> t2
       then error "incompatible strings"
       else loc1, s1 ^ s2, t1
     }


zexpr:
 | /*(*empty*)*/ { None }
 | lexpr         { Some $1 }

/*(*todo: (long expr) is wrapping expr in a (long) cast *)*/
lexpr: expr { $1 }

zcexpr:
 | /*(*empty*)*/ { None }
 | cexpr         { Some $1 }

zelist:
 | /*(*empty*)*/ { [] }
 | elist         { $1 }

elist:
 | expr { [$1] }
 | elist TComma elist { $1 @ $3 }

/*(*************************************************************************)*/
/*(*1 Initializers *)*/
/*(*************************************************************************)*/

init: 
 | expr                  { $1 }
 | TOBrace ilist comma_opt TCBrace 
     { match $2 with
       | [] -> raise (Impossible "grammar force at least one element")
       | (Left x)::xs ->
           mk_e (ArrayInit (x::(xs |> List.map (function
             | Left x -> x
             | Right _ -> error "mixing array and record initializer forbidden"
           )))) $1
       | (Right x)::xs ->
           mk_e (RecordInit (x::(xs |> List.map (function
             | Right x -> x
             | Left _ -> error "mixing array and record initializer forbidden"
           )))) $1
     }

comma_opt:
 | /*(*empty*)*/ { }
 | TComma { }

ilist:
 | init2              { [$1] }
 | ilist TComma init2 { $1 @ [$3] }

init2:
 | init          { Left (None, $1) }
 | qual TEq init { $1 $3 }

qual:
 | TOBra lexpr TCBra { (fun x -> Left (Some $2, x)) }
 | TDot tag          { (fun x -> Right (snd $2, x)) }


/*(*************************************************************************)*/
/*(*1 Types *)*/
/*(*************************************************************************)*/

/*(*-----------------------------------------*)*/
/*(*2 Types part 1 (left part of a type) *)*/
/*(*-----------------------------------------*)*/

simple_type:
 | Tchar            { (T.I (T.Char, T.Signed), $1) }
 /*(* meh, I should remove all Signed variants *)*/
 | Tsigned Tchar    { (T.I (T.Char, T.Signed), $1) }
 | Tunsigned Tchar  { (T.I (T.Char, T.Unsigned), $1) }

 | Tshort           { (T.I (T.Short, T.Signed), $1) }
 | Tunsigned Tshort { (T.I (T.Short, T.Unsigned), $1) }

 | Tint             { (T.I (T.Int, T.Signed), $1) }
 | Tunsigned Tint   { (T.I (T.Int, T.Unsigned), $1) }
 /*(*bad: should be removed, but for compatibility with plan9 code I keep it*)*/
 | Tunsigned        { (T.I (T.Int, T.Unsigned), $1) }

 | Tlong            { (T.I (T.Long, T.Signed), $1) }
 | Tunsigned Tlong  { (T.I (T.Long, T.Unsigned), $1) }

 | Tlong Tlong      { (T.I (T.VLong, T.Signed), $1) }
 | Tunsigned Tlong Tlong { (T.I (T.VLong, T.Unsigned), $1) }


 | Tfloat  { (T.F (T.Float), $1) }
 | Tdouble { (T.F (T.Double), $1) }

 | Tvoid   { (T.Void, $1) }
/*(* less: allow more combinations, so better than just "syntax error"? *)*/


su:
 | Tstruct { T.Struct, $1 }
 | Tunion  { T.Union, $1 }

tag_opt:
 | tag           { snd $1 }
 | /*(*empty*)*/ { gensym () }

complex_type:
 | su tag { 
     let (su, loc) = $1 in
     let (_, id) = $2 in
     try 
       let (_tagkind, bid) = Hashtbl.find env.tags id in
       (* assert takind = $1? let check.ml do this check *)
       let fullname = id, bid in
       mk_t (Ast.TStructName (su, fullname)) loc
     with Not_found ->
       (* will check in check.ml whether struct defined later *)
       let fullname = id, 0 (* less: or env.block? *) in
       mk_t (Ast.TStructName (su, fullname)) loc
 }
 | su tag_opt sbody {
     let (su, loc) = $1 in
     let id = $2 in
     let fullname = id, env.block in
     (* check if already defined in check.ml *)
     defs := (StructDef { su_name = fullname; 
                          su_loc = loc;
                          su_kind = su; 
                          su_flds = $3 })::!defs;
     add_tag env id (Ast.tagkind_of_su su);
     mk_t (Ast.TStructName (su, fullname)) loc
 }


 | Tenum tag   { 
     let (_, id) = $2 in
     try 
       let (_tagkind, bid) = Hashtbl.find env.tags id in
       let fullname = id, bid in
       mk_t (Ast.TEnumName (fullname)) $1
     with Not_found ->
       let fullname = id, 0 (* less: or env.block? *) in
       mk_t (Ast.TEnumName (fullname)) $1
    }
 | Tenum tag_opt TOBrace enum TCBrace {
     let id = $2 in
     let fullname = id, env.block in
     defs := (EnumDef { enum_name = fullname;
                        enum_loc = $1;
                        enum_constants = $4 })::!defs;
     add_tag env id TagEnum;
     mk_t (Ast.TEnumName fullname) $1
 }

 | TTypeName 
     { let (loc, id) = $1 in
       try 
         let (idkind, bid) = Hashtbl.find env.ids id in 
         assert (idkind = IdTypedef);
         mk_t (Ast.TTypeName (id, bid)) loc
       with Not_found -> 
         raise (Impossible (spf "could not find typedef for %s" id))
     }

type_:
  | simple_type  { let (t, loc) = $1 in mk_t (Ast.TBase t) loc }
  | complex_type { $1 }

/*(*-----------------------------------------*)*/
/*(*2 Types part 2 (right part of a type) *)*/
/*(*-----------------------------------------*)*/
/*
(* declarator return a couple: 
 *  (name, partial type (a function to be applied to return type))
 *
 * Note that with 'int* foo(int)' we must return 
 * TFunction(Pointer int, [int]) and not Pointer (Func(int,[int])).
 * The grammar parses the xdecor part  '*foo(int)' as:
 *         *
 *         |
 *         ()
 *       /   \
 *      foo     [ int]
 * 
 * So when we return the partial function for TMul, we must
 * apply first TPointer to the return type 'x', and then apply
 * the function for xdecor.
 * 
 * 
 * 
 * less: handle qualifiers
 *)*/

xdecor:
 | xdecor2                { $1 }
 | TMul qualifiers xdecor 
     { let (id, f) = $3 in 
       id, (fun x -> f (mk_t (TPointer x) $1))
     }

/*(* use 'tag' here too, because you can have 'foo foo;' declarations *)*/
xdecor2:
 | tag                
     { (snd $1, fst $1), (fun x -> x) }
 | TOPar xdecor TCPar 
     { $2 }
 | xdecor2 TOBra zexpr TCBra 
     { let (id, f) = $1 in 
       (* bug: not 'id, (fun x -> mk_t (TArray ($3, f x)) $2)' *)
       id, (fun x -> f (mk_t (TArray ($3, x)) $2))
     }
 /*(* add parameters in scope in caller, when processing the function body *)*/
 | xdecor2 TOPar zparamlist TCPar
     { let (id, f) = $1 in 
       (* bug: not 'id, (fun x -> mk_t (TFunction (f x, $3)) $2)' *)
       id, (fun x -> f (mk_t (TFunction (x, $3)) $2)) 
     }



zparamlist:
 | /*(*empty*)*/ { [], false }
 | paramlist     { $1 }

paramlist:
 | qualifier_and_type xdecor  
     { let ((id, loc), typ2) = $2 in
       (* the final blockid will be assigned when we create the scope of the
        * function body.
        *)
       [{p_name = Some (id, -1); p_loc = loc; p_type = typ2 $1 }], false
     }
 | qualifier_and_type abdecor 
     { [{ p_name = None; p_loc = $1.t_loc; p_type = $2 $1 }], false }

 | paramlist TComma paramlist 
     { let (xs, isdot1) = $1 in
       let (ys, isdot2) = $3 in
       (* stricter: 5c does not report *)
       if isdot1
       then error "dots allowed only in last parameter position";
       xs @ ys, isdot2
     }
 | TDot TDot TDot { [], true }


/*(*-----------------------------------------*)*/

abdecor:
 | /*(*empty*)*/ { (fun x -> x) }
 | abdecor1      { $1 }

abdecor1:
 | TMul qualifiers          { (fun x -> mk_t (TPointer x) $1) }
 | TMul qualifiers abdecor1 { (fun x -> $3 (mk_t (TPointer x) $1)) }
 | abdecor2  { $1 }

abdecor2:
 | abdecor3 { $1 }
 | abdecor2 TOPar zparamlist TCPar { (fun x -> $1 (mk_t (TFunction (x, $3))$2))}
 | abdecor2 TOBra zexpr TCBra      { (fun x -> $1 (mk_t (TArray ($3, x))$2))}

abdecor3:
 | TOPar TCPar          { (fun x -> mk_t (TFunction (x, ([], false))) $1)  }
 | TOBra zexpr TCBra    { (fun x -> mk_t (TArray ($2, x)) $1) }
 | TOPar abdecor1 TCPar { $2 }

/*(*-----------------------------------------*)*/
/*(*3 qualifiers *)*/
/*(*-----------------------------------------*)*/

qualifier:
 | Tconst    { T.Const }
 | Tvolatile { T.Volatile }
 | Trestrict { error "restrict not supported" }

qualifier_and_type: qualifiers type_ { $2 }
/*(* less: allow storage here, so better than just "syntax error"? *)*/

qualifiers:
 | /*(*empty*)*/        { [] }
 | qualifiers qualifier { $1 @ [$2] }

/*(*************************************************************************)*/
/*(*1 Struct/union/enum body *)*/
/*(*************************************************************************)*/

/*(* note that a structure does not define a new scope *)*/
sbody: TOBrace edecl TCBrace { $2 }

edecl:
 |       edecl_elem TSemicolon { $1 }
 | edecl edecl_elem TSemicolon { $1 @ $2 }

edecl_elem: 
 | qualifier_and_type edlist
   { $2 |> List.map (fun ((id, loc), typ2) -> 
       (* note that this element can introduce a nested struct definition! *)
       let typ1 = $1 in
       let typ = typ2 typ1 in
       { fld_name = id; fld_loc = loc; fld_type = typ }
     )
   }
/*(* kenccext: c99ext? unnamed structure elt; used in u.h/regexp.h/bio.h/.. *)*/
 | qualifier_and_type
   { let s = gensym () in
    (* note that this anon elt can even be a nested anon struct definition! *)
     let typ = $1 in
     (* check that struct/union done later after typedef expansion *)
     [ { fld_name = s; fld_loc = typ.t_loc; fld_type = typ } ]
   }

/*(* todo: bitfield *)*/
edlist:
 | edecor               { [$1] }
 | edlist TComma edecor { $1 @ [$3] }

edecor: xdecor { $1 }



enum:
 | TName                
     { let (loc, id) = $1 in
       add_id env id IdEnumConstant; 
       [{ecst_name = (id, env.block); ecst_loc = loc; ecst_value = None}] 
     }
 | TName TEq const_expr 
     { let (loc, id) = $1 in
      (* note that const_expr can reference enum constants defined before *)
       add_id env id IdEnumConstant;
       [{ecst_name = (id, env.block); ecst_loc = loc; ecst_value = Some $3}] 
     }

 | enum TComma enum { $1 @ $3 }
 | enum TComma      { $1 }

const_expr: expr { $1 }

/*(*************************************************************************)*/
/*(*1 Storage, qualifiers *)*/
/*(*************************************************************************)*/

/*(* less: allow some combinations? like extern register? *)*/
storage:
 | Tauto     { Storage.Local }
 | Tstatic   { Storage.Static }
 | Textern   { Storage.Extern }
 /*(* stricter: 5c just skips register declarations, I forbid them *)*/
 | Tregister { error "register not supported" }
 | Tinline   { error "inline not supported" }
/*(* less: allow more combinations, so better than just "syntax error"? *)*/


/*(* stricter: I impose an order. c(lass) then g(arbage) then t(type). *)*/
storage_and_type:
 |          qualifiers type_ { Left None, $2 }
 | storage  qualifiers type_ { Left (Some $1), $3 }
 | Ttypedef qualifiers type_ { Right (), $3 }
/*(* less: allow more combinations, so better than just "syntax error"? *)*/
@


<<Parser tokens priorities>>=
/*(* must be at the top so that it has the lowest priority *)*/
%nonassoc LOW_PRIORITY_RULE
/*(* see conflicts.txt *)*/
%nonassoc Telse

/*(* in 5c but not in orig_c.mly *)*/
%left   TSemicolon
%left   TComma
%right  TEq TOpEq
%right  TQuestion TColon

/*(* same than in orig_c.mly *)*/
%left   TOrOr
%left   TAndAnd
%left   TOr
%left   TXor
%left   TAnd
%left   TEqEq TBangEq
%left   TInf TSup TInfEq TSupEq
%left   TInfInf TSupSup
%left   TPlus TMinus
%left   TMul TDiv TMod

/*(* in 5c but not in orig_c.mly *)*/
%right  TMinusMinus TPlusPlus TArrow TDot TOBra TOPar
@

<<Parser type declarations>>=
%type <Ast.toplevels> prog
@

\section{Declarations and definitions, part one}

\subsection{No-declarator declarations}

\subsection{Declarator-based declarations}

\subsection{Entity declarations, the declarator}

\subsection{Function definitions}

\section{Statements}

\subsection{Blocks}

\subsection{Conditionals}

\subsection{Loops}

\subsection{Control flow jumps}

\subsection{Labels and goto}

\subsection{Switch}

\section{Expressions}

\subsection{Numeric constants}

\subsection{String constants}

\subsection{Entity uses}

\subsection{Arithmetic expressions}

\subsection{Boolean expressions}

\subsection{Assignments}

\subsection{Pointers}

\subsection{Array accesses}

\subsection{Field accesses}

\subsection{Function calls}

\subsection{Cast}

\subsection{Ternary expressions}

\subsection{Prefix/postfix}

\subsection{[[sizeof()]]}

\section{Initializers and designators}

\section{Types and storage classes}

\subsection{Basic types}

\subsection{Storage classes}

\subsection{Qualifiers}

\subsection{Structures and unions}

\subsection{Enums}

\subsection{Pointer and array types}

\subsection{Function types, parameter types}

\subsection{Typedefs}

\section{Declarations and definitions, part two}

\subsection{Globals, external declarator}

\subsection{Function parameters}

\subsection{Locals, automatic declarator}

\subsection{Types, abstract declarator}

%******************************************************************************
\chapter{Checking}
%******************************************************************************

\section{Overview}

<<type [[Check.error]]>>=
type error = 
  | Inconsistent of 
      string * Location_cpp.loc * (* error here *) 
      string * Location_cpp.loc   (* previous decl/def/whatever here *)
  | Misc of string * Location_cpp.loc
@
<<exception [[Check.Error]]>>=
exception Error of error
@


<<function [[Check.error]]>>=
let error err =
  if !failhard
  then raise (Error err)
  else Logs.err (fun m -> m "%s" (string_of_error err))
@

<<signature [[Check.failhard]]>>=
val failhard : bool ref
@
<<constant [[Check.failhard]]>>=
let failhard = ref false
@



<<signature [[Check.check_program]]>>=
(* can raise Error if failhard, otherwise print on stderr *)
val check_program: Ast.program -> unit
@

<<signature [[Typecheck.check_and_annotate_program]]>>=
(* Returns resolved type and storage information for identifiers and tags.
 * Annotate also with types each expression nodes in the returned functions
 * (so you can more easily generate code later).
 * 
 * It also internally resolves enum constants and replaces them
 * with constants and evaluates some constant expressions (e.g., for
 * array size).
 * 
 * can raise Error.
 *)
val check_and_annotate_program: 
  Ast.program -> typed_program
@
%TODO: return Frontend.result or Typecheck.result?

<<type [[Typecheck.error]]>>=
type error = Check.error
@

<<exception [[Typecheck.Error]]>>=
exception Error of error
@


\section{Printing warnings: [[5c -w]] and [[5c -W]]}
% now -w and -werror ?

<<constant [[Flags.warn]]>>=
let warn = ref false
@

<<constant [[Flags.warnerror]]>>=
let warnerror = ref false
@


<<signature [[Error.warn]]>>=
val warn: string -> Location_cpp.loc -> unit
@

<<function [[Error.warn]]>>=
let warn s loc =
  if !Flags.warn
  then 
    if !Flags.warnerror
    then raise (Location_cpp.Error (spf "Warning: %s" s, loc))
    else 
      let (file, line) = Location_cpp.final_loc_of_loc loc in
      Logs.warn (fun m -> m "%s:%d: %s" !!file line s)
@

\section{Symbol resolution}

\section{Storage resolution}

%%\subsection{xdecl}
%%\subsection{doinit}
%%\subsection{pdecl}
%%\subsection{adecl}

\section{Typechecking helpers}

<<type [[Typecheck.env]]>>=
(* Environment for typechecking *)
type env = {
  (* those 2 fields will be returned ultimately by check_and_annotate_program *)
  ids_:  (Ast.fullname, idinfo) Hashtbl.t;
  structs_: (Ast.fullname, Type.struct_kind * Type.structdef) Hashtbl.t;

  (* internal *)
  typedefs: (Ast.fullname, Type.t) Hashtbl.t;
  (* stricter: no float enum *)
  enums: (fullname, Type.integer_type) Hashtbl.t;
  (* stricter: no support for float enum constants either *)
  constants: (Ast.fullname, integer * Type.integer_type) Hashtbl.t;

  (* return type of function; used to typecheck Return *)
  return_type: Type.t;
  (* used to add some implicit GetRef for arrays and functions *)
  expr_context: expr_context;
}
@


<<type [[Typecheck.expr_context]]>>=
and expr_context = CtxWantValue | CtxGetRef | CtxSizeof
@


\subsection{Overview}

<<function [[Typecheck.type_error]]>>=
let type_error _t loc =
  (* less: dump t? *)
  raise (Error (E.Misc ("incompatible type", loc)))
@

<<function [[Typecheck.type_error2]]>>=
(* todo: for op xxx *)
let type_error2 t1 t2 loc =
  let s1 = Dumper_.s_of_any (FinalType t1) in
  let s2 = Dumper_.s_of_any (FinalType t2) in
  raise (Error (E.Misc (spf "incompatible types (%s and %s)" s1 s2, loc)))
@


\subsection{Type equality} %%: [[sametype()]]

\subsection{generic [[void*]] pointer conversions: [[5c -V]]}

\subsection{Type merge} %%: [[tmerge()]]
%%\subsection{Set of types constants: [[typexxx[]]]}

\subsection{Type compatibility} %%: [[tcompat()]]

<<function [[Typecheck.same_types]]>>=
(* if you declare multiple times the same global, we need to make sure
 * the types are the same. ex: 'extern int foo; ... int foo = 1;'
 * This is where we detect inconsistencies like 'int foo; void foo();'.
 * 
 * Because we expand typedefs before calling same_types, and because
 * we do struct equality by name not fields, testing the equality of 
 * two types is simple.
 *)
let same_types t1 t2 =
  match t1, t2 with
  (* 'void*' can match any pointer! The generic trick of C
   * (but only when the pointer is at the top of the type).
   *)
  | T.Pointer T.Void, T.Pointer _      -> true
  | T.Pointer _,      T.Pointer T.Void -> true
  (* stricter: struct equality by name, not by fields *)
  | _ -> t1 = t2
@

<<function [[Typecheck.merge_types]]>>=
(* if you declare multiple times the same global, we must merge types. *)
let merge_types t1 _t2 =
  t1
@

\subsection{Compatibility policies} %%: [[txxx]]

\subsection{Typechecker} %%: [[tcom()]]

\subsection{Array to pointer conversions}


\section{Typechecking expressions}

<<function [[Typecheck.expr]]>>=
let rec expr env e0 =
  (* default env for recursive call *)
  let newenv = { env with expr_context = CtxWantValue } in

  match e0.e with
  | Int    (_s, inttype)   -> { e0 with e_type = T.I inttype }
  | Float  (_s, floattype) -> { e0 with e_type = T.F floattype }
  (* less: transform in Id later? *)
  | String (_s, t)         -> { e0 with e_type = t } |> array_to_pointer env
  | Id fullname ->
     if Hashtbl.mem env.constants fullname
     then
       let (i, inttype) = Hashtbl.find env.constants fullname in
       { e0 with e = Int (spf "%d" i, inttype); e_type = T.I inttype }
     else
       let idinfo = Hashtbl.find env.ids_ fullname in
       { e0 with e_type = idinfo.typ } |> array_to_pointer env
  | Sequence (e1, e2) -> 
    let e1 = expr newenv e1 in
    let e2 = expr newenv e2 in
    { e0 with e = Sequence (e1, e2); e_type = e2.e_type }

  | Binary (e1, op, e2) ->
    let e1 = expr newenv e1 in
    let e2 = expr newenv e2 in
    check_compatible_binary op e1.e_type e2.e_type e0.e_loc;
    (* todo: add casts if left and right not the same types? or do it later? *)
    let finalt = 
      match op with
      | Arith Minus ->
        (match e1.e_type, e2.e_type with
        | T.Pointer _, T.Pointer _ -> T.long
        | _ -> result_type_binary e1.e_type e2.e_type
        )
      | Arith (Plus | Mul | Div | Mod    
              | And | Or | Xor
              (* todo: also add T.int cast when shl/shr on right operand *)
              | ShiftLeft | ShiftRight
              ) -> result_type_binary e1.e_type e2.e_type
      | Logical (Eq | NotEq  
                | Inf | Sup | InfEq | SupEq
                | AndLog | OrLog
                ) ->
        T.int
    in
    { e0 with e = Binary (e1, op, e2); e_type = finalt }

  | Unary (op, e) ->
    (match op with
    | UnPlus -> 
      let e = Binary ({e0 with e = Int ("0",(T.Int,T.Signed))}, Arith Plus,e) in
      expr env { e0 with e = e }
    | UnMinus -> 
      let e = Binary ({e0 with e = Int ("0",(T.Int,T.Signed))}, Arith Minus,e)in
      expr env { e0 with e = e }
    | Tilde ->
      let e = Binary ({e0 with e = Int ("-1",(T.Int,T.Signed))}, Arith Xor,e) in
      expr env { e0 with e = e }
    | Not ->
      let e = expr newenv e in
      (match e.e_type with
      (* what about T.Array? see array_to_pointer above *)
      | T.I _ | T.F _ | T.Pointer _ -> ()
      | _ -> type_error e.e_type e.e_loc 
      );
      { e0 with e = Unary (Not, e); e_type = T.int }

    | GetRef ->
      (* we dont want an additional '&' added before an array *)
      let e = expr { env with expr_context = CtxGetRef } e in
      if not (lvalue (e))
      then raise (Error (E.Misc ("not an l-value", e0.e_loc)));
      (* less: warn if take address of array or function, ADDROP *)
      { e0 with e = Unary (GetRef, e); e_type = T.Pointer (e.e_type) }

    | DeRef ->
      let e = expr newenv e in
      (match e.e_type with
      | T.Pointer t -> 
        { e0 with e = Unary (DeRef, e); e_type = t } |> array_to_pointer env
      (* what about T.Array? see array_to_pointer() *)
      | _ -> type_error e.e_type e.e_loc
      )
    )
  | Assign (op, e1, e2) ->
    let e1 = expr newenv e1 in
    let e2 = expr newenv e2 in
    if not (lvalue (e1))
    then raise (Error (E.Misc ("not an l-value", e0.e_loc)));
    check_compatible_assign op e1.e_type e2.e_type e0.e_loc;
    (* todo: add cast on e2 if not same type,
     * todo: mixedasop thing?
     *)
    { e0 with e = Assign (op, e1, e2); e_type = e1.e_type }


  (* x[y] --> *(x+y) *)
  | ArrayAccess (e1, e2) ->
    let e = Unary (DeRef, { e0 with e = Binary (e1, Arith Plus, e2) }) in
    expr env { e0 with e = e }
  (* x->y --> ( *x).y *)
  | RecordPtAccess (e, name) ->
    let e = RecordAccess ({ e0 with e = Unary (DeRef, e)}, name) in
    expr env { e0 with e = e }

  | RecordAccess (e, name) ->
    let e = expr newenv e in
    (match e.e_type with
    | T.StructName (_su, fullname) ->
      let (_su2, def) = Hashtbl.find env.structs_ fullname in
      (try
         let t = List.assoc name def in
         { e0 with e = RecordAccess (e, name); e_type = t } 
          |> array_to_pointer env
       with Not_found ->
         if def |> List.exists (fun (fld, _) -> Ast.is_gensymed fld)
         then 
           try 
             unsugar_anon_structure_element env e0 e name def 
               |>array_to_pointer env
           with Not_found ->
             raise (Error(E.Misc(spf "not a member of struct/union: %s" name,
                                 e.e_loc)))
         else
           raise (Error(E.Misc(spf "not a member of struct/union: %s" name,
                               e.e_loc)))
      )
    | _ -> type_error e.e_type e.e_loc
    )
  | Call (e, es) ->
    (* less: should disable implicit OADDR for function here in env *)
    let e = expr newenv e in
    (match e.e_type with
    | T.Pointer (T.Func (_tret, _tparams, _varargs)) ->
      (* stricter?: we could forbid it, but annoying for my print in libc.h *)
      let e = { e with e = Unary (DeRef, e); } in
      expr newenv { e0 with e = Call (e, es) }
    | T.Func (tret, tparams, varargs) ->
       (* we enable GetRef for array here (and functions) *)
      let es = List.map (expr { env with expr_context = CtxWantValue }) es in
      check_args_vs_params es tparams varargs e0.e_loc;
      (* todo: add cast *)
      (* less: format checking *)
      { e0 with e = Call (e, es); e_type = tret }
    | _ -> type_error e.e_type e.e_loc
    )
  | Cast (typ, e) ->
    let t = type_ env typ in
    let e = expr newenv e in
    (match e.e_type, t with
    | T.I _, (T.I _ | T.F _ | T.Pointer _ | T.Void)
    | T.F _, (T.I _ | T.F _ | T.Void)
    | T.Pointer _, (T.I _ | T.Pointer _ | T.Void)
      -> ()
    (* less: seems pretty useless *)
    | T.Void, T.Void -> ()
    (* less: seems pretty useless *)
    | T.StructName (su1, _) , T.StructName (su2, _) when su1 = su2 -> ()
    | T.StructName _, T.Void -> ()
    | _ -> type_error2 e.e_type t e0.e_loc
    );
    { e0 with e = Cast (typ, e); e_type = t } (* |> array_to_pointer ? *)

  | CondExpr (e1, e2, e3) ->
    let e1 = expr newenv e1 in
    let e2 = expr newenv e2 in
    let e3 = expr newenv e3 in
    (* stricter? should enforce e1.e_type is a Bool *)
    check_compatible_binary (Logical Eq) e2.e_type e3.e_type e0.e_loc;
    (* todo: special nil handling? need? *)
    let finalt = result_type_binary e2.e_type e3.e_type in
    (* todo: add cast *)
    { e0 with e = CondExpr (e1, e2, e3); e_type = finalt }

  (* ocaml-light: | Postfix (e, op) | Prefix (op, e) *)
  | Postfix (_, _) | Prefix (_, _) ->
    let (e, op) =
        match e0.e with
        | Postfix (e, op) -> e, op
        | Prefix (op, e) -> e, op
        | _ -> raise (Impossible "pattern match only those cases")
    in
    let e = expr newenv e in
    if not (lvalue (e))
    then raise (Error (E.Misc ("not an l-value", e.e_loc)));
    check_compatible_binary (Arith Plus) e.e_type T.int e0.e_loc;
    (match e.e_type with
    | T.Pointer T.Void ->
      raise (Error (E.Misc ("inc/dec of a void pointer", e.e_loc)));
    | _ -> ()
    );
    { e0 with e = 
        (match e0.e with 
        | Postfix _ -> Postfix (e, op)
        | Prefix _ -> Prefix (op, e)
        | _ -> raise (Impossible "pattern match only those cases")
        ); e_type = e.e_type }

  | SizeOf(te) ->
    (match te with
    | Left e ->
      (* we pass a special context because if t2 mentions an array, 
       * we want the size of the array, not the size of a pointer to an array
       *)
      let e = expr { env with expr_context = CtxSizeof  } e in
      { e0 with e = SizeOf (Left e); e_type = T.int }
    (* todo: build a fake expression but with the right expanded type
     * so the codegen later does not have to redo the job of expanding
     * typedefs.
     *)
    | Right typ ->
      { e0 with e = SizeOf (Right typ); e_type = T.int }
    )

  | ArrayInit _
  | RecordInit _
  | GccConstructor _
      -> raise Todo
@

<<function [[Typecheck.expropt]]>>=
and expropt env eopt = 
    match eopt with
    | None -> None
    | Some e -> Some (expr env e)
@

\subsection{Numeric constants}

\subsection{String constants}

\subsection{Entity uses}

\subsection{Arithmetic expressions}

\subsection{Arithmetic conversions}

\subsection{Pointer arithmetic}

\subsection{Boolean expressions}

\subsection{Assignments}

\subsection{Pointers}

\subsection{Array accesses}

\subsection{Field accesses}

\subsection{Function calls}

\subsection{Cast}

\subsection{Ternary expressions}

\subsection{Prefix/postfix}

\subsection{[[sizeof()]]}

\section{Typechecking statements}

<<function [[Typecheck.stmt]]>>=
(* The code below is boilerplate, mostly.
 * expr() should not do any side effect on the environment, so we can
 * call recursively in any order stmt() and expr() (including the
 * reverse order of evaluation of OCaml for arguments).
 *)
let rec stmt env st0 =
  { st0 with s = 
    (match st0.s with
    | ExprSt e -> ExprSt (expr env e)
    | Block xs -> Block (List.map (stmt env) xs)

    | If (e, st1, st2) -> 
      let e = expr env e in
      (match e.e_type with
      | T.I _ | T.F _ | T.Pointer _ -> ()
      (* stricter: error when does not typecheck, not just set null type on e *)
      | _ -> type_error e.e_type e.e_loc
      );
      If (e, stmt env st1, stmt env st2)

    | Switch (e, xs) -> 
      let e = expr env e in
      (* ensure e is a number! not a pointer *)
      (match e.e_type with
      | T.I _ | T.F _ -> ()
      | _ -> type_error e.e_type e.e_loc
      );
      Switch (e, stmt env xs)

    (* less: should enforce int expr? *)
    | Case (e, st) -> Case (expr env e, stmt env st)
    | Default st -> Default (stmt env st)

    (* stricter? should require Bool, not abuse pointer *)
    | While (e, st) -> 
      While (expr env e, stmt env st)
    | DoWhile (st, e) -> 
      DoWhile (stmt env st, expr env e)

    | For (e1either, e2opt, e3opt, st) ->
      (* we may have to do side effects on the environment, so we process
       * e1either first
       *)
      let e1either = 
        (match e1either with 
        | Left e1opt -> Left (expropt env e1opt)
        | Right _decls -> raise Todo
        )
      in
      For (e1either, expropt env e2opt, expropt env e3opt, stmt env st)

    | Return eopt -> 
      Return 
        (match eopt with
        | None -> 
          if env.return_type = T.Void
          then None 
          (* stricter: error, not warn *)
          else raise (Error (E.Misc ("null return of a typed function", 
                                     st0.s_loc)))
        | Some e -> 
          let e = expr env e in
          check_compatible_assign SimpleAssign env.return_type e.e_type e.e_loc;
          (* todo: add cast *)
          Some e
        )
    | Continue -> Continue
    | Break -> Break
    | Label (name, st) -> Label (name, stmt env st)
    | Goto name -> Goto name
    | Var { v_name = fullname; v_loc = loc; v_type = typ;
            v_storage = stoopt; v_init = eopt} -> 

      let t = type_ env typ in
      let ini = expropt env eopt in
      (match t with
      (* stricter: forbid nested prototypes *)
      | T.Func _ -> 
         raise (Error(E.Misc("prototypes inside functions are forbidden",loc)));
      | _ -> ()
      );
      let sto =
        match stoopt with
        | None -> S.Local
        (* stricter? forbid? confusing anyway to shadow locals *)
        | Some S.Extern ->
          raise(Error(E.Misc 
                     ("extern declaration inside functions are forbidden",loc)))
        | Some S.Static -> 
          raise Todo
        | Some S.Local -> 
          (* stricter: I warn at least *)
          Error.warn "useless auto keyword" loc;
          S.Local
        | Some (S.Global | S.Param) -> 
          raise (Impossible "global/param are not keywords")
      in

      (match ini with
      | None -> ()
      | Some e ->
        (* less: no const checking for this assign *)
        check_compatible_assign (SimpleAssign) t e.e_type loc
        (* todo: add cast if not same type *)
      );
      Hashtbl.add env.ids_ fullname { typ = t; sto = sto; ini = ini; loc = loc };
      Var { v_name = fullname; v_loc = loc; v_type = typ; v_storage = stoopt;
            v_init = ini }
    )
  }
@


\subsection{[[return]]}

\subsection{[[switch]]}

\subsection{[[if]]}

\section{Typechecking declarations and constant evaluation}

<<function [[Typecheck.check_and_annotate_program]]>>=
let check_and_annotate_program (prog: Ast.program) : typed_program =
  let (ast, _locs) = prog in

  let funcs = ref [] in

  let toplevel (env : env) = function
    | StructDef { su_kind=su; su_name=fullname; su_loc=loc; su_flds=flds }->
      Hashtbl.add env.structs_ fullname 
        (su, flds |> List.map 
            (fun {fld_name = name; fld_loc=_; fld_type = typ } ->
              let t = type_ env typ in
              (* kenccext: c99ext?:
               * less: if there are multiple anon structure elements, we 
               * could check eagerly if no ambiguous fields instead
               * of checking it when you use a field.
               *)
              (match Ast.is_gensymed name, t with
              | false, _ -> ()
              | true, T.StructName _ -> ()
              | true, _ -> 
                raise (Error (E.Misc 
                       ("unnamed structure element must be struct/union", loc)))
              );
              (name, t)
            )
        )

    | TypeDef { typedef_name = fullname; typedef_loc = _loc; typedef_type =typ}->
      Hashtbl.add env.typedefs fullname (type_ env typ)

    | EnumDef { enum_name = fullname; enum_loc = _loc; enum_constants = csts }
      ->
      (* stricter: no support for float enum constants *)
      let lastvalue = ref 0 in
      let maxt = ref (T.Int, T.Signed) in
      csts |> List.iter (fun 
        { ecst_name = fullname; ecst_loc = loc; ecst_value = eopt } ->
          (match eopt with
          | Some e ->
            (try 
               (* less: should also return an integer type *)
               let i = Eval_const.eval env.constants e in
               let t = (T.Int, T.Signed) in
               (* todo: maxt := max_types !maxt t; *)
               Hashtbl.add env.constants fullname (i, t);
               lastvalue := i;
             with Eval_const.NotAConstant ->
               raise (Error (E.Misc (spf "enum not a constant: %s"
                                            (unwrap fullname), loc)))
            )
          | None ->
            (* todo: curt *)
            let t = (T.Int ,T.Signed) in
            Hashtbl.add env.constants fullname (!lastvalue, t);
          );
          incr lastvalue
      );
      Hashtbl.add env.enums fullname !maxt

    (* remember that VarDecl covers also prototypes *)
    | VarDecl { v_name = fullname; v_loc = loc; v_type = typ;
                v_storage = stoopt; v_init = eopt} ->
      let t = type_ env typ in
      let ini = expropt env eopt in

      (* step 0: typechecking initializer *)
      (match ini with
      | None -> ()
      | Some e ->
        (* less: no const checking for this assign *)
        check_compatible_assign (SimpleAssign) t e.e_type loc
      );

      (* step1: check for weird declarations *)
      (match t, ini, stoopt with
      | T.Func _, Some _, _ -> 
        raise (Error(E.Misc 
                     ("illegal initializer (only var can be initialized)",loc)))
      (* stricter: 5c says nothing, clang just warns *)
      | _, Some _, Some S.Extern ->
        raise (Error (E.Misc ("'extern' variable has an initializer", loc)))
      | _ -> ()
      );

      (try 
         (* step2: check for weird redeclarations *)
         let old = Hashtbl.find env.ids_ fullname in

         (* check type compatibility *)
         if not (same_types t old.typ)
         then raise (Error (E.Inconsistent (
              (* less: could dump both type using vof_type *)
               spf "redefinition of '%s' with a different type" 
                 (unwrap fullname), loc,
               "previous definition is here", old.loc)))
         else
           let finalt = 
             merge_types t old.typ in
           let finalini = 
             match ini, old.ini with
             | Some x, None  -> Some x
             | None, Some x -> Some x
             | None, None -> None
             | Some _x, Some _y ->
               raise (Error (E.Inconsistent (
               spf "redefinition of '%s'" (unwrap fullname), loc,
               "previous definition is here", old.loc)))
           in
           (* check storage compatibility and compute final storage *)
           let finalsto = 
             merge_storage_toplevel (unwrap fullname) loc stoopt ini old in

           Hashtbl.replace env.ids_ fullname 
             {typ = finalt; sto = finalsto; loc = loc; ini = finalini }
       with Not_found ->
         let finalsto =
           match stoopt with
           | None -> S.Global
           | Some S.Extern -> S.Extern
           | Some S.Static -> S.Static
           | Some S.Local -> 
             raise (Error(E.Misc 
                          ("illegal storage class for file-scoped entity",loc)))
           | Some (S.Global | S.Param) -> 
             raise (Impossible "global or param are not keywords")
         in
         Hashtbl.add env.ids_ fullname 
           {typ = t; sto = finalsto; loc = loc; ini = ini }
      )


    | FuncDef ({f_name=name; f_loc=loc; f_type=ftyp; 
               f_storage=stoopt; f_body=st;} as def) ->
      (* less: lots of code in common with Var_decl; we could factorize
       * but a few things are different still.
       *)
      let t = type_ env ({t = TFunction ftyp; t_loc = loc}) in
      let fullname = (name, 0) in
      (* we use a fake initializer for function definitions to 
       * be able to store those definitions in env.ids. That way
       * we can detect function redefinitions, useless redeclarations, etc.
       *)
      let ini = Some { e = Id fullname; e_loc = loc; e_type = T.Void } in

      (try 
         (* check for weird redeclarations *)
         let old = Hashtbl.find env.ids_ fullname in

         (* check type compatibility *)
         if not (same_types t old.typ)
         then raise (Error (E.Inconsistent (
              (* less: could dump both type using vof_type *)
               spf "redefinition of '%s' with a different type" 
                 (unwrap fullname), loc,
               "previous definition is here", old.loc)))
         else
           let finalt = 
             merge_types t old.typ in
           let finalini = 
             match ini, old.ini with
             | Some x, None -> Some x
             | None, Some x -> Some x
             | None, None -> None
             | Some _x, Some _y ->
               raise (Error (E.Inconsistent (
               spf "redefinition of '%s'" (unwrap fullname), loc,
               "previous definition is here", old.loc)))
           in
           (* check storage compatibility and compute final storage *)
           let finalsto = 
             merge_storage_toplevel (unwrap fullname) loc stoopt ini old in

           Hashtbl.replace env.ids_ fullname 
             {typ = finalt; sto = finalsto; loc = loc; ini = finalini }
       with Not_found ->
         let finalsto =
           match stoopt with
           | None -> S.Global
           | Some S.Static -> S.Static
           (* different than for VarDecl here *)
           | Some S.Extern -> 
             raise (Error (E.Misc ("'extern' function with initializer", loc)))
           | Some S.Local -> 
             raise (Error(E.Misc 
                          ("illegal storage class for file-scoped entity",loc)))
           | Some (S.Global | S.Param) -> 
             raise (Impossible "global or param are not keywords")
         in
         Hashtbl.add env.ids_ fullname 
           {typ = t; sto = finalsto; loc = loc; ini = ini }
      );

      (* add params in environment before process st *)
      let (tret, (tparams, _dots)) = ftyp in
      tparams |> List.iter (fun p ->
        p.p_name |> Option.iter (fun fullname ->
          let t = type_ env p.p_type in
          (match t with
          (* stricter: 5c and clang says nothing, could convert in pointer *) 
          | T.Array _ | T.Func _ -> type_error t p.p_loc
          (* todo: convert small types to int? see paramconv? *)
          | _ -> ()
          );
          Hashtbl.add env.ids_ fullname 
            {typ = t; sto = S.Param; loc = loc; ini = None }
        )
      );
      (* the expressions inside the statements are now annontated with types *)
      let st = stmt { env with return_type = type_ env tret } st in
      funcs := { def with f_body = st }::!funcs;
  in

  let env = {
    ids_ = Hashtbl.create 101;
    structs_ = Hashtbl.create 101;

    typedefs = Hashtbl.create 101;
    enums = Hashtbl.create 101;
    constants = Hashtbl.create 101;
    
    return_type = T.Void;
    expr_context = CtxWantValue;
  }
  in
  ast |> List.iter (toplevel env);

  { ids = env.ids_; structs = env.structs_; funcs = List.rev !funcs }
@



\subsection{Enumerations}

\subsection{Arrays}

\subsection{Functions}

\subsection{Typedef expansions}




\section{Lint checking}

<<type [[Check.usedef]]>>=
type usedef = {
  mutable defined: Ast.loc option;
  mutable used: Ast.loc option;
}
@

<<type [[Check.env]]>>=
type env = {
  ids:      (fullname, usedef * Ast.idkind) Hashtbl.t;
  tags:     (fullname, usedef * Ast.tagkind) Hashtbl.t;

  (* to reset after each function (because labels have a function scope) *)
  mutable labels:   (string, usedef) Hashtbl.t;
  (* block scope *)
  mutable local_ids: fullname list;

  (* todo: inbreakable: bool; incontinueable: bool *)
}
@


<<function [[Check.check_usedef]]>>=
(* use of undefined, redefined, redeclared, unused, inconsistent tags, etc. *)
let check_usedef program =

  let rec toplevel env = function
    | StructDef { su_kind=su; su_name=fullname; su_loc=loc; su_flds=flds }->
      (* checking the tag *)

      let tagkind = Ast.tagkind_of_su su in
      check_inconsistent_or_redefined_tag env fullname tagkind loc;

      (* checking the fields *)

      let hflds = Hashtbl.create 11 in
      flds |> List.iter 
       (fun {fld_name = name; fld_loc = loc; fld_type = typ} ->
          (* stricter: 5c reports at use time, clang does immediately *)
          if Hashtbl.mem hflds name
          then error (Inconsistent (spf "duplicate member '%s'" name, loc,
                                    "previous declaration is here", 
                                    Hashtbl.find hflds name));
          Hashtbl.add hflds name loc;
          type_ env typ
      )

    | EnumDef { enum_name = fullname; enum_loc = loc; enum_constants = csts }->
      (* checking the tag *)

      let tagkind = TagEnum in
      check_inconsistent_or_redefined_tag env fullname tagkind loc;

      (* checking the constants *)

      csts |> List.iter 
          (fun { ecst_name = fullname; ecst_loc = loc; ecst_value = eopt } ->
            check_inconsistent_or_redefined_id env fullname IdEnumConstant loc;
            eopt |> Option.iter (expr env)
          );

    | TypeDef { typedef_name = fullname; typedef_loc = loc; typedef_type =typ}->
      check_inconsistent_or_redefined_id env fullname IdTypedef loc;
      type_ env typ

    (* todo: if use struct tags params, they must be complete at this point *)
    | FuncDef { f_name = name; f_loc = loc; f_type = ftyp; f_body = st; f_storage = _ } ->
      let fullname = name, 0 in
      (if Hashtbl.mem env.ids fullname &&
          snd (Hashtbl.find env.ids fullname) = IdIdent
      (* this can be ok, you can redeclare toplevel identifiers as you
       * can give a final storage. It depends on the situation, 
       * see typecheck.ml
       *)
       then ()
       else check_inconsistent_or_redefined_id env fullname IdIdent loc
      );
      type_ env {t = TFunction ftyp; t_loc = loc };
      (* new function scope *)
      let env = { env with local_ids = []; labels = Hashtbl.create 11 } in
      let (_tret, (tparams, _dots)) = ftyp in
      tparams |> List.iter (fun { p_name = fullnameopt; p_loc; p_type = _} ->
        fullnameopt |> Option.iter (fun fullname ->
          check_inconsistent_or_redefined_id env fullname IdIdent p_loc;
          env.local_ids <- fullname :: env.local_ids;
        );
      );

      (* We could match st to a Block and avoid new scope for it, but
       * it does not matter here. We do it correctly in parser.mly so
       * a parameter and local with the same name will have the same
       * blockid so we will detect if you redefine an entity even
       * if in different scope here.
       *)
      stmt env st;

      (* check function scope *)
      check_unused_locals env;
      env.labels |> Hashtbl.iter (fun name usedef ->
        match usedef with
        | { defined = Some _; used = Some _ } -> ()
        | { used = Some loc; defined = None } ->
            error (Misc (spf "use of undeclared label '%s'" name, loc))
        | { defined = Some loc; used = None } ->
            Error.warn (spf "label declared and not used '%s'" name) loc
        | { defined = None; used = None } -> 
          raise (Impossible "at least one of used or defined")
      );
        
    | VarDecl { v_name = fullname; v_loc; v_type = t; v_init = eopt; v_storage = _} ->
      (if Hashtbl.mem env.ids fullname &&
          snd (Hashtbl.find env.ids fullname) = IdIdent
      (* this can be ok, you can redeclare toplevel identifiers as you
       * can give a final storage. It depends on the situation, 
       * see typecheck.ml
       *)
       then ()
       else check_inconsistent_or_redefined_id env fullname IdIdent v_loc
      );
      type_ env t;
      eopt |> Option.iter (expr env)

  and stmt env st0 =
    match st0.s with
    | ExprSt e -> expr env e
    | Block xs ->
        (* new block scope *)
        let env = { env with local_ids = [] } in
        List.iter (stmt env) xs;
        (* check block scope *)
        check_unused_locals env
    | If (e, st1, st2) ->
        expr env e;
        stmt env st1;
        stmt env st2;
    (* ocaml-light: | While (e, st)  | Switch (e, st) | Case (e, st) *)
    | While (e, st) ->
        expr env e;
        stmt env st;
    | Switch (e, st) ->
        expr env e;
        stmt env st;
    | Case (e, st) ->
        expr env e;
        stmt env st;
    | DoWhile (st, e) ->
        stmt env st;
        expr env e
    | For (e1either, e2opt, e3opt, st) ->
        (* new block scope again *)
        let env = { env with local_ids = [] } in
        (match e1either with
        | Left e1opt -> e1opt |> Option.iter (expr env)
        | Right decls ->
            decls |> List.iter (fun decl -> 
              stmt env ({s = Var decl; s_loc = decl.v_loc }) 
            )
        );
        e2opt |> Option.iter (expr env);
        e3opt |> Option.iter (expr env);
        stmt env st;
        (* check block scope *)
        check_unused_locals env

    | Return eopt -> eopt |> Option.iter (expr env)
    (* todo: check that inside something that be continue/break *)
    | Continue | Break -> ()

    (* checks on labels are done in FuncDef once we analyzed the whole body *)
    | Label (name, st) ->
        (try
           let usedef = Hashtbl.find env.labels name in
           usedef.defined |> Option.iter (fun locprev ->
             error (Inconsistent (spf "redefinition of label '%s'" name, 
                                  st0.s_loc,
                                  "previous definition is here", locprev))
           );
           usedef.defined <- Some st0.s_loc;
         with Not_found ->
           Hashtbl.add env.labels name 
             {defined = Some st0.s_loc; used = None}
        );
        stmt env st;
    | Goto name ->
        (try 
           let usedef = Hashtbl.find env.labels name in
           usedef.used <- Some st0.s_loc
         with Not_found ->
           Hashtbl.add env.labels name { defined = None; used = Some st0.s_loc }
        )
    | Default st -> stmt env st

    | Var { v_name = fullname; v_loc = loc; v_type = typ; v_init = eopt; v_storage = _ } ->
      (* less: before adding in environment? can have recursive use? *)
      eopt |> Option.iter (expr env);
    (* todo: if local VarDEcl, can actually have stuff nested like
     *  extern int i;  in which case we must go back to global
     *  scope for i! so rewrite AST? or just in typecheck.ml
     *  generate right storage for it.
     * can also be nested prototype (but I should forbid it
     *)
      check_inconsistent_or_redefined_id env fullname IdIdent loc;
      env.local_ids <- fullname :: env.local_ids;
      type_ env typ;

  and expr env e0 =
    match e0.e with
    | Int _ | Float _ | String _ -> ()
    | Id fullname ->
        (try 
           let (usedef, _idkind) = Hashtbl.find env.ids fullname in
           usedef.used <- Some e0.e_loc
         with Not_found ->
           (* todo: can be USED or SET *)
           raise (Impossible (spf "ids are always declared first: %s" 
                                (unwrap fullname)))
        )
    | Call (e, es) -> exprs env (e::es)
    (* ocaml-light: | Assign (_, e1, e2) | Binary (e1, _, e2) | Sequence (e1, e2) | ArrayAccess (e1, e2) *)
    | Assign (_, e1, e2) -> exprs env [e1; e2]
    | Binary (e1, _, e2) -> exprs env [e1; e2]
    | Sequence (e1, e2) -> exprs env [e1; e2]
    | ArrayAccess (e1, e2) -> exprs env [e1; e2]
    (* ocaml-light: | RecordAccess (e, _) | RecordPtAccess (e, _) 
    | Postfix (e, _) | Prefix (_, e) | Unary (_, e) *)
    | RecordAccess (e, _) -> expr env e
    | RecordPtAccess (e, _) -> expr env e
    | Postfix (e, _) -> expr env e
    | Prefix (_, e) -> expr env e
    | Unary (_, e) -> expr env e
    (* ocaml-light: | Cast (typ, e) | GccConstructor (typ, e) *)
    | Cast (typ, e) ->
      type_ env typ;
      expr env e
    | GccConstructor (typ, e) ->
      type_ env typ;
      expr env e
    | CondExpr (e1, e2, e3) -> exprs env [e1; e2; e3]
    | SizeOf either ->
        (match either with
        | Left e -> expr env e
        | Right t -> type_ env t
        )
    | ArrayInit xs -> 
      xs |> List.iter (fun (eopt, e) -> 
        eopt |> Option.iter (expr env);
        expr env e
      )
    | RecordInit xs -> xs |> List.iter (fun (_, e) -> expr env e)

  and exprs env xs = xs |> List.iter (expr env)

  and type_ env = fun typ ->
    match typ.t with
    | TBase _ -> ()
    | TPointer t -> type_ env t
    | TArray (eopt, t) -> 
      eopt |> Option.iter (expr env);
      type_ env t;
    | TFunction (tret, (params, _dots)) ->
      type_ env tret;
      params |> List.iter (fun p ->
        (* nothing to do with p.p_name here *)
        type_ env p.p_type
      )
    | TStructName (_, _) | TEnumName _ ->
      let tagkind, fullname = 
        match typ.t with
        | TStructName (su, fullname) -> Ast.tagkind_of_su su, fullname
        | TEnumName fullname -> TagEnum, fullname
        | _ -> raise (Impossible "see pattern above")
      in
      (try 
        let (usedef, oldtagkind) = Hashtbl.find env.tags fullname in
        if tagkind <> oldtagkind
        then inconsistent_tag fullname typ.t_loc usedef;
        usedef.used <- Some typ.t_loc;
      with Not_found ->
        (* forward decl *)
        Hashtbl.add env.tags fullname 
          ({defined = None; used = Some typ.t_loc; }, tagkind)
      )
    | TTypeName fullname ->
        (try 
           let (usedef, idkind) = Hashtbl.find env.ids fullname in
           if idkind <> IdTypedef
           then raise (Impossible "typename returned only if typedef in scope");
           usedef.used <- Some typ.t_loc
         with Not_found ->
           raise (Impossible "typename returned only if typedef in scope")
        )
  in
  
  let env = {
    ids = Hashtbl.create 101;
    tags = Hashtbl.create 101;
    labels = Hashtbl.create 101;
    local_ids = [];
  }
  in
  program |> List.iter (toplevel env);

  (* stricter: check if used but not defined tags (5c does not, clang does) *)
  env.tags |> Hashtbl.iter (fun fullname (usedef, _idkind) ->
    match usedef with
    | { used = Some loc; defined = None } ->
      error (Misc (spf "use of tag '%s' that is never completed"
                          (unwrap fullname), loc))
    (* this can happen, header file are big and can cover multiple modules *)
    | { defined = Some _; used = None } -> ()
    (* perfect *)
    | { defined = Some _; used = Some _} -> ()
    | { defined = None; used = None } -> raise (Impossible "one or the other")
  );

  (* less: could check unused static var decl? *)
  ()
@

<<function [[Check.check_program]]>>=
let check_program (ast, _locs) =
  check_usedef ast
@



\subsection{Unused variables}

<<function [[Check.check_unused_locals]]>>=
let check_unused_locals env =
  (* less: could also delete entries in env.ids *)
  env.local_ids |> List.iter (fun fullname ->
    let (usedef, idkind) = Hashtbl.find env.ids fullname in
    assert (idkind = IdIdent);
    match usedef with
    | { defined = Some loc; used = None } ->
        (* 5c says whether 'auto' or 'param' *) 
        Error.warn 
          (spf "variable declared and not used: '%s'" (unwrap fullname)) loc
    | { defined = None; used = _} -> 
          raise (Impossible "locals are always defined")
    | { defined = _; used = Some _ } -> ()
  )
@

\subsection{Used before set}

\subsection{False positives silencing: [[SET()/USED()]]}

\subsection{Redeclared or unused labels}

\subsection{Unreachable code}

\subsection{Missing return}

\subsection{Unused expression}

\subsection{Constant if: [[5c -c]]}

\subsection{Out of range shifting}

\subsection{Useless comparisons}



\section{Const checking}

<<signature [[Eval_const.eval]]>>=
(* may raise NotAConstant or Error *)
val eval: env -> Ast.expr -> integer
@

<<exception [[Eval_const.NotAConstant]]>>=
exception NotAConstant
@
<<exception [[Eval_const.Error]]>>=
exception Error of error
@
<<type [[Eval_const.error]]>>=
(* less: could factorize things in error.ml? *)
type error = Check.error
@


<<type [[Eval_const.env]]>>=
(* less: could do that in rewrite.ml so no need to pass is to eval *)
type env = (Ast.fullname, integer * Type.integer_type) Hashtbl.t 
@

<<type [[Eval_const.integer]]>>=
(* less: return also float at some point? *)
type integer = int
@


<<function [[Eval_const.eval]]>>=
(* stricter: I do not handle float constants for enums *)
let rec eval env e0 =
  match e0.e with
  (* todo: enough for big integers? 
   * todo: we should also return an inttype in addition to the integer value.
   *)
  | Int (s, _inttype) -> int_of_string s
  | Id fullname ->
     if Hashtbl.mem env fullname
     then
       let (i, _inttype) = Hashtbl.find env fullname in
       i
     else raise NotAConstant
  | Binary (e1, op, e2) ->
    let i1 = eval env e1 in
    let i2 = eval env e2 in
    (match op with
    | Arith op -> 
      (match op with
      | Plus -> i1 + i2
      | Minus -> i1 - i2
      | Mul -> i1 * i2
      | Div -> 
        (* stricter: error, not warning *)
        if i2 = 0 
        then raise (Error (E.Misc ("divide by zero", e0.e_loc)))
        else i1 / i2
      | Mod -> 
        if i2 = 0 
        then raise (Error (E.Misc ("modulo by zero", e0.e_loc)))
        else i1 mod i2
      | And -> i1 land i2
      | Or -> i1 lor i2
      | Xor -> i1 lxor i2
      | ShiftLeft -> i1 lsl i2
      (* less: could be asr! need type information! *)
      | ShiftRight -> i1 lsr i2
      )
    | Logical op ->
      (match op with
      | Eq    -> if i1 =  i2 then 1 else 0
      | NotEq -> if i1 <> i2 then 1 else 0
      | Inf   -> if i1 <  i2 then 1 else 0
      | Sup   -> if i1 >  i2 then 1 else 0
      | InfEq -> if i1 <= i2 then 1 else 0
      | SupEq -> if i1 >= i2 then 1 else 0
      | AndLog -> raise Todo
      | OrLog -> raise Todo
      )
    )
  | Unary (op, e) ->
    let i = eval env e in
    (match op with
    | UnPlus -> i
    | UnMinus -> - i
    | Tilde -> lnot i (* sure? *)
    | _ -> raise Todo
    )

  | _ -> 
    raise NotAConstant (* todo: more opporunities? *)
@


%******************************************************************************
%alt:\chapter{Backend}
%******************************************************************************

%******************************************************************************
\chapter{Assembly Generation}
%******************************************************************************

\section{Overview}

<<type [[Arch_compiler.t]]>>=
type t = {
  width_of_type: env -> Type.t -> int;
}
@

<<signature [[Arch5.arch]]>>=
val arch: Arch_compiler.t
@


<<function [[Arch5.width_of_type]]>>=
let rec width_of_type (env : Arch_compiler.env) (t : Type.t) : int =
  match t with
  | T.Void -> 0
  | T.I (inttype, _sign) ->
    (match inttype with
    | T.Char -> 1
    | T.Short -> 2
    | T.Int -> 4
    | T.Long -> 4
    | T.VLong -> 8
    )
  | T.F T.Float -> 4
  | T.F T.Double -> 8
  | T.Pointer _ -> 4

  | T.Func _ -> raise (Impossible "width of Func")
  | T.Array (iopt, t) ->
    (match iopt with
    | None -> raise (Impossible "width of incomplete array")
    | Some i -> i * width_of_type env t
    )
  | T.StructName (_su, fullname) ->
      let (_su, flds) = Hashtbl.find env.structs fullname in
      (* todo: align so extra size *)
      flds 
      |> List.map (fun (_fld, t) -> width_of_type env t)
      |> List.fold_left (+) 0
@

<<constant [[Arch5.arch]]>>=
let arch = { width_of_type }
@



<<type [[Codegen5.env]]>>=
(* Environment for code generation *)
type env = {

  (* computed by previous typechecking phase *)

  ids_:     (Ast.fullname, TC.idinfo) Hashtbl.t;
  structs_: (Ast.fullname, Type.struct_kind * Type.structdef) Hashtbl.t;

  (* less: compute offset for each field?
   * fields: (Ast.fullname * string, A.offset) Hashtbl.t
   *)

  arch: Arch_compiler.t;

  (* the output *)

  pc: Ast_asm.virt_pc ref;

  (* growing array *)
  code: (A5.instr_with_cond A.line * A.loc) array ref;
  (* should contain only DATA or GLOBL *)
  data: (A5.instr_with_cond A.line * A.loc) list ref;

  (* reinitialized for each function *)

  (* reference counting the used registers (size = 16), 
   * really a (A.register, int) Hashtbl.t;
   *)
  regs: int array;

  size_locals: int ref;
  offset_locals: int ref;
  (* for parameters and locals *)
  offsets: (Ast.fullname, int) Hashtbl.t;

  (* for goto/labels *)
  labels: (string, Ast_asm.virt_pc) Hashtbl.t;
  (* if the label is defined after the goto, when we process the label,
   * we need to update previous goto instructions.
   *)
  forward_gotos: (string, Ast_asm.virt_pc list) Hashtbl.t;

  (* for loops (and switch) *)
  (* reinitialized for each block scope *)
  break_pc: Ast_asm.virt_pc option;
  continue_pc: Ast_asm.virt_pc option;

}
@


<<type [[Codegen5.error]]>>=
type error = Check.error
@
<<exception [[Codegen5.Error]]>>=
exception Error of error
@

<<function [[Codegen5.codegen]]>>=
let codegen (tp : Typecheck.typed_program) : Ast_asm5.program =
  let env = {
    ids_ = tp.ids;
    structs_ = tp.structs;

    arch = Arch5.arch;

    pc = ref 0;
    code = ref [||];
    data = ref [];

    size_locals = ref 0;
    offset_locals = ref 0;
    offsets       = Hashtbl.create 0;
    labels        = Hashtbl.create 0;
    forward_gotos = Hashtbl.create 0;

    break_pc = None;
    continue_pc = None;

    regs          = Array.make 0 16;
  } in

  tp.funcs |> List.iter (fun { f_name=name; f_loc; f_body=st; f_type=typ; f_storage=_ } ->
    let fullname = (name, 0) in
    let idinfo = Hashtbl.find env.ids_ fullname in
    (* todo: if Flag.profile (can be disabled by #pragma) *)
    let attrs = A.default_attr in

    let spc = add_fake_instr env "TEXT" in
    
    (* set offsets for parameters *)
    let offsets = Hashtbl.create 11 in
    let (_typret, (typparams, _varargs)) = typ in
    let t = idinfo.TC.typ in
    let tparams = 
      match t with
      | T.Func (_tret, tparams, _varargs) -> tparams
      | _ -> raise (Impossible "not a FUNC")
    in
    assert (List.length tparams = List.length typparams);
    let xs = List_.zip typparams tparams in
    let offset = ref 0 in
    xs |> List.iter (fun (p, t) ->
      let sizet = env.arch.width_of_type {Arch_compiler.structs = env.structs_} t
      in
      p.p_name |> Option.iter (fun fullname ->
        Hashtbl.add offsets fullname !offset
      );
      (* todo: align *)
      offset := !offset + sizet;
    );
    
    
    (* todo: align offset_locals with return type *)
    let env = { env with
      size_locals = ref 0;
      offset_locals = ref 0;
      offsets       = offsets;
      labels        = Hashtbl.create 11;
      forward_gotos = Hashtbl.create 11;
      regs          = Array.copy regs_initial;
    }
    in
    stmt env st;

    set_instr env spc 
      (A.Pseudo (A.TEXT (global_of_id fullname idinfo, attrs, 
                         !(env.size_locals)))) f_loc;
    add_instr env (A.Virtual A.RET) f_loc;

    (* sanity check register allocation *)
    env.regs |> Array.iteri (fun i v ->
      if regs_initial.(i) <> v
      then raise (Error (E.Misc (spf "reg %d left allocated" i, f_loc)));
    );
  );

  (* todo: generate code for ids after, for CGLOBAL *)
  let instrs = 
    (Array.sub !(env.code) 0 !(env.pc) |> Array.to_list) @
      List.rev !(env.data)
  in
  let locs = [] in
  instrs, locs
@



\section{[[pc]], [[p]], and [[nextpc()]]}

\section{Functions} %%: [[codgen()]]

%%\subsection{[[gpseudo()]]}
%%\subsection{[[gbranch()]]}
%%\subsection{[[patch()]]}
%%\subsection{Offset}

\section{Statements} %%: [[gen()]]

<<function [[Codegen5.stmt]]>>=
let rec stmt env st0 =
  match st0.s with
  | ExprSt e -> expr env e None
  | Block xs -> xs |> List.iter (stmt env)
  | Var { v_name = fullname; v_loc=_;v_storage=_;v_type=_;v_init=_} ->
      let idinfo = Hashtbl.find env.ids_ fullname in
      (* todo: generate code for idinfo.ini *)

      (* update env.offsets *)
      let t = idinfo.TC.typ in
      let sizet = env.arch.width_of_type {Arch_compiler.structs = env.structs_} t
      in
      (* todo: align *)
      env.offset_locals := !(env.offset_locals) + sizet;
      env.size_locals := !(env.size_locals) + sizet;
      Hashtbl.add env.offsets fullname !(env.offset_locals);
  | Return eopt ->
    (match eopt with
    | None ->
      add_instr env (A.Virtual A.RET) st0.s_loc
    | Some e ->
      (* todo: if type compatible with R0 *)
      with_reg env rRET (fun () ->
        let dst = { opd = Register rRET; typ = e.e_type; loc = e.e_loc } in
        expr env e (Some dst);
        add_instr env (A.Virtual A.RET) st0.s_loc
      )
    )

  | Label (name, st) ->
    let here = !(env.pc) in
    Hashtbl.add env.labels name here;
    if Hashtbl.mem env.forward_gotos name
    then begin
      let xs = Hashtbl.find env.forward_gotos name in
      xs |> List.iter (fun xpc -> patch_fake_goto env xpc here);
      (* not really necessary because can not define the same label twice *)
      Hashtbl.remove env.forward_gotos name
    end;
    (* todo? generate dummy Goto +1? *)
    stmt env st
  | Goto name ->
    let here = !(env.pc) in
    let dstpc = 
      if Hashtbl.mem env.labels name
      then Hashtbl.find env.labels name
      else begin
        Hashtbl.replace env.forward_gotos name
          (here:: (if Hashtbl.mem env.forward_gotos name
                  then Hashtbl.find env.forward_gotos name
                  else []));
        fake_pc
      end
    in
    add_instr env (A.Instr (A5.B (ref (A.Absolute dstpc)), A5.AL)) st0.s_loc;
    
  | If (e, st1, st2) ->
    let goto_else_or_end = ref (expr_cond env e) in
    if st1.s <> Block []
    then stmt env st1;
    if st2.s <> Block []
    then begin
      let goto_end = add_fake_goto env st2.s_loc in
      patch_fake_goto env !goto_else_or_end !(env.pc);
      stmt env st2;
      goto_else_or_end := goto_end;
    end;
    patch_fake_goto env !goto_else_or_end !(env.pc)

  | While (e, st) ->
    let goto_entry        = add_fake_goto env e.e_loc in
    let goto_for_continue = add_fake_goto env e.e_loc in
    let goto_for_break    = add_fake_goto env e.e_loc in
    patch_fake_goto env goto_for_continue !(env.pc);
    patch_fake_goto env goto_entry !(env.pc);
    
    let goto_else = expr_cond env e in
    patch_fake_goto env goto_else goto_for_break;

    let env = { env with 
      break_pc = Some goto_for_break; 
      continue_pc = Some goto_for_continue;
    }
    in
    stmt env st;

    (* less: should be last loc of st? *)
    let loc = e.e_loc in
    add_instr env (A.Instr (A5.B (ref(A.Absolute goto_for_continue)), A5.AL)) loc;
    patch_fake_goto env goto_for_break !(env.pc)

  | DoWhile (st, e) ->

    let goto_entry        = add_fake_goto env e.e_loc in
    let goto_for_continue = add_fake_goto env e.e_loc in
    let goto_for_break    = add_fake_goto env e.e_loc in
    patch_fake_goto env goto_for_continue !(env.pc);
    (* for a while: patch_fake_goto env goto_entry env.pc; *)
    
    let goto_else = expr_cond env e in
    patch_fake_goto env goto_else goto_for_break;
    (* for a dowhile! *)
    patch_fake_goto env goto_entry !(env.pc);

    let env = { env with 
      break_pc = Some goto_for_break; 
      continue_pc = Some goto_for_continue;
    }
    in
    stmt env st;

    (* less: should be last loc of st? *)
    let loc = e.e_loc in
    add_instr env (A.Instr (A5.B (ref(A.Absolute goto_for_continue)), A5.AL)) loc;
    patch_fake_goto env goto_for_break !(env.pc)

  | Break -> 
    (match env.break_pc with
    | Some dst ->
      add_instr env (A.Instr (A5.B (ref(A.Absolute dst)), A5.AL)) st0.s_loc;
    | None -> raise (Impossible "should be detected in check.ml")
    )
  | Continue ->
    (match env.continue_pc with
    | Some dst ->
      add_instr env (A.Instr (A5.B (ref(A.Absolute dst)), A5.AL)) st0.s_loc;
    | None -> raise (Impossible "should be detected in check.ml")
    )

  | For (e1either, e2opt, e3opt, st) ->
    (match e1either with
    | Left e1opt -> expropt env e1opt
    (* todo: scope, should reset autoffset once processed loop *)
    | Right decls -> 
      decls |> List.iter (fun var -> stmt env { s = Var var; s_loc=var.v_loc});
    );
    let goto_entry        = add_fake_goto env st0.s_loc in
    let goto_for_continue = add_fake_goto env st0.s_loc in
    let goto_for_break    = add_fake_goto env st0.s_loc in

    patch_fake_goto env goto_for_continue !(env.pc);
    expropt env e3opt;
    patch_fake_goto env goto_entry !(env.pc);
    (match e2opt with
    | None -> ()
    | Some e2 -> 
      let goto_else = expr_cond env e2 in
      patch_fake_goto env goto_else goto_for_break;
    );
    
    let env = { env with 
      break_pc = Some goto_for_break; 
      continue_pc = Some goto_for_continue;
    }
    in
    stmt env st;

    let loc = st0.s_loc in
    add_instr env (A.Instr (A5.B (ref(A.Absolute goto_for_continue)), A5.AL)) loc;
    patch_fake_goto env goto_for_break !(env.pc)

  | Switch _ 
  | Case _ | Default _ -> 
    raise Todo
@

\subsection{Blocks, sequences}

\subsection{Conditionals}

\subsection{Switch}

\subsection{Labels and goto}

\subsection{Loops}

\subsection{Control flow jumps}

\section{Register allocation}

%%\subsection{[[reg]]}
%%\subsection{[[OREGISTER]]}
%%\subsection{[[nodreg()]]}
%%\subsection{[[regfree()]]}

\section{Typechecking, expliciting, annotating, and rewriting}%%: [[complex()]]}

\section{Addressability and complexity}%%: [[xcom()]]

\subsection{Addressable} %%: [[INDEXED]]

\subsection{Addressability} %%: [[addable]]

<<type [[Codegen5.operand_able]]>>=
(* some form of instruction selection *)
type operand_able = 
 { opd: operand_able_kind;
   typ: Type.t;
   loc: Ast.loc;
 }
@

<<type [[Codegen5.operand_able_kind]]>>=
and operand_able_kind =
 | ConstI of integer
 | Register of register

 (* indirect *)
 | Name of Ast.fullname * offset
 | Indirect of register * offset
 (* was not "addressable" in original 5c, but I think it should *)
 | Addr of Ast.fullname
@


<<function [[Codegen5.operand_able]]>>=
let operand_able e0 =
  let kind_opt = 
    match e0.e with
    | Int (s, _inttype) -> Some (ConstI (int_of_string s))
    (* todo: float handling *)
    | Float _ -> None
    | Id fullname -> Some (Name (fullname, 0))
    | Unary (op, e) ->
      (match op with
      (* special case to handle *(&arr + <cst>) *)
      | DeRef  ->
        (match e.e with
        (* less: this should be handled in rewrite.ml *(&x) ==> x *)
        | (Unary (GetRef, { e = Id fullname; e_loc=_;e_type=_ })) -> Some (Name (fullname, 0))
        (* less: should normalize constant to left or right in rewrite.ml *)
        | Binary ({ e = Int (s1, _); e_loc=_;e_type=_ }, 
                  Arith Plus, 
                  {e = (Unary (GetRef, { e = Id fullname; e_loc=_;e_type=_ })); e_loc=_;e_type=_ })
          -> Some (Name (fullname, int_of_string s1))
        | Binary ({e = (Unary (GetRef, { e = Id fullname; e_loc=_;e_type=_ })); e_loc=_;e_type=_ }, 
                  Arith Plus, 
                  { e = Int (s1, _); e_loc=_;e_type=_a })
          -> Some (Name (fullname, int_of_string s1))
        | _ -> None
        )

      | GetRef -> 
        (match e.e with
        (* why 5c does not make OADDR (ONAME) an addressable node? *)
        | Id fullname -> Some (Addr fullname)
        | _ -> None
        )
   
      | (UnPlus | UnMinus | Tilde) -> 
        raise (Impossible "should have been converted")
      | Not -> None
      )
    (* less: could be operand_able if we do constant_evaluation later *)
    | Binary (_e1, _op, _e2) -> None
    | Call _ | Assign _ | Postfix _ | Prefix _ | CondExpr _ | Sequence _
      -> None
    
    | Cast _ -> raise Todo
    | RecordAccess _ -> raise Todo
    
    | String _ | ArrayAccess _ | RecordPtAccess _ | SizeOf _ -> 
      raise (Impossible "should have been converted")
    | ArrayInit _ | RecordInit _ | GccConstructor _ -> 
      None
  in
  match kind_opt with
  | None -> None
  | Some opd -> Some { opd = opd; typ = e0.e_type; loc = e0.e_loc }
@


\subsection{Complexity} %%: [[complex]]

%%\subsection{[[FNX]]}

<<constant [[Codegen5.fn_complexity]]>>=
let fn_complexity = 100 
@

<<function [[Codegen5.complexity]]>>=
(* less: could optimize by caching result in node, so no need
 * call again complexity on subtree later
 *)
let rec complexity e =
  if operand_able e <> None
  then 0
  else 
    match e.e with
    | Int _ | Float _ | String _ | Id _ -> 0
    | Call _ -> fn_complexity
    | Assign _ | ArrayAccess _ | Binary _ | Sequence _ ->
      let (e1, e2) =
        match e.e with
        | Assign (_, e1, e2) -> e1, e2
        | ArrayAccess (e1, e2) -> e1, e2
        | Binary (e1, _, e2) -> e1, e2
        | Sequence (e1, e2) -> e1, e2
        | _ -> raise (Impossible "see pattern match above")
      in
      let n1 = complexity e1 in
      let n2 = complexity e2 in
      if n1 = n2
      then 1 + n1
      else max n1 n2

    | CondExpr (e1, e2, e3) -> 
      complexity {e with e = Sequence (e1, { e with e = Sequence (e2, e3) } ) }

    | RecordAccess _ | RecordPtAccess _ | Cast _ | Postfix _ | Prefix _ | Unary _
      -> 
       let e =
         match e.e with
         | RecordAccess (e, _) -> e
         | RecordPtAccess (e, _) -> e
         | Cast (_, e) -> e
         | Postfix (e, _) -> e
         | Prefix (_, e) -> e
         | Unary (_, e) -> e
         | _ -> raise (Impossible "see pattern match above")
      in
      let n = complexity e in
      if n = 0 then 1 else n
    (* should be converted in Int anyway *)
    | SizeOf _ -> 0

    | ArrayInit _ | RecordInit _ | GccConstructor _ -> raise Todo
@


\section{Basic expressions}

%%\subsection{[[gmove()]]}
%%\subsection{Conversions}
%%\subsection{[[gins()]]}
%%\subsection{[[naddr()]]}
%%\subsection{[[regalloc()]]}

\section{Expressions} %: [[cgen()]]

<<function [[Codegen5.expr]]>>=
(* todo: inrel ? 
 * todo: if complex type node
 * less: dst_opd always a register? maybe, but still need to carry
 *  also its type and loc, so maybe easier to always wrap it in an operand?
 *)
let rec expr env e0 dst_opd_opt =

  match operand_able e0 with
  | Some opd1 -> gmove_opt env opd1 dst_opd_opt
  | None ->
    (match e0.e with
    | Sequence (e1, e2) -> 
      expr env e1 None;
      expr env e2 dst_opd_opt
    
    (* less: lots of possible opti *)
    | Binary (e1, op, e2) ->
      (match op with
      | Arith (Plus | Minus 
              | And | Or | Xor 
              | ShiftLeft | ShiftRight
              | Mul | Div | Mod) ->
        let n1 = complexity e1 in
        let n2 = complexity e2 in
        let opdres, opdother = 
          if n1 >= n2
          then begin
            let opd1reg = opd_regalloc env e1.e_type e1.e_loc dst_opd_opt in
            expr env e1 (Some opd1reg);
            let opd2reg = opd_regalloc env e2.e_type e2.e_loc None in
            expr env e2 (Some opd2reg);
            (match opd1reg.opd, opd2reg.opd with
            | Register r1, Register r2 ->
              (* again reverse order SUB r2 r1 ... means r1 - r2 *)
              add_instr env (A.Instr (arith_instr_of_op op r2 r1 r1, A5.AL)) 
                e0.e_loc;
            | _ -> raise (Impossible "both operands comes from opd_regalloc")
            );
            opd1reg, opd2reg
          end
          else begin
            let opd2reg = opd_regalloc env e2.e_type e2.e_loc dst_opd_opt in
            expr env e2 (Some opd2reg);
            let opd1reg = opd_regalloc env e1.e_type e1.e_loc None in
            expr env e1 (Some opd1reg);
            (match opd1reg.opd, opd2reg.opd with
            | Register r1, Register r2 ->
              (* This time we store result in r2! important and subtle.
               * This avoids some extra MOVW; see plus_chain.c
               *)
              add_instr env (A.Instr (arith_instr_of_op op r2 r1 r2, A5.AL)) 
                e0.e_loc;
            | _ -> raise (Impossible "both operands comes from opd_regalloc")
            );
            opd2reg, opd1reg
          end
        in
        (* This is why it is better for opdres to be the register
         * allocated from dst_opd_opt so the MOVW below can become a NOP
         * and be removed.
         *)
        gmove_opt env opdres dst_opd_opt;

        opd_regfree env opdres;
        opd_regfree env opdother;
            
      | Logical _ ->
        raise Todo
      )
    
    | Assign (op, e1, e2) ->
      (match op with
      | SimpleAssign ->
        (match operand_able e1, operand_able e2, dst_opd_opt with
        (* ex: x = 1; *)
        | Some opd1, Some opd2, None -> 
          (* note that e1=e2 -->  MOVW opd2,opd1, (right->left -> left->right)*)
          gmove env opd2 opd1

        (* ex: return x = 1;, x = y = z, ... *)
        | Some _opd1, Some _opd2, Some _dst ->
          raise Todo


        (* ex: y = &x;, y = x + y, ... *)
        | Some opd1, None, None ->
          let opd2reg = opd_regalloc env e2.e_type e2.e_loc None in
          expr env e2 (Some opd2reg);
          gmove env opd2reg opd1;
          opd_regfree env opd2reg;

        (* ex: return x = x+y;, x = y = z, ... *)
        | Some opd1, None, Some dst ->
          let opd2reg = opd_regalloc env e2.e_type e2.e_loc None in
          expr env e2 (Some opd2reg);
          gmove env opd2reg opd1;
          gmove env opd2reg dst; (* only diff with case above *)
          opd_regfree env opd2reg;


        (* ex: *x = 1; *)
        | None, _, _ ->
          raise Todo
        )
      | OpAssign _op ->
        raise Todo
      )
    | Unary (op, e) ->
      (match op with
      | GetRef -> 
        (match e.e  with
        | Id _fullname -> 
          raise (Impossible "handled in operand_able()")
        | Unary (DeRef, _) ->
          raise (Impossible "should be simplified in rewrite.ml")
        | _ -> 
          raise (Impossible "not an lvalue?")
        )

      | DeRef ->
        (* less: opti of Deref of Add with constant? *)
        let opd1reg = opd_regalloc env e.e_type e.e_loc dst_opd_opt in
        expr env e (Some opd1reg);
        gmove_opt env
          (match opd1reg.opd with
          | Register r -> { opd = Indirect (r, 0); loc = e.e_loc;
                            typ = e0.e_type }
          | _ -> raise (Impossible "opd_regalloc_e returns always Register")
          ) dst_opd_opt;
        opd_regfree env opd1reg;
        

      | (UnPlus | UnMinus | Tilde) -> 
        raise (Impossible "should have been converted")
      | Not -> raise Todo
      )
    | _ -> 
      Logs.err (fun m -> m "%s" (Dumper_.s_of_any (Expr e0)));
      raise Todo
    )
@


\subsection{Numeric constants}

\subsection{Entity uses}

\subsection{String constants}

\subsection{Arithmetic expressions}

\subsection{Boolean expressions}

\subsection{Assignments part 1}

\subsection{Pointers}

\subsection{Assignments part 2}

\subsection{Assignments and arithmetic}

\subsection{Function calls}

\subsection{Array accesses}

\subsection{Field accesses}

\subsection{Cast}

\subsection{Ternary expressions}

\subsection{Prefix/postfix}

\subsection{[[sizeof()]]}

\section{Boolean expressions}

\section{Other topics}

\subsection{Sizes}

\subsection{First argument}

\subsection{Alignment}

\subsection{Toplevel globals}

\subsection{Initializers}

%%\subsection{[[gextern()]]}

\section{Advanced assembly generation}

\subsection{Function calls}

\subsection{Switch}


%******************************************************************************
\chapter{Object File Generation}
%******************************************************************************

\section{Object format}

\section{Instruction output} %%: [[outcode()]]

%%\section{Operand output: [[zaddr()]]}
%%\section{Symbol table, [[zname()]], [[h]] and [[ANAME]]}
%%\section{File and line information: [[outhist()]]}

%******************************************************************************
\chapter{AST-level Optimizations}
%******************************************************************************

\section{AST simplifications}

\subsection{General rewrites}%%: [[ccom()]]

\subsection{Constant evaluation}%%: [[evconst()]]

\section{Comma hoisting}%: [[comma()]]

\section{Bitshifting opportunities}

\section{And opportunities}

\section{Immediate operands}

\subsection{Substraction}

\subsection{Addition, or, etc.}

\subsection{Multiplication}

\section{Associative-commutative arithmetic optimisations}

%%\subsection{[[Term]]}
%%\subsection{[[acom()]]}

%******************************************************************************
\chapter{Assembly-level Optimisations}
%******************************************************************************

\section{Nop detection}

\section{ARM special instructions}

\section{Register passing argument: [[REGARG]]}

\section{Register allocation optimisations}

%%\subsection{[[regopt()]]}
%%\subsection{[[noretval()]]}
%%\subsection{Pass 1}
%%\subsection{Pass 2}
%%\subsection{Pass 3}
%%\subsection{Pass 4}
%%\subsection{pass 5}
%%\subsection{pass 6}
%%\subsection{pass 7, peep hole optimizations}
%%\subsection{pass 8}
%%\subsection{pass 9}
%%\subsection{[[Bits]]}
%%\subsection{[[Var]]}
%%\subsection{[[Reg]]}
%%\subsection{[[XXX]]}

\section{Peephole optimizer}%%: [[peep()]]

\section{Dominators}


%******************************************************************************
\chapter{Linking Support}
%******************************************************************************

\section{[[#pragma lib]] and automagic linking}

\section{Safe linking with type signatures: [[5c -T]]}

\subsection{[[sign()]]}

\subsection{[[#pragma incomplete]]}

%******************************************************************************
\chapter{Debugging Support}
%******************************************************************************

\section{General debugging metadata}

\section{Acid debugger metadata: [[5c -a]]}

\subsection{Entities}

\subsection{Structure/union definitions}

\section{Pickle: [[5c -Z]]}

%******************************************************************************
\chapter{Profiling Support}
%******************************************************************************

\section{Text attributes}

\section{[[#pragma profile]]}



%******************************************************************************
\chapter{Preprocessing}
%******************************************************************************
%alt: in appendix

\section{Overview}

<<function [[Parse.parse]]>>=
let parse (caps : < Cap.open_in; .. >) (conf : Preprocessor.conf) (file : Fpath.t) : Ast.program = 
  let hooks = Parse_cpp.{
     lexer = Lexer.token;
     category = (fun t ->
       match t with
       | T.EOF    -> Parse_cpp.Eof
       | T.TSharp -> Parse_cpp.Sharp

       (* ocaml-light: | T.TName (_, s) | T.TTypeName (_, s) *)
       | T.TName (_, s)  -> Parse_cpp.Ident s
       | T.TTypeName (_, s) -> Parse_cpp.Ident s
        (* stricter: I forbid to have macros overwrite keywords *)
        (*
        | T.Tvoid | T.Tchar | T.Tshort | T.Tint | T.Tlong
        | T.Tdouble | T.Tfloat | T.Tsigned | T.Tunsigned
        | T.Tstruct | T.Tunion | T.Tenum | T.Ttypedef
        | T.Tconst | T.Tvolatile | T.Trestrict | T.Tinline
        | T.Tauto | T.Tstatic | T.Textern | T.Tregister
        | T.Tif | T.Telse | T.Twhile | T.Tdo | T.Tfor 
        | T.Tbreak | T.Tcontinue | T.Treturn | T.Tgoto
        | T.Tswitch | T.Tcase | T.Tdefault | T.Tsizeof
        *)
       | _ -> Parse_cpp.Other
     );
   parser = Parser.prog;
   eof = T.EOF;
  }
  in
  Parse_cpp.parse caps hooks conf file
@



%%\section{[[mactab]] and [[domacro()]] dispatch}

<<type [[Ast_cpp.directive]]>>=
type directive =
  | Include of Fpath.t * bool (* true if <>, false if "" *)

  | Define of macro
  | Undef of string

  | Ifdef of string
  | Ifndef of string
  | Else
  | Endif

  | Line of int * Fpath.t
  (* ex: #pragma lib "libc.a" -> Pragma("lib", ["libc.a"]) *)
  | Pragma of string * string list
@


\section{Lexing}

<<macroprocessor/Lexer_cpp.mll>>=
{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Regexp_.Operators

open Ast_cpp
module L = Location_cpp

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* A port of plan 9 builtin preprocessing in OCaml.
 *
 * The main functions of the text preprocessors are:
 *  - including other files
 *  - expanding macros
 *  - skipping text inside ifdefs
 * 
 *
 * Limitations compared to cpp:
 *  - no support for unicode
 * 
 * stricter: 
 *  - no space allowed between '#' and the directive
 *    (even though some people like to do  '#  ifdef', when have nested ifdefs,
 *     but nested ifdefs are bad practice anyway)
 *  - single '#' are not converted in #endif
 *    (who does use that?)
 *  - only space or comment between the directive and the newline; 
 *    we do not skip any character
 *    (who does put garbage there?)
 *)

let error s =
  raise  (L.Error (spf "Lexical error in cpp: %s" s, !L.line))

(* needed only because of ocamllex limitations in ocaml-light
 * which does not support the 'as' feature.
 *)
let symbol_after_space lexbuf =
  let s = Lexing.lexeme lexbuf in
  s =~ ".*[ \t]\\([^ \t]+\\)" |> ignore; 
  Regexp_.matched1 s
let char lexbuf =
  let s = Lexing.lexeme lexbuf in
  String.get s 0

}

(*****************************************************************************)
(* Regexps aliases *)
(*****************************************************************************)
let space  = [' ''\t']
let letter = ['a'-'z''A'-'Z']
let digit  = ['0'-'9']

let symbol = (letter | '_') (letter | digit | '_')*

(*****************************************************************************)
(* Main rule *)
(*****************************************************************************)

(* pre: 'token' below assumes the '#' has already been consumed *)
rule token = parse

  (* note that filenames containing double quotes are not supported *)
  | "include" space* '"' ([^ '"' '\n']+ (*as file*)) '"'
      { let file = 
          let s = Lexing.lexeme lexbuf in s =~ ".*\"\\(.*\\)\"" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Include (Fpath.v file, false)  
      }
  | "include" space* '<' ([^ '>' '\n']+ (*as file*)) '>'
      { let file = 
          let s = Lexing.lexeme lexbuf in s =~ ".*<\\(.*\\)>" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Include(Fpath.v file, true) 
      }
  | "include" { error "syntax in #include" }

  (* Macro definition part 1 *)
  | "define" space+ (symbol (*as s1*)) '(' ([^')']* (*as s2*)) ')'
      { let (s1, s2) =
           let s = Lexing.lexeme lexbuf in s =~ "define[ \t]+\\(.*\\)(\\(.*\\))" |> ignore;
           Regexp_.matched2 s in
        let xs = Str.split (Str.regexp "[ \t]*,[ \t]*") s2 in
        (* check if identifier or "..." for last one *)
        let params, varargs = 
          let rec aux xs =
            match xs with
            | [] -> [], false
            (* todo: __VA_ARGS__ *)
            | ["..."] -> [], true
            | "..."::_ -> error "... should be the last parameter of a macro"
            | x::xs ->
               if x =~ "[A-Za-z_][A-Za-z_0-9]*" 
               then let (params, bool) = aux xs in x::params, bool
               else error (spf "wrong syntax for macro parameter: %s" x)
          in
          aux xs
        in
        let body = define_body s1 (List_.index_list_1 params) lexbuf in
        Define { name = s1; params = Some (params); varargs = varargs;
                 body = Some body }
      }
  (* a space after the symbol means the macro has no argument, even if
   * this space is followed by a '('.
   *)
  | "define" space+ (symbol (*as s1*)) space+
      { let s1 = symbol_after_space lexbuf in
        let body = define_body s1 [] lexbuf in 
        Define { name = s1; params = None; varargs = false; body = Some body}
      }
  (* if do '#define FOO+' then? we should return a syntax error because
   * of the space_or_comment_and_newline below.
   *)
  | "define" space+ (symbol (*as s1*))
      { let s1 = symbol_after_space lexbuf in
        space_or_comment_and_newline lexbuf; 
        Define { name = s1; params = None; varargs = false; body =  None }
      }
  | "define" { error "syntax in #define" }

  (* stricter: require space_or_comment-only after sym *)
  | "undef" space+ (symbol (*as name*))
      { let name = symbol_after_space lexbuf in
        space_or_comment_and_newline lexbuf; 
        Undef name
      }
  | "undef" { error "syntax in #undef" } 


  | "ifdef" space+ (symbol (*as name*))
      { let name = symbol_after_space lexbuf in
        space_or_comment_and_newline lexbuf;
        Ifdef name 
      }
  | "ifndef" space+ (symbol (*as name*))
      { let name = symbol_after_space lexbuf in
        space_or_comment_and_newline lexbuf;
        Ifndef name
      }
  | "ifdef" { error "syntax in #ifdef" } 
  | "ifndef" { error "syntax in #ifndef" } 

  | "else"  
      { space_or_comment_and_newline lexbuf; 
        Else 
      }
  | "endif" 
      { space_or_comment_and_newline lexbuf; 
        Endif 
      }

  (* stricter: I impose a filename (with no quote in name, like original?) *)
  | "line" space+ (digit+ (*as s1*)) space* ('"' ([^'"']* (*as s2*)) '"')
      { 
        let (s1, s2) =
           let s = Lexing.lexeme lexbuf in s =~ ".*[ \t]+\\([0-9]+\\).*\"(\\(.*\\)\"" |> ignore;
           Regexp_.matched2 s in
        space_or_comment_and_newline lexbuf;
        Line (int_of_string s1, Fpath.v s2) }
  | "line" { error "syntax in #line" }


  | "pragma" space+ "lib" space* '"' ([^'"''\n']+ (*as file*)) '"'
      { let file = 
          let s = Lexing.lexeme lexbuf in s =~ ".*\"\\(.*\\)\"" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Pragma("lib", [file]) 
      }
  | "pragma" space+ "src" space* '"' ([^'"''\n']+ (*as file*)) '"'
      { let file = 
          let s = Lexing.lexeme lexbuf in s =~ ".*\"\\(.*\\)\"" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Pragma("src", [file]) 
      }

  | "pragma" space+ "varargck" space* "argpos" [^'\n']+
      { space_or_comment_and_newline lexbuf; 
        Pragma("varargck", ["TODO"]) 
      }
  | "pragma" space+ "varargck" space* "type" [^'\n']+
      { space_or_comment_and_newline lexbuf; 
        Pragma("varargck", ["TODO"]) 
      }
  | "pragma" space+ "varargck" space* "flag" [^'\n']+
      { space_or_comment_and_newline lexbuf; 
        Pragma("varargck", ["TODO"]) 
      }

  | "pragma" space+ "incomplete" space+ (symbol (*as name*))
      { let name = 
          let s = Lexing.lexeme lexbuf in s =~ ".*[ \t]+\\([^ \t]+\\)" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Pragma("incomplete", [name]) 
      }
  (* stricter: we do not silently skip unknown pragmas *)
  | "pragma"  { error "syntax in #pragma" }

  | symbol { error (spf "unknown #: %s" (Lexing.lexeme lexbuf)) }

(*****************************************************************************)
(* Macro definition part 2, the body *)
(*****************************************************************************)
and define_body name params = parse
  | symbol (*as s *)
     { let s = Lexing.lexeme lexbuf in
       try 
        let i = List.assoc s params in
        (* safe to use # for a special mark since C code can not
         * use this symbol since it is reserved by cpp
         *)
        spf "#%d" i ^ define_body name params lexbuf
      with Not_found ->
        s ^ define_body name params lexbuf
     }

  | [^ '\n' '_''a'-'z''A'-'Z' '\'' '"' '\\' '/' '#']+ (*as s *)
      { let s = Lexing.lexeme lexbuf in
        s ^ define_body name params lexbuf }

  (* end of macro *)
  | '\n' { incr Location_cpp.line; "" }

  (* special cases *)
  | ['\'' '"'] (*as c *)
      { let c = char lexbuf in
        let s = define_body_strchar c name params lexbuf in 
        String.make 1 c ^ s ^ define_body name params lexbuf 
      }

  | "//" [^'\n']* { define_body name params lexbuf }
  | "/*"          
      { comment_star_no_newline lexbuf; 
        define_body name params lexbuf 
      }

  | '/' { "/" ^ define_body name params lexbuf }
  (* we escape single '#' by doubling it (classic) *)
  | '#' { "##" ^ define_body name params lexbuf }

  (* could do " " ^ but that is not what 5c does *)
  | '\\' '\n' { incr Location_cpp.line; define_body name params lexbuf }
  | '\\' { "\\" ^ define_body name params lexbuf }

  | eof  { error (spf "eof in macro %s" name) }

(*****************************************************************************)
(* Strings and characters (part1) *)
(*****************************************************************************)

(* Diff with string/character handling in lexer.mll for C?
 *  - need to recognize macro parameter (yes 5c does that! no need stringify)
 *  - need to escape '#' to ##
 *  - do not care about precise parsing of \\, octal, escaped char,
 *    just return the string
*)

and define_body_strchar endchar name params = parse
  (* no need for stringify! substitute also in strings *)
  | symbol (*as s*)
     { let s = Lexing.lexeme lexbuf in
       try let i = List.assoc s params in
        spf "#%d" i ^ define_body_strchar endchar name params lexbuf
       with Not_found -> s ^ define_body_strchar endchar name params lexbuf
     }
  | [^ '\n' '_' 'a'-'z''A'-'Z' '\'' '"' '\\' '#']+ (*as s *)
      { let s = Lexing.lexeme lexbuf in
        s ^ define_body_strchar endchar name params lexbuf }

  | '\\' '\n' 
      { incr Location_cpp.line; define_body_strchar endchar name params lexbuf }
  | '\\' _ (*as s*) 
       { let s = Lexing.lexeme lexbuf in
         s^define_body_strchar endchar name params lexbuf }

  (* escape # to disambiguate with use of # to reference a parameter *)
  | '#' { "##" ^ define_body_strchar endchar name params lexbuf }

  | ['\'' '"'] (*as c*)
      { let c = char lexbuf in
        if c = endchar 
        then String.make 1 c
        else String.make 1 c ^ define_body_strchar endchar name params lexbuf
      }

  | '\n' { error (spf "newline in character or string in macro %s" name) }
  | eof  { error (spf "eof in macro %s" name) }

(*****************************************************************************)
(* Macro use *)
(*****************************************************************************)

(* Extracting the arguments. 
 * Note that as opposed to the other rules in this file, here
 * we do not parse a directive; we parse C code used as arguments to
 * a macro. We still use ocamllex for that because it is convenient.
 *)
and macro_arguments = parse
 | space* "("   
     { let xs = macro_args 0 "" [] lexbuf in
       let xs = List.rev xs in
       if xs = [""] then [] else xs
     }
 (* stricter: better error message *)
 | _ (*as c*) { let c = char lexbuf in 
                error (spf "was expecting a '(' not %c for macro arguments" c) }
 | eof    { error "was expecting a '(', not an eof for macro arguments" }

and macro_args depth str args = parse
 | ")" 
     { if depth = 0 
       then str::args
       else macro_args (depth - 1) (str ^ ")") args lexbuf
     }

 | [^ '\'' '"' '/' ',' '\n' '(' ')']+ 
     { macro_args depth (str ^ Lexing.lexeme lexbuf) args lexbuf }

 | "," 
     { if depth = 0 
       (* todo: if reached varargs! *)
       then macro_args 0 "" (str::args) lexbuf 
       else macro_args depth (str ^ ",") args lexbuf
     }

 | "("  { macro_args (depth+1) (str^"(") args lexbuf }

  | ['\'' '"'] (*as c*)
      { let c = char lexbuf in
        let s = macro_args_strchar c lexbuf in 
        macro_args depth (str ^ String.make 1 c ^ s) args lexbuf
      }

 | "//" [^ '\n']* { macro_args depth str args lexbuf }
 | "/*" 
     { comment_star_newline_ok lexbuf; 
       macro_args depth (str^" ") args lexbuf 
     }
 | "/"  { macro_args depth     (str^"/") args lexbuf }

 | '\n' { incr Location_cpp.line; macro_args depth     (str^" ") args lexbuf }

 | _ (*as c*) { let c = char lexbuf in error (spf "unrecognized character: '%c'" c) }
 (* stricter: better error message *)
 | eof { error "eof in macro arguments" }

(* Substituting the arguments.
 * Note that the lexbuf here will be different. It will correspond
 * to the string of the body of a macro.
 *)
and subst_args_in_macro_body name args = parse
 | [^ '\n' '#']+ (*as s*) { 
       let s = Lexing.lexeme lexbuf in
       s ^ subst_args_in_macro_body name args lexbuf }
 | "##" { "#" ^ subst_args_in_macro_body name args lexbuf }
 | "#" (digit+ (*as s*)) 
     { let s = Lexing.lexeme lexbuf |> String_.drop_prefix 1 in
       let i = int_of_string s in
       try 
         let arg = List.nth args (i - 1) in
         arg ^ subst_args_in_macro_body name args lexbuf
       with Failure _ -> 
         (* stricter: better error message *)
         error (spf "could not find argument %d in macro of %s" i name)
     }
 (* the escaped newlines should have been removed *)
 | '\n' { failwith "impossible: newline in macro body" }
 | eof { "" }


(*****************************************************************************)
(* Strings and characters (part1) *)
(*****************************************************************************)
and macro_args_strchar endchar = parse
  | [^ '\n' '\'' '"' '\\' ]+ (*as s*)  
      { let s = Lexing.lexeme lexbuf in
        s ^ macro_args_strchar endchar lexbuf }

  | '\\' '\n' { incr Location_cpp.line; macro_args_strchar endchar lexbuf }
  | '\\' _ (*as s*) 
        { let s = Lexing.lexeme lexbuf in
          s^macro_args_strchar endchar lexbuf }

  | ['\'' '"'] (*as c*)
      { let c = char lexbuf in
        if c = endchar 
        then String.make 1 c
        else String.make 1 c ^ macro_args_strchar endchar lexbuf
      }
  | '\n' { error (spf "newline in character or string") }
  | eof  { error (spf "eof in character or string in macro argument") }


(*****************************************************************************)
(* Comments *)
(*****************************************************************************)

and space_or_comment_and_newline = parse
  | space+        { space_or_comment_and_newline lexbuf }
  | '\n'          { incr Location_cpp.line }

  | "//" [^'\n']* { space_or_comment_and_newline lexbuf }
  | "/*"          { comment_star_no_newline lexbuf; 
                    space_or_comment_and_newline lexbuf }

  (* stricter: new error message *)
  | _ (*as c*)    { let c = char lexbuf in
                    error (spf "unexpected character %c after directive" c) }
  | eof           { error "expected newline, not EOF" }

and comment_star_no_newline = parse
  | "*/"          { }
  | [^ '*' '\n']+ { comment_star_no_newline lexbuf }
  | '*'           { comment_star_no_newline lexbuf }

  | '\n'          { error "comment across newline" }
  | eof           { error "eof in comment" }

and comment_star_newline_ok = parse
  | "*/"          { }
  | [^ '*' '\n']+ { comment_star_newline_ok lexbuf }
  | '*'           { comment_star_newline_ok lexbuf }
  | '\n'          { incr Location_cpp.line; comment_star_newline_ok lexbuf }
  | eof           { error "eof in comment" }


(*****************************************************************************)
(* Skipping, for ifdefs *)
(*****************************************************************************)

and skip_for_ifdef depth bol = parse
  | '\n'         { incr Location_cpp.line; skip_for_ifdef depth true lexbuf }
  | [' ' '\t']+  { skip_for_ifdef depth bol lexbuf }
  | [^'#' '\n' ' ' '\t']+ { skip_for_ifdef depth false lexbuf }
  
  | "#endif" 
      { if bol
        then
          if depth = 0 
          (* done! just eat until newline *)
          then space_or_comment_and_newline lexbuf
          else skip_for_ifdef (depth - 1) false lexbuf
        else skip_for_ifdef depth false lexbuf
      }
  | "#else" 
      { if bol && depth = 0
        then space_or_comment_and_newline lexbuf
        else skip_for_ifdef depth false lexbuf
      }
  | "#ifdef" | "#ifndef" 
      { if bol 
        then skip_for_ifdef (depth + 1) false lexbuf 
        else skip_for_ifdef depth false lexbuf
      }

  | "#" { skip_for_ifdef depth false lexbuf }

  (* stricter: *)
  | eof { error "eof in #ifdef or #ifndef" }  

@

\section{[[#include]]}

\subsection{Include paths, [[-I]]}

\subsection{Tracing origin} %% and [[Hist]]

\subsection{[[#include]]}

\section{[[#define]]}

\subsection{[[-D]]}

\subsection{[[#define]]}

\subsection{Macro Expansion}

\section{[[#undef]]}

\section{[[#ifdef]]}

\section{[[#pragma]]}

\section{[[#line]]}

%******************************************************************************
\chapter{Advanced Topics TODO}
%******************************************************************************

\section{Advanced C features}

\subsection{Function and function pointer automatic conversions}

\subsection{Array and pointer automatic conversions}

\subsection{Local [[static]]}

\subsection{Local [[volatile]]}

\subsection{Bitfields}

\subsection{Old style prototypes}

\subsection{[[_Noreturn()]]}

\section{C extensions}

\subsection{Typing extensions}%%: [[typeext()]]

\subsection{Unnamed structure elements}

\subsection{Struct constructors}

\subsection{Per-processor storage: [[extern register]]}

\subsection{Type reflection: [[typestr()]]}

\subsection{Signature reflection: [[signof()]]}

\subsection{Format's arguments checking}

\section{Floats}

\section{Big values}

\subsection{Complex types}

\subsection{Complex return value}

\subsection{Complex argument}

\subsection{Complex expression}

\subsection{[[vlong]] constant}

\section{64 bits operations}

%%\subsection{[[com64init()]]}
%%\subsection{Rewriting: [[com64()]]}
%%\subsection{[[bool64()]]}

\section{Endianness}

%%\section{Using an external preprocessor: [[/bin/cpp]]}
%%\section{Processing multiple files}

\section{Other optimizations}

\subsection{Packing: [[#pragma pack]]}

%%\subsection{Minimizing [[#line]] history}

%******************************************************************************
\chapter{Conclusion}
%******************************************************************************

%##############################################################################

\appendix

%******************************************************************************
\chapter{Debugging}
%******************************************************************************

\section{Dumpers}

<<constant [[Flags.dump_tokens]]>>=
let dump_tokens = ref false
@


%%\subsection{[[cc/]] [[Fmt]] data structures}
%%\subsection{[[5c/]] [[Fmt]] data structures}
%%\subsection{[[xxxnames[]]]}
\subsection{AST dumper: [[5c -x]]} %% [[prtree()]] and

<<signature [[Dumper_.s_of_any]]>>=
val s_of_any: Ast.any -> string
@

<<function [[Dumper_.s_of_any]]>>=
(* less: could have s_of_any_with_pos *)
let s_of_any x =
  Meta_ast.show_types := false;
  Meta_ast.show_all_pos := false;
  let v = Meta_ast.vof_any x in
  OCaml.string_of_v v
@

<<type [[Ast.any]]>>=
(* for visitor and dumper *)
type any =
  | Expr of expr
  | Stmt of stmt
  | Type of typ
  | Toplevel of toplevel
  | Program of program
  | FinalType of Type.t
[@@deriving show]
@

<<constant [[Flags.dump_ast]]>>=
let dump_ast = ref false
@



<<function [[CLI.do_action]]>>=
let do_action (caps: < caps; .. >) thestring s xs =
  match s with
  | "-test_parser" ->
      xs |> List.iter (fun file ->
        Logs.info (fun m -> m "processing %s" file);
        let conf = Preprocessor.{
          defs = [];
          paths = [spf "/%s/include" thestring; "/sys/include";] |> Fpath_.of_strings;
          dir_source_file = Fpath.v ".";
        }
        in
        try 
          let _ = Parse.parse caps conf (Fpath.v file) in
          ()
        with Location_cpp.Error (s, loc) ->
          let (file, line) = Location_cpp.final_loc_of_loc loc in
          failwith (spf "%s:%d %s" !!file line s)
      )

  | _ -> failwith ("action not supported: " ^ s)
@


\section{[[5c -v]], verbose mode}

\section{Preprocessing debugging}

\subsection{Macro debugging: [[5c -m]]}

<<constant [[Flags_cpp.debug_macros]]>>=
(* -m *)
let debug_macros = ref false
@

\subsection{File inclusion debugging: [[5c -e]]}

<<constant [[Flags_cpp.debug_include]]>>=
(* -e *)
let debug_include = ref false
@

\subsection{Line information debugging: [[5c -f]]}

<<constant [[Flags_cpp.debug_line]]>>=
(* -f *)
let debug_line = ref false
@


\section{Parsing debugging}

\subsection{Printing names: [[5c -L]]}

\subsection{Printing declarations: [[5c -d]]}

\section{Typing debugging}

<<constant [[Flags.dump_typed_ast]]>>=
let dump_typed_ast = ref false
@
<<signature [[Dumper_.s_of_any_with_types]]>>=
val s_of_any_with_types: Ast.any -> string
@

<<function [[Dumper_.s_of_any_with_types]]>>=
let s_of_any_with_types x =
  Meta_ast.show_types := true;
  Meta_ast.show_all_pos := false;
  let v = Meta_ast.vof_any x in
  OCaml.string_of_v v
@


\subsection{Printing expression type trees: [[5c -t]]}


\section{Code generation debugging}

<<constant [[Flags.dump_asm]]>>=
let dump_asm = ref false
@

\subsection{Printing processed opcodes: [[5c -G]]}

\subsection{Printing code generation information: [[5c -g]]}

\subsection{Printing generated assembly: [[5c -S]]}


\section{Optimization debugging}

\subsection{Printing arithmetic trees: [[5c -m]]}

\subsection{Printing registerization: [[5c -r]]}



\section{Printing initializations: [[5c -i]]}


%******************************************************************************
\chapter{Error Management}
%******************************************************************************

\subsection{[[errorexit()]]}

<<signature [[Error.errorexit]]>>=
(* this raises Exit.ExitCode 1 *)
val errorexit: string -> 'a
@
<<function [[Error.errorexit]]>>=
let errorexit s =
  Logs.err (fun m -> m "%s" s);
  raise (Exit.ExitCode 1)
@

% also show Error.warn before

\subsection{Lexing error}

\subsection{Parsing error}%%[[yyerror()]]

\subsection{Typechecking error}

<<signature [[Typecheck.string_of_error]]>>=
val string_of_error: error -> string
@
<<function [[Typecheck.string_of_error]]>>=
let string_of_error err =
  Check.string_of_error err
@

\subsection{Checking error}

<<signature [[Check.string_of_error]]>>=
val string_of_error: error -> string
@

<<function [[Check.string_of_error]]>>=
let string_of_error err =
  match err with
  | Inconsistent (s1, loc1, s2, loc2) ->
    let (file1, line1) = Location_cpp.final_loc_of_loc loc1 in
    let (file2, line2) = Location_cpp.final_loc_of_loc loc2 in
    spf "%s:%d error: %s\n%s:%d note: %s" !!file1 line1 s1 !!file2 line2 s2
  | Misc (s, loc) ->
    let (file, line) = Location_cpp.final_loc_of_loc loc in
    spf "%s:%d error: %s" !!file line s
@


\subsection{Code generation error}

<<function [[Codegen5.string_of_error]]>>=
let string_of_error err =
  Check.string_of_error err
@

\subsection{[[diag()]]}

\subsection{[[fatal()]]}

\subsection{Backtraces}

<<constant [[Flags.backtrace]]>>=
let backtrace = ref false
@


\subsection{Error location}

%******************************************************************************
%%\chapter{Libc}
%******************************************************************************
%%\section{Memory management}
%%\section{String management}
%%\section{Bit operations}
%%\section{Mathematic functions}
%%\section{Key/value data structure}
%%\section{Portability}

%******************************************************************************
\chapter{Extra Code}
%******************************************************************************

#include "occ_extra.nw"

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
SUE = Structure/Union/Enum
SU  = Structure/Union
\end{verbatim}



\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Indexes}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
