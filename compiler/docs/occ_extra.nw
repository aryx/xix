\section{[[Arch_compiler.ml]]}

%-------------------------------------------------------------

<<Arch_compiler.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

<<type [[Arch_compiler.env]]>>
<<type [[Arch_compiler.t]]>>

(* TODO? instead of Arch5, ... could also define an of_arch function
 * here, like I did for Arch_linker
 *
 * todo? have a portable asm? ast_asm_common.ml? 
 * with ATEXT, ANOP, ARET, etc.
 *)
@

\section{[[Arch5.mli]]}

%-------------------------------------------------------------

<<Arch5.mli>>=

<<signature [[Arch5.arch]]>>
@


\section{[[Arch5.ml]]}

%-------------------------------------------------------------

<<Arch5.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

open Arch_compiler
module T = Type

<<function [[Arch5.width_of_type]]>>

<<constant [[Arch5.arch]]>>
@

\section{[[Ast.ml]]}

%-------------------------------------------------------------

<<Ast.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An Abstract Syntax Tree (AST) for C.
 * 
 * The AST below does not match exactly the source code; I do a few
 * simplications at parsing time:
 *  - no nested struct definitions; they are lifted to the toplevel and 
 *    a blockid is associated with the tag name to avoid name conflicts
 *  - no anonymous structure; an artificial name is gensym'ed.
 *  - no anonymous structure element; an artificial field name is gensym'ed
 *  - no mix of typedefs with variable declarations;
 *    again typedefs are lifted to the top
 *  - enums are also lifted to the top (and its constants are tagged with
 *    a blockid)
 * 
 * This AST is actually more a named AST (but not a typed AST). 
 * Indeed, in C, you can not separate completely the naming phase from parsing.
 * The grammar of C has an ambiguity with typedefs, so we need to keep track of 
 * typedefs and identifiers and their scope during parsing. It would be
 * redundant to do this work again in a separate naming phase, so I 
 * name and resolve the scope of identifiers at parsing time
 * (however I check for inconsistencies or redefinitions after parsing).
 * Moreover, because I lift up struct definitions, I also keep track
 * and resolve the scope of tags.
 * 
 * See also pfff/lang_c/parsing/ast_c.ml and pfff/lang_cpp/parsing/ast_cpp.ml
 * 
 * todo: 
 *  - have a (large) integer and (large) double for Int and Float?
 *    Int64.t? if unsigned long long constant? enough? overflow in int64_of_str?
 *)

(*****************************************************************************)
(* The AST related types *)
(*****************************************************************************)

<<type [[Ast.loc]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Name *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast.name]]>>
[@@deriving show]

<<type [[Ast.blockid]]>>
[@@deriving show]

<<type [[Ast.fullname]]>>
[@@deriving show]

<<type [[Ast.idkind]]>>

<<type [[Ast.tagkind]]>>

(* ------------------------------------------------------------------------- *)
(* Types *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.typ]]>>
<<type [[Ast.type_bis]]>>

<<type [[Ast.function_type]]>>

<<type [[Ast.parameter]]>>

(* ------------------------------------------------------------------------- *)
(* Expression *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.expr]]>>
<<type [[Ast.expr_bis]]>>

<<type [[Ast.argument]]>>

<<type [[Ast.const_expr]]>>

<<type [[Ast.unaryOp]]>>
<<type [[Ast.assignOp]]>>
<<type [[Ast.fixOp]]>>

<<type [[Ast.binaryOp]]>>
<<type [[Ast.arithOp]]>>
<<type [[Ast.logicalOp]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Statement *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.stmt]]>>
<<type [[Ast.stmt_bis]]>>

<<type [[Ast.case_list]]>>

(* ------------------------------------------------------------------------- *)
(* Variables *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast.var_decl]]>>
<<type [[Ast.initialiser]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Definitions *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.func_def]]>>
[@@deriving show]

<<type [[Ast.struct_def]]>>
<<type [[Ast.field_def]]>>
[@@deriving show]

<<type [[Ast.enum_def]]>>
<<type [[Ast.enum_constant]]>>
[@@deriving show]

<<type [[Ast.type_def]]>>

(* ------------------------------------------------------------------------- *)
(* Program *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.toplevel]]>>
[@@deriving show]

<<type [[Ast.toplevels]]>>
[@@deriving show]

<<type [[Ast.program]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Any *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.any]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Ast.tagkind_of_su]]>>

<<function [[Ast.unwrap]]>>

open Common
open Regexp_.Operators
<<function [[Ast.is_gensymed]]>>
@

\section{[[Check.mli]]}

%-------------------------------------------------------------

<<Check.mli>>=

<<type [[Check.error]]>>

<<signature [[Check.string_of_error]]>>

<<exception [[Check.Error]]>>
<<signature [[Check.failhard]]>>

<<signature [[Check.check_program]]>>
@

\section{[[Check.ml]]}

%-------------------------------------------------------------

<<Check.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
open Either

open Ast

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This module makes sure every entity used is defined. In some cases
 * it also checks if an entity is unused, or if it is incorrectly redeclared.
 * 
 * For typechecking see Typecheck.ml.
 * For naming and scope resolving see Parser.mly.
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Check.usedef]]>>

<<type [[Check.env]]>>

<<type [[Check.error]]>>

<<function [[Check.string_of_error]]>>

<<exception [[Check.Error]]>>

<<constant [[Check.failhard]]>>

<<function [[Check.error]]>>
 
(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Check.inconsistent_tag]]>>

<<function [[Check.check_inconsistent_or_redefined_tag]]>>

<<function [[Check.inconsistent_id]]>>

<<function [[Check.check_inconsistent_or_redefined_id]]>>

<<function [[Check.check_unused_locals]]>>

<<function [[Check.check_labels]]>>

(*****************************************************************************)
(* Use/Def *)
(*****************************************************************************)
<<function [[Check.check_usedef]]>>

(*****************************************************************************)
(* Unreachable code *)
(*****************************************************************************)
(* TODO *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Check.check_program]]>>
@

\section{[[CLI.mli]]}

%-------------------------------------------------------------

<<CLI.mli>>=
<<type [[CLI.caps]]>>

<<signature [[CLI.main]]>>

<<signature [[CLI.compile]]>>
@

\section{[[CLI.ml]]}

%-------------------------------------------------------------

<<CLI.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
open Regexp_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of 5c, the Plan 9 C compiler for ARM.
 *
 * Main limitations compared to 5c/vc/...:
 *  - no unicode support
 *  - can not compile multiple files at the same time
 *    (but you should use mk anyway)
 *  - can not compile from stdin
 *    (but who uses that?)
 *  - no -. to remove auto search for header in current directory
 *    (but who uses that?)
 *  - no error recovery, we stop at the first error (except in check.ml)
 *    (but compiler now fast enough and errors have a domino effect anyway)
 *  - no support for certain kencc extensions: 
 *     * STILL? unnamed structure element
 *       (confusing anyway, and annoying when porting code to gcc/clang)
 *     * typestr
 *       (seems dead)
 *  - no support for certain C features:
 *     * enum float
 *       (who uses that?)
 *
 * stricter:
 *  - stricter for grammar (see parser.mly), for instance force a specific
 *    order between the sign, qualifier, and type.
 *  - disallow implicit declarations of functions
 *  - stricter for typechecking (see typecheck.ml), for instance
 *    we do not support void* conversions (5c -V), and we use name
 *    equality for typechecking structs, not field equality.
 *    we also do not automatically transform 0 in nil; I force to write
 *    nil
 * 
 * improvements:
 *  - we forbid more constructs: 
 *     * typedef and initializers, 
 *     * typedef function definitions, 
 *     * three dots parameter in the middle, 
 *     * far more (see tests/)
 *  - better error location (no use of vague nearln) and
 *    better error messages (a la clang)
 * 
 * todo:
 *  - finish enough to at least handle helloc.c (basic function calls, basic
 *    types)
 *  - safe-linking support
 *  - debugger support
 *  - profiler support
 *)

(*****************************************************************************)
(* Types, constants, and globals *)
(*****************************************************************************)
<<type [[CLI.caps]]>>

(*****************************************************************************)
(* Testing *)
(*****************************************************************************)

<<function [[CLI.do_action]]>>

(*****************************************************************************)
(* Main algorithms *)
(*****************************************************************************)

<<function [[CLI.frontend]]>>

<<function [[CLI.backend5]]>>
<<function [[CLI.compile5]]>>

<<function [[CLI.compile]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[CLI.main]]>>
@

\section{[[Codegen5.mli]]}

%-------------------------------------------------------------

<<Codegen5.mli>>=

<<type [[Codegen5.error]]>>
<<signature [[Codegen5.string_of_error]]>>
<<exception [[Codegen5.Error]]>>

<<signature [[Codegen5.codegen]]>>
@

\section{[[Codegen5.ml]]}

<<type [[Codegen5.integer]]>>=
type integer = int
@

%-------------------------------------------------------------

<<Codegen5.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast_asm
open Ast
module C = Ast
module A = Ast_asm
module A5 = Ast_asm5

module T = Type
module S = Storage
module TC = Typecheck
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * todo:
 *   - funcalls
 *   - fields, structures
 * todo later:
 *   - firstarg opti
 *   - alignment 
 *     * fields (sualign)
 *     * parameters
 *   - other integer types and cast
 *   - float
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Codegen5.env]]>>

<<constant [[Codegen5.rRET]]>>
(* opti: let rARG = A.R 0 *)

<<constant [[Codegen5.rEXT1]]>>
<<constant [[Codegen5.rEXT2]]>>

<<constant [[Codegen5.regs_initial]]>>
   
  
<<type [[Codegen5.integer]]>>

<<type [[Codegen5.operand_able]]>>
<<type [[Codegen5.operand_able_kind]]>>


<<type [[Codegen5.error]]>>
<<function [[Codegen5.string_of_error]]>>
<<exception [[Codegen5.Error]]>>

(*****************************************************************************)
(* Instructions  *)
(*****************************************************************************)
<<constant [[Codegen5.fake_instr]]>>
<<constant [[Codegen5.fake_loc]]>>
<<constant [[Codegen5.fake_pc]]>>

<<function [[Codegen5.add_instr]]>>

<<function [[Codegen5.set_instr]]>>


<<function [[Codegen5.add_fake_instr]]>>

<<function [[Codegen5.add_fake_goto]]>>
 
<<function [[Codegen5.patch_fake_goto]]>>

(*****************************************************************************)
(* C to Asm helpers  *)
(*****************************************************************************)
<<function [[Codegen5.global_of_id]]>>

<<function [[Codegen5.symbol]]>>

<<function [[Codegen5.entity_of_id]]>>


<<function [[Codegen5.mov_operand_of_opd]]>>

<<function [[Codegen5.arith_instr_of_op]]>>

(*****************************************************************************)
(* Operand able, instruction selection  *)
(*****************************************************************************)
<<function [[Codegen5.operand_able]]>>

<<constant [[Codegen5.fn_complexity]]>>

<<function [[Codegen5.complexity]]>>

(*****************************************************************************)
(* Register allocation helpers *)
(*****************************************************************************)
<<function [[Codegen5.reguse]]>>

<<function [[Codegen5.regfree]]>>

<<function [[Codegen5.with_reg]]>>
  
<<function [[Codegen5.regalloc]]>>

<<function [[Codegen5.opd_regalloc]]>>

<<function [[Codegen5.opd_regfree]]>>

(*****************************************************************************)
(* Code generation helpers *)
(*****************************************************************************)
<<function [[Codegen5.gmove]]>>

<<function [[Codegen5.gmove_opt]]>>

(*****************************************************************************)
(* Expression *)
(*****************************************************************************)
<<function [[Codegen5.expr]]>>

<<function [[Codegen5.expr_cond]]>>

<<function [[Codegen5.expropt]]>>

(*****************************************************************************)
(* Statement *)
(*****************************************************************************)
<<function [[Codegen5.stmt]]>>

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)
<<function [[Codegen5.codegen]]>>
@


\section{[[Dumper_.mli]]}

%-------------------------------------------------------------

<<Dumper_.mli>>=

<<signature [[Dumper_.s_of_any]]>>

<<signature [[Dumper_.s_of_any_with_types]]>>
@

\section{[[Dumper_.ml]]}

%-------------------------------------------------------------

<<Dumper_.ml>>=

<<function [[Dumper_.s_of_any]]>>

<<function [[Dumper_.s_of_any_with_types]]>>
@

\section{[[Error.mli]]}

%-------------------------------------------------------------

<<Error.mli>>=

<<signature [[Error.warn]]>>

<<signature [[Error.errorexit]]>>
@

\section{[[Error.ml]]}

%-------------------------------------------------------------

<<Error.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

<<function [[Error.warn]]>>

<<function [[Error.errorexit]]>>
@

\section{[[Eval_const.mli]]}

%-------------------------------------------------------------

<<Eval_const.mli>>=

<<exception [[Eval_const.NotAConstant]]>>

<<type [[Eval_const.error]]>>
<<exception [[Eval_const.Error]]>>

<<type [[Eval_const.integer]]>>
<<type [[Eval_const.env]]>>

<<signature [[Eval_const.eval]]>>
@

\section{[[Eval_const.ml]]}

%-------------------------------------------------------------

<<Eval_const.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common

open Ast
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Eval_const.integer]]>>

<<type [[Eval_const.env]]>>

<<exception [[Eval_const.NotAConstant]]>>

<<type [[Eval_const.error]]>>

<<exception [[Eval_const.Error]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Eval_const.eval]]>>
@

\section{[[Flags.ml]]}

<<constant [[Flags.debugger]]>>=
let debugger = ref false
@
%TODO: delete

%-------------------------------------------------------------

<<Flags.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

<<global [[Flags.warn]]>>
<<global [[Flags.warnerror]]>>

(* see also macroprocessor/flags_cpp.ml *)

<<constant [[Flags.dump_tokens]]>>
<<constant [[Flags.dump_ast]]>>
<<constant [[Flags.dump_typed_ast]]>>
<<constant [[Flags.dump_asm]]>>

<<constant [[Flags.debugger]]>>
<<constant [[Flags.backtrace]]>>
@

\section{[[Globals.ml]]}

%-------------------------------------------------------------

<<Globals.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(* See also globals in ../macroprocessor/location_cpp.ml  *)

<<global [[Globals.hids]]>>
@

\section{[[Lexer.mll]]}

<<Lexer helpers>>=
<<function [[Lexer.error]]>>
<<function [[Lexer.loc]]>>
<<function [[Lexer.inttype_of_suffix]]>>
<<function [[Lexer.floattype_of_suffix]]>>
(* dup: lexer_asm5.mll *)
<<function [[Lexer.code_of_escape_char]]>>
(* dup: lexer_asm5.mll *)
<<function [[Lexer.string_of_ascii]]>>
<<function [[Lexer.char_]]>>
@


\section{[[Main.ml]]}

%-------------------------------------------------------------

<<Main.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
(* open Xix_compiler *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<toplevel [[Main._1]]>>
@

\section{[[Parse.mli]]}

%-------------------------------------------------------------

<<Parse.mli>>=

<<signature [[Parse.parse]]>>

<<signature [[Parse.parse_no_cpp]]>>
@

\section{[[Parse.ml]]}

%-------------------------------------------------------------

<<Parse.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module L = Location_cpp
module T = Parser  (* T for Tokens *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[Parse.parse]]>>

<<function [[Parse.parse_no_cpp]]>>
@

\section{[[Parser.mly]]}

<<Parser helpers>>=
<<function [[Parser.error]]>>
<<function [[Parser.mk_e]]>>
<<function [[Parser.mk_t]]>>
<<function [[Parser.mk_st]]>>

<<global [[Parser.defs]]>>
<<function [[Parser.get_and_reset]]>>

<<type [[Parser.env]]>>

<<function [[Parser.add_id]]>>
<<function [[Parser.add_tag]]>>

<<global [[Parser.env]]>>

<<global [[Parser.block_counter]]>>

<<function [[Parser.gensym]]>>

<<function [[Parser.new_scope]]>>
<<function [[Parser.pop_scope]]>>
@

<<other stmt related rules>>=
<<rule [[Parser.tag]]>>
<<rule [[Parser.tfor]]>>
<<rule [[Parser.forexpr]]>>
<<rule [[Parser.labels]]>>
<<rule [[Parser.label]]>>
@

\section{[[Rewrite.mli]]}

%-------------------------------------------------------------

<<Rewrite.mli>>=
@

\section{[[Rewrite.ml]]}

%-------------------------------------------------------------

<<Rewrite.ml>>=

(* todo mandatory:
 *  - pointer arithmetic
 *  - automatic casts
 * todo for opti?:
 *  - OADDR/OIND simplifications
 *  - put constants on the right for commutative operations
 *)
@

\section{[[Storage.ml]]}

%-------------------------------------------------------------

<<Storage.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

<<type [[Storage.t]]>>
[@@deriving show]
@

\section{[[Type.ml]]}

%-------------------------------------------------------------

<<Type.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(* TODO? rename to Type_.ml because conflict with OCaml5 module name *)

<<type [[Type.blockid]]>>
[@@deriving show]
<<type [[Type.fullname]]>>
[@@deriving show]

<<type [[Type.t]]>>

<<type [[Type.integer_type]]>>
<<type [[Type.integer_kind]]>>
<<type [[Type.sign]]>>

<<type [[Type.float_type]]>>

<<type [[Type.struct_kind]]>>
[@@deriving show]

<<type [[Type.qualifier]]>>
[@@deriving show]


<<type [[Type.structdef]]>>
[@@deriving show]

<<constant [[Type.int]]>>
<<constant [[Type.long]]>>
@

\section{[[Typecheck.mli]]}

%-------------------------------------------------------------

<<Typecheck.mli>>=

<<type [[Typecheck.idinfo]]>>

<<type [[Typecheck.typed_program]]>>

<<type [[Typecheck.error]]>>
<<signature [[Typecheck.string_of_error]]>>
<<exception [[Typecheck.Error]]>>

<<signature [[Typecheck.check_and_annotate_program]]>>
@

\section{[[Typecheck.ml]]}

<<type [[Typecheck.integer]]>>=
type integer = int
@

%-------------------------------------------------------------

<<Typecheck.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast
module T = Type
module S = Storage
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This module does many things:
 *  - it expands typedefs
 *  - it assigns a final (resolved) type to every identifiers
 *  - it assigns a final storage to every identifiers
 *  - it assigns a type to every expressions
 *  - it returns a typed AST and also transforms this AST
 *    (e.g., enum constants are replaced by their value)
 * 
 * Thanks to the naming done in parser.mly and the unambiguous Ast.fullname,
 * we do not have to handle scope here. 
 * Thanks to check.ml we do not have to check for inconsistencies or
 * redefinition of tags. We can assume everything is fine.
 * 
 * limitations compared to 5c:
 *  - no 'void*' conversions 
 *    (clang does not either? but we do accept so void* vs xxx* )
 *  - no struct equality by field equality. I use name equality.
 *    (who uses that anyway?)
 *  - no float enum
 *    (who uses that anyway?)
 *  - no 0 to nil automatic cast inserted
 *    (I prefer stricter typechecking)
 * 
 * todo: 
 *  - const checking (in check_const.ml?) need types!
 *  - format checking (in check_format.ml?) need types!
 *  - misc checks
 *    * stupid shift bits (need constant evaluation) outside width
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* less: vlong? *)
<<type [[Typecheck.integer]]>>

<<type [[Typecheck.idinfo]]>>

(* alt: Frontend.result, Frontend.entities, Frontend.t, Typecheck.result *)
<<type [[Typecheck.typed_program]]>>

<<type [[Typecheck.env]]>>
<<type [[Typecheck.expr_context]]>>

(* less: could factorize things in error.ml? *)
<<type [[Typecheck.error]]>>

<<function [[Typecheck.string_of_error]]>>

<<exception [[Typecheck.Error]]>>

<<function [[Typecheck.type_error]]>>

<<function [[Typecheck.type_error2]]>>

(*****************************************************************************)
(* Types helpers *)
(*****************************************************************************)

<<function [[Typecheck.same_types]]>>
   
<<function [[Typecheck.merge_types]]>>

(* when processing enumeration constants, we want to keep the biggest type *)
(*
let max_types t1 t2 = ...
*)

<<function [[Typecheck.check_compatible_binary]]>>

<<function [[Typecheck.result_type_binary]]>>

<<function [[Typecheck.check_compatible_assign]]>>

<<function [[Typecheck.check_args_vs_params]]>>
    
(*****************************************************************************)
(* Storage helpers *)
(*****************************************************************************)
<<function [[Typecheck.merge_storage_toplevel]]>>

(*****************************************************************************)
(* Other helpers *)
(*****************************************************************************)
<<function [[Typecheck.lvalue]]>>

<<function [[Typecheck.array_to_pointer]]>>

<<function [[Typecheck.unsugar_anon_structure_element]]>>

(*****************************************************************************)
(* AST Types to Types.t *)
(*****************************************************************************)
<<function [[Typecheck.type_]]>>

(*****************************************************************************)
(* Expression typechecking *)
(*****************************************************************************)
<<function [[Typecheck.expr]]>>
<<function [[Typecheck.expropt]]>>

(*****************************************************************************)
(* Statement *)
(*****************************************************************************)
<<function [[Typecheck.stmt]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Typecheck.check_and_annotate_program]]>>
@

\section{[[macroprocessor/Ast_cpp.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Ast_cpp.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An Abstract Syntax Tree (AST) for the C Pre-Processor (CPP) directives. *)

(*****************************************************************************)
(* The AST *)
(*****************************************************************************)

<<type [[Ast_cpp.directive]]>>

<<type [[Ast_cpp.macro]]>>
[@@deriving show]
@

\section{[[macroprocessor/Flags_cpp.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Flags_cpp.ml>>=

<<constant [[Flags_cpp.debug_line]]>>
<<constant [[Flags_cpp.debug_include]]>>
<<constant [[Flags_cpp.debug_macros]]>>
@

\section{[[macroprocessor/Lexer_cpp.mll]]}

\section{[[macroprocessor/Location_cpp.mli]]}

<<signature [[Location_cpp.add_event]]>>=
(* add to history *)
val add_event: 
  location_event -> unit
@

<<signature [[Location_cpp.final_loc_of_loc]]>>=
(* !uses history! you should avoid this function in a multifile processing
 * context (e.g., in the linker) *)
val final_loc_of_loc: 
    loc -> final_loc
@

<<signature [[Location_cpp.dump_event]]>>=
val dump_event:
  location_event -> unit
@

%-------------------------------------------------------------

<<macroprocessor/Location_cpp.mli>>=

<<type [[Location_cpp.loc]]>>
<<type [[Location_cpp.final_loc]]>>

<<type [[Location_cpp.location_history]]>>
<<type [[Location_cpp.location_event]]>>
[@@deriving show]

<<signature [[Location_cpp.history]]>>
<<signature [[Location_cpp.line]]>>

<<exception [[Location_cpp.Error]]>>


<<signature [[Location_cpp.add_event]]>>

<<signature [[Location_cpp.final_loc_of_loc]]>>


<<signature [[Location_cpp.dump_event]]>>
@


\section{[[macroprocessor/Location_cpp.ml]]}

<<exception [[Location_cpp.Error]]>>=
exception Error of string * loc
@

<<function [[Location_cpp.dump_event]]>>=
(* for 5c -f 
 * alt: just rely on deriving show but kept this for compatibility with kencc
 *)
let dump_event (event : location_event) : unit =
  match event with
  | Include file -> 
      Logs.app (fun m -> m "%4d: %s" !line !!file)
  | Line (local_line, file) -> 
      Logs.app (fun m -> m "%4d: %s (#line %d)" !line !!file local_line)
  | Eof -> 
      Logs.app (fun m -> m "%4d: <pop>" !line)
@

<<function [[Location_cpp.add_event]]>>=
let add_event (event : location_event) : unit =
  (* alt: use Logs.debug instead of a flag *)
  if !Flags_cpp.debug_line
  then dump_event event;
  history := {location_event = event; global_line = !line }::!history
@

<<function [[Location_cpp.final_loc_of_loc]]>>=
(* 'history' contains the list of location_events in reverse order
 * since we always add an event to the end, for instance: 
 * [200; 150; 130; 60; 1]. The first step is to reverse this list:
 * [1; 60; 130; 150; 200]. Then, if we look for information about line 135, 
 * we want to stop when we encounter 150,
 * so when lineno < x.global_line below succeed for the first time.
 *)
let final_loc_of_loc (lineno : loc) : final_loc =
  let rec aux (lastfile, lastlineno, lastdelta) stack xs =
    match xs with
    | [] -> lastfile, lineno - lastlineno + lastdelta
    | x::xs ->
      if lineno < x.global_line 
      then lastfile, lineno - lastlineno + lastdelta
      else
        (match x.location_event, stack with
        | Eof, (lastfile, _lastlineno, lastdelta)::ys ->
            (* bugfix: wrong!! TODO *)
            aux (lastfile, x.global_line, lastdelta) ys xs
        | Eof, [] -> 
            failwith ("impossible: wrong location history, unpaired Eof")
        | Include file, ys ->
            aux (file, x.global_line, 1)
              ((lastfile, lastlineno, lastdelta)::ys) xs
        | Line (line, file), _y::ys ->
            aux (file, x.global_line, line) ys xs
        | Line (line, file), [] ->
            (* todo: wrong *)
            aux (file, x.global_line, line) [] xs
        )
  in
  aux (Fpath.v "<nofile>", 0, 0) [] (List.rev !history)
@

<<function [[Location_cpp._final_loc_and_includers_of_loc]]>>=
let _final_loc_and_includers_of_loc _lineno =
  raise Todo
@


%-------------------------------------------------------------

<<macroprocessor/Location_cpp.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * less: normalize filenames? use realpath?
 *)

(*****************************************************************************)
(* Types and globals *)
(*****************************************************************************)

<<type [[Location_cpp.loc]]>>
[@@deriving show]

<<type [[Location_cpp.final_loc]]>>
[@@deriving show]

<<type [[Location_cpp.location_history]]>>
<<type [[Location_cpp.location_event]]>>
[@@deriving show {with_path = false}]

(* TODO? move to local in Parse_cpp.ml? *)
<<constant [[Location_cpp.history]]>>

<<constant [[Location_cpp.line]]>>

<<exception [[Location_cpp.Error]]>>

(*****************************************************************************)
(* Debugging *)
(*****************************************************************************)

<<function [[Location_cpp.dump_event]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)
<<function [[Location_cpp.add_event]]>>


<<function [[Location_cpp.final_loc_of_loc]]>>

<<function [[Location_cpp._final_loc_and_includers_of_loc]]>>
@

\section{[[macroprocessor/Parse_cpp.mli]]}

%-------------------------------------------------------------

<<macroprocessor/Parse_cpp.mli>>=

<<type [[Parse_cpp.token_category]]>>
[@@deriving show]

(* wrapper around a parser/lexer (e.g., 5c) to preprocess first the file *)
<<type [[Parse_cpp.hook]]>>

<<signature [[Parse_cpp.parse]]>>

@

\section{[[macroprocessor/Parse_cpp.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Parse_cpp.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

module D = Ast_cpp (* D for Directives *)
module L = Location_cpp
module Flags = Flags_cpp

(* for record matching for ocaml-light *)
open Ast_cpp

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Cpp as a library. This is used by 5c but also 5a.
 * 
 * Main limitations compared to the cpp embedded in 5c of Plan 9:
 *  - no support for unicode
 *  - see Lexer_cpp.mll
 * Main limitations compared to ANSI cpp:
 *  - no complex boolean expressions for #ifdefs
 *
 * stricter:
 *  - see Lexer_cpp.mll
 * more general:
 *  - allow any number of arguments for macros 
 *    (not limited to 25 because of the use of #a to #z)
 *  - allow any body size 
 *    (no 8196 buffer limit)
 *  - allow any filename length in #include 
 *    (no 200 limit)
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Parse_cpp.token_category]]>>
[@@deriving show]

<<type [[Parse_cpp.hook]]>>

<<type [[Parse_cpp.macro]]>>

(*****************************************************************************)
(* Globals *)
(*****************************************************************************)
<<constant [[Parse_cpp.hmacros]]>>

<<constant [[Parse_cpp._cwd]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Parse_cpp.error]]>>


<<function [[Parse_cpp.define_cmdline_def]]>>

<<function [[Parse_cpp.define]]>>

<<function [[Parse_cpp.find_include]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Parse_cpp.parse]]>>
@


\section{[[macroprocessor/Preprocessor.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Preprocessor.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Data structure containing the command-line data that one can pass to cpp
 * (e.g, -D and -I CLI flags).
 * This is passed then to Parse_cpp.parse() in addition to hooks.
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Preprocessor.conf]]>>
[@@deriving show]
@
