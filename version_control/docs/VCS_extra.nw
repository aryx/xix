\section{[[version_control/]]}

\subsection{[[version_control/IO_.mli]]}

%-------------------------------------------------------------

<<version_control/IO_.mli>>=

<<signature [[IO_.read_string_and_stop_char]]>>

<<signature [[IO_.read_int_and_nullbyte]]>>

<<signature [[IO_.read_key_space_value_newline]]>>

<<signature [[IO_.with_close_out]]>>
@

\subsection{[[version_control/IO_.ml]]}

%-------------------------------------------------------------

<<version_control/IO_.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[IO_.with_close_out]]>>

<<function [[IO_.read_string_and_stop_char]]>>

<<function [[IO_.read_int_and_nullbyte]]>>

<<function [[IO_.read_key_space_value_newline]]>>
@

\subsection{[[version_control/blob.mli]]}

%-------------------------------------------------------------

<<version_control/blob.mli>>=

<<type [[Blob.t]]>>

<<type [[Blob.hash]]>>

<<signature [[Blob.read]]>>
<<signature [[Blob.write]]>>

<<signature [[Blob.show]]>>
@

\subsection{[[version_control/blob.ml]]}

%-------------------------------------------------------------

<<version_control/blob.ml>>=
<<copyright ocamlgit>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Blob.t]]>>

<<type [[Blob.hash]]>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function [[Blob.read]]>>

<<function [[Blob.write]]>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function [[Blob.show]]>>
@

\subsection{[[version_control/change.mli]]}

%-------------------------------------------------------------

<<version_control/change.mli>>=

<<type [[Change.content]]>>

<<type [[Change.entry]]>>

<<type [[Change.t]]>>
@

\subsection{[[version_control/change.ml]]}

%-------------------------------------------------------------

<<version_control/change.ml>>=
<<copyright ocamlgit>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Change.content]]>>

<<type [[Change.entry]]>>

<<type [[Change.t]]>>
@

\subsection{[[version_control/changes.mli]]}

%-------------------------------------------------------------

<<version_control/changes.mli>>=

<<signature [[Changes.changes_tree_vs_tree]]>>

<<signature [[Changes.changes_worktree_vs_index]]>>

<<signature [[Changes.changes_index_vs_tree]]>>
@

\subsection{[[version_control/changes.ml]]}

%-------------------------------------------------------------

<<version_control/changes.ml>>=
<<copyright ocamlgit>>
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * todo: 
 *  - rename detection
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Changes.skip_tree_and_adjust_path]]>>

<<function [[Changes.content_from_path_and_stat_index]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[Changes.changes_tree_vs_tree]]>>

<<function [[Changes.changes_worktree_vs_index]]>>

<<function [[Changes.changes_index_vs_tree]]>>
@

\subsection{[[version_control/client.mli]]}

%-------------------------------------------------------------

<<version_control/client.mli>>=

<<type [[Client.t]]>>
@

\subsection{[[version_control/client.ml]]}

%-------------------------------------------------------------

<<version_control/client.ml>>=
<<copyright ocamlgit>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Client.t]]>>
@

\subsection{[[version_control/client_git.mli]]}

%-------------------------------------------------------------

<<version_control/client_git.mli>>=

<<signature [[Client_git.mk_client]]>>
@

\subsection{[[version_control/client_git.ml]]}

%-------------------------------------------------------------

<<version_control/client_git.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Client_git.mk_client]]>>
@

\subsection{[[version_control/client_local.mli]]}

%-------------------------------------------------------------

<<version_control/client_local.mli>>=

<<signature [[Client_local.mk_client]]>>
@

\subsection{[[version_control/client_local.ml]]}

%-------------------------------------------------------------

<<version_control/client_local.ml>>=
<<copyright ocamlgit>>
open Common
open Fpath_.Operators
open Regexp_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Graph walkers *)
(*****************************************************************************)

<<type [[Client_local.graph_walker]]>>

<<function [[Client_local.ml_graph_walker]]>>

<<function [[Client_local.collect_filetree]]>>
    
(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
 
<<function [[Client_local.find_top_common_commits]]>>

<<function [[Client_local.iter_missing_objects]]>>


<<function [[Client_local.fetch_objects]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Client_local.mk_client]]>>
@

\subsection{[[version_control/clients.mli]]}

%-------------------------------------------------------------

<<version_control/clients.mli>>=

<<signature [[Clients.client_of_url]]>>
@

\subsection{[[version_control/clients.ml]]}

%-------------------------------------------------------------

<<version_control/clients.ml>>=
<<copyright ocamlgit>>
open Common
open Regexp_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Clients.client_of_url]]>>
@

\subsection{[[version_control/cmd_.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_.ml>>=

<<type [[Cmd_.t]]>>

<<exception [[Cmd_.ShowUsage]]>>
@

\subsection{[[version_control/cmd_add.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_add.ml>>=
<<copyright ocamlgit>>

<<function [[Cmd_add.add]]>>

<<constant [[Cmd_add.cmd]]>>
@

\subsection{[[version_control/cmd_branch.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_branch.ml>>=
<<copyright ocamlgit>>
open Common
open Regexp_.Operators


<<function [[Cmd_branch.list_branches]]>>

<<function [[Cmd_branch.create_branch]]>>

<<function [[Cmd_branch.delete_branch]]>>

(* less: rename_branch *)

<<constant [[Cmd_branch.del_flag]]>>
<<constant [[Cmd_branch.del_force]]>>

<<constant [[Cmd_branch.cmd]]>>
@

\subsection{[[version_control/cmd_checkout.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_checkout.ml>>=
<<copyright ocamlgit>>
open Common

<<function [[Cmd_checkout.checkout]]>>

<<function [[Cmd_checkout.update]]>>

<<constant [[Cmd_checkout.cmd]]>>
@

\subsection{[[version_control/cmd_clone.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_clone.ml>>=
<<copyright ocamlgit>>

<<function [[Cmd_clone.clone]]>>

(* todo: when clone then repo should have a "refs/remotes/origin/master" *)

<<constant [[Cmd_clone.cmd]]>>
@

\subsection{[[version_control/cmd_commit.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_commit.ml>>=
<<copyright ocamlgit>>
open Common

<<function [[Cmd_commit.commit]]>>

<<constant [[Cmd_commit.author]]>>
<<constant [[Cmd_commit.committer]]>>
<<constant [[Cmd_commit.message]]>>

<<constant [[Cmd_commit.cmd]]>>
@

\subsection{[[version_control/cmd_diff.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_diff.ml>>=
<<copyright ocamlgit>>

<<function [[Cmd_diff.diff_worktree_vs_index]]>>

<<constant [[Cmd_diff.cmd]]>>
@

\subsection{[[version_control/cmd_dump.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_dump.ml>>=
<<copyright ocamlgit>>
open Common

<<constant [[Cmd_dump.raw]]>>
<<constant [[Cmd_dump.index]]>>

<<function [[Cmd_dump.dump_object]]>>

<<function [[Cmd_dump.dump_index]]>>

<<function [[Cmd_dump.dump]]>>

<<constant [[Cmd_dump.cmd]]>>
@

\subsection{[[version_control/cmd_help.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_help.ml>>=
<<copyright ocamlgit>>
open Common

<<constant [[Cmd_help.list_extra]]>>

<<constant [[Cmd_help.cmd]]>>
@

\subsection{[[version_control/cmd_init.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_init.ml>>=
<<copyright ocamlgit>>

(* less: let bare = ref false *)

<<constant [[Cmd_init.cmd]]>>
@

\subsection{[[version_control/cmd_log.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_log.ml>>=
<<copyright ocamlgit>>
open Common
open Fpath_.Operators

(* todo: git log --graph --oneline --decorate --all *)

<<function [[Cmd_log.print_commit]]>>

<<function [[Cmd_log.print_change]]>>


<<constant [[Cmd_log.name_status]]>>

<<function [[Cmd_log.log]]>>

<<constant [[Cmd_log.cmd]]>>
@

\subsection{[[version_control/cmd_merge.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_merge.ml>>=
@

\subsection{[[version_control/cmd_pull.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_pull.ml>>=
<<copyright ocamlgit>>
open Common

<<function [[Cmd_pull.pull]]>>

<<constant [[Cmd_pull.cmd]]>>
@

\subsection{[[version_control/cmd_push.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_push.ml>>=
<<copyright ocamlgit>>
open Common
open Fpath_.Operators

<<function [[Cmd_push.push]]>>

<<constant [[Cmd_push.cmd]]>>
@

\subsection{[[version_control/cmd_reset.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_reset.ml>>=
<<copyright ocamlgit>>
open Common

<<function [[Cmd_reset.reset_hard]]>>

<<constant [[Cmd_reset.hard]]>>
<<constant [[Cmd_reset.soft]]>>
<<constant [[Cmd_reset.mixed]]>>

<<constant [[Cmd_reset.cmd]]>>
@

\subsection{[[version_control/cmd_rm.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_rm.ml>>=
<<copyright ocamlgit>>

<<function [[Cmd_rm.rm]]>>

<<constant [[Cmd_rm.cmd]]>>
@

\subsection{[[version_control/cmd_show.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_show.ml>>=
<<copyright ocamlgit>>
open Common

<<function [[Cmd_show.show]]>>

<<constant [[Cmd_show.cmd]]>>
@

\subsection{[[version_control/cmd_status.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_status.ml>>=
<<copyright ocamlgit>>
open Common
open Fpath_.Operators
open Regexp_.Operators

<<type [[Cmd_status.status]]>>

<<function [[Cmd_status.changes_index_vs_HEAD]]>>

<<function [[Cmd_status.untracked]]>>


<<function [[Cmd_status.status_of_repository]]>>

<<function [[Cmd_status.print_change_long]]>>


<<function [[Cmd_status.print_status_long]]>>
    

<<function [[Cmd_status.print_status_short]]>>

<<constant [[Cmd_status.short_format]]>>

<<function [[Cmd_status.status]]>>

<<constant [[Cmd_status.cmd]]>>
@

\subsection{[[version_control/cmd_test.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_test.ml>>=
<<copyright ocamlgit>>
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Algorithm tests *)
(*****************************************************************************)

<<function [[Cmd_test.test_sha1]]>>

let test_diff file1 file2 =
  let read_all path =
      let path = Fpath.v path in
      path |> UChan.with_open_in (fun (ch : Chan.i) ->
        ch.ic |> IO.input_channel |> IO.read_all
      )
  in
  let content1 = read_all file1 in
  let content2 = read_all file2 in

  let diffs = Diffs.diff content1 content2 in
  if not (diffs |> List.for_all (function Diff.Equal _ -> true | _ -> false))
  then begin
    UConsole.print (spf "diff --git %s %s" file1 file2);
    (* less: display change of modes *)
    Diff_unified.show_unified_diff diffs
  end

let test_diff3 fileo filea fileb =
  let read_all path =
      let path = Fpath.v path in
      path |> UChan.with_open_in (fun (ch : Chan.i) ->
        ch.ic |> IO.input_channel |> IO.read_all
      )
  in
  let contento = read_all fileo in
  let contenta = read_all filea in
  let contentb = read_all fileb in

  let chunks = Diff3.diff3 contento contenta contentb in
  let str = Diff3.merge filea fileb chunks in
  print_string str

let test_unzip file =
  let chan = open_in file in
  let input = IO.input_channel chan in
  let unzipped = Unzip.inflate input in
  let str = IO.read_all unzipped in
  print_string str

let test_zip file =
  let chan = open_in file in
  let input = IO.input_channel chan in
  let zipped = Zip.deflate input in
  let str = IO.read_all zipped in
  UConsole.print str
(* TODO
  let dst = file ^ ".deflate" in
  let chan = open_out dst in
  let output = IO.output_channel chan in
  IO.nwrite_string output str;
  IO.close_out output
*)
  

let test_unzip_all_objects () =
  Unzip.debug := true;
  let dir = Fpath.v ".git/objects" in
  dir |> Repository.walk_dir (fun path _dirs files ->
    files |> List.iter (fun file ->
      let file = path / file in
      UConsole.print !!file;
      let chan = open_in !!file in
      let input = IO.input_channel chan in
      let unzipped = Unzip.inflate input in
      let _str = IO.read_all unzipped in 
      ()
    )
  )

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<constant [[Cmd_test.cmd]]>>

@

\subsection{[[version_control/cmds.ml]]}

%-------------------------------------------------------------

<<version_control/cmds.ml>>=

<<constant [[Cmds.main_commands]]>>

<<constant [[Cmds.extra_commands]]>>
@

\subsection{[[version_control/commit.mli]]}

%-------------------------------------------------------------

<<version_control/commit.mli>>=
open Common

<<type [[Commit.t]]>>
<<type [[Commit.hash]]>>


<<signature [[Commit.read]]>>
<<signature [[Commit.write]]>>

<<signature [[Commit.show]]>>

<<signature [[Commit.collect_ancestors]]>>

<<signature [[Commit.walk_history]]>>
@

\subsection{[[version_control/commit.ml]]}

%-------------------------------------------------------------

<<version_control/commit.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Commit.t]]>>
<<type [[Commit.hash]]>>

(*****************************************************************************)
(* API *)
(*****************************************************************************)

(* for git log *)

<<function [[Commit.walk_history]]>>

(* for git pull *)

<<function [[Commit.collect_ancestors]]>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function [[Commit.read]]>>

<<function [[Commit.write]]>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function [[Commit.show]]>>
@

\subsection{[[version_control/compression.mli]]}

%-------------------------------------------------------------

<<version_control/compression.mli>>=

<<signature [[Compression.decompress]]>>
<<signature [[Compression.compress]]>>
@

\subsection{[[version_control/compression.ml]]}

%-------------------------------------------------------------

<<version_control/compression.ml>>=
<<copyright ocamlgit>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Compression/decompression wrappers.
 * 
 * alternatives:
 *  * https://github.com/ygrek/ocaml-extlib/src/unzip.ml
 *    just decompression (inflate), pretty small: 450 LOC
 *  - https://github.com/mirage/decompress
 *    compression/decompression, seems complete, but pretty big. 
 *    used by https://github.com/mirage/ocaml-git
 *  * https://github.com/xavierleroy/camlzip
 *    uses C code (some of the code in ocaml-git uses ML code from camlzip)
 *  - https://github.com/madroach/ocaml-zlib
 *    ??
 *  - https://github.com/samoht/ocaml-lz77 
 *    copy-pasted in decompress, but too simple. Does not
 *    support right API where can compress/decompress strings.
 *  - libflate in plan9 :)
 *  - ocamlgz from ocamlplot, but just an OCaml binding to C lib
 * 
 * Currently used solutions are marked with a '*' above.
 *)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[Compression.decompress]]>>

<<function [[Compression.compress]]>>
@

\subsection{[[version_control/diff.mli]]}

%-------------------------------------------------------------

<<version_control/diff.mli>>=

<<type [[Diff.item]]>>

<<type [[Diff.diff_elem]]>>

<<type [[Diff.diff]]>>

@

\subsection{[[version_control/diff.ml]]}

%-------------------------------------------------------------

<<version_control/diff.ml>>=
<<copyright ocamlgit>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Diff.item]]>>

<<type [[Diff.diff_elem]]>>

<<type [[Diff.diff]]>>

@

\subsection{[[version_control/diff_basic.mli]]}

<<version_control/diff_basic.mli>>=

<<signature [[Diff_basic.diff]]>>

@

\subsection{[[version_control/diff_basic.ml]]}

<<version_control/diff_basic.ml>>=
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Basic Diff algorithm based on the computation of the edit distance between
 * two strings (also known as the Longuest Common Subsequence (LCS) problem).
 * 
 * reference: 
 * "Algorithms on Strings, Trees, and Sequences" by Dan Gusfield, P217.
 * 
 * For two strings S1 and S2, D(i,j) is defined to be the edit distance 
 * of S1[1..i] to S2[1..j].
 * So the edit distance of S1 (of length n) and S2 (of length m) is D(n,m).
 * 
 * Dynamic programming technique
 * base: 
 *  D(i,0) = i  for all i 
 *   because to go from S1[1..i] to 0 characters of S2 you have to 
 *   delete all the characters from S1[1..i]
 *  D(0,j) = j  for all j 
 *    because j characters must be inserted
 * recurrence:
 *  D(i,j) = min([D(i-1, j)+1, 
 *                D(i, j-1)+1, 
 *                D(i-1, j-1) + t(i,j)])
 *   where t(i,j) is equal to 1 if S1(i) != S2(j) and  0 if equal
 * 
 *  Intuition = there are 4 possible actions:
 *    deletion, insertion, substitution, or match
 *  so Lemma =
 *   D(i,j) must be one of the three
 *     D(i, j-1) + 1
 *     D(i-1, j)+1 
 *     D(i-1, j-1) + 
 *       t(i,j) 
 * 
 * history: done in summer 2007 for Julia Lawall
 * 
 * complexity: O(nm) in time and space, so if you want to diff two
 * sequences of more than 10 000 elts, it will requires a matrix with
 * 100 M and 100 M operations, so this is not very scalable 
 * (see Myers's algorithm used in GNU diff for a more scalable algorithm).
 *)

(*****************************************************************************)
(* Algorithm *)
(*****************************************************************************)

<<function [[Diff_basic.matrix_distance]]>>

<<function [[Diff_basic.traceback_transcript]]>>

(*****************************************************************************)
(* Optimization *)
(*****************************************************************************)
(* Actually this is not a big win. On files of 20 000 LOC, you
 * go from 125s to 118s, so the string comparison in matrix_distance()
 * is not the bottleneck.
 * Actually in native mode you go from 33s to 35s so this is even
 * slowing things down, weird.
 *)
let hash_strings arr1 arr2 =
  let cnt = ref 0 in
  let h = Hashtbl.create (Array.length arr1 / 3) in
  Array.concat [arr1; arr2] |> Array.iter (fun s ->
    if not (Hashtbl.mem h s)
    then begin
      Hashtbl.add h s !cnt;
      incr cnt;
    end
  );
  let revh = Array.make !cnt ("INCORRECT") in
  h |> Hashtbl.iter (fun k v ->
    revh.(v) <- k
  );
  arr1 |> Array.map (fun s -> Hashtbl.find h s),
  arr2 |> Array.map (fun s -> Hashtbl.find h s),
  revh

(* other optimizations:
 *  - strip common lines in the front and end (McIlroy diff was doing that)
 *    so can reduce significantly the size of the matrix
 *  - Use Hirschberg space opti of storing only the last row.
 *    No need for full matrix to determine the next row (but then
 *    need to be clever to get the traceback).
 *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Diff_basic.diff]]>>

(*****************************************************************************)
(* Tests/Bench *)
(*****************************************************************************)
(* good bench: sqlite aggalmation, more than 200 000 LOC 
 * time ./ogit test diff /tmp/test1.c /tmp/test2.c 
 *  (where test[12].c = sqlite.c or shorter version of sqlite.c)
 *  on my Macbook Air (from around 2014).
 * 200 000 LOC:
 * - Myers: 1.4s (in ocaml bytecode mode)
 * - Basic: ???
 * 20 000 LOC: (matrix_distance requires a matrix of 400M elements)
 * - Myers: 0.1s 
 * - Basic: 104s in bytecode, 33s in native
 *)

(*
let edit_distance s1 s2 = 
  (matrix_distance s1 s2).(String.length s1).(String.length s2)


let test = edit_distance "vintner" "writers"
let _ = assert (edit_distance "winter" "winter" = 0)
let _ = assert (edit_distance "vintner" "writers" = 5)
*)

@

\subsection{[[version_control/diff_myers.mli]]}
%pad: I defunctorized it and factorized types with types in diff.ml

%<<type Diff_myers.common>>
%
%<<type Diff_myers.edit>>
%
%<<signature Diff_myers.SeqType>>
%
%<<signature Diff_myers.S>>
%
%<<signature Diff_myers.Make>>
%
%<<type Diff_myers.common>>=
%(** an element of lcs of seq1 and seq2 *)
%type 'a common =
%  [ `Common of int * int * 'a ]
%@
%
%<<type Diff_myers.edit>>=
%(** an element of diff of seq1 and seq2. *)
%type 'a edit =
%  [ `Added of int * 'a
%  | `Removed of int * 'a
%  | 'a common
%  ]
%@
%
%<<signature Diff_myers.SeqType>>=
%module type SeqType = sig
%  type t
%  (** The type of the sequence. *)
%
%  type elem
%  (** The type of the elements of the sequence. *)
%
%  val get : t -> int -> elem
%  (** [get t n] returns [n]-th element of the sequence [t]. *)
%
%  val length : t -> int
%  (** [length t] returns the length of the sequence [t]. *)
%end
%(** Input signature of {!Diff.Make}. *)
%@
%
%<<signature Diff_myers.S>>=
%module type S = sig
%  type t
%  (** The type of input sequence. *)
%
%  type elem
%  (** The type of the elemenents of result / input sequence. *)
%
%  val lcs :
%      ?equal:(elem -> elem -> bool) ->
%      t -> t -> elem common list
%  (**
%     [lcs ~equal seq1 seq2] computes the LCS (longest common sequence) of
%     [seq1] and [seq2].
%     Elements of [seq1] and [seq2] are compared with [equal].
%     [equal] defaults to [Pervasives.(=)].
%
%     Elements of lcs are [`Common (pos1, pos2, e)]
%     where [e] is an element, [pos1] is a position in [seq1],
%     and [pos2] is a position in [seq2].
%   *)
%
%  val diff :
%      ?equal:(elem -> elem -> bool) ->
%      t -> t -> elem edit list
%  (**
%     [diff ~equal seq1 seq2] computes the diff of [seq1] and [seq2].
%     Elements of [seq1] and [seq2] are compared with [equal].
%
%     Elements only in [seq1] are represented as [`Removed (pos, e)]
%     where [e] is an element, and [pos] is a position in [seq1];
%     those only in [seq2] are represented as [`Added (pos, e)]
%     where [e] is an element, and [pos] is a position in [seq2];
%     those common in [seq1] and [seq2] are represented as
%     [`Common (pos1, pos2, e)]
%     where [e] is an element, [pos1] is a position in [seq1],
%     and [pos2] is a position in [seq2].
%   *)
%
%  val fold_left :
%      ?equal:(elem -> elem -> bool) ->
%      f:('a -> elem edit -> 'a) ->
%      init:'a ->
%      t -> t -> 'a
%  (**
%     [fold_left ~equal ~f ~init seq1 seq2] is same as
%     [diff ~equal seq1 seq2 |> ListLabels.fold_left ~f ~init],
%     but does not create an intermediate list.
%   *)
%
%  val iter :
%      ?equal:(elem -> elem -> bool) ->
%      f:(elem edit -> unit) ->
%      t -> t -> unit
%  (**
%     [iter ~equal ~f seq1 seq2] is same as
%     [diff ~equal seq1 seq2 |> ListLabels.iter ~f],
%     but does not create an intermediate list.
%   *)
%end
%(** Output signature of {!Diff.Make}. *)
%@
%
%<<signature Diff_myers.Make>>=
%module Make :
%  functor (M : SeqType) -> (S with type t = M.t and type elem = M.elem)
%(** Functor building an implementation of the diff structure
%    given a sequence type.  *)
%@

%-------------------------------------------------------------

<<version_control/diff_myers.mli>>=
(**
   An implementation of Eugene Myers' O(ND) Difference Algorithm\[1\].
   This implementation is a port of util.lcs module of
   {{:http://practical-scheme.net/gauche} Gauche Scheme interpreter}.

   - \[1\] Eugene Myers, An O(ND) Difference Algorithm and Its Variations, Algorithmica Vol. 1 No. 2, pp. 251-266, 1986.
 *)

<<signature [[Diff_myers.diff]]>>
@


\subsection{[[version_control/diff_myers.ml]]}

%pad: I defunctorized it, removed @@, removed default argument, removed labels
% and specialized fold_left

%<<type Diff_myers.common>>
%
%<<type Diff_myers.edit>>
%
%<<signature Diff_myers.SeqType>>
%
%<<signature Diff_myers.S>>
%
%<<module Diff_myers.Make>>

%<<module Diff_myers.Make>>=
%module Make(M : SeqType) : (S with type t = M.t and type elem = M.elem) = struct
%  type t = M.t
%  type elem = M.elem
%
%let iter ?(equal = (=)) ~f a b =
%  fold_left a b
%    ~equal
%    ~f:(fun () x -> f x)
%    ~init:()
%end

%<<module Diffs.StringDiff>>

%<<module Diffs.StringDiff>>=
%module StringDiff = Diff_myers.Make(struct
%  type t = string array
%  type elem = string
%  let get t i = Array.get t i
%  let length t = Array.length t
%end)
%@
%(*
%  let res = StringDiff.diff (Array.of_list xs) (Array.of_list ys) in
%  res |> List.rev |> List.map (function
%    | `Common (_, _, s) -> Diff.Equal s
%    | `Removed (_, s) -> Diff.Deleted s
%    | `Added (_, s) -> Diff.Added s
%  )
%*)

%<<function Diff_myers.fold_left>>

%let fold_left f init a b =
%  let ff x y = f y x in
%  let fold_map f g x from to_ init =
%    let rec loop i init =
%      if i >= to_ 
%      then init
%      else loop (i + 1) (f (g i (M.get x i)) init)
%    in loop from init
%  in
%  let added _i x = Diff.Added x in
%  let removed _i x = Diff.Deleted x in
%  let rec loop cs apos bpos init =
%    match cs with
%    | [] ->
%        init
%        |> fold_map ff removed a apos (M.length a)
%        |> fold_map ff added b bpos (M.length b)
%    | `Common (aoff, boff, x) as e :: rest ->
%        init
%        |> fold_map ff removed a apos aoff
%        |> fold_map ff added b bpos boff
%        |> ff (Diff.Equal x)
%        |> loop rest (aoff + 1) (boff + 1)
%  in loop (lcs a b) 0 0 init
%
%let diff a b =
%  fold_left (fun xs x -> x::xs) [] a b


%-------------------------------------------------------------

<<version_control/diff_myers.ml>>=
<<copyright ocaml-diff-myers>>

(* was functorized and parametrized before *)
let equal = (=)

<<function [[Diff_myers.lcs]]>>

<<function [[Diff_myers.diff]]>>
@


\subsection{[[version_control/diff_simple.mli]]}

%-------------------------------------------------------------

<<version_control/diff_simple.mli>>=
(** A simple diffing algorithm *)

module type Comparable =
  sig
    type t
      (** The type of the items being compared *)

    val compare: t -> t -> int
      (** A way to distinguish if items are equal or unequal. It follows
          the OCaml convention of returning an integer between -1 to 1. *)
  end

module type S =
  sig
    type item
    (** The type of the item that will be compared. *)

    type diff =
      | Deleted of item array
      | Added of item array
      | Equal of item array
    (** Represents the change or lack of change in a line or character
        between the old and new version. *)

    type t = diff list
    (** List of diffs which is the return value of the main function. *)

    val get_diff : item array -> item array -> t
    (** Returns a list of diffs between two arrays *)
  end

module Make (Item: Comparable) : S with type item = Item.t
@


\subsection{[[version_control/diff_simple.ml]]}
%buggy! so not in mkfile for now

%
%<<function Diff.diff_buggy>>=
%(*
%SimpleDiff is buggy!
%Here is an example of output after an ogit diff (with some debugging 
%information):
%
%diff --git a/authors.txt b/authors.txt
%["Yoann Padioleau\n"; "\n"; "except \n"; " - lex/ by Xavier Leroy (from ocaml)\n"; " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n"; " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n"; " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n"; " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n"; " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n"; " - commons/IO.ml by Nicolas Canasse (from exblib)\n"]
%["Yoann Padioleau\n"; "\n"; "xxx\n"; "except \n"; " - lex/ by Xavier Leroy (from ocaml)\n"; " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n"; " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n"; " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n"; " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n"; " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n"; " - commons/IO.ml by Nicolas Canasse (from exblib)\n"]
%[(()); Tag1 (("Yoann Padioleau\n")); Tag2 (("\n", "xxx\n", "except \n", " - lex/ by Xavier Leroy (from ocaml)\n", " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n", " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n", " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n", " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n", " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n", " - commons/IO.ml by Nicolas Canasse (from exblib)\n"))]
%+Yoann Padioleau
% 
% xxx
% except 
%  - lex/ by Xavier Leroy (from ocaml)
%  - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)
%  - version_control/sha.ml by Daniel Bunzli (from uuidm)
%  - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)
%  - version_control/zlib.ml by Xavier Leroy (from camlzip)
%  - version_control/unzip.ml by Nicolas Canasse (from extlib)
%  - commons/IO.ml by Nicolas Canasse (from exblib)
%
%-----------
%SimpleDiff says the diff is the addition of 'Yoann Padioleau' but it's not!
%It's in both content. The diff should be the addition of 'xxx'.
%*)
%
%let diff_buggy str1 str2 =
%  let xs = split_lines str1 in
%  let ys = split_lines str2 in
%  pr2_gen xs;
%  pr2_gen ys;
%  let res = SimpleDiff.get_diff (Array.of_list xs) (Array.of_list ys) in
%  pr2_gen res;
%  res |> List.map (function
%    | SimpleDiff.Equal arr   -> 
%      arr |> Array.to_list |> List.map (fun x -> Equal x)
%    | SimpleDiff.Deleted arr -> 
%      arr |> Array.to_list |> List.map (fun x -> Deleted x)
%    | SimpleDiff.Added arr   -> 
%      arr |> Array.to_list |> List.map (fun x -> Added x)
%  )
%@
%module SimpleDiff = Diff_simple.Make(String)


%-------------------------------------------------------------

<<version_control/diff_simple.ml>>=
module type Comparable =
  sig
    type t
    val compare: t -> t -> int
  end

module type S =
  sig
    type item

    type diff =
      | Deleted of item array
      | Added of item array
      | Equal of item array

    type t = diff list

    val get_diff : item array -> item array -> t
  end

module Make(Item : Comparable) = struct
  type item = Item.t

  type diff =
    | Deleted of item array
    | Added of item array
    | Equal of item array

  type t = diff list

  type subsequence_info =
    { (* Starting index of longest subsequence in the list of new values *)
      sub_start_new : int;
      (* Starting index of longest subsequence in the list of old values *)
      sub_start_old : int;
      (* The length of the longest subsequence *)
      longest_subsequence : int; }

  module CounterMap = Map.Make(Item)

  (* Returns a map with the line as key and a list of indices as value.
     Represents counts of all the lines. *)
  let map_counter keys =
    let keys_and_indices = Array.mapi (fun index key -> index, key) keys in
    Array.fold_left (fun map (index, key) ->
        let indices = try CounterMap.find key map with | Not_found -> [] in
        CounterMap.add key (index :: indices) map
      ) CounterMap.empty keys_and_indices


  (* Computes longest subsequence and returns data on the length of longest
     subsequence and the starting index for the longest subsequence in the old
     and new versions. *)
  let get_longest_subsequence old_lines new_lines =
    let old_values_counter = map_counter old_lines in
    let overlap = Hashtbl.create 5000 in
    let sub_start_old = ref 0 in
    let sub_start_new = ref 0 in
    let longest_subsequence = ref 0 in

    Array.iteri (fun new_index new_value ->
        let indices = try CounterMap.find new_value old_values_counter with
          | Not_found -> []
        in
        List.iter (fun old_index ->
            let prev_subsequence = try Hashtbl.find overlap (old_index - 1) with | Not_found -> 0 in
            let new_subsequence = prev_subsequence + 1 in
            Hashtbl.add overlap old_index new_subsequence;

            if new_subsequence > !longest_subsequence then
              sub_start_old := old_index - new_subsequence + 1;
            sub_start_new := new_index - new_subsequence + 1;
            longest_subsequence := new_subsequence;
          ) indices;
      ) new_lines;

    { sub_start_new = !sub_start_new;
      sub_start_old = !sub_start_old;
      longest_subsequence = !longest_subsequence }


  let rec get_diff old_lines new_lines =
    match old_lines, new_lines with
    | [||], [||] -> []
    | _, _ ->
      let { sub_start_new; sub_start_old; longest_subsequence } =
        get_longest_subsequence old_lines new_lines
      in

      if longest_subsequence == 0 then
        [Deleted old_lines; Added new_lines]
      else
        let old_lines_presubseq = Array.sub old_lines 0 sub_start_old in
        let new_lines_presubseq = Array.sub new_lines 0 sub_start_new in
        let old_lines_postsubseq =
          let start_index = sub_start_old + longest_subsequence in
          let end_index = Array.length old_lines - start_index in
          Array.sub old_lines start_index end_index
        in
        let new_lines_postsubseq =
          let start_index = sub_start_new + longest_subsequence in
          let end_index = Array.length new_lines - start_index in
          Array.sub new_lines start_index end_index
        in
        let unchanged_lines = Array.sub new_lines sub_start_new longest_subsequence in
        get_diff old_lines_presubseq new_lines_presubseq @
        [Equal unchanged_lines] @
        get_diff old_lines_postsubseq new_lines_postsubseq
end
@


\subsection{[[version_control/diffs.mli]]}

%-------------------------------------------------------------

<<version_control/diffs.mli>>=

<<signature [[Diffs.diff]]>>

(* the split lines contain the trailing '\n' when they have one *)
val split_lines: string -> string list

@



\subsection{[[version_control/diffs.ml]]}

%-------------------------------------------------------------

<<version_control/diffs.ml>>=
<<copyright ocamlgit>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Compute the differences between two files line-wise.
 *
 * alternatives:
 *  - Basic diff using simple edit distance algorithm
 *    but O(nm) time and space complexity (space especially is bad)
 *  - Hirshberg invented a linear space optimization of basic diff
 *  - Hunt and Mcilroy UNIX diff, the original diff program
 *    rely on pair of lines which are the same in both files
 *    (but if the two files contain blank lines, then very bad complexity)
 *  - Myers's diff: https://github.com/leque/ocaml-diff port of
 *    "Eugene Myers, An O(ND) Difference Algorithm and Its Variations, 
 *    Algorithmica Vol. 1 No. 2, pp. 251-266, 1986."
 *    https://stackoverflow.com/questions/42635889/myers-diff-algorithm-vs-hunt-mcilroy-algorithm
 *    Apparently Ukkonen discovered independently the same algorithm
 *    Good if the edit distance is small, but very bad if both files are
 *    very different.
 *  - Simple diff: https://github.com/gjaldon/simple-diff
 *    (an OCaml port of https://github.com/paulgb/simplediff )
 *    http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1988/8807/8807c/8807c.htm article explaining but assembly code (wtf)
 *    based on Ratcliff/Obershelp pattern-matching algorithm
 *    seems simple, but not optimal (but "looks right" to people)
 *    but ocaml version seems buggy!
 *  - Bram Cohen's Patience diff: https://github.com/janestreet/patdiff
 *    support also colored output, and word diff, but heavily modularized
 *    https://blog.jcoglan.com/2017/09/19/the-patience-diff-algorithm/
 *    https://blog.jcoglan.com/2017/09/28/implementing-patience-diff/
 *  - Plan9 diff (in plan9/utilities/string/diff/)
 *    not Myers's diff
 *  - GNU diff (in plan9/ape_cmd/diff)
 *    is based on Myers's algorithm
 *  - http://pynash.org/2013/02/26/diff-in-50-lines/ 
 *    implement Mcilroy in Python (also talk about Python difflib)
 *  - Heckle diff mentionned in diff3.py
 *    "P. Heckel. ``A technique for isolating differences between files.''
 *     Communications of the ACM, Vol. 21, No. 4, page 264, April 1978."
 * 
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Diffs.split_lines]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Diffs.diff]]>>
@


\subsection{[[version_control/diff_unified.mli]]}

%-------------------------------------------------------------

<<version_control/diff_unified.mli>>=

<<signature [[Diff_unified.show_change]]>>

(* internals *)
val show_unified_diff: Diff.diff -> unit
@


\subsection{[[version_control/diff_unified.ml]]}

%-------------------------------------------------------------

<<version_control/diff_unified.ml>>=
<<copyright ocamlgit>>
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Show differences between 2 files.
 *
 * Short explanation of unified format:
 *  - https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html
 *  - http://www.artima.com/weblogs/viewpost.jsp?thread=164293  
 * 
 * alternatives:
 *  - ocamldiff: https://github.com/zoggy/ocamldiff 
 *    parse and display unified diffs
 *  - unidiff: https://github.com/gildor478/ocaml-unidiff
 *    parse 
 *  - call diff -u (as I did in pfff) directly via Sys.command
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Diff_unified.print]]>>

<<function [[Diff_unified.print_header]]>>

<<constant [[Diff_unified.nContext]]>>

<<function [[Diff_unified.show_unified_diff]]>>


(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[Diff_unified.show_change]]>>
@


\subsection{[[version_control/diff3.ml]]}


%-------------------------------------------------------------

<<version_control/diff3.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*
 * alternatives:
 *  - gnu diff3, in C
 *    https://www.gnu.org/software/diffutils/manual/html_node/diff3-Merging.html
 *    apparently by Randy Smith in 1988 and popularized by CVS
 *  - Perl Text::Diff3
 *    http://search.cpan.org/~tociyuki/Text-Diff3-0.10/lib/Text/Diff3.pm
 *    with good example of use in man page
 *  - python diff3
 *    https://github.com/schuhschuh/cmake-basis/blob/master/src/utilities/python/diff3.py
 *    apparently translation of the Perl code, itself a translation of the
 *    C code
 *  - formal investigation of diff3:
 *    http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf
 * 
 *)
@

\subsection{[[version_control/dump.mli]]}

%-------------------------------------------------------------

<<version_control/dump.mli>>=

<<signature [[Dump.vof_obj]]>>
<<signature [[Dump.vof_index]]>>
@


\subsection{[[version_control/dump.ml]]}

%-------------------------------------------------------------

<<version_control/dump.ml>>=
open Fpath_.Operators

module Ocaml = OCaml

(* mostly auto-generated by ocamltarzan *)

module Int64 = struct
let vof_t x =
  Ocaml.vof_int (Int64.to_int x)
end

module Int32 = struct
let vof_t x =
  Ocaml.vof_int (Int32.to_int x)
end


module Sha1 = struct
  let vof_t x = 
    Ocaml.VSum (("ShaHex", [Ocaml.vof_string (Hexsha.of_sha x)]))
end

module Blob = struct
  let vof_t x = Ocaml.vof_string x
end

module Tree = struct
open Tree
let vof_perm =
  function
  | Normal -> Ocaml.VSum (("Normal", []))
  | Exec -> Ocaml.VSum (("Exec", []))
  | Link -> Ocaml.VSum (("Link", []))
  | Dir -> Ocaml.VSum (("Dir", []))
  | Commit -> Ocaml.VSum (("Commit", []))
  
let vof_entry { perm = v_perm; name = v_name; id = v_node } =
  let bnds = [] in
  let arg = Sha1.vof_t v_node in
  let bnd = ("id", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_perm v_perm in
  let bnd = ("perm", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  
let vof_t v = Ocaml.vof_list vof_entry v
end

module User = struct
open User

let vof_tz_offset x = Ocaml.vof_int x

let vof_t { name = v_name; email = v_email; date = v_date } =
  let bnds = [] in
  let arg =
    match v_date with
    | (v1, v2) ->
        let v1 = Int64.vof_t v1
        and v2 = vof_tz_offset v2
        in Ocaml.VTuple [ v1; v2 ] in
  let bnd = ("date", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_email in
  let bnd = ("email", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
end

module Commit = struct
open Commit
let vof_t {
            tree = v_tree;
            parents = v_parents;
            author = v_author;
            committer = v_committer;
            message = v_message
          } =
  let bnds = [] in
  let arg = Ocaml.vof_string v_message in
  let bnd = ("message", arg) in
  let bnds = bnd :: bnds in
  let arg = User.vof_t v_committer in
  let bnd = ("committer", arg) in
  let bnds = bnd :: bnds in
  let arg = User.vof_t v_author in
  let bnd = ("author", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list Sha1.vof_t v_parents in
  let bnd = ("parents", arg) in
  let bnds = bnd :: bnds in
  let arg = Sha1.vof_t v_tree in
  let bnd = ("tree", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
end

module Objects = struct
open Objects
let vof_t =
  function
  | Blob v1 -> let v1 = Blob.vof_t v1 in Ocaml.VSum (("Blob", [ v1 ]))
  | Commit v1 -> let v1 = Commit.vof_t v1 in Ocaml.VSum (("Commit", [ v1 ]))
  | Tree v1 -> let v1 = Tree.vof_t v1 in Ocaml.VSum (("Tree", [ v1 ]))
end
<<constant [[Dump.vof_obj]]>>

module Index = struct
open Index
let rec
  vof_stat_info {
                  ctime = v_ctime;
                  mtime = v_mtime;
                  dev = v_dev;
                  inode = v_inode;
                  mode = v_mode;
                  uid = v_uid;
                  gid = v_gid;
                  size = v_size
                } =
  let bnds = [] in
  let arg = Int32.vof_t v_size in
  let bnd = ("size", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_gid in
  let bnd = ("gid", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_uid in
  let bnd = ("uid", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_mode v_mode in
  let bnd = ("mode", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_inode in
  let bnd = ("inode", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_dev in
  let bnd = ("dev", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_time v_mtime in
  let bnd = ("mtime", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_time v_ctime in
  let bnd = ("ctime", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_mode =
  function
  | Normal -> Ocaml.VSum (("Normal", []))
  | Exec -> Ocaml.VSum (("Exec", []))
  | Link -> Ocaml.VSum (("Link", []))
  | Gitlink -> Ocaml.VSum (("Gitlink", []))
and vof_time { lsb32 = v_lsb32; nsec = v_nsec } =
  let bnds = [] in
  let arg = Int32.vof_t v_nsec in
  let bnd = ("nsec", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_lsb32 in
  let bnd = ("lsb32", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  

let vof_entry { stats = v_stats; id = v_id; path = v_name }
              =
  let bnds = [] in
  let arg = Ocaml.vof_string !!v_name in
  let bnd = ("path", arg) in
  let bnds = bnd :: bnds in
  let arg = Sha1.vof_t v_id in
  let bnd = ("id", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_stat_info v_stats in
  let bnd = ("stats", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let vof_t v = Ocaml.vof_list vof_entry v
end
<<constant [[Dump.vof_index]]>>
@


\subsection{[[version_control/hexsha.mli]]}

%-------------------------------------------------------------

<<version_control/hexsha.mli>>=
<<type [[Hexsha.t]]>>

<<signature [[Hexsha.of_sha]]>>
<<signature [[Hexsha.to_sha]]>>

<<signature [[Hexsha.read]]>>
<<signature [[Hexsha.write]]>>

<<signature [[Hexsha.is_hexsha]]>>

@

\subsection{[[version_control/hexsha.ml]]}

%-------------------------------------------------------------

<<version_control/hexsha.ml>>=
<<copyright ocaml-hex>>
open Common
open Regexp_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * Most of the code below comes from src: https://github.com/mirage/ocaml-hex
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Hexsha.t]]>>

<<function [[Hexsha.is_hexsha]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

(* start of copy-pasted code from ocaml-hex *)

let _hexa = "0123456789abcdef"
<<constant [[Hexsha.hexa1]]>>
<<constant [[Hexsha.hexa2]]>>

<<function [[Hexsha.to_char]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Hexsha.of_sha]]>>

<<function [[Hexsha.to_sha]]>>

<<function [[Hexsha.read]]>>
<<function [[Hexsha.write]]>>
@


\subsection{[[version_control/index.mli]]}

%-------------------------------------------------------------

<<version_control/index.mli>>=

<<type [[Index.stat_info]]>>
<<type [[Index.mode]]>>
<<type [[Index.time]]>>
    
<<type [[Index.entry]]>>

<<type [[Index.t]]>>

<<signature [[Index.empty]]>>
<<signature [[Index.mk_entry]]>>

<<signature [[Index.stat_info_of_lstats]]>>
<<signature [[Index.mode_of_perm]]>>
<<signature [[Index.perm_of_mode]]>>

<<signature [[Index.read]]>>
<<signature [[Index.write]]>>

<<signature [[Index.remove_entry]]>>
<<signature [[Index.add_entry]]>>

<<signature [[Index.trees_of_index]]>>
@

\subsection{[[version_control/index.ml]]}

%-------------------------------------------------------------

<<version_control/index.ml>>=
<<copyright ocaml-git>>
open Common
open Ord.Operators
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 * in index.ml and git_unix.ml
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Index.stat_info]]>>
<<type [[Index.mode]]>>
<<type [[Index.time]]>>
    
<<type [[Index.entry]]>>

(* less: extensions *)

<<type [[Index.t]]>>

<<constant [[Index.empty]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*
(* Index entries are sorted by the byte sequence that comprises the
   entry name; with a secondary comparison of the stage bits from the
   <ENTRY_FLAGS> if the entry name byte sequences are identical. *)
let compare_entries e1 e2 =
  match String.compare e1.name e2.name with
  | 0 -> Hash.Blob.compare e2.id e1.id
  | i -> i
*)

<<function [[Index.stat_info_of_lstats]]>>

<<function [[Index.mk_entry]]>>

<<function [[Index.perm_of_mode]]>>

<<function [[Index.mode_of_perm]]>>

(*****************************************************************************)
(* Add/Del *)
(*****************************************************************************)

<<function [[Index.remove_entry]]>>

<<function [[Index.add_entry]]>>

(*****************************************************************************)
(* tree of index *)
(*****************************************************************************)

<<type [[Index.dir]]>>
<<type [[Index.dir_entry]]>>
<<type [[Index.dirs]]>>

(* the code in this section derives from dulwich *)

<<function [[Index.add_dir]]>>

<<function [[Index.build_trees]]>>


<<function [[Index.trees_of_index]]>>

(*****************************************************************************)
(* index of tree *)
(*****************************************************************************)
(* See repository.set_worktree_and_index_to_tree() *)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

(* was in IO.BigEndian and IO.ml before but better to moved here
 * so we can compile most of xix
 *)
let read_real_i32 ch =
  let big = Int32.shift_left (Int32.of_int (IO.read_byte ch)) 24 in
  let ch3 = IO.read_byte ch in
  let ch2 = IO.read_byte ch in
  let ch1 = IO.read_byte ch in
  let base = Int32.of_int (ch1 lor (ch2 lsl 8) lor (ch3 lsl 16)) in
  Int32.logor base big

let write_real_i32 ch n =
  let base = Int32.to_int n in
  let big = Int32.to_int (Int32.shift_right_logical n 24) in
  IO.write_byte ch big;
  IO.write_byte ch (base lsr 16);
  IO.write_byte ch (base lsr 8);
  IO.write_byte ch base


<<function [[Index.read_time]]>>

<<function [[Index.write_time]]>>

<<function [[Index.read_mode]]>>

<<function [[Index.write_mode]]>>

<<function [[Index.read_stat_info]]>>

<<function [[Index.write_stat_info]]>>
 

<<function [[Index.read_entry]]>>

<<function [[Index.write_entry]]>>




<<function [[Index.read_entries]]>>

<<function [[Index.read]]>>


<<function [[Index.write]]>>
@

\subsection{[[version_control/main.ml]]}

%-------------------------------------------------------------

<<version_control/main.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of git, a distributed version control system.
 *
 * Some of the code derives from dulwich (a clone of git in Python)
 * and ocaml-git (another clone of git in OCaml).
 *
 * Main limitations compared to git/dulwich/ocaml-git:
 *  -??
 * 
 * todo:
 *  - a simplified version where just Marshall data instead of using
 *    the specific git format. Save many LOC?
 *  - ??
 * 
 * The code of ocamlgit uses code from 
 *  - ocaml-git
 *  - ocaml-hex
 *  - camlzip
 *  - extlib
 *  - uuidm
 * 
 * ocamlgit uses code from ocaml-git. However, ocamlgit is simpler because
 * it does not use fancy features of OCaml or fancy libraries:
 *  - no functor, include, module types, polymorphic variants, keyword args,
 *    or excessive nested modules. KISS.
 *  - no functorized Set and Map so no need for hash(), compare(), and equal()
 *    boilerplate functions everywhere
 *  - hardcoded use of SHA1, so no need functors taking Git.DIGEST and HashIO
 *  - no support for Mirage, so no need to parametrize many things,
 *    no need Fs module, no need lwt
 *  - no disk vs mem, just disk, so again need less functors
 *  - hardcoded use of zlib so no need functors taking inflate signature
 *  - no support for filename requiring special escapes
 *  - no use of Cstruct or Mstruct or Bigarray (simply use IO.ml and Bytes)
 *  - no logs
 *  - no fmt (use ocamldebug or ocamltarzan dumpers)
 *  - no sexplib
 * 
 * good stuff I took from ocaml-git:
 *  - dotgit (more readable than commondir in dulwich)
 *  - '/' operator (more readable than all those os.path.join in dulwich)
 *  - Hash.Tree.t, Hash.Commit.t, Hash.Blob.t more precise hash types
 *    (but they are not statically checked in ocamlgit)
 *  - TODO GRI (generalization of URI)
 * good stuff I wish I could take from dulwich:
 *  - hashtbl [] overloading, so can do r.refs["refs/tags/"+tag] = obj.id
 *    (thx to __setitem__ and __getitem__, but true that it also entails
 *     lots of boilerplate code)
 *
 * TODO:
 *  - look go-git, better basis? more complete than ocamlgit?
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<constant [[Main.commands]]>>

<<function [[Main.usage]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Main.main]]>>
        
<<toplevel [[Main._1]]>>
@

\subsection{[[version_control/merge.ml]]}

%-------------------------------------------------------------

<<version_control/merge.ml>>=
(*
https://github.com/schuhschuh/cmake-basis/blob/master/src/utilities/python/diff3.py
*)
@

\subsection{[[version_control/objects.mli]]}

%-------------------------------------------------------------

<<version_control/objects.mli>>=

<<type [[Objects.t]]>>

<<signature [[Objects.read]]>>

<<signature [[Objects.write]]>>
@

\subsection{[[version_control/objects.ml]]}

%-------------------------------------------------------------

<<version_control/objects.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Objects.t]]>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function [[Objects.read]]>>

<<function [[Objects.write]]>>
@


\subsection{[[version_control/refs.mli]]}

%-------------------------------------------------------------

<<version_control/refs.mli>>=

<<type [[Refs.refname]]>>

<<type [[Refs.t]]>>

<<type [[Refs.ref_content]]>>

<<signature [[Refs.default_head_content]]>>

<<signature [[Refs.is_valid_refname]]>>

<<signature [[Refs.read]]>>
<<signature [[Refs.write]]>>

<<signature [[Refs.string_of_ref]]>>
@

\subsection{[[version_control/refs.ml]]}

%-------------------------------------------------------------

<<version_control/refs.ml>>=
open Common
open Regexp_.Operators

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Refs.refname]]>>

<<type [[Refs.t]]>>

<<type [[Refs.ref_content]]>>

<<constant [[Refs.default_head_content]]>>

<<function [[Refs.is_valid_refname]]>>

(*****************************************************************************)
(* Dumper *)
(*****************************************************************************)

<<function [[Refs.string_of_ref]]>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function [[Refs.read]]>>

<<function [[Refs.write]]>>
@

\subsection{[[version_control/repository.mli]]}

%-------------------------------------------------------------

<<version_control/repository.mli>>=

<<type [[Repository.t]]>>

<<type [[Repository.objectish]]>>


(* repo *)
<<signature [[Repository.init]]>>
<<signature [[Repository.open_]]>>
<<signature [[Repository.find_dotgit_root_and_open]]>>

(* objects *)
<<signature [[Repository.read_obj]]>>
<<signature [[Repository.read_objectish]]>>
<<signature [[Repository.read_commit]]>>
<<signature [[Repository.read_tree]]>>
<<signature [[Repository.read_blob]]>>
<<signature [[Repository.add_obj]]>>
<<signature [[Repository.has_obj]]>>

(* refs *)
<<signature [[Repository.read_ref]]>>
<<signature [[Repository.write_ref]]>>
<<signature [[Repository.follow_ref]]>>
<<signature [[Repository.follow_ref_some]]>>
<<signature [[Repository.all_refs]]>>
<<signature [[Repository.set_ref]]>>
<<signature [[Repository.del_ref]]>>
(* atomic op *)
<<signature [[Repository.add_ref_if_new]]>>
<<signature [[Repository.set_ref_if_same_old]]>>

(* index *)
<<signature [[Repository.read_index]]>>
<<signature [[Repository.write_index]]>>
<<signature [[Repository.add_in_index]]>>

<<signature [[Repository.commit_index]]>>
<<signature [[Repository.set_worktree_and_index_to_tree]]>>

(* packs *)

(* misc *)
<<signature [[Repository.walk_dir]]>>

val parse_objectish: string -> objectish

@

\subsection{[[version_control/repository.ml]]}

%-------------------------------------------------------------

<<version_control/repository.ml>>=
<<copyright ocamlgit>>
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* API to access repository data (objects, index, refs, packs).
 *
 * less: use nested modules for objects, index, refs below?
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Repository.t]]>>

<<constant [[Repository.SlashOperator]]>>

<<constant [[Repository.dirperm]]>>

<<type [[Repository.objectish]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Repository.hexsha_to_filename]]>>

<<function [[Repository.ref_to_filename]]>>

<<function [[Repository.index_to_filename]]>>

<<function [[Repository.with_file_out_with_lock]]>>


(* move in common.ml? *)
<<function [[Repository.with_opendir]]>>
    
(* move in common.ml? (but remove .git specific stuff) *)
<<function [[Repository.walk_dir]]>>

(*****************************************************************************)
(* Refs *)
(*****************************************************************************)

<<function [[Repository.read_ref]]>>

<<function [[Repository.follow_ref]]>>

<<function [[Repository.follow_ref_some]]>>

<<function [[Repository.add_ref_if_new]]>>

<<function [[Repository.del_ref]]>>

<<function [[Repository.set_ref_if_same_old]]>>

<<function [[Repository.set_ref]]>>
  

<<function [[Repository.write_ref]]>>

<<function [[Repository.all_refs]]>>

(*****************************************************************************)
(* Objects *)
(*****************************************************************************)

<<function [[Repository.read_obj]]>>

<<function [[Repository.read_commit]]>>
<<function [[Repository.read_tree]]>>
<<function [[Repository.read_blob]]>>

<<function [[Repository.read_objectish]]>>

<<function [[Repository.add_obj]]>>

<<function [[Repository.has_obj]]>>

(*****************************************************************************)
(* Index *)
(*****************************************************************************)

<<function [[Repository.read_index]]>>

<<function [[Repository.write_index]]>>

    
<<function [[Repository.content_from_path_and_unix_stat]]>>

<<function [[Repository.add_in_index]]>>

(*****************************************************************************)
(* Commit *)
(*****************************************************************************)

(* less: move to cmd_commit.ml? *)
<<function [[Repository.commit_index]]>>
  
(*****************************************************************************)
(* Checkout and reset *)
(*****************************************************************************)

<<function [[Repository.build_file_from_blob]]>>


<<function [[Repository.set_worktree_and_index_to_tree]]>>

(*****************************************************************************)
(* Packs *)
(*****************************************************************************)

(*****************************************************************************)
(* Repo init/open *)
(*****************************************************************************)

<<function [[Repository.init]]>>

<<function [[Repository.open_]]>>

<<function [[Repository.find_dotgit_root_and_open]]>>

let parse_objectish _str = 
  raise Todo

@

\subsection{[[version_control/sha1.mli]]}

%-------------------------------------------------------------

<<version_control/sha1.mli>>=

<<type [[Sha1.t]]>>

<<signature [[Sha1.sha1]]>>

<<signature [[Sha1.read]]>>
<<signature [[Sha1.write]]>>

<<signature [[Sha1.is_sha]]>>
@

\subsection{[[version_control/sha1.ml]]}

%-------------------------------------------------------------

<<version_control/sha1.ml>>=
<<copyright uuidm>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below comes from: https://github.com/dbuenzli/uuidm 
 * (this code is also copy-pasted and used in git-mirage)
 * 
 * alternatives:
 *  - https://github.com/vincenthz/ocaml-sha 
 *    implements algorithm in highly optimized C code and then provides
 *    bindings to call this C code
 *  - https://github.com/xavierleroy/cryptokit/
 *    by Xavier Leroy, but also uses C code
 *  - nocrypto
 *    seems like the official crypto lib, but also uses C code
 *  - md5sum, produces 128-bit hash value (sha1 is 20 bytes so 160 bits)
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Sha1.t]]>>

<<function [[Sha1.is_sha]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[Sha1.read]]>>

<<function [[Sha1.write]]>>

(* start of copy-pasted code from uuidm *)

<<function [[Sha1.sha1]]>>
@

\subsection{[[version_control/tree.mli]]}

%-------------------------------------------------------------

<<version_control/tree.mli>>=

<<type [[Tree.perm]]>>

<<type [[Tree.entry]]>>

<<type [[Tree.t]]>>

<<type [[Tree.hash]]>>


<<signature [[Tree.read]]>>
<<signature [[Tree.write]]>>

<<signature [[Tree.show]]>>

<<signature [[Tree.walk_tree]]>>

<<signature [[Tree.walk_trees]]>>

@

\subsection{[[version_control/tree.ml]]}

%-------------------------------------------------------------

<<version_control/tree.ml>>=
<<copyright ocaml-git>>
open Common
open Ord.Operators
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Tree.perm]]>>

<<type [[Tree.entry]]>>

<<type [[Tree.t]]>>

<<type [[Tree.hash]]>>

(*****************************************************************************)
(* Walk *)
(*****************************************************************************)
<<function [[Tree.walk_tree]]>>

<<function [[Tree.walk_trees]]>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function [[Tree.perm_of_string]]>>

<<function [[Tree.string_of_perm]]>>

<<function [[Tree.read_entry]]>>

<<function [[Tree.write_entry]]>>
  

<<function [[Tree.read]]>>


<<function [[Tree.write]]>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function [[Tree.show]]>>
@

\subsection{[[version_control/unzip.mli]]}

%-------------------------------------------------------------

<<version_control/unzip.mli>>=
(*
 * Unzip - inflate format decompression algorithm
 * Copyright (C) 2004 Nicolas Cannasse
 * Compliant with RFC 1950 and 1951
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version,
 * with the special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *)
(** Decompression algorithm.

  Unzip decompression algorithm is compliant with RFC 1950 and 1951 which
  are describing the "inflate" algorithm used in most popular file formats.
  This format is also the one used by the popular ZLib library.  
*)

<<type [[Unzip.error_msg]]>>

<<exception [[Unzip.Error]]>>

<<signature [[Unzip.inflate]]>>



(* internals *)
type t

<<signature [[Unzip.inflate_init]]>>
<<signature [[Unzip.inflate_data]]>>

val debug: bool ref

@

\subsection{[[version_control/unzip.ml]]}

%-------------------------------------------------------------

<<version_control/unzip.ml>>=
<<copyright ocaml-unzip>>

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

let debug = ref false

<<type [[Unzip.huffman]]>>


<<type [[Unzip.adler32]]>>

<<type [[Unzip.window]]>>

<<type [[Unzip.state]]>>

<<type [[Unzip.t]]>>

<<type [[Unzip.error_msg]]>>

<<exception [[Unzip.Error]]>>

<<function [[Unzip.error]]>>

(* ************************************************************************ *)
(* HUFFMAN TREES *)

<<function [[Unzip.tree_depth]]>>

<<function [[Unzip.tree_compress]]>>

<<function [[Unzip.make_huffman]]>>

(* ************************************************************************ *)
(* ADLER32 (CRC) *)

<<function [[Unzip.adler32_create]]>>

<<function [[Unzip.adler32_update]]>>

<<function [[Unzip.adler32_read]]>>

(* ************************************************************************ *)
(* WINDOW *)

<<constant [[Unzip.window_size]]>>
<<constant [[Unzip.buffer_size]]>>

<<function [[Unzip.window_create]]>>

<<function [[Unzip.window_slide]]>>

<<function [[Unzip.window_add_bytes]]>>

<<function [[Unzip.window_add_char]]>>

<<function [[Unzip.window_get_last_char]]>>

<<function [[Unzip.window_available]]>>

<<function [[Unzip.window_checksum]]>>

(* ************************************************************************ *)

<<constant [[Unzip.len_extra_bits_tbl]]>>
<<constant [[Unzip.len_base_val_tbl]]>>
<<constant [[Unzip.dist_extra_bits_tbl]]>>
<<constant [[Unzip.dist_base_val_tbl]]>>
<<constant [[Unzip.code_lengths_pos]]>>

<<constant [[Unzip.fixed_huffman]]>>

<<function [[Unzip.get_bits]]>>

<<function [[Unzip.get_bit]]>>

<<function [[Unzip.get_rev_bits]]>>

<<function [[Unzip.reset_bits]]>>

<<function [[Unzip.add_bytes]]>>

<<function [[Unzip.add_char]]>>

<<function [[Unzip.add_dist_one]]>>

<<function [[Unzip.add_dist]]>>

<<function [[Unzip.apply_huffman]]>>

<<function [[Unzip.inflate_lengths]]>>

<<function [[Unzip.inflate_loop]]>>

<<function [[Unzip.inflate_data]]>>

<<function [[Unzip.inflate_init]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Unzip.inflate]]>>
@

\subsection{[[version_control/user.mli]]}

%-------------------------------------------------------------

<<version_control/user.mli>>=

<<type [[User.tz_offset]]>>

<<type [[User.t]]>>

<<signature [[User.read]]>>
<<signature [[User.write]]>>

<<signature [[User.string_of_date]]>>
@


\subsection{[[version_control/user.ml]]}

%-------------------------------------------------------------

<<version_control/user.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[User.tz_offset]]>>

<<type [[User.t]]>>

(* less: default_tz_offset ? *)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function [[User.sign_of_char]]>>

<<function [[User.char_of_sign]]>>

<<function [[User.read]]>>

<<function [[User.write_date]]>>

<<function [[User.write]]>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function [[User.string_of_date]]>>

@

\subsection{[[version_control/zip.mli]]}

%-------------------------------------------------------------

<<version_control/zip.mli>>=
@

\subsection{[[version_control/zip.ml]]}

%-------------------------------------------------------------

<<version_control/zip.ml>>=
@

\subsection{[[version_control/zlib.mli]]}

%-------------------------------------------------------------

<<version_control/zlib.mli>>=
<<copyright camlzip>>

<<exception [[Zlib.Error]]>>

<<signature [[Zlib.compress]]>>

<<signature [[Zlib.compress_direct]]>>

<<signature [[Zlib.uncompress]]>>

type stream

<<type [[Zlib.flush_command]]>>

external deflate_init: int -> bool -> stream = "camlzip_deflateInit"
external deflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_deflate_bytecode" "camlzip_deflate"
external deflate_end: stream -> unit = "camlzip_deflateEnd"

external inflate_init: bool -> stream = "camlzip_inflateInit"
external inflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_inflate_bytecode" "camlzip_inflate"
external inflate_end: stream -> unit = "camlzip_inflateEnd"

external update_crc: int32 -> bytes -> int -> int -> int32
                   = "camlzip_update_crc32"
external update_crc_string: int32 -> string -> int -> int -> int32
                   = "camlzip_update_crc32"
@



\subsection{[[version_control/zlib.ml]]}

%-------------------------------------------------------------

<<version_control/zlib.ml>>=
<<copyright camlzip>>

<<exception [[Zlib.Error]]>>

<<toplevel [[Zlib._1]]>>

type stream

<<type [[Zlib.flush_command]]>>

external deflate_init: int -> bool -> stream = "camlzip_deflateInit"
external deflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_deflate_bytecode" "camlzip_deflate"
external deflate_end: stream -> unit = "camlzip_deflateEnd"

external inflate_init: bool -> stream = "camlzip_inflateInit"
external inflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_inflate_bytecode" "camlzip_inflate"
external inflate_end: stream -> unit = "camlzip_inflateEnd"

external update_crc: int32 -> bytes -> int -> int -> int32
                   = "camlzip_update_crc32"
external update_crc_string: int32 -> string -> int -> int -> int32
                   = "camlzip_update_crc32"

<<constant [[Zlib.buffer_size]]>>

<<function [[Zlib.compress]]>>

<<function [[Zlib.compress_direct]]>>

<<function [[Zlib.uncompress]]>>
@


