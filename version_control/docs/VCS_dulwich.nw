** TODO

*** regression synced dulwich
was not working anymore at last sync

*** aspectize error management and write_pkt_line(NONE)

*** aspectize peeled

*** aspectize capabilities

*** where is used LRU?
same as file cache of ocaml-git? (and weaktbl)
just for cache of unserialized objects?

** mkfile 

SRC_VIEWS=dulwich.py \
  dulwich/__init__.py \
  dulwich/archive.py \
  dulwich/archive.py \
  dulwich/client.py \
  dulwich/client.py \
  dulwich/config.py \
  dulwich/config.py \
  dulwich/diff_tree.py \
  dulwich/errors.py \
  dulwich/fastexport.py \
  dulwich/file.py \
  dulwich/greenthreads.py \
  dulwich/hooks.py \
  dulwich/ignore.py \
  dulwich/index.py \
  dulwich/log_utils.py \
  dulwich/lru_cache.py \
  dulwich/object_store.py \
  dulwich/objects.py \
  dulwich/objectspec.py \
  dulwich/pack.py \
  dulwich/patch.py \
  dulwich/porcelain.py \
  dulwich/protocol.py \
  dulwich/reflog.py \
  dulwich/refs.py \
  dulwich/repo.py \
  dulwich/server.py \
  dulwich/walk.py \
  dulwich/web.py \


\part{VCS}

\chapter{Introduction}

\section{The version control system [[git]] ([[dulwich]])}

** import of dulwich at this commit:

commit b501e4d3a867ab18c3c1de7cc38a439cba4e90a6
Author: Segev Finer <segev208@gmail.com>
Date:   Wed Jul 5 20:16:08 2017 +0300

    gitignore patterns without a trailing slash should match directories too.
    
    gitignore patterns with a trailing slash should match both directories
    and files, while patterns with a trailing slash should match only
    directories.

\section{Copyright}

Most of this document is actually source code from [[dulwich]], so
those parts are copyright by Jelmer Vernooij.
The prose is mine and is licensed under the GNU Free Documentation
License.

<<dulwich license>>=
# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU
# General Public License as public by the Free Software Foundation; version 2.0
# or (at your option) any later version. You can redistribute it and/or
# modify it under the terms of either of these two licenses.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# You should have received a copy of the licenses; if not, see
# <http://www.gnu.org/licenses/> for a copy of the GNU General Public License
# and <http://www.apache.org/licenses/LICENSE-2.0> for a copy of the Apache
# License, Version 2.0.
#
@

\chapter{Overview}

%###############################################################################

\chapter{Core Data Structures}

% see 'dulwich in 5 min' pdf:
%  - basic obj read/write (tree, blob, commit, tag)
%  - pack (read/write)
%  - smart server/client???
%  - index (read/write)
%  - patch parsing/generation
%  - fastimport/fastexport

\section{SHA1}

<<function sha_to_hex>>=
def sha_to_hex(sha):
    """Takes a string and returns the hex of the sha within"""
    hexsha = binascii.hexlify(sha)
    assert len(hexsha) == 40, "Incorrect length of sha1 string: %d" % hexsha
    return hexsha
@
%ocaml: better with types: see that sha is bytes (numbers) and 
% hexsha is string (characters)

% by 'string' I think it means series of 20 bytes representing an sha 
% (binsha).

<<function hex_to_sha>>=
def hex_to_sha(hex):
    """Takes a hex sha and returns a binary sha"""
    assert len(hex) == 40, "Incorrect length of hexsha: %s" % hex
    try:
        return binascii.unhexlify(hex)
    except TypeError as exc:
        <<[[hex_to_sha()]] if hex not bytes>>
        raise ValueError(exc.args[0])
@

<<function valid_hexsha>>=
def valid_hexsha(hex):
    if len(hex) != 40:
        return False
    try:
        binascii.unhexlify(hex)
    except (TypeError, binascii.Error):
        return False
    else:
        return True
@



\section{Repository}

<<class Repo>>=
class Repo(BaseRepo):
    """A git repository backed by local disk.

    To open an existing repository, call the contructor with
    the path of the repository.

    To create a new repository, use the Repo.init class method.
    """

    <<[[Repo]] methods>>
@
%ocaml: no BaseRepo, DiskRepo, MemRepo, just a simple record,
% no ctor vs classmethod, just functions


<<class BaseRepo>>=
class BaseRepo(object):
    """Base class for a git repository.

    :ivar object_store: Dictionary-like object for accessing
        the objects
    :ivar refs: Dictionary-like object with the refs in this
        repository
    """

    <<[[BaseRepo]] methods>>
@
% split in 2 classes for MemRepo mock.


<<constant repo.CONTROLDIR>>=
CONTROLDIR = '.git'
@
% also called commondir when non-bare repo.
%ocaml: dotgit is a better name than controldir, also
% no need intermediate constant, should be used at very
% few places

<<constant repo.BASE_DIRECTORIES>>=
BASE_DIRECTORIES = [
    ["branches"],
    [REFSDIR],
    [REFSDIR, REFSDIR_TAGS],
    [REFSDIR, REFSDIR_HEADS],
    ["hooks"],
    ["info"]
    ]
@
%branches? need?

<<constant repo.REFSDIR>>=
REFSDIR = 'refs'
@
<<constant repo.REFSDIR_TAGS>>=
REFSDIR_TAGS = 'tags'
@
<<constant repo.REFSDIR_HEADS>>=
REFSDIR_HEADS = 'heads'
@


<<constant repo.OBJECTDIR>>=
OBJECTDIR = 'objects'
@
% why not in BASE_DIRECTORIES?

<<function hex_to_filename>>=
def hex_to_filename(path, hex):
    """Takes a hex sha and returns its filename relative to the given path."""
    # os.path.join accepts bytes or unicode, but all args must be of the same
    # type. Make sure that hex which is expected to be bytes, is the same type
    # as path.
    <<[[hex_to_filename()]] possibly decode hex>>
    dir = hex[:2]
    file = hex[2:]
    # Check from object dir
    return os.path.join(path, dir, file)

@
%python: nice syntax for substring access

% encode stuff? should aspectize, confusing.

%<<function filename_to_hex>>=
%def filename_to_hex(filename):
%    """Takes an object filename and returns its corresponding hex sha."""
%    # grab the last (up to) two path components
%    names = filename.rsplit(os.path.sep, 2)[-2:]
%    errmsg = "Invalid object filename: %s" % filename
%    assert len(names) == 2, errmsg
%    base, rest = names
%    assert len(base) == 2 and len(rest) == 38, errmsg
%    hex = (base + rest).encode('ascii')
%    hex_to_sha(hex)
%    return hex
%@
%dead: API

% this is open really. For git init see Repo.init classmethod later.
<<[[Repo]] methods>>=
def __init__(self, root):
    hidden_path = os.path.join(root, CONTROLDIR)
    if os.path.isdir(os.path.join(hidden_path, OBJECTDIR)):
        self.bare = False
        self._controldir = hidden_path
    <<[[Repo.__init__()]] else if no [[.git/objects/]] directory>>
    else:
        raise NotGitRepository(
            "No git repository was found at %(path)s" % dict(path=root)
        )

    <<[[Repo.__init__()]] commondir>>

    self.path = root
    object_store = DiskObjectStore(
        os.path.join(self.commondir(), OBJECTDIR))
    refs = DiskRefsContainer(
        self.commondir(), self._controldir)

    BaseRepo.__init__(self, object_store, refs)

    <<[[Repo.__init__()]] grafts>>
    <<[[Repo.__init__()]] hooks>>
@
%ocaml: no [] access for object store and refs, loaded
% on demand, so no need initialize DiskXxx.

<<[[BaseRepo]] methods>>=
def __init__(self, object_store, refs):
    """Open a repository.

    This shouldn't be called directly, but rather through one of the
    base classes, such as MemoryRepo or Repo.

    :param object_store: Object store to use
    :param refs: Refs container to use
    """
    self.object_store = object_store
    self.refs = refs

    <<[[BaseRepo.__init__()]] grafts>>
    <<[[BaseRepo.__init__()]] hooks>>
@
%ocaml: useless :param comments, types are better.

% repo = object store and refs in object store. Simple.
% In fact can use r[xx] to access transparently either:

<<[[BaseRepo]] methods>>=
def __getitem__(self, name):
    """Retrieve a Git object by SHA1 or ref.

    :param name: A Git object SHA1 or a ref name
    :return: A `ShaFile` object, such as a Commit or Blob
    :raise KeyError: when the specified ref or object does not exist
    """
    <<[[BaseRepo.__getitem__()]] sanity check name>>
    if len(name) in (20, 40):
        try:
            return self.object_store[name]
        except (KeyError, ValueError):
            pass
    try:
        return self.object_store[self.refs[name]]
    except RefFormatError:
        raise KeyError(name)
@
%python: nice overloading of [] (but bad to abuse it)
%ocaml: more precise type than string for ref or hexsha
% so should not allow len of 40 here
%ocaml: use precise function, no Repo smart wrapper

<<[[BaseRepo.__getitem__()]] sanity check name>>=
if not isinstance(name, bytes):
    raise TypeError("'name' must be bytestring, not %.80s" %
                    type(name).__name__)
@
%ocaml: types!

% can do r[xxx] or r.object_store[xxx]
% self.refs and self.object_store are themselves dictionary classes 

% xxx can be hexsha, or ref, or "HEAD"
%ocaml: explicit variant instead of abusing string

% can use hexsha or binsha? 20,40?

<<[[BaseRepo]] methods>>=
def __setitem__(self, name, value):
    """Set a ref.

    :param name: ref name
    :param value: Ref value - either a ShaFile object, or a hex sha
    """
    if name.startswith(b"refs/") or name == b'HEAD':
        <<[[BaseRepo.__setitem__]] if ShaFile value>>
        elif isinstance(value, bytes):
            self.refs[name] = value
        else:
            raise TypeError(value)
    else:
        raise ValueError(name)
@
%ocaml: value is vague
%ocaml: use precise function, no need extra smart wrapper
%ocaml: use type, so no need name.startwith check

\t allow bytes value? bytes is hexsha/


<<[[BaseRepo.__setitem__]] if ShaFile value>>=
if isinstance(value, ShaFile):
    #pad: self.refs[name] = value.id
    raise TypeError(value)
@
%need [] set by ShaFile?


<<[[BaseRepo]] methods>>=
def __delitem__(self, name):
    """Remove a ref.

    :param name: Name of the ref to remove
    """
    if name.startswith(b"refs/") or name == b"HEAD":
        del self.refs[name]
    else:
        raise ValueError(name)
@
%ocaml: use precise function, no need extra smart wrapper, and use
% types so no need extra check



\section{Objects}

\subsection{Object store}

<<class DiskObjectStore>>=
class DiskObjectStore(PackBasedObjectStore):
    """Git-style object store that exists on disk."""

    <<[[DiskObjectStore]] methods>>
@
%ocaml: no need 3 classes. Need just a few functions,
% and could inline that with Repository class

<<class PackBasedObjectStore>>=
class PackBasedObjectStore(BaseObjectStore):

    <<[[PackBasedObjectStore]] methods>>
@
% See Pack in adv topics.

<<class BaseObjectStore>>=
class BaseObjectStore(object):
    """Object store interface."""

    <<[[BaseObjectStore]] methods>>
@


<<[[DiskObjectStore]] methods>>=
def __init__(self, path):
    """Open an object store.

    :param path: Path of the object store.
    """
    super(DiskObjectStore, self).__init__()
    self.path = path

    <<[[DiskObjectStore.__init__()]] set pack fields>>
    <<[[DiskObjectStore.__init__()]] set alternates>>
@
%ocaml: need special class in addition to Repo? then would not need
% extra path field (already in Repo)







<<[[BaseObjectStore]] methods>>=
def __getitem__(self, sha):
    """Obtain an object by SHA1."""
    type_num, uncomp = self.get_raw(sha)
    return ShaFile.from_raw_string(type_num, uncomp, sha=sha)
@
%python: nice to have [] sugar
%ocaml: but already deserialize in get_raw, so why parse again?
% or optimized?

% why need raw and parsed? useful intermediate? requires intermediate string

<<[[BaseObjectStore]] methods>>=
def get_raw(self, name):
    """Obtain the raw text for an object.

    :param name: sha for the object.
    :return: tuple with numeric type and object contents.
    """
    raise NotImplementedError(self.get_raw)
@
%ocaml: no need ... oo is bad

<<[[PackBasedObjectStore]] methods>>=
def get_raw(self, name):
    """Obtain the raw text for an object.

    :param name: sha for the object.
    :return: tuple with numeric type and object contents.
    """
    <<[[PackBasedObjectStore.get_raw()]] set sha and hexsha from name>>
    <<[[PackBasedObjectStore.get_raw()]] look in packs>>
    <<[[PackBasedObjectStore.get_raw()]] set hexsha>>

    ret = self._get_loose_object(hexsha)
    if ret is not None:
        return ret.type_num, ret.as_raw_string()

    <<[[PackBasedObjectStore.get_raw()]] look in alternates>>
    raise KeyError(hexsha)
@

<<[[PackBasedObjectStore.get_raw()]] set sha and hexsha from name>>=
if len(name) == 20:
    sha = name
    hexsha = None
else:
    raise AssertionError("Invalid object name %r" % name)
@
%ocaml: use types, so do not allow mix binsha or hexsha
%old: 
%if len(name) == 40:
%    sha = hex_to_sha(name)
%    hexsha = name
%elif len(name) == 20:
%    sha = name
%    hexsha = None

<<[[PackBasedObjectStore.get_raw()]] set hexsha>>=
if hexsha is None:
    hexsha = sha_to_hex(name)
@




% so as_raw_string, and later from_fraw_string. useless a bit

<<[[ShaFile]] methods>>=
def as_raw_string(self):
    """Return raw string with serialization of the object.

    :return: String object
    """
    return b''.join(self.as_raw_chunks())
@
% why need intermediate chunks? 
% because want to read objects
% but also check if consistent with their hash so need save raw
% content also; this is on what sha1() will operate.

% Actually this will call serialize, so get_raw
% actually call serialize 1 time and deserialize 2 times?



\subsection{[[ShaFile]]}

<<class ShaFile>>=
class ShaFile(object):
    """A git SHA file."""

    __slots__ = ('_chunked_text', '_sha', '_needs_serialization')

    <<[[ShaFile]] methods>>
@
%ocaml: why _needs_serialization? why modifying objs? 
% just have read_obj and write_obj without clever stuff in the middle
%ocaml: why need _sha embedded inside?

<<[[ShaFile]] methods>>=
def __init__(self):
    """Don't call this directly"""
    self._sha = None
    self._chunked_text = []
    self._needs_serialization = True

@

% _sha is set on demand when ask for self.id which calls self.sha
% _needs_serialization is to know if _chunked_text is set which means
%  a call to _serialize() has been done already and cached in _chunked_text.
%  So set to True here because need call _serialize to set _chunked_text.
% Maybe could rename needs_serialization to 'modified'

% ShaFile.id -> <>
<<[[ShaFile]] methods>>=
def sha(self):
    """The SHA1 object that is the name of this object."""
    if self._sha is None or self._needs_serialization:
        # this is a local because as_raw_chunks() overwrites self._sha
        new_sha = sha1()
        new_sha.update(self._header())
        for chunk in self.as_raw_chunks():
            new_sha.update(chunk)
        self._sha = new_sha
    return self._sha

@
%ocaml: why need store it inside? so not have to compute it again?
% but why would you call sha() multiple times anyway?

% sha1() from external lib


<<[[ShaFile]] methods>>=
def check(self):
    """Check this object for internal consistency.

    :raise ObjectFormatException: if the object is malformed in some way
    :raise ChecksumMismatch: if the object was created with a SHA that does
        not match its contents
    """
    # TODO: if we find that error-checking during object parsing is a
    # performance bottleneck, those checks should be moved to the class's
    # check() method during optimization so we can still check the object
    # when necessary.
    old_sha = self.id
    try:
        self._deserialize(self.as_raw_chunks())
        self._sha = None
        new_sha = self.id
    except Exception as e:
        raise ObjectFormatException(e)
    if old_sha != new_sha:
        raise ChecksumMismatch(new_sha, old_sha)

@

<<[[ShaFile]] methods>>=
@property
def id(self):
    """The hex SHA of this object."""
    return self.sha().hexdigest().encode('ascii')
@

% ShaFile.as_raw_string | ShaFile.check | ??  -> <>
<<[[ShaFile]] methods>>=
def as_raw_chunks(self):
    """Return chunks with serialization of the object.

    :return: List of strings, not necessarily one per line
    """
    if self._needs_serialization:
        self._sha = None
        self._chunked_text = self._serialize()
        self._needs_serialization = False
    return self._chunked_text

@
% why chunks? why not single chunk? easier in writer
% because metadata is really a list of things.

% serialize and deserialize later


<<constant OBJECT_CLASSES>>=
OBJECT_CLASSES = (
    Commit,
    Tree,
    Blob,
    Tag,
    )
@
%Tag later in adv topics.

<<global _TYPE_MAP>>=
_TYPE_MAP = {}
@

<<[[objects.py]] toplevel>>=
for cls in OBJECT_CLASSES:
    _TYPE_MAP[cls.type_name] = cls
    _TYPE_MAP[cls.type_num] = cls
@
%ocaml: no need intermediate type_num and _TYPE_MAP

<<function serializable_property>>=
def serializable_property(name, docstring=None):
    """A property that helps tracking whether serialization is necessary.
    """
    def set(obj, value):
        setattr(obj, "_"+name, value)
        obj._needs_serialization = True

    def get(obj):
        return getattr(obj, "_"+name)
    return property(get, set, doc=docstring)
@
%ocaml: why you need to modify an object? they are immutable anyway
% in git so you should always construct another object.

\subsection{[[Blob]]}

<<class Blob>>=
class Blob(ShaFile):
    """A Git Blob object."""

    __slots__ = ()

    type_name = b'blob'
    type_num = 3

    <<[[Blob]] methods>>
@
%ocaml: simpler, just bytes.

<<[[Blob]] methods>>=
<<method Blob._get_data>>
<<method Blob._set_data>>
data = property(_get_data, _set_data,
                "The text contained within the blob object.")
@
<<method Blob._get_data>>=
def _get_data(self):
    return self.as_raw_string()
@
<<method Blob._set_data>>=
def _set_data(self, data):
    self.set_raw_string(data)
@
%ocaml: simpler, no get/set, no computation as_raw_string(),
% just directly access the bytes.

<<[[Blob]] methods>>=
<<method Blob._get_chunked>>
<<method Blob._set_chunked>>
chunked = property(
    _get_chunked, _set_chunked,
    "The text within the blob object, as chunks (not necessarily lines).")
@
<<method Blob._get_chunked>>=
def _get_chunked(self):
    return self._chunked_text
@
<<method Blob._set_chunked>>=
def _set_chunked(self, chunks):
    self._chunked_text = chunks
@
%ocaml: diff with data?



<<[[Blob]] methods>>=
def __init__(self):
    super(Blob, self).__init__()
    self._chunked_text = []
    self._needs_serialization = False
@

<<[[Blob]] methods>>=
def check(self):
    """Check this object for internal consistency.

    :raise ObjectFormatException: if the object is malformed in some way
    """
    super(Blob, self).check()

@


\subsection{[[Tree]] and [[TreeEntry]]}

<<class Tree>>=
class Tree(ShaFile):
    """A Git tree object"""

    type_name = b'tree'
    type_num = 2

    __slots__ = ('_entries')

    <<[[Tree]] methods>>
@

<<[[Tree]] methods>>=
def __init__(self):
    super(Tree, self).__init__()
    self._entries = {}
@




<<[[Tree]] methods>>=
def check(self):
    """Check this object for internal consistency.

    :raise ObjectFormatException: if the object is malformed in some way
    """
    super(Tree, self).check()
    last = None
    allowed_modes = (stat.S_IFREG | 0o755, stat.S_IFREG | 0o644,
                     stat.S_IFLNK, stat.S_IFDIR, S_IFGITLINK,
                     # TODO: optionally exclude as in git fsck --strict
                     stat.S_IFREG | 0o664)
    for name, mode, sha in parse_tree(b''.join(self._chunked_text),
                                      True):
        check_hexsha(sha, 'invalid sha %s' % sha)
        if b'/' in name or name in (b'', b'.', b'..'):
            raise ObjectFormatException('invalid name %s' % name)

        if mode not in allowed_modes:
            raise ObjectFormatException('invalid mode %06o' % mode)

        entry = (name, (mode, sha))
        if last:
            if key_entry(last) > key_entry(entry):
                raise ObjectFormatException('entries not sorted')
            if name == last[0]:
                raise ObjectFormatException('duplicate entry %s' % name)
        last = entry

@


<<[[Tree]] methods>>=
def add(self, name, mode, hexsha):
    """Add an entry to the tree.

    :param mode: The mode of the entry as an integral type. Not all
        possible modes are supported by git; see check() for details.
    :param name: The name of the entry, as a string.
    :param hexsha: The hex SHA of the entry as a string.
    """
    self._entries[name] = mode, hexsha
    self._needs_serialization = True
@

%deprecated:
%    if isinstance(name, int) and isinstance(mode, bytes):
%        (name, mode) = (mode, name)
%        warnings.warn(
%            "Please use Tree.add(name, mode, hexsha)",
%            category=DeprecationWarning, stacklevel=2)


<<[[Tree]] methods>>=
def __getitem__(self, name):
    return self._entries[name]

@

<<[[Tree]] methods>>=
def __setitem__(self, name, value):
    """Set a tree entry by name.

    :param name: The name of the entry, as a string.
    :param value: A tuple of (mode, hexsha), where mode is the mode of the
        entry as an integral type and hexsha is the hex SHA of the entry as
        a string.
    """
    mode, hexsha = value
    self._entries[name] = (mode, hexsha)
    self._needs_serialization = True
@
%ocaml: inconvenient to store hexsha, because then need to
% support at other places binsha and hexsha

<<[[Tree]] methods>>=
def __delitem__(self, name):
    del self._entries[name]
    self._needs_serialization = True

@


% returned by?
<<class TreeEntry>>=
class TreeEntry(namedtuple('TreeEntry', ['path', 'mode', 'sha'])):
    """Named tuple encapsulating a single tree entry."""

    <<method TreeEntry.in_path>>
@

\subsection{[[Commit]]}

<<class Commit>>=
class Commit(ShaFile):
    """A git commit object"""

    type_name = b'commit'
    type_num = 1

    __slots__ = ('_parents', '_encoding', '_extra', '_author_timezone_neg_utc',
                 '_commit_timezone_neg_utc', '_commit_time',
                 '_author_time', '_author_timezone', '_commit_timezone',
                 '_author', '_committer', '_tree', '_message',
                 '_mergetag', '_gpgsig')

    <<[[Commit]] methods>>
@
%ocaml: far too many fields

<<[[Commit]] methods>>=
def __init__(self):
    super(Commit, self).__init__()
    self._parents = []

    self._encoding = None
    self._mergetag = []
    self._gpgsig = None
    self._extra = []
    self._author_timezone_neg_utc = False
    self._commit_timezone_neg_utc = False
@

<<[[Commit]] methods>>=
tree = serializable_property(
    "tree", "Tree that is the state of this commit")
@


<<[[Commit]] methods>>=
<<method Commit._get_parents>>
<<method Commit._set_parents>>
parents = property(_get_parents, _set_parents,
                   doc="Parents of this commit, by their SHA1.")
@
<<method Commit._get_parents>>=
def _get_parents(self):
    """Return a list of parents of this commit."""
    return self._parents
@
<<method Commit._set_parents>>=
def _set_parents(self, value):
    """Set a list of parents of this commit."""
    self._needs_serialization = True
    self._parents = value
@
%ocaml: need introduce property because allow set_parents but
% what for? and why not using serializable_property here?

<<[[Commit]] methods>>=
author = serializable_property("author",
    "The name of the author of the commit")
@

<<[[Commit]] methods>>=
committer = serializable_property("committer",
    "The name of the committer of the commit")
@

<<[[Commit]] methods>>=
message = serializable_property(
    "message", "The commit message")
@


<<[[Commit]] methods>>=
commit_time = serializable_property("commit_time",
    "The timestamp of the commit. As the number of seconds since the epoch.")
@
<<[[Commit]] methods>>=
commit_timezone = serializable_property("commit_timezone",
    "The zone the commit time is in")
@
%ocaml: part of User.t

<<[[Commit]] methods>>=
author_time = serializable_property("author_time",
    "The timestamp the commit was written. As the number of "
    "seconds since the epoch.")
@
<<[[Commit]] methods>>=
author_timezone = serializable_property(
    "author_timezone", "Returns the zone the author time is in.")
@


%need that?
<<[[Commit]] methods>>=
encoding = serializable_property(
    "encoding", "Encoding of the commit message.")
@

<<[[Commit]] methods>>=
mergetag = serializable_property(
    "mergetag", "Associated signed tag.")
@
<<[[Commit]] methods>>=
gpgsig = serializable_property(
    "gpgsig", "GPG Signature.")
@


<<method Commit._get_extra>>=
def _get_extra(self):
    """Return extra settings of this commit."""
    return self._extra

@

<<[[Commit]] methods>>=
<<method Commit._get_extra>>
extra = property(_get_extra,
    doc="Extra header fields not understood (presumably added in a "
        "newer version of git). Kept verbatim so the object can "
        "be correctly reserialized. For private commit metadata, use "
        "pseudo-headers in Commit.message, rather than this field.")

@


<<[[Commit]] methods>>=
def check(self):
    """Check this object for internal consistency.

    :raise ObjectFormatException: if the object is malformed in some way
    """
    super(Commit, self).check()
    self._check_has_member("_tree", "missing tree")
    self._check_has_member("_author", "missing author")
    self._check_has_member("_committer", "missing committer")
    # times are currently checked when set

    for parent in self._parents:
        check_hexsha(parent, "invalid parent sha")
    check_hexsha(self._tree, "invalid tree sha")

    check_identity(self._author, "invalid author")
    check_identity(self._committer, "invalid committer")

    <<[[Commit.check()]] check message>>
    # TODO: optionally check for duplicate parents
@
%ocaml: use types, so no need check if has_member or if None.
% trust types!


<<[[ShaFile]] methods>>=
def _check_has_member(self, member, error_msg):
    """Check that the object has a given member variable.

    :param member: the member variable to check for
    :param error_msg: the message for an error if the member is missing
    :raise ObjectFormatException: with the given error_msg if member is
        missing or is None
    """
    if getattr(self, member, None) is None:
        raise ObjectFormatException(error_msg)
@
%ocaml: no None!

<<function objects.check_hexsha>>=
def check_hexsha(hex, error_msg):
    """Check if a string is a valid hex sha string.

    :param hex: Hex string to check
    :param error_msg: Error message to use in exception
    :raise ObjectFormatException: Raised when the string is not valid
    """
    if not valid_hexsha(hex):
        raise ObjectFormatException("%s %s" % (error_msg, hex))
@
%ocaml: use binsha consistently

<<function objects.check_identity>>=
def check_identity(identity, error_msg):
    """Check if the specified identity is valid.

    This will raise an exception if the identity is not valid.

    :param identity: Identity string
    :param error_msg: Error message to use in exception
    """
    email_start = identity.find(b'<')
    email_end = identity.find(b'>')
    if (email_start < 0 or email_end < 0 or email_end <= email_start
            or identity.find(b'<', email_start + 1) >= 0
            or identity.find(b'>', email_end + 1) >= 0
            or not identity.endswith(b'>')):
        raise ObjectFormatException(error_msg)
@
%ocaml: trust ctor

<<constants objects.commits_HEADER>>=
# Header fields for commits
_TREE_HEADER = b'tree'
_PARENT_HEADER = b'parent'
_AUTHOR_HEADER = b'author'
_COMMITTER_HEADER = b'committer'

_ENCODING_HEADER = b'encoding'
_MERGETAG_HEADER = b'mergetag'
_GPGSIG_HEADER = b'gpgsig'
@

<<[[Commit.check()]] check message>>=
last = None
for field, _ in _parse_message(self._chunked_text):
    if field == _TREE_HEADER and last is not None:
        raise ObjectFormatException("unexpected tree")
    elif field == _PARENT_HEADER and last not in (_PARENT_HEADER,
                                                  _TREE_HEADER):
        raise ObjectFormatException("unexpected parent")
    elif field == _AUTHOR_HEADER and last not in (_TREE_HEADER,
                                                  _PARENT_HEADER):
        raise ObjectFormatException("unexpected author")
    elif field == _COMMITTER_HEADER and last != _AUTHOR_HEADER:
        raise ObjectFormatException("unexpected committer")
    elif field == _ENCODING_HEADER and last != _COMMITTER_HEADER:
        raise ObjectFormatException("unexpected encoding")
    last = field
@


\section{References}

<<class DiskRefsContainer>>=
class DiskRefsContainer(RefsContainer):
    """Refs container that reads refs from disk."""

    <<[[DiskRefsContainer]] methods>>
@
%ocaml: no need 3 classes, just use a few functions

<<class RefsContainer>>=
class RefsContainer(object):
    """A container for refs."""

    <<[[RefsContainer]] methods>>
@

<<[[DiskRefsContainer]] methods>>=
def __init__(self, path, worktree_path=None):
    self.path = path
    self.worktree_path = worktree_path or path
    <<[[DiskRefsContainer.__init__()]] set pack fields>>
@
%ocaml: path and worktree_path redundant with repo
% and confusing with worktree?

<<[[RefsContainer]] methods>>=
def __getitem__(self, name):
    """Get the SHA1 for a reference name.

    This method follows all symbolic references.
    """
    _, sha = self.follow(name)
    if sha is None:
        raise KeyError(name)
    return sha

@
%ocaml: use exn, can not be None

% follow() later. 
% fst in returned pair is set of intermediate ref but not used here.

<<[[RefsContainer]] methods>>=
def __setitem__(self, name, ref):
    """Set a reference name to point to the given SHA1.

    This method follows all symbolic references if applicable for the
    subclass.

    :note: This method unconditionally overwrites the contents of a
        reference. To update atomically only if the reference has not
        changed, use set_if_equals().
    :param name: The refname to set.
    :param ref: The new sha the refname will refer to.
    """
    self.set_if_equals(name, None, ref)
@





<<[[RefsContainer]] methods>>=
def __delitem__(self, name):
    """Remove a refname.

    This method does not follow symbolic references, even if applicable for
    the subclass.

    :note: This method unconditionally deletes the contents of a reference.
        To delete atomically only if the reference has not changed, use
        remove_if_equals().

    :param name: The refname to delete.
    """
    self.remove_if_equals(name, None)
@

<<[[RefsContainer]] methods>>=
def remove_if_equals(self, name, old_ref):
    """Remove a refname only if it currently equals old_ref.

    This method does not follow symbolic references, even if applicable for
    the subclass. It can be used to perform an atomic compare-and-delete
    operation.

    :param name: The refname to delete.
    :param old_ref: The old sha the refname must refer to, or None to delete
        unconditionally.
    :return: True if the delete was successful, False otherwise.
    """
    raise NotImplementedError(self.remove_if_equals)
@
%ocaml: too many methods no? just have test_and_set?


\section{The index}

<<constant repo.INDEX_FILENAME>>=
INDEX_FILENAME = "index"
@

% .git/index

<<class Index>>=
class Index(object):
    """A Git Index file."""

    <<[[Index]] methods>>
@

% ??? -> <>
<<[[Index]] methods>>=
def __init__(self, filename):
    """Open an index file.

    :param filename: Path to the index file
    """
    self._filename = filename
    self.clear()
    self.read()
@
%ocaml: again, need embed _filename in class? just store that in repo

<<[[Index]] methods>>=
def clear(self):
    """Remove all contents from this index."""
    self._byname = {}

@

% Index.read() will be in Parsing chapter.

<<type IndexEntry>>=
IndexEntry = collections.namedtuple(
    'IndexEntry', [
        'ctime', 'mtime', 'dev', 'ino', 'mode', 'uid', 'gid', 'size', 'sha',
        'flags'])
@


<<[[Index]] methods>>=
def __getitem__(self, name):
    """Retrieve entry by relative path.

    :return: tuple with (ctime, mtime, dev, ino, mode, uid, gid, size, sha, flags)
    """
    return self._byname[name]
@

<<[[Index]] methods>>=
def __setitem__(self, name, x):
    <<[[Index.__setitem__]] sanity check arguments>>
    # Remove the old entry if any
    self._byname[name] = x
@

<<[[Index.__setitem__]] sanity check arguments>>=
assert isinstance(name, bytes)
assert len(x) == 10
@

<<[[Index]] methods>>=
def __delitem__(self, name):
    <<[[Index.__delitem__]] sanity check argument>>
    del self._byname[name]
@

<<[[Index.__delitem__]] sanity check argument>>=
assert isinstance(name, bytes)
@

\section{[[GitFile]]}

<<function GitFile>>=
def GitFile(filename, mode='rb', bufsize=-1):
    """Create a file object that obeys the git file locking protocol.

    :return: a builtin file object or a _GitFile object

    :note: See _GitFile for a description of the file locking protocol.

    Only read-only and write-only (binary) modes are supported; r+, w+, and a
    are not.  To read and write from the same file, you can take advantage of
    the fact that opening a file for write does not actually open the file you
    request.
    """
    <<[[GitFile()]] sanity check mode>>
    if 'w' in mode:
        return _GitFile(filename, mode, bufsize)
    else:
        return io.open(filename, mode, bufsize)
@
% if read, then no lock.

<<[[GitFile()]] sanity check mode>>=
if 'a' in mode:
    raise IOError('append mode not supported for Git files')
if '+' in mode:
    raise IOError('read/write mode not supported for Git files')
if 'b' not in mode:
    raise IOError('text mode not supported for Git files')
@

% if write, then lock! so atomic!
<<class _GitFile>>=
class _GitFile(object):
    """File that follows the git locking protocol for writes.

    All writes to a file foo will be written into foo.lock in the same
    directory, and the lockfile will be renamed to overwrite the original file
    on close.

    :note: You *must* call close() or abort() on a _GitFile for the lock to be
        released. Typically this will happen in a finally block.
    """

    PROXY_PROPERTIES = set(['closed', 'encoding', 'errors', 'mode', 'name',
                            'newlines', 'softspace'])
    PROXY_METHODS = ('__iter__', 'flush', 'fileno', 'isatty', 'read',
                     'readline', 'readlines', 'seek', 'tell',
                     'truncate', 'write', 'writelines')

    <<[[_GitFile]] methods>>
@
%ocaml: be less smart, just use specific function instead of
% smart wrapper?

<<[[_GitFile]] methods>>=
def __init__(self, filename, mode, bufsize):
    self._filename = filename
    self._lockfilename = '%s.lock' % self._filename
    fd = os.open(
        self._lockfilename,
        os.O_RDWR | os.O_CREAT | os.O_EXCL | getattr(os, "O_BINARY", 0))
    self._file = os.fdopen(fd, mode, bufsize)
    self._closed = False

    for method in self.PROXY_METHODS:
        setattr(self, method, getattr(self._file, method))
@
%ocaml: just with_file_out_with_lock() function

<<[[_GitFile]] methods>>=
def close(self):
    """Close this file, saving the lockfile over the original.

    :note: If this method fails, it will attempt to delete the lockfile.
        However, it is not guaranteed to do so (e.g. if a filesystem
        becomes suddenly read-only), which will prevent future writes to
        this file until the lockfile is removed manually.
    :raises OSError: if the original file could not be overwritten. The
        lock file is still closed, so further attempts to write to the same
        file object will raise ValueError.
    """
    <<[[_GitFile.close()]] sanity check>>
    self._file.close()
    try:
        try:
            os.rename(self._lockfilename, self._filename)
        except OSError as e:
                raise
    finally:
        self.abort()
@


%win32:
%            if sys.platform == 'win32' and e.errno == errno.EEXIST:
%                # Windows versions prior to Vista don't support atomic
%                # renames
%                _fancy_rename(self._lockfilename, self._filename)
%            else:
%win32:
%def _fancy_rename(oldname, newname):
%    """Rename file with temporary backup file to rollback if rename fails"""
%    if not os.path.exists(newname):
%        try:
%            os.rename(oldname, newname)
%        except OSError:
%            raise
%        return
%
%    # destination file exists
%    try:
%        (fd, tmpfile) = tempfile.mkstemp(".tmp", prefix=oldname+".", dir=".")
%        os.close(fd)
%        os.remove(tmpfile)
%    except OSError:
%        # either file could not be created (e.g. permission problem)
%        # or could not be deleted (e.g. rude virus scanner)
%        raise
%    try:
%        os.rename(newname, tmpfile)
%    except OSError:
%        raise   # no rename occurred
%    try:
%        os.rename(oldname, newname)
%    except OSError:
%        os.rename(tmpfile, newname)
%        raise
%    os.remove(tmpfile)

<<[[_GitFile.close()]] sanity check>>=
if self._closed:
    return
@
%ocaml: should be stricter and now allow double close, but avoid that
% by using with_file_xxx idiom


<<[[_GitFile]] methods>>=
def abort(self):
    """Close and discard the lockfile without overwriting the target.

    If the file is already closed, this is a no-op.
    """
    <<[[_GitFile.abort()]] sanity check>>
    self._file.close()
    try:
        os.remove(self._lockfilename)
        self._closed = True
    except OSError as e:
        # The file may have been removed already, which is ok.
        if e.errno != errno.ENOENT:
            raise
        self._closed = True
@
%ocaml: just one function instead of spread code in __init__, close, abort

<<[[_GitFile.abort()]] sanity check>>=
if self._closed:
    return
@

<<[[_GitFile]] methods>>=
def __enter__(self):
    return self
@
%???

<<[[_GitFile]] methods>>=
def __exit__(self, exc_type, exc_val, exc_tb):
    self.close()
@
%???

<<[[_GitFile]] methods>>=
def __getattr__(self, name):
    """Proxy property calls to the underlying file."""
    if name in self.PROXY_PROPERTIES:
        return getattr(self._file, name)
    raise AttributeError(name)
@
%ocaml: no need this generality

\section{Pack files}


\section{Client}

<<class GitClient>>=
# TODO(durin42): this doesn't correctly degrade if the server doesn't
# support some capabilities. This should work properly with servers
# that don't support multi_ack.
class GitClient(object):
    """Git smart server client.

    """

    <<[[GitClient]] methods>>
@

<<class LocalGitClient>>=
class LocalGitClient(GitClient):
    """Git Client that just uses a local Repo."""

    <<[[LocalGitClient]] methods>>
@


% porcelain.clone | porcelain.push | porcelain.pull -> <>
<<function client.get_transport_and_path>>=
def get_transport_and_path(location, **kwargs):
    """Obtain a git client from a URL.

    :param location: URL or path (a string)
    :param config: Optional config object
    :param thin_packs: Whether or not thin packs should be retrieved
    :param report_activity: Optional callback for reporting transport
        activity.
    :return: Tuple with client instance and relative path.
    """
    <<[[get_transport_and_path()]] try parse location as a URL>>
    # Otherwise, assume it's a local path.
    return default_local_git_client_cls(**kwargs), location
@
%win32:
%    if (sys.platform == 'win32' and
%            location[0].isalpha() and location[1:3] == ':\\'):
%        # Windows local path
%        return default_local_git_client_cls(**kwargs), location

<<class default_local_git_client_cls>>=
# What Git client to use for local access
default_local_git_client_cls = LocalGitClient
@


<<[[GitClient]] methods>>=
def __init__(self, thin_packs=True, report_activity=None, quiet=False):
    """Create a new GitClient instance.

    :param thin_packs: Whether or not thin packs should be retrieved
    :param report_activity: Optional callback for reporting transport
        activity.
    """
    <<[[GitClient.__init__()]] set fields>>
    <<[[GitClient.__init__()]] set capabilities>>
    <<[[GitClient.__init__()]] adjust capabilities>>
@

<<[[LocalGitClient]] methods>>=
def __init__(self, thin_packs=True, report_activity=None):
    """Create a new LocalGitClient instance.

    :param thin_packs: Whether or not thin packs should be retrieved
    :param report_activity: Optional callback for reporting transport
        activity.
    """
    <<[[LocalGitClient.__init__()]] set fields>>
    # Ignore the thin_packs argument
@

\t what are the important methods of a client? fetch?


\chapter{Main Functions}

\section{[[commands]]}

<<class Command>>=
class Command(object):
    """A Dulwich subcommand."""

    def run(self, args):
        """Run the command."""
        raise NotImplementedError(self.run)
@
%ocaml: just make it a function ... or a record to
% factorize some structure and a function

<<constant commands>>=
commands = {
    "add": cmd_add,
    "archive": cmd_archive,
    "clone": cmd_clone,
    "commit": cmd_commit,
    "commit-tree": cmd_commit_tree,
    "daemon": cmd_daemon,
    "diff": cmd_diff,
    "diff-tree": cmd_diff_tree,
    "dump-pack": cmd_dump_pack,
    "dump-index": cmd_dump_index,
    "fetch-pack": cmd_fetch_pack,
    "fetch": cmd_fetch,
    "help": cmd_help,
    "init": cmd_init,
    "log": cmd_log,
    "ls-remote": cmd_ls_remote,
    "ls-tree": cmd_ls_tree,
    "pack-objects": cmd_pack_objects,
    "pull": cmd_pull,
    "receive-pack": cmd_receive_pack,
    "remote": cmd_remote,
    "repack": cmd_repack,
    "reset": cmd_reset,
    "rev-list": cmd_rev_list,
    "rm": cmd_rm,
    "show": cmd_show,
    "status": cmd_status,
    "symbolic-ref": cmd_symbolic_ref,
    "tag": cmd_tag,
    "update-server-info": cmd_update_server_info,
    "upload-pack": cmd_upload_pack,
    "web-daemon": cmd_web_daemon,
    }
@
% no branching, no merge, no rebase

\section{[[git help]]}

<<function cmd_help>>=
class cmd_help(Command):

    def run(self, args):
        parser = optparse.OptionParser()
        parser.add_option("-a", "--all", dest="all",
                          action="store_true",
                          help="List all commands.")
        options, args = parser.parse_args(args)

        if options.all:
            print('Available commands:')
            for cmd in sorted(commands):
                print('  %s' % cmd)
        else:
            print("""\
The dulwich command line tool is currently a very basic frontend for the
Dulwich python module. For full functionality, please see the API reference.

For a list of supported commands, see 'dulwich help -a'.
""")
@

\section{Entry point}

<<toplevel main>>=
<<sanity check [[sys.argv]]>>
cmd = sys.argv[1]
try:
    cmd_kls = commands[cmd]
except KeyError:
    print("No such subcommand: %s" % cmd)
    sys.exit(1)

# TODO(jelmer): Return non-0 on errors
cmd_kls().run(sys.argv[2:])
@

<<sanity check [[sys.argv]]>>=
if len(sys.argv) < 2:
    print("Usage: %s <%s> [OPTIONS...]" % (sys.argv[0], "|".join(commands.keys())))
    sys.exit(1)
@
% so redundant with 'git help'?

\section{[[Porcelain]]}

<<function porcelain.open_repo_closing>>=
def open_repo_closing(path_or_repo):
    """Open an argument that can be a repository or a path for a repository.
    returns a context manager that will close the repo on exit if the argument
    is a path, else does nothing if the argument is a repo.
    """
    if isinstance(path_or_repo, BaseRepo):
        return _noop_context_manager(path_or_repo)
    return closing(Repo(path_or_repo))
@
% closing(): 'from contextlib import closing'
\t so will call which method from Repo? Repo.close()? why need a close?

<<function _noop_context_manager>>=
@contextmanager
def _noop_context_manager(obj):
    """Context manager that has the same api as closing but does nothing."""
    yield obj
@


<<[[Repo]] methods>>=
def close(self):
    """Close any files opened by this repository."""
    self.object_store.close()
@
<<[[BaseObjectStore]] methods>>=
def close(self):
    """Close any files opened by this object store."""
    # Default implementation is a NO-OP
@
%ocaml: no need close then ... so no need open_repo_closing()



\chapter{Initializing a Repository}

\section{Creating a fresh repository, [[git init]]}

<<function cmd_init>>=
class cmd_init(Command):

    def run(self, args):
        opts, args = getopt(args, "", ["bare"])
        opts = dict(opts)

        if args == []:
            path = os.getcwd()
        else:
            path = args[0]

        porcelain.init(path, bare=("--bare" in opts))
@

<<function porcelain.init>>=
def init(path=".", bare=False):
    """Create a new git repository.

    :param path: Path to repository.
    :param bare: Whether to create a bare repository.
    :return: A Repo instance
    """
    if not os.path.exists(path):
        os.mkdir(path)

    <<[[porcelain.init()]] if bare>>
    else:
        return Repo.init(path)
@
% this mkdir can be done in Repo.init if pass true as second argument


<<[[Repo]] methods>>=
@classmethod
def init(cls, path, mkdir=False):
    """Create a new repository.

    :param path: Path in which to create the repository
    :param mkdir: Whether to create the directory
    :return: `Repo` instance
    """
    <<[[Repo.init()]] if mkdir>>
    controldir = os.path.join(path, CONTROLDIR)
    os.mkdir(controldir)
    cls._init_maybe_bare(controldir, False)
    return cls(path)
@
% useless cls(path) here, done already in _init_maybe_bare

<<[[Repo.init()]] if mkdir>>=
if mkdir:
    os.mkdir(path)
@
% useless mkdir arg, done already in porcelain.init

<<[[Repo]] methods>>=
@classmethod
def _init_maybe_bare(cls, path, bare):
    for d in BASE_DIRECTORIES:
        os.mkdir(os.path.join(path, *d))

    DiskObjectStore.init(os.path.join(path, OBJECTDIR))
    ret = cls(path)

    ret.refs.set_symbolic_ref(b'HEAD', DEFAULT_REF)
    ret._init_files(bare)

    return ret
@
%ocaml: why so many _initxxx, just put everything in one function

% set ref later!

\t who initialize the index? on demand when do first 'git add'?


\subsection{Common directory}

% To abstract diff between bare and normal repository

<<[[Repo.__init__()]] commondir>>=
<<[[Repo.__init__()]] if commondir>>
else:
    self._commondir = self._controldir
@

<<[[Repo]] methods>>=
def commondir(self):
    """Return the path of the common directory.

    For a main working tree, it is identical to controldir().

    For a linked working tree, it is the control directory of the
    main working tree."""

    return self._commondir
@
%ocaml: just make it a field ... useless getter

\subsection{[[DiskObjectStore]]}

<<[[DiskObjectStore]] methods>>=
@classmethod
def init(cls, path):
    try:
        os.mkdir(path)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    os.mkdir(os.path.join(path, "info"))
    <<[[DiskObjectStore.init()]] create pack dir>>
    return cls(path)

@
%ocaml: useless mkdir again

% should use INFODIR





\subsection{[[DiskRefsContainer]]}

% Saw in Repo._init_maybe_bare
%    ret.refs.set_symbolic_ref(b'HEAD', DEFAULT_REF)

<<constant repo.DEFAULT_REF>>=
DEFAULT_REF = b'refs/heads/master'
@

<<[[RefsContainer]] methods>>=
def set_symbolic_ref(self, name, other):
    """Make a ref point at another ref.

    :param name: Name of the ref to set
    :param other: Name of the ref to point at
    """
    raise NotImplementedError(self.set_symbolic_ref)
@
%ocaml: OO boilerplate


\subsection{Named files}

<<[[BaseRepo]] methods>>=
def _init_files(self, bare):
    """Initialize a default set of named files."""
    from dulwich.config import ConfigFile

    self._put_named_file('description', b"Unnamed repository")
    self._put_named_file(os.path.join('info', 'exclude'), b'')

    <<[[BaseRepo.__init_files()]] create config file>>
@
%pad: reorder _put_named_file, put simpler stuff first


<<[[BaseRepo]] methods>>=
def get_named_file(self, path):
    """Get a file from the control dir with a specific name.

    Although the filename should be interpreted as a filename relative to
    the control dir in a disk-based Repo, the object returned need not be
    pointing to a file in that location.

    :param path: The path to the file, relative to the control dir.
    :return: An open file object, or None if the file does not exist.
    """
    raise NotImplementedError(self.get_named_file)
@
%ocaml: OO boilerplate
<<[[Repo]] methods>>=
def get_named_file(self, path, basedir=None):
    """Get a file from the control dir with a specific name.

    Although the filename should be interpreted as a filename relative to
    the control dir in a disk-based Repo, the object returned need not be
    pointing to a file in that location.

    :param path: The path to the file, relative to the control dir.
    :param basedir: Optional argument that specifies an alternative to the
        control dir.
    :return: An open file object, or None if the file does not exist.
    """
    # TODO(dborowitz): sanitize filenames, since this is used directly by
    # the dumb web serving code.
    if basedir is None:
        basedir = self.controldir()
    path = path.lstrip(os.path.sep)
    try:
        return open(os.path.join(basedir, path), 'rb')
    except (IOError, OSError) as e:
        if e.errno == errno.ENOENT:
            return None
        raise
@
%ocaml: seems useless wrapper

<<[[BaseRepo]] methods>>=
def _put_named_file(self, path, contents):
    """Write a file to the control dir with the given name and contents.

    :param path: The path to the file, relative to the control dir.
    :param contents: A string to write to the file.
    """
    raise NotImplementedError(self._put_named_file)
@
%ocaml: OO boilerplate
<<[[Repo]] methods>>=
def _put_named_file(self, path, contents):
    """Write a file to the control dir with the given name and contents.

    :param path: The path to the file, relative to the control dir.
    :param contents: A string to write to the file.
    """
    path = path.lstrip(os.path.sep)
    with GitFile(os.path.join(self.controldir(), path), 'wb') as f:
        f.write(contents)
@
%ocaml: useless wrapper?



\section{Copying a repository}

\chapter{Reading from a Repository}

\section{Objects}

% Will go from 
% sha -> path -> GitFile -> header -> compressed -> raw -> deserialize
% Many intermediate functions below.
%ocaml: no need for all those intermediates. can just go from
% sha -> path -> (channel -> input) -> deserialize

% BaseObjectStore.__get__item -> PackBasedObjectStore.get_raw -> <>
<<[[DiskObjectStore]] methods>>=
def _get_loose_object(self, sha):
    path = self._get_shafile_path(sha)
    try:
        return ShaFile.from_path(path)
    except (OSError, IOError) as e:
        if e.errno == errno.ENOENT:
            return None
        raise
@
% why catch exn? ok if not there? just so can raise right exn in caller 
% (KeyError)

<<[[DiskObjectStore]] methods>>=
def _get_shafile_path(self, sha):
    # Check from object dir
    return hex_to_filename(self.path, sha)
@
%ocaml: useless intermediate


<<[[ShaFile]] methods>>=
@classmethod
def from_path(cls, path):
    """Open a SHA file from disk."""
    with GitFile(path, 'rb') as f:
        return cls.from_file(f)
@


<<[[ShaFile]] methods>>=
@classmethod
def from_file(cls, f):
    """Get the contents of a SHA file on disk."""
    try:
        obj = cls._parse_file(f)
        obj._sha = None
        return obj
    except (IndexError, ValueError):
        raise ObjectFormatException("invalid object header")
@
%ocaml: no need compute sha here, it was already given as parameter.
% or because want consistency check?

<<[[ShaFile]] methods>>=
@classmethod
def _parse_file(cls, f):
    map = f.read()
    <<[[ShaFile._parse_file()]] if legacy object>>
    else:
        obj = cls._parse_object_header(map, f)
        obj._parse_object(map)
    return obj
@

% map for ? mmap? f.read is Gifile.read?

<<[[ShaFile]] methods>>=
@staticmethod
def _parse_object_header(magic, f):
    """Parse a new style object, creating it but not reading the file."""
    num_type = (ord(magic[0:1]) >> 4) & 7
    obj_class = object_class(num_type)
    if not obj_class:
        raise ObjectFormatException("Not a known type %d" % num_type)
    return obj_class()

@

<<function objects.object_class>>=
def object_class(type):
    """Get the object class corresponding to the given type.

    :param type: Either a type name string or a numeric type.
    :return: The ShaFile subclass corresponding to the given type, or None if
        type is not a valid type name/number.
    """
    return _TYPE_MAP.get(type, None)
@



% old format actually where read the whole content
<<[[ShaFile]] methods>>=
def _parse_object(self, map):
    """Parse a new style object, setting self._text."""
    # skip type and size; type must have already been determined, and
    # we trust zlib to fail if it's otherwise corrupted
    byte = ord(map[0:1])
    used = 1
    while (byte & 0x80) != 0:
        byte = ord(map[used:used+1])
        used += 1
    raw = map[used:]
    self.set_raw_string(_decompress(raw))

@
%bug: comment is wrong, it's set self._chunked_text

<<function objects._decompress>>=
def _decompress(string):
    dcomp = zlib.decompressobj()
    dcomped = dcomp.decompress(string)
    dcomped += dcomp.flush()
    return dcomped
@


%\section{Legacy objects}

% actually legacy object are standard format of git.

<<[[ShaFile._parse_file()]] if legacy object>>=
if cls._is_legacy_object(map):
    #pad: raise AssertionError('use legacy format')
    obj = cls._parse_legacy_object_header(map, f)
    obj._parse_legacy_object(map)
@

<<[[ShaFile]] methods>>=
@classmethod
def _is_legacy_object(cls, magic):
    b0 = ord(magic[0:1])
    b1 = ord(magic[1:2])
    word = (b0 << 8) + b1
    return (b0 & 0x8F) == 0x08 and (word % 31) == 0
@
\t ?? what are those magic chars?

<<[[ShaFile]] methods>>=
@staticmethod
def _parse_legacy_object_header(magic, f):
    """Parse a legacy object, creating it but not reading the file."""
    bufsize = 1024
    decomp = zlib.decompressobj()
    header = decomp.decompress(magic)
    start = 0
    end = -1
    while end < 0:
        extra = f.read(bufsize)
        header += decomp.decompress(extra)
        magic += extra
        end = header.find(b'\0', start)
        start = len(header)
    header = header[:end]
    type_name, size = header.split(b' ', 1)
    size = int(size)  # sanity check

    obj_class = object_class(type_name)
    if not obj_class:
        raise ObjectFormatException("Not a known type: %s" % type_name)
    return obj_class()
@

<<[[ShaFile]] methods>>=
def _parse_legacy_object(self, map):
    """Parse a legacy object, setting the raw string."""
    text = _decompress(map)
    header_end = text.find(b'\0')
    if header_end < 0:
        raise ObjectFormatException("Invalid object header, no \\0")
    self.set_raw_string(text[header_end+1:])

@





<<[[ShaFile]] methods>>=
def set_raw_string(self, text, sha=None):
    """Set the contents of this object from a serialized string."""
    <<[[ShaFile.set_raw_string()]] sanity check text>>
    self.set_raw_chunks([text], sha)
@

<<[[ShaFile.set_raw_string()]] sanity check text>>=
if not isinstance(text, bytes):
    raise TypeError('Expected bytes for text, got %r' % text)
@
%ocaml: types ...


<<[[ShaFile]] methods>>=
def set_raw_chunks(self, chunks, sha=None):
    """Set the contents of this object from a list of chunks."""
    self._chunked_text = chunks
    self._deserialize(chunks)
    if sha is None:
        self._sha = None
    else:
        self._sha = FixedSha(sha)
    self._needs_serialization = False

@
% raw but actually call deserialize! so not really raw.
% In fact ShaFile does call againt ShaFile.from_raw_string later

% ShaFile.set_raw_chunks -> <>
<<class FixedSha>>=
class FixedSha(object):
    """SHA object that behaves like hashlib's but is given a fixed value."""

    __slots__ = ('_hexsha', '_sha')

    def __init__(self, hexsha):
        <<[[FixedSha.__init__()]] sanitize hexsha>>
        <<[[FixedSha.__init__()]] sanity check hexsha>>
        self._hexsha = hexsha
        self._sha = hex_to_sha(hexsha)

    def digest(self):
        """Return the raw SHA digest."""
        return self._sha

    def hexdigest(self):
        """Return the hex SHA digest."""
        return self._hexsha.decode('ascii')
@
%??

<<[[FixedSha.__init__()]] sanity check hexsha>>=
if not isinstance(hexsha, bytes):
    raise TypeError('Expected bytes for hexsha, got %r' % hexsha)
@


% deserialize!!! Finally. .... long chain ... 

% (BxxxStore.__getitem__ -> PxxxStore.get_raw -> DxxxStore._get_loose_object ->
%  S.from_path -> S.from_file -> S._parse_file -> S._parse_object -> 
%  S.set_raw_string -> S.set_raw_chunks) 
% | ShaFile.check 
% -> <>
<<[[ShaFile]] methods>>=
def _deserialize(self, chunks):
    raise NotImplementedError(self._deserialize)

@


% BaseObjectStore.__getitem__ -> <>
<<[[ShaFile]] methods>>=
@staticmethod
def from_raw_string(type_num, string, sha=None):
    """Creates an object of the indicated type from the raw string given.

    :param type_num: The numeric type of the object.
    :param string: The raw uncompressed contents.
    :param sha: Optional known sha for the object
    """
    obj = object_class(type_num)()
    obj.set_raw_string(string, sha)
    return obj

@
%bug? so call deserialize 2 times!!



% porcelain.show | porcelain.branch_create | porcelain.tag_create -> <>
<<function objectspec.parse_object>>=
def parse_object(repo, objectish):
    """Parse a string referring to an object.

    :param repo: A `Repo` object
    :param objectish: A string referring to an object
    :return: A git object
    :raise KeyError: If the object can not be found
    """
    objectish = to_bytes(objectish)
    return repo[objectish]
@
% objectish is ref or sha1. use of repo[xxx] here

% to_bytes() in adv topics about encoding.

<<[[ShaFile]] methods>>=
@classmethod
def from_string(cls, string):
    """Create a ShaFile from a string."""
    obj = cls()
    obj.set_raw_string(string)
    return obj
@




\subsection{Blob}


% ShaFile.set_raw_chunks | ShaFile.check -> <>
<<[[Blob]] methods>>=
def _deserialize(self, chunks):
    self._chunked_text = chunks
@


%dead: API?
%<<[[Blob]] methods>>=
%@classmethod
%def from_path(cls, path):
%    blob = ShaFile.from_path(path)
%    if not isinstance(blob, cls):
%        raise NotBlobError(path)
%    return blob
%@


\subsection{Tree}

% ShaFile.set_raw_chunks | ShaFile.check -> <>
<<[[Tree]] methods>>=
def _deserialize(self, chunks):
    """Grab the entries in the tree"""
    try:
        parsed_entries = parse_tree(b''.join(chunks))
    except ValueError as e:
        raise ObjectFormatException(e)
    # TODO: list comprehension is for efficiency in the common (small)
    # case; if memory efficiency in the large case is a concern, use a genexp.
    self._entries = dict([(n, (m, s)) for n, m, s in parsed_entries])

@

% Tree.check | Tree._deserialize -> <>
<<function object.parse_tree>>=
def parse_tree(text, strict=False):
    """Parse a tree text.

    :param text: Serialized text to parse
    :return: iterator of tuples of (name, mode, sha)
    :raise ObjectFormatException: if the object was malformed in some way
    """
    count = 0
    l = len(text)
    while count < l:
        mode_end = text.index(b' ', count)
        mode_text = text[count:mode_end]
        if strict and mode_text.startswith(b'0'):
            raise ObjectFormatException("Invalid mode '%s'" % mode_text)
        try:
            mode = int(mode_text, 8)
        except ValueError:
            raise ObjectFormatException("Invalid mode '%s'" % mode_text)
        name_end = text.index(b'\0', mode_end)
        name = text[mode_end+1:name_end]
        count = name_end+21
        sha = text[name_end+1:count]
        if len(sha) != 20:
            raise ObjectFormatException("Sha has invalid length")
        hexsha = sha_to_hex(sha)
        yield (name, mode, hexsha)
@

%dead: API?
%<<[[Tree]] methods>>=
%@classmethod
%def from_path(cls, filename):
%    tree = ShaFile.from_path(filename)
%    if not isinstance(tree, cls):
%        raise NotTreeError(filename)
%    return tree
%@


%\section{[[git show]]}
%here?

\subsection{Commit}

% ShaFile.set_raw_chunks | ShaFile.check -> <>
<<[[Commit]] methods>>=
def _deserialize(self, chunks):
    (self._tree, self._parents, author_info, commit_info, self._encoding,
            self._mergetag, self._gpgsig, self._message, self._extra) = (
                    parse_commit(chunks))
    (self._author, self._author_time, (self._author_timezone,
         self._author_timezone_neg_utc)) = author_info
    (self._committer, self._commit_time, (self._commit_timezone,
         self._commit_timezone_neg_utc)) = commit_info
@
%ocaml: use subrecord for User so no need tuples above

<<function objects.parse_commit>>=
def parse_commit(chunks):
    """Parse a commit object from chunks.

    :param chunks: Chunks to parse
    :return: Tuple of (tree, parents, author_info, commit_info,
        encoding, mergetag, gpgsig, message, extra)
    """
    parents = []
    extra = []
    tree = None
    author_info = (None, None, (None, None))
    commit_info = (None, None, (None, None))
    encoding = None
    mergetag = []
    message = None
    gpgsig = None

    for field, value in _parse_message(chunks):
        # TODO(jelmer): Enforce ordering
        if field == _TREE_HEADER:
            tree = value
        elif field == _PARENT_HEADER:
            parents.append(value)
        elif field == _AUTHOR_HEADER:
            author, timetext, timezonetext = value.rsplit(b' ', 2)
            author_time = int(timetext)
            author_info = (author, author_time, parse_timezone(timezonetext))
        elif field == _COMMITTER_HEADER:
            committer, timetext, timezonetext = value.rsplit(b' ', 2)
            commit_time = int(timetext)
            commit_info = (committer, commit_time, parse_timezone(timezonetext))
        elif field == _ENCODING_HEADER:
            encoding = value
        elif field == _MERGETAG_HEADER:
            mergetag.append(Tag.from_string(value + b'\n'))
        elif field == _GPGSIG_HEADER:
            gpgsig = value
        elif field is None:
            message = value
        else:
            extra.append((field, value))
    return (tree, parents, author_info, commit_info, encoding, mergetag,
            gpgsig, message, extra)

@

% Commit.check | ... -> <>
<<function objects._parse_message>>=
def _parse_message(chunks):
    """Parse a message with a list of fields and a body.

    :param chunks: the raw chunks of the tag or commit object.
    :return: iterator of tuples of (field, value), one per header line, in the
        order read from the text, possibly including duplicates. Includes a
        field named None for the freeform tag/commit text.
    """
    f = BytesIO(b''.join(chunks))
    k = None
    v = ""
    eof = False

    def _strip_last_newline(value):
        """Strip the last newline from value"""
        if value and value.endswith(b'\n'):
            return value[:-1]
        return value

    # Parse the headers
    #
    # Headers can contain newlines. The next line is indented with a space.
    # We store the latest key as 'k', and the accumulated value as 'v'.
    for l in f:
        if l.startswith(b' '):
            # Indented continuation of the previous line
            v += l[1:]
        else:
            if k is not None:
                # We parsed a new header, return its value
                yield (k, _strip_last_newline(v))
            if l == b'\n':
                # Empty line indicates end of headers
                break
            (k, v) = l.split(b' ', 1)

    else:
        # We reached end of file before the headers ended. We still need to
        # return the previous header, then we need to return a None field for
        # the text.
        eof = True
        if k is not None:
            yield (k, _strip_last_newline(v))
        yield (None, None)

    if not eof:
        # We didn't reach the end of file while parsing headers. We can return
        # the rest of the file as a message.
        yield (None, f.read())

    f.close()
@


<<function objects.parse_timezone>>=
def parse_timezone(text):
    """Parse a timezone text fragment (e.g. '+0100').

    :param text: Text to parse.
    :return: Tuple with timezone as seconds difference to UTC
        and a boolean indicating whether this was a UTC timezone
        prefixed with a negative sign (-0000).
    """
    # cgit parses the first character as the sign, and the rest
    #  as an integer (using strtol), which could also be negative.
    #  We do the same for compatibility. See #697828.
    if not text[0] in b'+-':
        raise ValueError("Timezone must start with + or - (%(text)s)" % vars())
    sign = text[:1]
    offset = int(text[1:])
    if sign == b'-':
        offset = -offset
    unnecessary_negative_timezone = (offset >= 0 and sign == b'-')
    signum = (offset < 0) and -1 or 1
    offset = abs(offset)
    hours = int(offset / 100)
    minutes = (offset % 100)
    return (signum * (hours * 3600 + minutes * 60),
            unnecessary_negative_timezone)
@



%dead: API?
%<<[[Commit]] methods>>=
%@classmethod
%def from_path(cls, path):
%    commit = ShaFile.from_path(path)
%    if not isinstance(commit, cls):
%        raise NotCommitError(path)
%    return commit
%
%@


\section{Refs}

% RefsContainer.__getitem__ -> RefsContainer.follow -> <>
<<[[RefsContainer]] methods>>=
def read_ref(self, refname):
    """Read a reference without following any references.

    :param refname: The name of the reference
    :return: The contents of the ref file, or None if it does
        not exist.
    """
    contents = self.read_loose_ref(refname)
    <<[[RefsContainer.read_ref]] read packed refs if no loose ref>>
    return contents

@

<<[[RefsContainer]] methods>>=
def read_loose_ref(self, name):
    """Read a loose reference and return its contents.

    :param name: the refname to read
    :return: The contents of the ref file, or None if it does
        not exist.
    """
    raise NotImplementedError(self.read_loose_ref)
@
%ocaml: OO boilerplate
<<[[DiskRefsContainer]] methods>>=
def read_loose_ref(self, name):
    """Read a reference file and return its contents.

    If the reference file a symbolic reference, only read the first line of
    the file. Otherwise, only read the first 40 bytes.

    :param name: the refname to read, relative to refpath
    :return: The contents of the ref file, or None if the file does not
        exist.
    :raises IOError: if any other error occurs
    """
    filename = self.refpath(name)
    try:
        with GitFile(filename, 'rb') as f:
            header = f.read(len(SYMREF))
            if header == SYMREF:
                # Read only the first line
                return header + next(iter(f)).rstrip(b'\r\n')
            else:
                # Read only the first 40 bytes
                return header + f.read(40 - len(SYMREF))
    except IOError as e:
        if e.errno == errno.ENOENT:
            return None
        raise
@
%ocaml: should just call hexsha reader



% will see follow later.
% will see allkeys and subkeys and keys later.


\section{Index}

<<[[BaseRepo]] methods>>=
def open_index(self):
    """Open the index for this repository.

    :raise NoIndexPresent: If no index is present
    :return: The matching `Index`
    """
    raise NotImplementedError(self.open_index)
@
%ocaml: OO boilerplate

% porcelain.add -> <>
<<[[Repo]] methods>>=
def open_index(self):
    """Open the index for this repository.

    :raise NoIndexPresent: If no index is present
    :return: The matching `Index`
    """
    from dulwich.index import Index
    if not self.has_index():
        raise NoIndexPresent()
    return Index(self.index_path())
@

<<[[Repo]] methods>>=
def has_index(self):
    """Check if an index is present."""
    # Bare repos must never have index files; non-bare repos may have a
    # missing index file, which is treated as empty.
    return not self.bare
@
% after git init there is not index file yet, but has_index 
% will return true. It's ok?


<<[[Repo]] methods>>=
def index_path(self):
    """Return path to the index file."""
    return os.path.join(self.controldir(), INDEX_FILENAME)
@

% Index.__init__ -> <>
<<[[Index]] methods>>=
def read(self):
    """Read current contents of index from disk."""
    if not os.path.exists(self._filename):
        return
    f = GitFile(self._filename, 'rb')
    try:
        f = SHA1Reader(f)
        for x in read_index(f):
            self[x[0]] = IndexEntry(*x[1:])
        # FIXME: Additional data?
        f.read(os.path.getsize(self._filename)-f.tell()-20)
        f.check_sha()
    finally:
        f.close()
@

<<class SHA1Reader>>=
class SHA1Reader(object):
    """Wrapper around a file-like object that remembers the SHA1 of its data."""

    def __init__(self, f):
        self.f = f
        self.sha1 = sha1(b'')

    def read(self, num=None):
        data = self.f.read(num)
        self.sha1.update(data)
        return data

    def check_sha(self):
        stored = self.f.read(20)
        if stored != self.sha1.digest():
            raise ChecksumMismatch(self.sha1.hexdigest(), sha_to_hex(stored))

    def close(self):
        return self.f.close()

    def tell(self):
        return self.f.tell()
@
\l why not use that for ShaFile too?

<<function read_index>>=
def read_index(f):
    """Read an index file, yielding the individual entries."""
    header = f.read(4)
    if header != b'DIRC':
        raise AssertionError("Invalid index file header: %r" % header)
    (version, num_entries) = struct.unpack(b'>LL', f.read(4 * 2))
    assert version in (1, 2)
    for i in range(num_entries):
        yield read_cache_entry(f)
@

<<function index.read_cache_entry>>=
def read_cache_entry(f):
    """Read an entry from a cache file.

    :param f: File-like object to read from
    :return: tuple with: device, inode, mode, uid, gid, size, sha, flags
    """
    beginoffset = f.tell()
    ctime = read_cache_time(f)
    mtime = read_cache_time(f)
    (dev, ino, mode, uid, gid, size, sha, flags, ) = \
        struct.unpack(">LLLLLL20sH", f.read(20 + 4 * 6 + 2))
    name = f.read((flags & 0x0fff))
    # Padding:
    real_size = ((f.tell() - beginoffset + 8) & ~7)
    f.read((beginoffset + real_size) - f.tell())
    return (name, ctime, mtime, dev, ino, mode, uid, gid, size,
            sha_to_hex(sha), flags & ~0x0fff)
@
%ocaml: should not call sha_to_hex, so can use binsha consistently
% everywhere

<<function index.read_cache_time>>=
def read_cache_time(f):
    """Read a cache time.

    :param f: File-like object to read from
    :return: Tuple with seconds and nanoseconds
    """
    return struct.unpack(">LL", f.read(8))
@

\chapter{Writing to a Repository}

\section{Objects}

% will go from ShaFile -> chunks -> hexsha -> path -> Gitfile

<<[[BaseObjectStore]] methods>>=
def add_object(self, obj):
    """Add a single object to this object store.

    """
    raise NotImplementedError(self.add_object)
@
%ocaml: OO boilerplate

% Repo.stage  | BaseRepo.do_commit-> <>
<<[[DiskObjectStore]] methods>>=
def add_object(self, obj):
    """Add a single object to this object store.

    :param obj: Object to add
    """
    path = self._get_shafile_path(obj.id)
    dir = os.path.dirname(path)
    try:
        os.mkdir(dir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    if os.path.exists(path):
        return  # Already there, no need to write again
    with GitFile(path, 'wb') as f:
        f.write(obj.as_legacy_object())
@
% so it uses the legacy format?

% obj.id here, so ShaFile will compute its own id.
\t but how when build object from scratch? then have just
\t deserialized content, so no sha yet ...

<<[[ShaFile]] methods>>=
def as_legacy_object(self):
    """Return string representing the object in the experimental format.
    """
    return b''.join(self.as_legacy_object_chunks())
@
<<[[ShaFile]] methods>>=
def as_legacy_object_chunks(self):
    """Return chunks representing the object in the experimental format.

    :return: List of strings
    """
    compobj = zlib.compressobj()
    yield compobj.compress(self._header())
    for chunk in self.as_raw_chunks():
        yield compobj.compress(chunk)
    yield compobj.flush()
@



<<[[ShaFile]] methods>>=
def _header(self):
    return object_header(self.type_num, self.raw_length())
@
%bug: was self.type, but deprecated

<<[[ShaFile]] methods>>=
def raw_length(self):
    """Returns the length of the raw string of this object."""
    ret = 0
    for chunk in self.as_raw_chunks():
        ret += len(chunk)
    return ret
@
%ocaml: still not sure why need multiple chunks

% because when write object, write its size.


<<function objects.object_header>>=
def object_header(num_type, length):
    """Return an object header for the given numeric type and text length."""
    return (object_class(num_type).type_name +
            b' ' + str(length).encode('ascii') + b'\0')
@


% ShaFile.as_raw_chunks -> <>
<<[[ShaFile]] methods>>=
def _serialize(self):
    raise NotImplementedError(self._serialize)

@


\subsection{Blob}

<<[[Blob]] methods>>=
def _serialize(self):
    return self._chunked_text
@

\subsection{Tree}


<<[[Tree]] methods>>=
def _serialize(self):
    return list(serialize_tree(self.iteritems()))
@

<<[[Tree]] methods>>=
def iteritems(self, name_order=False):
    """Iterate over entries.

    :param name_order: If True, iterate in name order instead of tree
        order.
    :return: Iterator over (name, mode, sha) tuples
    """
    return sorted_tree_items(self._entries, name_order)
@

<<function object.sorted_tree_items>>=
def sorted_tree_items(entries, name_order):
    """Iterate over a tree entries dictionary.

    :param name_order: If True, iterate entries in order of their name. If
        False, iterate entries in tree order, that is, treat subtree entries as
        having '/' appended.
    :param entries: Dictionary mapping names to (mode, sha) tuples
    :return: Iterator over (name, mode, hexsha)
    """
    key_func = name_order and key_entry_name_order or key_entry
    for name, entry in sorted(entries.items(), key=key_func):
        mode, hexsha = entry
        # Stricter type checks than normal to mirror checks in the C version.
        mode = int(mode)
        if not isinstance(hexsha, bytes):
            raise TypeError('Expected bytes for SHA, got %r' % hexsha)
        yield TreeEntry(name, mode, hexsha)
@

<<function object.key_entry>>=
def key_entry(entry):
    """Sort key for tree entry.

    :param entry: (name, value) tuplee
    """
    (name, value) = entry
    if stat.S_ISDIR(value[0]):
        name += b'/'
    return name
@

<<function object.key_entry_name_order>>=
def key_entry_name_order(entry):
    """Sort key for tree entry in name order."""
    return entry[0]

@

<<function object.serialize_tree>>=
def serialize_tree(items):
    """Serialize the items in a tree to a text.

    :param items: Sorted iterable over (name, mode, sha) tuples
    :return: Serialized tree text as chunks
    """
    for name, mode, hexsha in items:
        yield ("%04o" % mode).encode('ascii') + b' ' + name + b'\0' + hex_to_sha(hexsha)
@

\subsection{Commit}

<<[[Commit]] methods>>=
def _serialize(self):
    chunks = []
    tree_bytes = self._tree.id if isinstance(self._tree, Tree) else self._tree
    chunks.append(git_line(_TREE_HEADER, tree_bytes))
    for p in self._parents:
        chunks.append(git_line(_PARENT_HEADER, p))
    chunks.append(git_line(
        _AUTHOR_HEADER, self._author, str(self._author_time).encode('ascii'),
        format_timezone(self._author_timezone,
                        self._author_timezone_neg_utc)))
    chunks.append(git_line(
        _COMMITTER_HEADER, self._committer, str(self._commit_time).encode('ascii'),
        format_timezone(self._commit_timezone,
                        self._commit_timezone_neg_utc)))
    if self.encoding:
        chunks.append(git_line(_ENCODING_HEADER, self.encoding))
    for mergetag in self.mergetag:
        mergetag_chunks = mergetag.as_raw_string().split(b'\n')

        chunks.append(git_line(_MERGETAG_HEADER, mergetag_chunks[0]))
        # Embedded extra header needs leading space
        for chunk in mergetag_chunks[1:]:
            chunks.append(b' ' + chunk + b'\n')

        # No trailing empty line
        if chunks[-1].endswith(b' \n'):
            chunks[-1] = chunks[-1][:-2]
    for k, v in self.extra:
        if b'\n' in k or b'\n' in v:
            raise AssertionError(
                "newline in extra data: %r -> %r" % (k, v))
        chunks.append(git_line(k, v))
    if self.gpgsig:
        sig_chunks = self.gpgsig.split(b'\n')
        chunks.append(git_line(_GPGSIG_HEADER, sig_chunks[0]))
        for chunk in sig_chunks[1:]:
            chunks.append(git_line(b'',  chunk))
    chunks.append(b'\n')  # There must be a new line after the headers
    chunks.append(self._message)
    return chunks
@


<<function objects.git_line>>=
def git_line(*items):
    """Formats items into a space sepreated line."""
    return b' '.join(items) + b'\n'
@

<<function objects.format_timezone>>=
def format_timezone(offset, unnecessary_negative_timezone=False):
    """Format a timezone for Git serialization.

    :param offset: Timezone offset as seconds difference to UTC
    :param unnecessary_negative_timezone: Whether to use a minus sign for
        UTC or positive timezones (-0000 and --700 rather than +0000 / +0700).
    """
    if offset % 60 != 0:
        raise ValueError("Unable to handle non-minute offset.")
    if offset < 0 or unnecessary_negative_timezone:
        sign = '-'
        offset = -offset
    else:
        sign = '+'
    return ('%c%02d%02d' % (sign, offset / 3600, (offset / 60) % 60)).encode('ascii')
@


\section{Refs}


<<[[DiskRefsContainer]] methods>>=
def set_symbolic_ref(self, name, other):
    """Make a ref point at another ref.

    :param name: Name of the ref to set
    :param other: Name of the ref to point at
    """
    self._check_refname(name)
    self._check_refname(other)
    filename = self.refpath(name)
    try:
        f = GitFile(filename, 'wb')
        try:
            f.write(SYMREF + other + b'\n')
        except (IOError, OSError):
            f.abort()
            raise
    finally:
        f.close()
@
%ocaml: no need special API for symbolic_ref, just proper ADT
% and set_ref
%ocaml: with_file_out_lock would help to factorize this boilerplate

<<constant refs.SYMREF>>=
SYMREF = b'ref: '
@

<<[[RefsContainer]] methods>>=
def _check_refname(self, name):
    """Ensure a refname is valid and lives in refs or is HEAD.

    HEAD is not a valid refname according to git-check-ref-format, but this
    class needs to be able to touch HEAD. Also, check_ref_format expects
    refnames without the leading 'refs/', but this class requires that
    so it cannot touch anything outside the refs dir (or HEAD).

    :param name: The name of the reference.
    :raises KeyError: if a refname is not HEAD or is otherwise not valid.
    """
    if name in (b'HEAD', b'refs/stash'):
        return
    if not name.startswith(b'refs/') or not check_ref_format(name[5:]):
        raise RefFormatError(name)

@

<<function refs.check_ref_format>>=
def check_ref_format(refname):
    """Check if a refname is correctly formatted.

    Implements all the same rules as git-check-ref-format[1].

    [1] http://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html

    :param refname: The refname to check
    :return: True if refname is valid, False otherwise
    """
    # These could be combined into one big expression, but are listed separately
    # to parallel [1].
    if b'/.' in refname or refname.startswith(b'.'):
        return False
    if b'/' not in refname:
        return False
    if b'..' in refname:
        return False
    for i, c in enumerate(refname):
        if ord(refname[i:i+1]) < 0o40 or c in BAD_REF_CHARS:
            return False
    if refname[-1] in b'/.':
        return False
    if refname.endswith(b'.lock'):
        return False
    if b'@{' in refname:
        return False
    if b'\\' in refname:
        return False
    return True
@

<<constant refs.BAD_REF_CHARS>>=
BAD_REF_CHARS = set(b'\177 ~^:?*[')
@




<<[[DiskRefsContainer]] methods>>=
def refpath(self, name):
    """Return the disk path of a ref.

    """
    <<[[DiskRefsContainer.refpath()]] sanitize name>>
    # TODO: as the 'HEAD' reference is working tree specific, it
    # should actually not be a part of RefsContainer
    if name == 'HEAD':
        return os.path.join(self.worktree_path, name)
    else:
        return os.path.join(self.path, name)
@

% worktree_path?? it's not .git/ ?


%win32:
%    if os.path.sep != "/":
%        name = name.replace("/", os.path.sep)



<<[[DiskRefsContainer]] methods>>=
def remove_if_equals(self, name, old_ref):
    """Remove a refname only if it currently equals old_ref.

    This method does not follow symbolic references. It can be used to
    perform an atomic compare-and-delete operation.

    :param name: The refname to delete.
    :param old_ref: The old sha the refname must refer to, or None to delete
        unconditionally.
    :return: True if the delete was successful, False otherwise.
    """
    self._check_refname(name)
    filename = self.refpath(name)
    ensure_dir_exists(os.path.dirname(filename))
    f = GitFile(filename, 'wb')
    try:
        if old_ref is not None:
            orig_ref = self.read_loose_ref(name)
            <<[[DiskRefsContainer.remove_if_equals()]] read packed refs, if no loose ref>>
            if orig_ref != old_ref:
                return False
        # may only be packed
        try:
            os.remove(filename)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise
        self._remove_packed_ref(name)
    finally:
        # never write, we just wanted the lock
        f.abort()
    return True
@






\section{Index}

% porcelain.rm -> ()
<<[[Index]] methods>>=
def write(self):
    """Write current contents of index to disk."""
    f = GitFile(self._filename, 'wb')
    try:
        f = SHA1Writer(f)
        write_index_dict(f, self._byname)
    finally:
        f.close()

@

<<class SHA1Writer>>=
class SHA1Writer(object):
    """Wrapper around a file-like object that remembers the SHA1 of its data."""

    def __init__(self, f):
        self.f = f
        self.length = 0
        self.sha1 = sha1(b'')

    def write(self, data):
        self.sha1.update(data)
        self.f.write(data)
        self.length += len(data)

    def write_sha(self):
        sha = self.sha1.digest()
        assert len(sha) == 20
        self.f.write(sha)
        self.length += len(sha)
        return sha

    def close(self):
        sha = self.write_sha()
        self.f.close()
        return sha

    def offset(self):
        return self.length

    def tell(self):
        return self.f.tell()
@
% avoids to use intermediate strings?

<<function write_index_dict>>=
def write_index_dict(f, entries):
    """Write an index file based on the contents of a dictionary.

    """
    entries_list = []
    for name in sorted(entries):
        entries_list.append((name,) + tuple(entries[name]))
    write_index(f, entries_list)
@

<<function write_index>>=
def write_index(f, entries):
    """Write an index file.

    :param f: File-like object to write to
    :param entries: Iterable over the entries to write
    """
    f.write(b'DIRC')
    f.write(struct.pack(b'>LL', 2, len(entries)))
    for x in entries:
        write_cache_entry(f, x)
@

<<function index.write_cache_entry>>=
def write_cache_entry(f, entry):
    """Write an index entry to a file.

    :param f: File object
    :param entry: Entry to write, tuple with:
        (name, ctime, mtime, dev, ino, mode, uid, gid, size, sha, flags)
    """
    beginoffset = f.tell()
    (name, ctime, mtime, dev, ino, mode, uid, gid, size, sha, flags) = entry
    write_cache_time(f, ctime)
    write_cache_time(f, mtime)
    flags = len(name) | (flags &~ 0x0fff)
    f.write(struct.pack(b'>LLLLLL20sH', dev & 0xFFFFFFFF, ino & 0xFFFFFFFF, mode, uid, gid, size, hex_to_sha(sha), flags))
    f.write(name)
    real_size = ((f.tell() - beginoffset + 8) & ~7)
    f.write(b'\0' * ((beginoffset + real_size) - f.tell()))
@

<<function index.write_cache_time>>=
def write_cache_time(f, t):
    """Write a cache time.

    :param f: File-like object to write to
    :param t: Time to write (as int, float or tuple with secs and nsecs)
    """
    if isinstance(t, int):
        t = (t, 0)
    elif isinstance(t, float):
        (secs, nsecs) = divmod(t, 1.0)
        t = (int(secs), int(nsecs * 1000000000))
    elif not isinstance(t, tuple):
        raise TypeError(t)
    f.write(struct.pack(">LL", *t))
@

%\chapter{Walking a Repository}

\chapter{Staging a Diff}


\section{Adding files, [[git add]]}

<<function cmd_add>>=
class cmd_add(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])

        porcelain.add(".", paths=args)
@

<<function porcelain.add>>=
def add(repo=".", paths=None):
    """Add files to the staging area.

    :param repo: Repository for the files
    :param paths: Paths to add.  No value passed stages all modified files.
    """
    with open_repo_closing(repo) as r:
        <<[[porcelain.add()]] if no paths, get untracked paths>>
        # TODO(jelmer): Possibly allow passing in absolute paths?
        relpaths = []
        <<[[porcelain.add()]] adjust paths if not a list>>
        for p in paths:
            # FIXME: Support patterns, directories.
            if os.path.isabs(p) and p.startswith(repo.path):
                relpath = os.path.relpath(p, repo.path)
            else:
                relpath = p
            relpaths.append(relpath)
        r.stage(relpaths)
@
% so this will create the first index file!

\l comment about :param paths??

<<[[porcelain.add()]] adjust paths if not a list>>=
if not isinstance(paths, list):
    paths = [paths]
@
%ocaml: types! useless flexibility.



\section{Removing files, [[git rm]]}

<<function cmd_rm>>=
class cmd_rm(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])

        porcelain.rm(".", paths=args)
@

<<function porcelain.rm>>=
def rm(repo=".", paths=None):
    """Remove files from the staging area.

    :param repo: Repository for the files
    :param paths: Paths to remove
    """
    with open_repo_closing(repo) as r:
        index = r.open_index()
        for p in paths:
            del index[p.encode(sys.getfilesystemencoding())]
        index.write()
@
%bug? does not do the relpath here? so does allow
% to rm only from the topdir?

% index.write here! (so why need open_repo_closing really?)


% when rm, we just want to build from index a tree without
% this entry. Simple.

\section{[[Repo.stage()]]}

% porcelain.add -> <>
<<[[Repo]] methods>>=
def stage(self, fs_paths):
    """Stage a set of paths.

    :param fs_paths: List of paths, relative to the repository path
    """

    root_path_bytes = self.path.encode(sys.getfilesystemencoding())
    <<[[Repo.stage()]] adjust fs_paths if not a list>>
    from dulwich.index import (
        blob_from_path_and_stat,
        index_entry_from_stat,
        _fs_to_tree_path,
        )
    index = self.open_index()

    for fs_path in fs_paths:
        <<[[Repo.stage()]] sanitize fs_path>>
        <<[[Repo.stage()]] sanity check fs_path>>
        tree_path = _fs_to_tree_path(fs_path)
        full_path = os.path.join(root_path_bytes, fs_path)
        try:
            st = os.lstat(full_path)
        except OSError:
            # File no longer exists
            try:
                del index[tree_path]
            except KeyError:
                pass  # already removed
        else:
            blob = blob_from_path_and_stat(full_path, st)
            self.object_store.add_object(blob)
            index[tree_path] = index_entry_from_stat(st, blob.id, 0)
    index.write()
@

% create blob and add object! so 'git add' add object to repo.
% if git add again same file then old object is useless (git gc).

<<[[Repo.stage()]] adjust fs_paths if not a list>>=
if not isinstance(fs_paths, list):
    fs_paths = [fs_paths]
@
%ocaml: types!

<<[[Repo.stage()]] sanity check fs_path>>=
if os.path.isabs(fs_path):
    raise ValueError(
        "path %r should be relative to "
        "repository root, not absolute" % fs_path)
@



% and opposite later _tree_to_fs_path
<<function index._fs_to_tree_path>>=
def _fs_to_tree_path(fs_path, fs_encoding=None):
    """Convert a file system path to a git tree path.

    :param fs_path: File system path.
    :param fs_encoding: File system encoding

    :return:  Git tree path as bytes
    """
    <<[[_fs_to_tree_path()]] sanitize fs_path_bytes if not bytes>>
    else:
        fs_path_bytes = fs_path
    return fs_path_bytes
@
%win32:
%    if os_sep_bytes != b'/':
%        tree_path = fs_path_bytes.replace(os_sep_bytes, b'/')
%    else:
%    tree_path = fs_path_bytes



\subsection{[[blob_from_path_and_stat()]]}

% Repo.stage -> <>
<<function index.blob_from_path_and_stat>>=
def blob_from_path_and_stat(fs_path, st):
    """Create a blob from a path and a stat object.

    :param fs_path: Full file system path to file
    :param st: A stat object
    :return: A `Blob` object
    """
    <<[[blob_from_path_and_stat()]] sanity check fs_path>>
    blob = Blob()
    if not stat.S_ISLNK(st.st_mode):
        with open(fs_path, 'rb') as f:
            blob.data = f.read()
    else:
            blob.data = os.readlink(fs_path)
    return blob
@

% but then no sha! so when add_object it will call serialize
% and compute sha?

%win32:
%        if sys.platform == 'win32' and sys.version_info[0] == 3:
%            # os.readlink on Python3 on Windows requires a unicode string.
%            # TODO(jelmer): Don't assume tree_encoding == fs_encoding
%            tree_encoding = sys.getfilesystemencoding()
%            fs_path = fs_path.decode(tree_encoding)
%            blob.data = os.readlink(fs_path).encode(tree_encoding)
%        else:

\subsection{[[index_entry_from_stat()]]}


<<function index.index_entry_from_stat>>=
def index_entry_from_stat(stat_val, hex_sha, flags, mode=None):
    """Create a new index entry from a stat value.

    :param stat_val: POSIX stat_result instance
    :param hex_sha: Hex sha of the object
    :param flags: Index flags
    """
    if mode is None:
        mode = cleanup_mode(stat_val.st_mode)
    return (stat_val.st_ctime, stat_val.st_mtime, stat_val.st_dev,
            stat_val.st_ino, mode, stat_val.st_uid,
            stat_val.st_gid, stat_val.st_size, hex_sha, flags)
@


<<function index.cleanup_mode>>=
def cleanup_mode(mode):
    """Cleanup a mode value.

    This will return a mode that can be stored in a tree object.

    :param mode: Mode to clean up.
    """
    if stat.S_ISLNK(mode):
        return stat.S_IFLNK
    elif stat.S_ISDIR(mode):
        return stat.S_IFDIR
    <<[[index.cleanup_mode()]] if gitlink>>
    ret = stat.S_IFREG | 0o644
    ret |= (mode & 0o111)
    return ret
@





\chapter{Committing a Diff}

\section{Committing the index, [[git commit]]}

<<function cmd_commit>>=
class cmd_commit(Command):

    def run(self, args):
        opts, args = getopt(args, "", ["message"])
        opts = dict(opts)

        porcelain.commit(".", message=opts["--message"])
@

<<function porcelain.commit>>=
def commit(repo=".", message=None, author=None, committer=None):
    """Create a new commit.

    :param repo: Path to repository
    :param message: Optional commit message
    :param author: Optional author name and email
    :param committer: Optional committer name and email
    :return: SHA1 of the new commit
    """
    # FIXME: Support --all argument
    # FIXME: Support --signoff argument

    with open_repo_closing(repo) as r:
        return r.do_commit(message=message, author=author, committer=committer)
@



<<[[BaseRepo]] methods>>=
def do_commit(self, message=None, committer=None,
              author=None, commit_timestamp=None,
              commit_timezone=None, author_timestamp=None,
              author_timezone=None, tree=None, encoding=None,
              ref=b'HEAD', merge_heads=None):
    """Create a new commit.

    :param message: Commit message
    :param committer: Committer fullname
    :param author: Author fullname (defaults to committer)
    :param commit_timestamp: Commit timestamp (defaults to now)
    :param commit_timezone: Commit timestamp timezone (defaults to GMT)
    :param author_timestamp: Author timestamp (defaults to commit
        timestamp)
    :param author_timezone: Author timestamp timezone
        (defaults to commit timestamp timezone)
    :param tree: SHA1 of the tree root to use (if not specified the
        current index will be committed).
    :param encoding: Encoding
    :param ref: Optional ref to commit to (defaults to current branch)
    :param merge_heads: Merge heads (defaults to .git/MERGE_HEADS)
    :return: New commit SHA1
    """

    import time
    c = Commit()

    <<[[BaseRepo.do_commit()]] set tree>>

    <<[[BaseRepo.do_commit()]] execute pre-commit hook>>

    <<[[BaseRepo.do_commit()]] set committer>>
    <<[[BaseRepo.do_commit()]] set author>>
    <<[[BaseRepo.do_commit()]] set encoding>>

    <<[[BaseRepo.do_commit()]] sanity check message>>
    <<[[BaseRepo.do_commit()]] execute commit-msg hook>>

    if merge_heads is None:
        # FIXME: Read merge heads from .git/MERGE_HEADS
        merge_heads = []

    <<[[BaseRepo.do_commit()]] if no ref>>
    else:
        try:
            old_head = self.refs[ref]
            c.parents = [old_head] + merge_heads
            self.object_store.add_object(c)
            ok = self.refs.set_if_equals(ref, old_head, c.id)
        <<[[BaseRepo.do_commit()]] if KeyError>>
        if not ok:
            # Fail if the atomic compare-and-swap failed, leaving the
            # commit and all its objects as garbage.
            raise CommitError("%s changed during commit" % (ref,))

    <<[[BaseRepo.do_commit()]] execute post-commit hook>>

    return c.id
@

% self.refs[ref] will call follow (see code of RefsContainer.__getitem__)

<<[[BaseRepo.do_commit()]] if KeyError>>=
except KeyError:
    c.parents = merge_heads
    self.object_store.add_object(c)
    ok = self.refs.add_if_new(ref, c.id)
@
% could not read ref because ref did not exist yet like when
% do first commit (in which case no parents)


<<[[BaseRepo.do_commit()]] if no ref>>=
if ref is None:
    # Create a dangling commit
    c.parents = merge_heads
    self.object_store.add_object(c)
@
\l when do you use that?


\section{Computing the tree, [[index.commit_tree()]]}

<<[[BaseRepo.do_commit()]] set tree>>=
if tree is None:
    index = self.open_index()
    c.tree = index.commit(self.object_store)
<<[[BaseRepo.do_commit()]] else, when passed a tree argument>>
@
% index.commit later

<<[[BaseRepo.do_commit()]] else, when passed a tree argument>>=
else:
    if len(tree) != 40:
        raise ValueError("tree must be a 40-byte hex sha string")
    c.tree = tree
@
% meh




<<[[Index]] methods>>=
def commit(self, object_store):
    """Create a new tree from an index.

    :param object_store: Object store to save the tree in
    :return: Root tree SHA
    """
    return commit_tree(object_store, self.iterblobs())
@

<<[[Index]] methods>>=
def iterblobs(self):
    """Iterate over path, sha, mode tuples for use with commit_tree."""
    for path in self:
        entry = self[path]
        yield path, entry.sha, cleanup_mode(entry.mode)
@



<<function index.commit_tree>>=
def commit_tree(object_store, blobs):
    """Commit a new tree.

    :param object_store: Object store to add trees to
    :param blobs: Iterable over blob path, sha, mode entries
    :return: SHA1 of the created tree.
    """

    trees = {b'': {}}

    <<function index.commit_tree.add_tree>>

    for path, sha, mode in blobs:
        tree_path, basename = pathsplit(path)
        tree = add_tree(tree_path)
        tree[basename] = (mode, sha)

    <<function index.commit_tree.build_tree>>

    return build_tree(b'')
@
\t too slow? each time a commit it rebuilds all tree and add objs?

%ocaml: much better with types!

<<function index.commit_tree.add_tree>>=
def add_tree(path):
    if path in trees:
        return trees[path]

    dirname, basename = pathsplit(path)
    t = add_tree(dirname)
    assert isinstance(basename, bytes)
    newtree = {}
    t[basename] = newtree
    trees[path] = newtree
    return newtree
@
% subtle. Same pathsplit again. recursive call!

<<function index.pathsplit>>=
def pathsplit(path):
    """Split a /-delimited path into a directory part and a basename.

    :param path: The path to split.
    :return: Tuple with directory name and basename
    """
    try:
        (dirname, basename) = path.rsplit(b"/", 1)
    except ValueError:
        return (b"", path)
    else:
        return (dirname, basename)
@

% step2

<<function index.commit_tree.build_tree>>=
def build_tree(path):
    tree = Tree()
    for basename, entry in trees[path].items():
        if isinstance(entry, dict):
            mode = stat.S_IFDIR
            sha = build_tree(pathjoin(path, basename))
        else:
            (mode, sha) = entry
        tree.add(basename, mode, sha)
    object_store.add_object(tree)
    return tree.id
@

<<function index.pathjoin>>=
def pathjoin(*args):
    """Join a /-delimited path.

    """
    return b"/".join([p for p in args if p])
@


\section{Storing the author and committer}

<<[[BaseRepo.do_commit()]] set committer>>=
if committer is None:
    # FIXME: Support GIT_COMMITTER_NAME/GIT_COMMITTER_EMAIL environment
    # variables
    committer = self._get_user_identity()
c.committer = committer
if commit_timestamp is None:
    # FIXME: Support GIT_COMMITTER_DATE environment variable
    commit_timestamp = time.time()
c.commit_time = int(commit_timestamp)
if commit_timezone is None:
    # FIXME: Use current user timezone rather than UTC
    commit_timezone = 0
c.commit_timezone = commit_timezone
@

<<[[BaseRepo.do_commit()]] set author>>=
if author is None:
    # FIXME: Support GIT_AUTHOR_NAME/GIT_AUTHOR_EMAIL environment
    # variables
    author = committer
c.author = author
if author_timestamp is None:
    # FIXME: Support GIT_AUTHOR_DATE environment variable
    author_timestamp = commit_timestamp
c.author_time = int(author_timestamp)
if author_timezone is None:
    author_timezone = commit_timezone
c.author_timezone = author_timezone
@


<<[[BaseRepo]] methods>>=
def _get_user_identity(self):
    """Determine the identity to use for new commits.
    """
    config = self.get_config_stack()
    return (config.get((b"user", ), b"name") + b" <" +
            config.get((b"user", ), b"email") + b">")
@
% Config, adv topics

\section{Recording the message}

<<[[BaseRepo.do_commit()]] sanity check message>>=
if message is None:
    # FIXME: Try to read commit message from .git/MERGE_MSG
    raise ValueError("No commit message specified")
@

\section{Updating [[HEAD]]}

% HEAD by default

% RefsContainer.__getitem__ -> <>
<<[[RefsContainer]] methods>>=
def follow(self, name):
    """Follow a reference name.

    :return: a tuple of (refnames, sha), wheres refnames are the names of
        references in the chain
    """
    contents = SYMREF + name
    depth = 0
    refnames = []
    while contents.startswith(SYMREF):
        refname = contents[len(SYMREF):]
        refnames.append(refname)
        contents = self.read_ref(refname)
        if not contents:
            break
        depth += 1
        if depth > 5:
            raise KeyError(name)
    return refnames, contents
@
%ocaml: ADT so no need this SYMREF trick


%            ok = self.refs.set_if_equals(ref, old_head, c.id)

\subsection{Updating an existing ref}


<<[[RefsContainer]] methods>>=
def set_if_equals(self, name, old_ref, new_ref):
    """Set a refname to new_ref only if it currently equals old_ref.

    This method follows all symbolic references if applicable for the
    subclass, and can be used to perform an atomic compare-and-swap
    operation.

    :param name: The refname to set.
    :param old_ref: The old sha the refname must refer to, or None to set
        unconditionally.
    :param new_ref: The new sha the refname will refer to.
    :return: True if the set was successful, False otherwise.
    """
    raise NotImplementedError(self.set_if_equals)
@
<<[[DiskRefsContainer]] methods>>=
def set_if_equals(self, name, old_ref, new_ref):
    """Set a refname to new_ref only if it currently equals old_ref.

    This method follows all symbolic references, and can be used to perform
    an atomic compare-and-swap operation.

    :param name: The refname to set.
    :param old_ref: The old sha the refname must refer to, or None to set
        unconditionally.
    :param new_ref: The new sha the refname will refer to.
    :return: True if the set was successful, False otherwise.
    """
    self._check_refname(name)
    try:
        realnames, _ = self.follow(name)
        realname = realnames[-1]
    except (KeyError, IndexError):
        realname = name
    filename = self.refpath(realname)
    ensure_dir_exists(os.path.dirname(filename))
    with GitFile(filename, 'wb') as f:
        if old_ref is not None:
            try:
                # read again while holding the lock
                orig_ref = self.read_loose_ref(realname)
                <<[[DiskRefsContainer.set_if_equals()]] read packed refs, if no loose ref>>
                if orig_ref != old_ref:
                    f.abort()
                    return False
            except (OSError, IOError):
                f.abort()
                raise
        try:
            f.write(new_ref + b'\n')
        except (OSError, IOError):
            f.abort()
            raise
    return True
@
\l when old_ref is not None? if it was None then you should use add_if_new



\subsection{Creating a ref, first commit}

<<[[RefsContainer]] methods>>=
def add_if_new(self, name, ref):
    """Add a new reference only if it does not already exist."""
    raise NotImplementedError(self.add_if_new)
@

<<[[DiskRefsContainer]] methods>>=
def add_if_new(self, name, ref):
    """Add a new reference only if it does not already exist.

    This method follows symrefs, and only ensures that the last ref in the
    chain does not exist.

    :param name: The refname to set.
    :param ref: The new sha the refname will refer to.
    :return: True if the add was successful, False otherwise.
    """
    try:
        realnames, contents = self.follow(name)
        if contents is not None:
            return False
        realname = realnames[-1]
    except (KeyError, IndexError):
        realname = name
    self._check_refname(realname)
    filename = self.refpath(realname)
    ensure_dir_exists(os.path.dirname(filename))
    with GitFile(filename, 'wb') as f:
        if os.path.exists(filename) or name in self.get_packed_refs():
            f.abort()
            return False
        try:
            f.write(ref + b'\n')
        except (OSError, IOError):
            f.abort()
            raise
    return True

@

<<function file.ensure_dir_exists>>=
def ensure_dir_exists(dirname):
    """Ensure a directory exists, creating if necessary."""
    try:
        os.makedirs(dirname)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
@



\chapter{Branching}

\section{Listing branches, [[git branch]]}

% <no dulwich command> -> <>
<<function porcelain.branch_list>>=
def branch_list(repo):
    """List all branches.

    :param repo: Path to the repository
    """
    with open_repo_closing(repo) as r:
        return r.refs.keys(base=b"refs/heads/")
@



<<[[RefsContainer]] methods>>=
def keys(self, base=None):
    """Refs present in this container.

    :param base: An optional base to return refs under.
    :return: An unsorted set of valid refs in this container, including
        packed refs.
    """
    if base is not None:
        return self.subkeys(base)
    else:
        return self.allkeys()
@
%ocaml: useless intermediate, just have only allkeys, anyway
% subkeys optimization not that useful

<<[[RefsContainer]] methods>>=
def allkeys(self):
    """All refs present in this container."""
    raise NotImplementedError(self.allkeys)
@
%ocaml: OO boilerplate
% -> <>
<<[[DiskRefsContainer]] methods>>=
def allkeys(self):
    allkeys = set()
    if os.path.exists(self.refpath(b'HEAD')):
        allkeys.add(b'HEAD')
    path = self.refpath(b'')
    for root, dirs, files in os.walk(self.refpath(b'refs')):
        dir = root[len(path):].strip(os.path.sep).replace(os.path.sep, "/")
        for filename in files:
            refname = ("%s/%s" % (dir, filename)).encode(sys.getfilesystemencoding())
            if check_ref_format(refname):
                allkeys.add(refname)
    <<[[DiskRefsContainer.allkeys()]] look in packed refs>>
    return allkeys
@


<<[[RefsContainer]] methods>>=
def subkeys(self, base):
    """Refs present in this container under a base.

    :param base: The base to return refs under.
    :return: A set of valid refs in this container under the base; the base
        prefix is stripped from the ref names returned.
    """
    keys = set()
    base_len = len(base) + 1
    for refname in self.allkeys():
        if refname.startswith(base):
            keys.add(refname[base_len:])
    return keys
@
%generic and slower
<<[[DiskRefsContainer]] methods>>=
def subkeys(self, base):
    subkeys = set()
    path = self.refpath(base)
    for root, dirs, files in os.walk(path):
        dir = root[len(path):].strip(os.path.sep).replace(os.path.sep, "/")
        for filename in files:
            refname = (("%s/%s" % (dir, filename))
                       .strip("/").encode(sys.getfilesystemencoding()))
            # check_ref_format requires at least one /, so we prepend the
            # base before calling it.
            if check_ref_format(base + b'/' + refname):
                subkeys.add(refname)
    <<[[DiskRefsContainer.subkeys()]] look in packed refs>>
    return subkeys
@
% a specialization that is faster? meh.
%ocaml: no need optimize this

\section{Creating branches, [[git branch <name>]]}

% <no dulwich command> -> <>
<<function porcelain.branch_create>>=
def branch_create(repo, name, objectish=None, force=False):
    """Create a branch.

    :param repo: Path to the repository
    :param name: Name of the new branch
    :param objectish: Target object to point new branch at (defaults to HEAD)
    :param force: Force creation of branch, even if it already exists
    """
    with open_repo_closing(repo) as r:
        if objectish is None:
            objectish = "HEAD"
        object = parse_object(r, objectish)
        refname = b"refs/heads/" + name
        if refname in r.refs and not force:
            raise KeyError("Branch with name %s already exists." % name)
        r.refs[refname] = object.id
@

% and then usually checkout!

\section{Deleting branches, [[git branch -d <name>]]}

<<function porcelain.branch_delete>>=
def branch_delete(repo, name):
    """Delete a branch.

    :param repo: Path to the repository
    :param name: Name of the branch
    """
    with open_repo_closing(repo) as r:
        <<[[porcelain.branch_delete()]] sanitize and sanity check names>>
        for name in names:
            del r.refs[b"refs/heads/" + name]
@

% see __delitem__ before

<<[[porcelain.branch_delete()]] sanitize and sanity check names>>=
if isinstance(name, bytes):
    names = [name]
elif isinstance(name, list):
    names = name
else:
    raise TypeError("Unexpected branch name type %r" % name)
@
%ocaml: types!


\section{checking out branches, [[git checkout]]}

% reset_index use for checkout!

% <no dulwich checkout> | porcelain.reset | porcelain.clone -> <>
<<[[Repo]] methods>>=
def reset_index(self, tree=None):
    """Reset the index back to a specific tree.

    :param tree: Tree SHA to reset to, None for current HEAD tree.
    """
    from dulwich.index import (
        build_index_from_tree,
        validate_path_element_default,
        )
    if tree is None:
        tree = self[b'HEAD'].tree
    <<[[Repo.reset_index()]] set [[honor_filemode]] using config file>>
    validate_path_element = validate_path_element_default
    return build_index_from_tree(
        self.path, self.index_path(), self.object_store, tree,
        honor_filemode=honor_filemode,
        validate_path_element=validate_path_element)
@
% build_index and also set worktree from tree.

% what about HEAD ref? not setting? in caller?

%win32:
%    from dulwich.index import (
%        build_index_from_tree,
%        validate_path_element_default,
%        validate_path_element_ntfs,
%        )
%    if config.get_boolean('core', 'core.protectNTFS', os.name == "nt"):
%        validate_path_element = validate_path_element_ntfs
%    else:

\subsection{Index from a tree, [[build_index_from_tree()]]}


<<function build_index_from_tree>>=
def build_index_from_tree(root_path, index_path, object_store, tree_id,
                          honor_filemode=True,
                          validate_path_element=validate_path_element_default):
    """Generate and materialize index from a tree

    :param tree_id: Tree to materialize
    :param root_path: Target dir for materialized index files
    :param index_path: Target path for generated index
    :param object_store: Non-empty object store holding tree contents
    :param honor_filemode: An optional flag to honor core.filemode setting in
        config file, default is core.filemode=True, change executable bit
    :param validate_path_element: Function to validate path elements to check out;
        default just refuses .git and .. directories.

    :note:: existing index is wiped and contents are not merged
        in a working dir. Suitable only for fresh clones.
    """

    index = Index(index_path)
    <<[[build_index_from_tree()]] sanitize root_path if not bytes>>

    for entry in object_store.iter_tree_contents(tree_id):
        <<[[build_index_from_tree()]] validate path>>
        full_path = _tree_to_fs_path(root_path, entry.path)

        if not os.path.exists(os.path.dirname(full_path)):
            os.makedirs(os.path.dirname(full_path))

        <<[[build_index_from_tree()]] if gitlink>>
        else:
            obj = object_store[entry.sha]
            st = build_file_from_blob(
                obj, entry.mode, full_path, honor_filemode=honor_filemode)
        # Add file to index
        <<[[build_index_from_tree()]] if gitlink or not honor filemode>>
        index[entry.path] = index_entry_from_stat(st, entry.sha, 0)

    index.write()
@
\t should also delete file not present in old version but were in
\t  current version

<<function index._tree_to_fs_path>>=
def _tree_to_fs_path(root_path, tree_path):
    """Convert a git tree path to a file system path.

    :param root_path: Root filesystem path
    :param tree_path: Git tree path as bytes

    :return: File system path.
    """
    <<[[_tree_to_fs_path()]] sanity check tree_path>>
    sep_corrected_path = tree_path
    return os.path.join(root_path, sep_corrected_path)
@

%win32:
%    if os_sep_bytes != b'/':
%        sep_corrected_path = tree_path.replace(b'/', os_sep_bytes)
%    else:
%        sep_corrected_path = tree_path

%win32:
%<<constant index.os_sep_bytes>>=
%os_sep_bytes = os.sep.encode('ascii')
%@



\subsection{[[iter_tree_contents()]]}

<<[[BaseObjectStore]] methods>>=
def iter_tree_contents(self, tree_id, include_trees=False):
    """Iterate the contents of a tree and all subtrees.

    Iteration is depth-first pre-order, as in e.g. os.walk.

    :param tree_id: SHA1 of the tree.
    :param include_trees: If True, include tree objects in the iteration.
    :return: Iterator over TreeEntry namedtuples for all the objects in a
        tree.
    """
    for entry, _ in walk_trees(self, tree_id, None):
        if not stat.S_ISDIR(entry.mode) or include_trees:
            yield entry
@

% walk_trees() later. Pass None for second tree, 
\t should pass current tree id to 3rd param
\t  so know if file not present in old version

\subsection{[[build_file_from_blob()]]}

<<function build_file_from_blob>>=
def build_file_from_blob(blob, mode, target_path, honor_filemode=True):
    """Build a file or symlink on disk based on a Git object.

    :param obj: The git object
    :param mode: File mode
    :param target_path: Path to write to
    :param honor_filemode: An optional flag to honor core.filemode setting in
        config file, default is core.filemode=True, change executable bit
    :return: stat object for the file
    """
    <<[[build_file_from_blob()]] compute oldstat>>
    contents = blob.as_raw_string()
    if stat.S_ISLNK(mode):
        # FIXME: This will fail on Windows. What should we do instead?
        if oldstat:
            os.unlink(target_path)
        os.symlink(contents, target_path)
    else:
        <<[[build_file_from_blob()]] if same content than before>>
        with open(target_path, 'wb') as f:
            # Write out file
            f.write(contents)
        <<[[build_file_from_blob()]] if honor filemode>>
    return os.lstat(target_path)
@

%win32:
%        if sys.platform == 'win32' and sys.version_info[0] == 3:
%            # os.readlink on Python3 on Windows requires a unicode string.
%            # TODO(jelmer): Don't assume tree_encoding == fs_encoding
%            tree_encoding = sys.getfilesystemencoding()
%            contents = contents.decode(tree_encoding)
%            target_path = target_path.decode(tree_encoding)

<<[[build_file_from_blob()]] compute oldstat>>=
try:
    oldstat = os.lstat(target_path)
except OSError as e:
    if e.errno == errno.ENOENT:
        oldstat = None
    else:
        raise
@

<<[[build_file_from_blob()]] if same content than before>>=
if oldstat is not None and oldstat.st_size == len(contents):
    with open(target_path, 'rb') as f:
        if f.read() == contents:
            return oldstat
@

<<[[build_file_from_blob()]] if honor filemode>>=
if honor_filemode:
    os.chmod(target_path, mode)
@


\subsection{[[validate_path()]]}

<<[[build_index_from_tree()]] validate path>>=
if not validate_path(entry.path, validate_path_element):
    continue
@

<<function index.validate_path>>=
def validate_path(path, element_validator=validate_path_element_default):
    """Default path validator that just checks for .git/."""
    parts = path.split(b"/")
    for p in parts:
        if not element_validator(p):
            return False
    else:
        return True
@

<<constant index.INVALID_DOTNAMES>>=
INVALID_DOTNAMES = (b".git", b".", b"..", b"")
@

<<function index.validate_path_element_default>>=
def validate_path_element_default(element):
    return element.lower() not in INVALID_DOTNAMES
@

%def validate_path_element_ntfs(element):
%    stripped = element.rstrip(b". ").lower()
%    if stripped in INVALID_DOTNAMES:
%        return False
%    if stripped == b"git~1":
%        return False
%    return True


\section{Resetting branches, [[git reset]]}

<<function cmd_reset>>=
class cmd_reset(Command):

    def run(self, args):
        opts, args = getopt(args, "", ["hard", "soft", "mixed"])
        opts = dict(opts)

        mode = ""
        if "--hard" in opts:
            mode = "hard"
        elif "--soft" in opts:
            mode = "soft"
        elif "--mixed" in opts:
            mode = "mixed"

        porcelain.reset('.', mode=mode, *args)

@

<<function porcelain.reset>>=
def reset(repo, mode, committish="HEAD"):
    """Reset current HEAD to the specified state.

    :param repo: Path to repository
    :param mode: Mode ("hard", "soft", "mixed")
    """

    if mode != "hard":
        raise ValueError("hard is the only mode currently supported")

    with open_repo_closing(repo) as r:
        tree = r[committish].tree
        r.reset_index(tree)
@
% what about HEAD ref? not setting?
% already set.


\chapter{Merging}

\section{merge}

% ??? -> <>
<<diff.tree_changes_for_merge>>=
def tree_changes_for_merge(store, parent_tree_ids, tree_id,
                           rename_detector=None):
    """Get the tree changes for a merge tree relative to all its parents.

    :param store: An ObjectStore for looking up objects.
    :param parent_tree_ids: An iterable of the SHAs of the parent trees.
    :param tree_id: The SHA of the merge tree.
    :param rename_detector: RenameDetector object for detecting renames.

    :return: Iterator over lists of TreeChange objects, one per conflicted path
        in the merge.

        Each list contains one element per parent, with the TreeChange for that
        path relative to that parent. An element may be None if it never
        existed in one parent and was deleted in two others.

        A path is only included in the output if it is a conflict, i.e. its SHA
        in the merge tree is not found in any of the parents, or in the case of
        deletes, if not all of the old SHAs match.
    """
    all_parent_changes = [tree_changes(store, t, tree_id,
                                       rename_detector=rename_detector)
                          for t in parent_tree_ids]
    num_parents = len(parent_tree_ids)
    changes_by_path = defaultdict(lambda: [None] * num_parents)

    # Organize by path.
    for i, parent_changes in enumerate(all_parent_changes):
        for change in parent_changes:
            if change.type == CHANGE_DELETE:
                path = change.old.path
            else:
                path = change.new.path
            changes_by_path[path][i] = change

    def old_sha(c):
        return c.old.sha

    def change_type(c):
        return c.type

    # Yield only conflicting changes.
    for _, changes in sorted(changes_by_path.items()):
        assert len(changes) == num_parents
        have = [c for c in changes if c is not None]
        if _all_eq(have, change_type, CHANGE_DELETE):
            if not _all_same(have, old_sha):
                yield changes
        elif not _all_same(have, change_type):
            yield changes
        elif None not in changes:
            # If no change was found relative to one parent, that means the SHA
            # must have matched the SHA in that parent, so it is not a
            # conflict.
            yield changes
@

\section{Rebase}

\section{Cherry-picking}





\chapter{Inspecting}

\section{[[git show]]}

<<function cmd_show>>=
class cmd_show(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])

        porcelain.show(".", args)
@

<<function porcelain.show>>=
# TODO(jelmer): better default for encoding?
def show(repo=".", objects=None, outstream=sys.stdout,
         default_encoding=DEFAULT_ENCODING):
    """Print the changes in a commit.

    :param repo: Path to repository
    :param objects: Objects to show (defaults to [HEAD])
    :param outstream: Stream to write to
    :param default_encoding: Default encoding to use if none is set in the
        commit
    """
    if objects is None:
        objects = ["HEAD"]
    <<[[porcelain.show]] adjust objects if not a list>>

    with open_repo_closing(repo) as r:
        for objectish in objects:
            o = parse_object(r, objectish)
            <<[[porcelain.show]] define [[decode()]]>>
            show_object(r, o, decode, outstream)
@
%bug? when I type 'dulwich show' it does nothing and does not
% default to listing HEAD. Because objects then is empty list instead
% of None?

<<[[porcelain.show]] adjust objects if not a list>>=
if not isinstance(objects, list):
    objects = [objects]
@
%ocaml: types! useless flexibility

<<function porcelain.show_object>>=
def show_object(repo, obj, decode, outstream):
    return {
        b"tree": show_tree,
        b"blob": show_blob,
        b"commit": show_commit,
        b"tag": show_tag,
            }[obj.type_name](repo, obj, decode, outstream)
@

\subsection{Blob}

<<function porcelain.show_blob>>=
def show_blob(repo, blob, decode, outstream=sys.stdout):
    """Write a blob to a stream.

    :param repo: A `Repo` object
    :param blob: A `Blob` object
    :param decode: Function for decoding bytes to unicode string
    :param outstream: A stream file to write to
    """
    outstream.write(decode(blob.data))
@
%ocaml: useless :param, just use types!

\subsection{Tree}

<<function porcelain.show_tree>>=
def show_tree(repo, tree, decode, outstream=sys.stdout):
    """Print a tree to a stream.

    :param repo: A `Repo` object
    :param tree: A `Tree` object
    :param decode: Function for decoding bytes to unicode string
    :param outstream: Stream to write to
    """
    for n in tree:
        outstream.write(decode(n) + "\n")
@

\l apparently displays only the name, but why? n is the whole entry
% not just the key no? or because itertree returns just the key?

\subsection{Commit}

<<function porcelain.show_commit>>=
def show_commit(repo, commit, decode, outstream=sys.stdout):
    """Show a commit to a stream.

    :param repo: A `Repo` object
    :param commit: A `Commit` object
    :param decode: Function for decoding bytes to unicode string
    :param outstream: Stream to write to
    """
    print_commit(commit, decode=decode, outstream=outstream)
    parent_commit = repo[commit.parents[0]]
    write_tree_diff(
        outstream, repo.object_store, parent_commit.tree, commit.tree)
@
% print_commit() before
% write_tree_diff later (for git diff)

\section{Tree changes}

\subsection{[[TreeChange]]}

<<type CHANGE>>=
# TreeChange type constants.
CHANGE_ADD = 'add'
CHANGE_MODIFY = 'modify'
CHANGE_DELETE = 'delete'

CHANGE_RENAME = 'rename'
CHANGE_COPY = 'copy'
CHANGE_UNCHANGED = 'unchanged'
@
%ocaml: ADT

<<class TreeChange>>=
class TreeChange(namedtuple('TreeChange', ['type', 'old', 'new'])):
    """Named tuple a single change between two trees."""

    @classmethod
    def add(cls, new):
        return cls(CHANGE_ADD, _NULL_ENTRY, new)

    @classmethod
    def delete(cls, old):
        return cls(CHANGE_DELETE, old, _NULL_ENTRY)
@
%ocaml: ADT, useless to have pair when for add only one entry is relevant

<<constant diff_tree._NULL_ENTRY>>=
_NULL_ENTRY = TreeEntry(None, None, None)
@
% TreeEntry is name, sha, mode



\subsection{[[tree_changes()]]}

<<[[BaseObjectStore]] methods>>=
def tree_changes(self, source, target, want_unchanged=False):
    """Find the differences between the contents of two trees

    :param source: SHA1 of the source tree
    :param target: SHA1 of the target tree
    :param want_unchanged: Whether unchanged files should be reported
    :return: Iterator over tuples with
        (oldpath, newpath), (oldmode, newmode), (oldsha, newsha)
    """
    for change in tree_changes(self, source, target,
                               want_unchanged=want_unchanged):
        yield ((change.old.path, change.new.path),
               (change.old.mode, change.new.mode),
               (change.old.sha, change.new.sha))
@
%ocaml: useless intermediate


<<function diff_tree.tree_changes>>=
def tree_changes(store, tree1_id, tree2_id, want_unchanged=False,
                 rename_detector=None):
    """Find the differences between the contents of two trees.

    :param store: An ObjectStore for looking up objects.
    :param tree1_id: The SHA of the source tree.
    :param tree2_id: The SHA of the target tree.
    :param want_unchanged: If True, include TreeChanges for unmodified entries
        as well.
    :param rename_detector: RenameDetector object for detecting renames.
    :return: Iterator over TreeChange instances for each change between the
        source and target tree.
    """
    <<[[diff_tree.tree_changes()]] if rename detection>>
    #// else

    entries = walk_trees(store, tree1_id, tree2_id,
                         prune_identical=(not want_unchanged))
    for entry1, entry2 in entries:
        if entry1 == entry2 and not want_unchanged:
            continue

        # Treat entries for trees as missing.
        entry1 = _skip_tree(entry1)
        entry2 = _skip_tree(entry2)

        if entry1 != _NULL_ENTRY and entry2 != _NULL_ENTRY:
            if stat.S_IFMT(entry1.mode) != stat.S_IFMT(entry2.mode):
                # File type changed: report as delete/add.
                yield TreeChange.delete(entry1)
                entry1 = _NULL_ENTRY
                change_type = CHANGE_ADD
            elif entry1 == entry2:
                change_type = CHANGE_UNCHANGED
            else:
                change_type = CHANGE_MODIFY
        elif entry1 != _NULL_ENTRY:
            change_type = CHANGE_DELETE
        elif entry2 != _NULL_ENTRY:
            change_type = CHANGE_ADD
        else:
            # Both were None because at least one was a tree.
            continue

        yield TreeChange(change_type, entry1, entry2)
@
%ocaml: use ADT so clearer than those constants

<<function diff_tree._skip_tree>>=
def _skip_tree(entry):
    if entry.mode is None or stat.S_ISDIR(entry.mode):
        return _NULL_ENTRY
    return entry
@

\subsection{[[walk_trees()]]}

<<function diff_tree.walk_trees>>=
def walk_trees(store, tree1_id, tree2_id, prune_identical=False):
    """Recursively walk all the entries of two trees.

    Iteration is depth-first pre-order, as in e.g. os.walk.

    :param store: An ObjectStore for looking up objects.
    :param tree1_id: The SHA of the first Tree object to iterate, or None.
    :param tree2_id: The SHA of the second Tree object to iterate, or None.
    :param prune_identical: If True, identical subtrees will not be walked.
    :return: Iterator over Pairs of TreeEntry objects for each pair of entries
        in the trees and their subtrees recursively. If an entry exists in one
        tree but not the other, the other entry will have all attributes set
        to None. If neither entry's path is None, they are guaranteed to
        match.
    """
    # This could be fairly easily generalized to >2 trees if we find a use
    # case.
    mode1 = tree1_id and stat.S_IFDIR or None
    mode2 = tree2_id and stat.S_IFDIR or None
    todo = [(TreeEntry(b'', mode1, tree1_id), TreeEntry(b'', mode2, tree2_id))]
    while todo:
        entry1, entry2 = todo.pop()
        is_tree1 = _is_tree(entry1)
        is_tree2 = _is_tree(entry2)

        if prune_identical and is_tree1 and is_tree2 and entry1 == entry2:
            continue

        tree1 = is_tree1 and store[entry1.sha] or None
        tree2 = is_tree2 and store[entry2.sha] or None
        path = entry1.path or entry2.path
        todo.extend(reversed(_merge_entries(path, tree1, tree2)))
        yield entry1, entry2
@
% prune_identical is useful opti to avoid comparing whole tree
% when same sha


<<function diff_tree._is_tree>>=
def _is_tree(entry):
    mode = entry.mode
    if mode is None:
        return False
    return stat.S_ISDIR(mode)
@

<<constant diff_tree._merge_entries>>=
def _merge_entries(path, tree1, tree2):
    """Merge the entries of two trees.

    :param path: A path to prepend to all tree entry names.
    :param tree1: The first Tree object to iterate, or None.
    :param tree2: The second Tree object to iterate, or None.
    :return: A list of pairs of TreeEntry objects for each pair of entries in
        the trees. If an entry exists in one tree but not the other, the other
        entry will have all attributes set to None. If neither entry's path is
        None, they are guaranteed to match.
    """
    entries1 = _tree_entries(path, tree1)
    entries2 = _tree_entries(path, tree2)
    i1 = i2 = 0
    len1 = len(entries1)
    len2 = len(entries2)

    result = []
    while i1 < len1 and i2 < len2:
        entry1 = entries1[i1]
        entry2 = entries2[i2]
        if entry1.path < entry2.path:
            result.append((entry1, _NULL_ENTRY))
            i1 += 1
        elif entry1.path > entry2.path:
            result.append((_NULL_ENTRY, entry2))
            i2 += 1
        else:
            result.append((entry1, entry2))
            i1 += 1
            i2 += 1
    for i in range(i1, len1):
        result.append((entries1[i], _NULL_ENTRY))
    for i in range(i2, len2):
        result.append((_NULL_ENTRY, entries2[i]))
    return result
@
%ocaml: recursive version cleaner?

<<constant diff_tree._tree_entries>>=
def _tree_entries(path, tree):
    result = []
    if not tree:
        return result
    for entry in tree.iteritems(name_order=True):
        result.append(entry.in_path(path))
    return result
@


<<method TreeEntry.in_path>>=
def in_path(self, path):
    """Return a copy of this entry with the given path prepended."""
    <<[[TreeEntry.in_path()]] sanity check path>>
    return TreeEntry(posixpath.join(path, self.path), self.mode, self.sha)
@

<<[[TreeEntry.in_path()]] sanity check path>>=
if not isinstance(self.path, bytes):
    raise TypeError('Expected bytes for path, got %r' % path)
@
%ocaml: types


\section{[[git diff]]}

<<function cmd_diff>>=
class cmd_diff(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])

        if args == []:
            print("Usage: dulwich diff COMMITID")
            sys.exit(1)

        r = Repo(".")
        commit_id = args[0]
        commit = r[commit_id]
        parent_commit = r[commit.parents[0]]

        write_tree_diff(sys.stdout, r.object_store, parent_commit.tree, commit.tree)
@
% it's not the usual meaning of git diff.

\subsection{[[write_tree_diff()]]}

<<function patch.write_tree_diff>>=
# TODO(jelmer): Support writing unicode, rather than bytes.
def write_tree_diff(f, store, old_tree, new_tree, diff_binary=False):
    """Write tree diff.

    :param f: File-like object to write to.
    :param old_tree: Old tree id
    :param new_tree: New tree id
    :param diff_binary: Whether to diff files even if they
        are considered binary files by is_binary().
    """
    changes = store.tree_changes(old_tree, new_tree)
    for (oldpath, newpath), (oldmode, newmode), (oldsha, newsha) in changes:
        write_object_diff(f, store, (oldpath, oldmode, oldsha),
                                    (newpath, newmode, newsha),
                                    diff_binary=diff_binary)
@

\subsection{[[write_object_diff()]]}

<<function patch.write_object_diff>>=
def write_object_diff(f, store, old_file, new_file, diff_binary=False):
    """Write the diff for an object.

    :param f: File-like object to write to
    :param store: Store to retrieve objects from, if necessary
    :param old_file: (path, mode, hexsha) tuple
    :param new_file: (path, mode, hexsha) tuple
    :param diff_binary: Whether to diff files even if they
        are considered binary files by is_binary().

    :note: the tuple elements should be None for nonexistant files
    """
    (old_path, old_mode, old_id) = old_file
    (new_path, new_mode, new_id) = new_file
    old_path = patch_filename(old_path, b"a")
    new_path = patch_filename(new_path, b"b")
    def content(mode, hexsha):
        if hexsha is None:
            return Blob.from_string(b'')
        <<[[write_object_diff()]] if gitlink>>
        else:
            return store[hexsha]

    def lines(content):
        if not content:
            return []
        else:
            return content.splitlines()
    f.writelines(gen_diff_header(
        (old_path, new_path), (old_mode, new_mode), (old_id, new_id)))
    old_content = content(old_mode, old_id)
    new_content = content(new_mode, new_id)
    <<[[write_object_diff()]] if binary files>>
    else:
        f.writelines(unified_diff(lines(old_content), lines(new_content),
            old_path, new_path))
@

<<function patch.patch_filename>>=
def patch_filename(p, root):
    if p is None:
        return b"/dev/null"
    else:
        return root + b"/" + p
@

<<function patch.gen_diff_header>>=
# TODO(jelmer): Support writing unicode, rather than bytes.
def gen_diff_header(paths, modes, shas):
    """Write a blob diff header.

    :param paths: Tuple with old and new path
    :param modes: Tuple with old and new modes
    :param shas: Tuple with old and new shas
    """
    (old_path, new_path) = paths
    (old_mode, new_mode) = modes
    (old_sha, new_sha) = shas
    yield b"diff --git " + old_path + b" " + new_path + b"\n"
    <<[[gen_diff_header()]] print old and new mode differences>>
    yield b"index " + shortid(old_sha) + b".." + shortid(new_sha)
    if new_mode is not None:
        yield (" %o" % new_mode).encode('ascii')
    yield b"\n"
@

<<[[gen_diff_header()]] print old and new mode differences>>=
if old_mode != new_mode:
    if new_mode is not None:
        if old_mode is not None:
            yield ("old mode %o\n" % old_mode).encode('ascii')
        yield ("new mode %o\n" % new_mode).encode('ascii')
    else:
        yield ("deleted mode %o\n" % old_mode).encode('ascii')
@

<<function patch.shortid>>=
def shortid(hexsha):
    if hexsha is None:
        return b"0" * 7
    else:
        return hexsha[:7]
@

<<function patch.unified_diff>>=
def unified_diff(a, b, fromfile, tofile, n=3):
    """difflib.unified_diff that doesn't write any dates or trailing spaces.

    Based on the same function in Python2.6.5-rc2's difflib.py
    """
    started = False
    for group in SequenceMatcher(None, a, b).get_grouped_opcodes(n):
        if not started:
            yield b'--- ' + fromfile + b'\n'
            yield b'+++ ' + tofile + b'\n'
            started = True
        i1, i2, j1, j2 = group[0][1], group[-1][2], group[0][3], group[-1][4]
        sizes = "@@ -%d,%d +%d,%d @@\n" % (i1+1, i2-i1, j1+1, j2-j1)
        yield sizes.encode('ascii')
        for tag, i1, i2, j1, j2 in group:
            if tag == 'equal':
                for line in a[i1:i2]:
                    yield b' ' + line
                continue
            if tag == 'replace' or tag == 'delete':
                for line in a[i1:i2]:
                    if not line[-1:] == b'\n':
                        line += b'\n\\ No newline at end of file\n'
                    yield b'-' + line
            if tag == 'replace' or tag == 'insert':
                for line in b[j1:j2]:
                    if not line[-1:] == b'\n':
                        line += b'\n\\ No newline at end of file\n'
                    yield b'+' + line
@

%difflib! for SequenceMatcher


<<function patch.is_binary>>=
def is_binary(content):
    """See if the first few bytes contain any null characters.

    :param content: Bytestring to check for binary content
    """
    return b'\0' in content[:FIRST_FEW_BYTES]
@

<<[[write_object_diff()]] if binary files>>=
if not diff_binary and (
        is_binary(old_content.data) or is_binary(new_content.data)):
    f.write(b"Binary files " + old_path + b" and " + new_path + b" differ\n")
@



\section{Graph walker}
\l make it a chapter? Walking a Repository?

% A bit complicated:
%  - Walker
%  - CommitQueue
%  - WalkerEntry
% and many options that operates at different levels

\subsection{[[get_walker()]]}

% porcelain.log -> <>
<<[[BaseRepo]] methods>>=
def get_walker(self, include=None, *args, **kwargs):
    """Obtain a walker for this repository.

    :param include: Iterable of SHAs of commits to include along with their
        ancestors. Defaults to [HEAD]
    :param exclude: Iterable of SHAs of commits to exclude along with their
        ancestors, overriding includes.
    :param order: ORDER_* constant specifying the order of results.
        Anything other than ORDER_DATE may result in O(n) memory usage.
    :param reverse: If True, reverse the order of output, requiring O(n)
        memory.
    :param max_entries: The maximum number of entries to yield, or None for
        no limit.
    :param paths: Iterable of file or subtree paths to show entries for.
    :param rename_detector: diff.RenameDetector object for detecting
        renames.
    :param follow: If True, follow path across renames/copies. Forces a
        default rename_detector.
    :param since: Timestamp to list commits after.
    :param until: Timestamp to list commits before.
    :param queue_cls: A class to use for a queue of commits, supporting the
        iterator protocol. The constructor takes a single argument, the
        Walker.
    :return: A `Walker` object
    """
    from dulwich.walk import Walker
    if include is None:
        include = [self.head()]
    <<[[BaseRepo.get_walker()]] adust include if not a list>>
    kwargs['get_parents'] = lambda commit: self.get_parents(
        commit.id, commit)

    return Walker(self.object_store, include, *args, **kwargs)
@
%ocaml: not using so many parameters, so no need *args and **kwargs trick.
% also useless wrapper over Walker

\l why refine get_parents? same than default anyway

<<[[BaseRepo.get_walker()]] adust include if not a list>>=
if isinstance(include, str):
    include = [include]
@
%ocaml: types! useless flexibility

\subsection{[[Walker]]}

<<class Walker>>=
class Walker(object):
    """Object for performing a walk of commits in a store.

    Walker objects are initialized with a store and other options and can then
    be treated as iterators of Commit objects.
    """

    <<[[Walker]] methods>>
@

<<[[Walker]] methods>>=
def __init__(self, store, include, exclude=None, order=ORDER_DATE,
             reverse=False, max_entries=None, paths=None,
             rename_detector=None, follow=False, since=None, until=None,
             get_parents=lambda commit: commit.parents,
             queue_cls=_CommitTimeQueue):
    """Constructor.

    :param store: ObjectStore instance for looking up objects.
    :param include: Iterable of SHAs of commits to include along with their
        ancestors.
    :param exclude: Iterable of SHAs of commits to exclude along with their
        ancestors, overriding includes.
    :param order: ORDER_* constant specifying the order of results. Anything
        other than ORDER_DATE may result in O(n) memory usage.
    :param reverse: If True, reverse the order of output, requiring O(n)
        memory.
    :param max_entries: The maximum number of entries to yield, or None for
        no limit.
    :param paths: Iterable of file or subtree paths to show entries for.
    :param rename_detector: diff.RenameDetector object for detecting
        renames.
    :param follow: If True, follow path across renames/copies. Forces a
        default rename_detector.
    :param since: Timestamp to list commits after.
    :param until: Timestamp to list commits before.
    :param get_parents: Method to retrieve the parents of a commit
    :param queue_cls: A class to use for a queue of commits, supporting the
        iterator protocol. The constructor takes a single argument, the
        Walker.
    """
    # Note: when adding arguments to this method, please also update
    # dulwich.repo.BaseRepo.get_walker
    <<[[Walker.__init__()]] sanity check order>>
    self.store = store
    <<[[Walker.__init__()]] adjust include if not list>>

    self.include = include
    self.excluded = set(exclude or [])

    self.order = order
    self.reverse = reverse
    self.max_entries = max_entries

    self.paths = paths and set(paths) or None
    <<[[Walker.__init__()]] rename detector setting>>
    self.get_parents = get_parents

    self.since = since
    self.until = until

    self._num_entries = 0
    self._queue = queue_cls(self)
    self._out_queue = collections.deque()
@
\l why want flexibility to change get_parents? 
%ocaml: ugly use of object fields above where self.include then
% used in queue_cls which is useless default argument.
% far simpler in ocaml.

\l why output queue?

<<[[Walker.__init__()]] adjust include if not list>>=
if isinstance(include, bytes):
    # TODO(jelmer): Really, this should require a single type.
    # Print deprecation warning here?
    include = [include]
@
%ocaml: types! useless flexibility

<<[[Walker]] methods>>=
def __iter__(self):
    return iter(self._reorder(iter(self._next, None)))
@
% double iter()!

% iter call iterators and generate a list that reorder then reorder
% and then iterate over this list.


\subsection{[[_CommitTimeQueue]]}

<<class _CommitTimeQueue>>=
class _CommitTimeQueue(object):
    """Priority queue of WalkEntry objects by commit time."""

    <<[[_CommitTimeQueue]] methods>>
@


<<[[_CommitTimeQueue]] methods>>=
def __init__(self, walker):
    self._walker = walker
    self._store = walker.store
    self._get_parents = walker.get_parents
    self._excluded = walker.excluded
    self._pq = []

    self._pq_set = set()
    self._done = set()

    self._seen = set()

    self._min_time = walker.since
    self._last = None
    self._extra_commits_left = _MAX_EXTRA_COMMITS
    self._is_finished = False

    for commit_id in chain(walker.include, walker.excluded):
        self._push(commit_id)
@
% pq_set = query set?

% chain()? python builtin for? =~ concat? but then why put excluded?


<<[[_CommitTimeQueue]] methods>>=
def _push(self, object_id):
    try:
        obj = self._store[object_id]
    except KeyError:
        raise MissingCommitError(object_id)
    <<[[_CommitTimeQueue._push()]] if tag>>
    # TODO(jelmer): What to do about non-Commit and non-Tag objects?
    commit = obj
    if commit.id not in self._pq_set and commit.id not in self._done:
        heapq.heappush(self._pq, (-commit.commit_time, commit))
        self._pq_set.add(commit.id)
        self._seen.add(commit.id)
@
\t _seen? what for? for extra features I think


\subsection{[[WalkEntry]]}

<<class WalkEntry>>=
class WalkEntry(object):
    """Object encapsulating a single result from a walk."""

    <<[[WalkEntry]] methods>>
@

<<[[WalkEntry]] methods>>=
def __init__(self, walker, commit):
    self.commit = commit
    self._store = walker.store
    self._get_parents = walker.get_parents

    self._changes = {}
    self._rename_detector = walker.rename_detector
@





\subsection{[[next()]]}

%seen before:
%def __iter__(self):
%    return iter(self._reorder(iter(self._next, None)))



\l iter(, None) ?

<<[[Walker]] methods>>=
def _next(self):
    max_entries = self.max_entries
    while max_entries is None or self._num_entries < max_entries:
        entry = next(self._queue)
        if entry is not None:
            self._out_queue.append(entry)
        if entry is None or len(self._out_queue) > _MAX_EXTRA_COMMITS:
            if not self._out_queue:
                return None
            entry = self._out_queue.popleft()
            if self._should_return(entry):
                self._num_entries += 1
                return entry
    return None
@
\l why go through intermediate _out_queue? because of time boundary shit
\l  when exclude some commits?

<<constant walk._MAX_EXTRA_COMMITS>>=
# Maximum number of commits to walk past a commit time boundary.
_MAX_EXTRA_COMMITS = 5
@


<<[[_CommitTimeQueue]] methods>>=
def next(self):
    if self._is_finished:
        return None
    while self._pq:
        _, commit = heapq.heappop(self._pq)
        sha = commit.id
        self._pq_set.remove(sha)
        if sha in self._done:
            continue
        self._done.add(sha)

        for parent_id in self._get_parents(commit):
            self._push(parent_id)

        <<[[_CommitTimeQueue.next()]] handle excluded commits>>
        <<[[_CommitTimeQueue.next()]] handle since time>>

        if not is_excluded:
            self._last = commit
            return WalkEntry(self._walker, commit)
    self._is_finished = True
    return None
@
%WalkEntry!

<<[[_CommitTimeQueue]] methods>>=
__next__ = next
@




<<[[Walker]] methods>>=
def _reorder(self, results):
    """Possibly reorder a results iterator.

    :param results: An iterator of WalkEntry objects, in the order returned
        from the queue_cls.
    :return: An iterator or list of WalkEntry objects, in the order required
        by the Walker.
    """
    <<[[Walker._reorder()]] if topological order>>
    <<[[Walker._reorder()]] if reverse order>>
    return results
@


<<[[Walker]] methods>>=
def _should_return(self, entry):
    """Determine if a walk entry should be returned..

    :param entry: The WalkEntry to consider.
    :return: True if the WalkEntry should be returned by this walk, or False
        otherwise (e.g. if it doesn't match any requested paths).
    """
    commit = entry.commit

    <<[[Walker._should_return()]] if not in time range>>
    <<[[Walker._should_return()]] if in exclude set>>

    if self.paths is None:
        return True
    <<[[Walker._should_return()]] when path restriction>>
@




\subsection{[[Walker]] extra features}

\subsubsection{max entries}

% git log -1, -10, useful.

\subsubsection{Reverse walking}

<<[[Walker._reorder()]] if reverse order>>=
if self.reverse:
    results = reversed(list(results))
@

% requires O(n). will call iterator and store result a list.

\subsubsection{Exclude set}

<<[[Walker._should_return()]] if in exclude set>>=
if commit.id in self.excluded:
    return False
@

<<[[_CommitTimeQueue.next()]] handle excluded commits>>=
reset_extra_commits = True
is_excluded = sha in self._excluded
if is_excluded:
    self._exclude_parents(commit)
    if self._pq and all(c.id in self._excluded
                        for _, c in self._pq):
        _, n = self._pq[0]

        if self._last and n.commit_time >= self._last.commit_time:
            # If the next commit is newer than the last one, we need
            # to keep walking in case its parents (which we may not
            # have seen yet) are excluded. This gives the excluded
            # set a chance to "catch up" while the commit is still
            # in the Walker's output queue.
            reset_extra_commits = True
        else:
            reset_extra_commits = False
@

<<[[_CommitTimeQueue]] methods>>=
def _exclude_parents(self, commit):
    excluded = self._excluded
    seen = self._seen
    todo = [commit]
    while todo:
        commit = todo.pop()
        for parent in self._get_parents(commit):
            if parent not in excluded and parent in seen:
                # TODO: This is inefficient unless the object store does
                # some caching (which DiskObjectStore currently does not).
                # We could either add caching in this class or pass around
                # parsed queue entry objects instead of commits.
                todo.append(self._store[parent])
            excluded.add(parent)
@


\subsubsection{Time range}

<<[[Walker._should_return()]] if not in time range>>=
if self.since is not None and commit.commit_time < self.since:
    return False
if self.until is not None and commit.commit_time > self.until:
    return False
@

<<[[_CommitTimeQueue.next()]] handle since time>>=
if (self._min_time is not None and
    commit.commit_time < self._min_time):
    # We want to stop walking at min_time, but commits at the
    # boundary may be out of order with respect to their parents. So
    # we walk _MAX_EXTRA_COMMITS more commits once we hit this
    # boundary.
    reset_extra_commits = False

if reset_extra_commits:
    # We're not at a boundary, so reset the counter.
    self._extra_commits_left = _MAX_EXTRA_COMMITS
else:
    self._extra_commits_left -= 1
    if not self._extra_commits_left:
        break
@

\subsubsection{Path restrictions}

<<[[Walker._should_return()]] when path restriction>>=
<<[[Walker._should_return()]] when path restriction, if merge commit>>
else:
    for change in entry.changes():
        if self._change_matches(change):
            return True
return None
@

<<[[Walker]] methods>>=
def _change_matches(self, change):
    if not change:
        return False

    old_path = change.old.path
    new_path = change.new.path
    if self._path_matches(new_path):
        <<[[Walker._change_matches()]] if follow, remember renamed file>>
        return True
    elif self._path_matches(old_path):
        return True
    return False
@



<<[[Walker]] methods>>=
def _path_matches(self, changed_path):
    if changed_path is None:
        return False
    for followed_path in self.paths:
        if changed_path == followed_path:
            return True
        if (changed_path.startswith(followed_path) and
                changed_path[len(followed_path)] == b'/'[0]):
            return True
    return False
@



% Walker.should_return | print_name_status -> <>
<<[[WalkEntry]] methods>>=
def changes(self, path_prefix=None):
    """Get the tree changes for this entry.

    :param path_prefix: Portion of the path in the repository to
        use to filter changes. Must be a directory name. Must be
        a full, valid, path reference (no partial names or wildcards).
    :return: For commits with up to one parent, a list of TreeChange
        objects; if the commit has no parents, these will be relative to the
        empty tree. For merge commits, a list of lists of TreeChange
        objects; see dulwich.diff.tree_changes_for_merge.
    """
    cached = self._changes.get(path_prefix)
    if cached is None:
        commit = self.commit
        <<[[WalkEntry.changes()]] when no parent>>
        elif len(self._get_parents(commit)) == 1:
            changes_func = tree_changes
            parent = self._store[self._get_parents(commit)[0]].tree
            if path_prefix:
                mode, subtree_sha = parent.lookup_path(
                    self._store.__getitem__,
                    path_prefix,
                )
                parent = self._store[subtree_sha]
        <<[[WalkEntry.changes()]] when many parents>>
        commit_tree_sha = commit.tree
        <<[[WalkEntry.changes()]] if path restriction>>
        cached = list(changes_func(
          self._store, parent, commit_tree_sha,
          rename_detector=self._rename_detector))
        self._changes[path_prefix] = cached
    return self._changes[path_prefix]
@



<<[[WalkEntry.changes()]] when no parent>>=
if not self._get_parents(commit):
    changes_func = tree_changes
    parent = None
@
<<[[WalkEntry.changes()]] when many parents>>=
else:
    changes_func = tree_changes_for_merge
    parent = [self._store[p].tree for p in self._get_parents(commit)]
    if path_prefix:
        parent_trees = [self._store[p] for p in parent]
        parent = []
        for p in parent_trees:
            try:
                mode, st = p.lookup_path(
                    self._store.__getitem__,
                    path_prefix,
                )
            except KeyError:
                pass
            else:
                parent.append(st)
@

<<[[WalkEntry.changes()]] if path restriction>>=
if path_prefix:
    commit_tree = self._store[commit_tree_sha]
    mode, commit_tree_sha = commit_tree.lookup_path(
        self._store.__getitem__,
        path_prefix,
    )
@

<<[[Walker._should_return()]] when path restriction, if merge commit>>=
if len(self.get_parents(commit)) > 1:
    for path_changes in entry.changes():
        # For merge commits, only include changes with conflicts for
        # this path. Since a rename conflict may include different
        # old.paths, we have to check all of them.
        for change in path_changes:
            if self._change_matches(change):
                return True
@


\subsubsection{Topological order}

<<[[Walker._reorder()]] if topological order>>=
if self.order == ORDER_TOPO:
    results = _topo_reorder(results, self.get_parents)
@

<<type walk.ORDER>>=
ORDER_DATE = 'date'
ORDER_TOPO = 'topo'
@
%ocaml: enum

<<constant walk.ALL_ORDERS>>=
ALL_ORDERS = (ORDER_DATE, ORDER_TOPO)
@

<<[[Walker.__init__()]] sanity check order>>=
if order not in ALL_ORDERS:
    raise ValueError('Unknown walk order %s' % order)
@
%ocaml: types!


<<function walk._topo_reorder>>=
def _topo_reorder(entries, get_parents=lambda commit: commit.parents):
    """Reorder an iterable of entries topologically.

    This works best assuming the entries are already in almost-topological
    order, e.g. in commit time order.

    :param entries: An iterable of WalkEntry objects.
    :param get_parents: Optional function for getting the parents of a commit.
    :return: iterator over WalkEntry objects from entries in FIFO order, except
        where a parent would be yielded before any of its children.
    """
    todo = collections.deque()
    pending = {}
    num_children = defaultdict(int)
    for entry in entries:
        todo.append(entry)
        for p in get_parents(entry.commit):
            num_children[p] += 1

    while todo:
        entry = todo.popleft()
        commit = entry.commit
        commit_id = commit.id
        if num_children[commit_id]:
            pending[commit_id] = entry
            continue
        for parent_id in get_parents(commit):
            num_children[parent_id] -= 1
            if not num_children[parent_id]:
                parent_entry = pending.pop(parent_id, None)
                if parent_entry:
                    todo.appendleft(parent_entry)
        yield entry
@





\section{[[git log]]}

<<function cmd_log>>=
class cmd_log(Command):

    def run(self, args):
        parser = optparse.OptionParser()
        parser.add_option("--reverse", dest="reverse", action="store_true",
                          help="Reverse order in which entries are printed")
        parser.add_option("--name-status", dest="name_status", action="store_true",
                          help="Print name/status for each changed file")
        options, args = parser.parse_args(args)

        porcelain.log(".", paths=args, reverse=options.reverse,
                      name_status=options.name_status,
                      outstream=sys.stdout)
@

<<function porcelain.log>>=
def log(repo=".", paths=None, outstream=sys.stdout, max_entries=None,
        reverse=False, name_status=False):
    """Write commit logs.

    :param repo: Path to repository
    :param paths: Optional set of specific paths to print entries for
    :param outstream: Stream to write log output to
    :param reverse: Reverse order in which entries are printed
    :param name_status: Print name status
    :param max_entries: Optional maximum number of entries to display
    """
    with open_repo_closing(repo) as r:
        walker = r.get_walker(
            max_entries=max_entries, paths=paths, reverse=reverse)
        for entry in walker:
            <<[[porcelain.log()]] define [[decode()]]>>
            print_commit(entry.commit, decode, outstream)
            <<[[porcelain.log()]] if name status option>>
@



\subsection{Printing a commit}

<<function porcelain.print_commit>>=
def print_commit(commit, decode, outstream=sys.stdout):
    """Write a human-readable commit log entry.

    :param commit: A `Commit` object
    :param outstream: A stream file to write to
    """
    outstream.write("-" * 50 + "\n")

    outstream.write("commit: " + commit.id.decode('ascii') + "\n")
    if len(commit.parents) > 1:
        outstream.write(
            "merge: " +
            "...".join([c.decode('ascii') for c in commit.parents[1:]]) + "\n")

    outstream.write("Author: " + decode(commit.author) + "\n")
    if commit.author != commit.committer:
        outstream.write("Committer: " + decode(commit.committer) + "\n")

    time_tuple = time.gmtime(commit.author_time + commit.author_timezone)
    time_str = time.strftime("%a %b %d %Y %H:%M:%S", time_tuple)
    timezone_str = format_timezone(commit.author_timezone).decode('ascii')
    outstream.write("Date:   " + time_str + " " + timezone_str + "\n")

    outstream.write("\n")
    outstream.write(decode(commit.message) + "\n")
    outstream.write("\n")
@


\subsection{Commit diff summary, [[git log --name-status]]}

<<[[porcelain.log()]] if name status option>>=
if name_status:
    outstream.writelines(
        [l+'\n' for l in print_name_status(entry.changes())])
@

% Commit.changes

<<constant diff_tree.RENAME_CHANGE_TYPES>>=
RENAME_CHANGE_TYPES = (CHANGE_RENAME, CHANGE_COPY)
@

<<function porcelain.print_name_status>>=
def print_name_status(changes):
    """Print a simple status summary, listing changed files.
    """
    for change in changes:
        if not change:
            continue
        <<[[print_name_status()]] adjust change if not list>>
        if change.type == CHANGE_ADD:
            path1 = change.new.path
            path2 = ''
            kind = 'A'
        elif change.type == CHANGE_DELETE:
            path1 = change.old.path
            path2 = ''
            kind = 'D'
        elif change.type == CHANGE_MODIFY:
            path1 = change.new.path
            path2 = ''
            kind = 'M'
        elif change.type in RENAME_CHANGE_TYPES:
            path1 = change.old.path
            path2 = change.new.path
            if change.type == CHANGE_RENAME:
                kind = 'R'
            elif change.type == CHANGE_COPY:
                kind = 'C'
        yield '%-8s%-20s%-20s' % (kind, path1, path2)
@
%ocaml: ADT so no need path1 path2 stuff

<<[[print_name_status()]] adjust change if not list>>=
if isinstance(change, list):
    change = change[0]
@

\section{[[git status]]}

<<function cmd_status>>=
class cmd_status(Command):

    def run(self, args):
        parser = optparse.OptionParser()
        options, args = parser.parse_args(args)
        if len(args) >= 1:
            gitdir = args[0]
        else:
            gitdir = '.'

        status = porcelain.status(gitdir)

        <<[[cmd_status()]] print staged>>
        <<[[cmd_status()]] print unstaged>>
        <<[[cmd_status()]] print untracked>>
@

<<type GitStatus>>=
# Module level tuple definition for status output
GitStatus = namedtuple('GitStatus', 'staged unstaged untracked')
@

<<function porcelain.status>>=
def status(repo="."):
    """Returns staged, unstaged, and untracked changes relative to the HEAD.

    :param repo: Path to repository or repository object
    :return: GitStatus tuple,
        staged -    list of staged paths (diff index/HEAD)
        unstaged -  list of unstaged paths (diff index/working-tree)
        untracked - list of untracked, un-ignored & non-.git paths
    """
    with open_repo_closing(repo) as r:
        # 1. Get status of staged
        tracked_changes = get_tree_changes(r)
        # 2. Get status of unstaged
        index = r.open_index()
        unstaged_changes = list(get_unstaged_changes(index, r.path))
        untracked_changes = list(get_untracked_paths(r.path, r.path, index))
        return GitStatus(tracked_changes, unstaged_changes, untracked_changes)
@


\subsection{Index vs HEAD, [[get_tree_changes()]]}

<<[[cmd_status()]] print staged>>=
if any(names for (kind, names) in status.staged.items()):
    sys.stdout.write("Changes to be committed:\n\n")
    for kind, names in status.staged.items():
        for name in names:
            sys.stdout.write("\t%s: %s\n" % (
                kind, name.decode(sys.getfilesystemencoding())))
    sys.stdout.write("\n")
@


\t vs BaseObjectRepo.tree_changes and diff_tree_tree_changes and
\t  tree_changes_for_merge?

<<function porcelain.get_tree_changes>>=
def get_tree_changes(repo):
    """Return add/delete/modify changes to tree by comparing index to HEAD.

    :param repo: repo path or object
    :return: dict with lists for each type of change
    """
    with open_repo_closing(repo) as r:
        index = r.open_index()

        # Compares the Index to the HEAD & determines changes
        # Iterate through the changes and report add/delete/modify
        # TODO: call out to dulwich.diff_tree somehow.
        tracked_changes = {
            'add': [],
            'delete': [],
            'modify': [],
        }
        try:
            tree_id = r[b'HEAD'].tree
        except KeyError:
            tree_id = None

        for change in index.changes_from_tree(r.object_store, tree_id):
            if not change[0][0]:
                tracked_changes['add'].append(change[0][1])
            elif not change[0][1]:
                tracked_changes['delete'].append(change[0][0])
            elif change[0][0] == change[0][1]:
                tracked_changes['modify'].append(change[0][0])
            else:
                raise AssertionError('git mv ops not yet supported')
        return tracked_changes
@


<<[[Index]] methods>>=
def changes_from_tree(self, object_store, tree, want_unchanged=False):
    """Find the differences between the contents of this index and a tree.

    :param object_store: Object store to use for retrieving tree contents
    :param tree: SHA1 of the root tree
    :param want_unchanged: Whether unchanged files should be reported
    :return: Iterator over tuples with (oldpath, newpath), (oldmode, newmode), (oldsha, newsha)
    """
    def lookup_entry(path):
        entry = self[path]
        return entry.sha, entry.mode
    for (name, mode, sha) in changes_from_tree(self._byname.keys(),
            lookup_entry, object_store, tree,
            want_unchanged=want_unchanged):
        yield (name, mode, sha)
@


<<function index.changes_from_tree>>=
def changes_from_tree(names, lookup_entry, object_store, tree,
        want_unchanged=False):
    """Find the differences between the contents of a tree and
    a working copy.

    :param names: Iterable of names in the working copy
    :param lookup_entry: Function to lookup an entry in the working copy
    :param object_store: Object store to use for retrieving tree contents
    :param tree: SHA1 of the root tree, or None for an empty tree
    :param want_unchanged: Whether unchanged files should be reported
    :return: Iterator over tuples with (oldpath, newpath), (oldmode, newmode),
        (oldsha, newsha)
    """
    other_names = set(names)

    if tree is not None:
        for (name, mode, sha) in object_store.iter_tree_contents(tree):
            try:
                (other_sha, other_mode) = lookup_entry(name)
            except KeyError:
                # Was removed
                yield ((name, None), (mode, None), (sha, None))
            else:
                other_names.remove(name)
                if (want_unchanged or other_sha != sha or other_mode != mode):
                    yield ((name, name), (mode, other_mode), (sha, other_sha))

    # Mention added files
    for name in other_names:
        try:
            (other_sha, other_mode) = lookup_entry(name)
        except KeyError:
            pass
        else:
            yield ((None, name), (None, other_mode), (None, other_sha))
@







\subsection{Worktree vs index, [[get_unstaged_changes()]]}

<<[[cmd_status()]] print unstaged>>=
if status.unstaged:
    sys.stdout.write("Changes not staged for commit:\n\n")
    for name in status.unstaged:
        sys.stdout.write("\t%s\n" %
                name.decode(sys.getfilesystemencoding()))
    sys.stdout.write("\n")
@
\l should also put delete (D) or modified (M) information here

% should be called from cmd_diff too
<<function index.get_unstaged_changes>>=
def get_unstaged_changes(index, root_path):
    """Walk through an index and check for differences against working tree.

    :param index: index to check
    :param root_path: path in which to find files
    :return: iterator over paths with unstaged changes
    """
    # For each entry in the index check the sha1 & ensure not staged
    <<[[get_unstaged_changes()]] adjust root_path if not bytes>>

    for tree_path, entry in index.iteritems():
        full_path = _tree_to_fs_path(root_path, tree_path)
        # TODO(jelmer): handle S_ISGITLINK(entry.mode) here
        try:
            blob = blob_from_path_and_stat(full_path, os.lstat(full_path))
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise
            # The file was removed, so we assume that counts as
            # different from whatever file used to exist.
            yield tree_path
        except IOError as e:
            if e.errno != errno.EISDIR:
                raise
            # The file was changed to a directory, so consider it removed.
            yield tree_path
        else:
            if blob.id != entry.sha:
                yield tree_path
@

\subsection{Worktree not in index, [[get_untracked_paths()]]}

<<[[cmd_status()]] print untracked>>=
if status.untracked:
    sys.stdout.write("Untracked files:\n\n")
    for name in status.untracked:
        sys.stdout.write("\t%s\n" % name)
    sys.stdout.write("\n")
@


% porcelain.add | porcelain.status -> <>
<<function porcelain.get_untracked_paths>>=
def get_untracked_paths(frompath, basepath, index):
    """Get untracked paths.

    ;param frompath: Path to walk
    :param basepath: Path to compare to
    :param index: Index to check against
    """
    # If nothing is specified, add all non-ignored files.
    for dirpath, dirnames, filenames in os.walk(frompath):
        # Skip .git and below.
        if '.git' in dirnames:
            dirnames.remove('.git')
        for filename in filenames:
            p = os.path.join(dirpath[len(basepath)+1:], filename)
            if p not in index:
                yield p
@

% seen before when showed

<<[[porcelain.add()]] if no paths, get untracked paths>>=
if not paths:
    paths = list(get_untracked_paths(os.getcwd(), r.path,
        r.open_index()))
@
\l should do that? should ask before at least no?

\chapter{Pulling and Pushing}


\section{[[git pull]]}

<<function cmd_pull>>=
class cmd_pull(Command):

    def run(self, args):
        parser = optparse.OptionParser()
        options, args = parser.parse_args(args)
        try:
            from_location = args[0]
        except IndexError:
            from_location = None

        porcelain.pull('.', from_location)
@

<<function porcelain.pull>>=
def pull(repo, remote_location=None, refspecs=None,
         outstream=default_bytes_out_stream,
         errstream=default_bytes_err_stream):
    """Pull from remote via dulwich.client

    :param repo: Path to repository
    :param remote_location: Location of the remote
    :param refspec: refspecs to fetch
    :param outstream: A stream file to write to output
    :param errstream: A stream file to write to errors
    """
    # Open the repo
    with open_repo_closing(repo) as r:
        <<[[porcelain.pull()]] sanity check remote_location>>
        if refspecs is None:
            refspecs = [b"HEAD"]

        <<[[porcelain.pull()]] define determine_wants>>

        client, path = get_transport_and_path(remote_location)
        remote_refs = client.fetch(
            path, r, progress=errstream.write, determine_wants=determine_wants)

        <<[[porcelain.pull()]] update refs with remote refs>>

        # Perform 'git checkout .' - syncs staged changes
        tree = r[b"HEAD"].tree
        r.reset_index()
@
% saw get_transport_and_path before in core DS and its default
% implem to LocalGitClient

% why return path and client, could embed path information
% in client already.

% determine_wants is about which refs to fetch. Get all remote_refs
% as arguments and returned the sha of the one to fetch (usually
% the one for HEAD)

\t this assumes no merge needed?

% Flow is to set the starting refs you want to fetch from,
% then compute common commits and missing commits by walking graph
% of commits on target repo and comparing to commits from source repo.
% find all missing objects needed by those commits.

<<constant default_bytes_out_stream>>=
default_bytes_out_stream = getattr(sys.stdout, 'buffer', sys.stdout)
@
<<constant default_bytes_err_stream>>=
default_bytes_err_stream = getattr(sys.stderr, 'buffer', sys.stderr)
@
%ocaml: meh

<<[[porcelain.pull()]] sanity check remote_location>>=
if remote_location is None:
    # TODO(jelmer): Lookup 'remote' for current branch in config
    raise NotImplementedError(
        "looking up remote from branch config not supported yet")
@

\subsection{Fetching objects (locally)}

% will see fetching remote later in Networking chapter.

% LocalGitClient overrides GitClient.fetch!
<<[[LocalGitClient]] methods>>=
def fetch(self, path, target, determine_wants=None, progress=None):
    """Fetch into a target repository.

    :param path: Path to fetch from (as bytestring)
    :param target: Target repository to fetch into
    :param determine_wants: Optional function determine what refs
        to fetch. Receives dictionary of name->sha, should return
        list of shas to fetch. Defaults to all shas.
    :param progress: Optional progress function
    :return: Dictionary with all remote refs (not just those fetched)
    """
    with self._open_repo(path) as r:
        return r.fetch(target, determine_wants=determine_wants,
                       progress=progress)
@

<<[[LocalGitClient]] methods>>=
@classmethod
def _open_repo(cls, path):
    from dulwich.repo import Repo
    <<[[LocalGitClient._open_repo()]] sanitize path>>
    return closing(Repo(path))
@
%ocaml: no need closing(), so no need this wrapper
\l no locking? objects store should be stable (unless when pack)
\l  and read references problem? anyway atomic rename from source repo
\l  so should be fine.

% LocalGitClient.fetch | ???? -> <>
<<[[BaseRepo]] methods>>=
def fetch(self, target, determine_wants=None, progress=None):
    """Fetch objects into another repository.

    :param target: The target repository
    :param determine_wants: Optional function to determine what refs to
        fetch.
    :param progress: Optional progress function
    :return: The local refs
    """
    <<[[BaseRepo.fetch()]] set determine_wants>>
    target.object_store.add_objects(
        self.fetch_objects(determine_wants, target.get_graph_walker(),
                           progress))
    return self.get_refs()
@
%python: fetch will return an iterator over objects?
% so no huge memory consumption? Hmm but in PackObjectStore.add_objects
% it calls len() on it so this should trigger the computation of the
% whole list.
%ocaml: again, no need this to be in BaseRepo, can be in localGitClient

% Note that graph walker is for the target! pass so dource can know
% which one the target needs. So it's also a kind of determine_wants
% but for objects this time.

<<[[BaseRepo]] methods>>=
def get_refs(self):
    """Get dictionary with all refs.

    :return: A ``dict`` mapping ref names to SHA1s
    """
    return self.refs.as_dict()
@
% ``
% remote refs returned.


% (LocalGitClient.fetch | ????) -> BaseRepo.fetch -> <>
<<[[BaseRepo]] methods>>=
def fetch_objects(self, determine_wants, graph_walker, progress,
                  get_tagged=None):
    """Fetch the missing objects required for a set of revisions.

    :param determine_wants: Function that takes a dictionary with heads
        and returns the list of heads to fetch.
    :param graph_walker: Object that can iterate over the list of revisions
        to fetch and has an "ack" method that will be called to acknowledge
        that a revision is present.
    :param progress: Simple progress function that will be called with
        updated progress strings.
    :param get_tagged: Function that returns a dict of pointed-to sha ->
        tag sha for including tags.
    :return: iterator over objects, with __len__ implemented
    """
    wants = determine_wants(self.get_refs())
    <<[[BaseRepo.fetch_objects()]] sanity check wants>>

    <<[[BaseRepo.fetch_objects()]] set shallows and unshallows>>

    <<[[BaseRepo.fetch_objects()]] if wants nothing>>

    # If the graph walker is set up with an implementation that can
    # ACK/NAK to the wire, it will write data to the client through
    # this call as a side-effect.
    haves = self.object_store.find_common_revisions(graph_walker)

    <<[[BaseRepo.fetch_objects()]] deal with shallow requests>>

    def get_parents(commit):
        <<[[BaseRepo.fetch_objects.get_parents()]] no parents if shallows>>
        return self.get_parents(commit.id, commit)

    return self.object_store.iter_shas(
      self.object_store.find_missing_objects(
          haves, wants, progress,
          get_tagged,
          get_parents=get_parents))
@
%python: iterate so add_objects can add one by one the elt, no need
% to store huge list of objects in memory.

% [[haves]] are just the top commits starting from heads in dst repo
% that the src repo has (should really be called top_commons_commits).
% Because of ack(), the graph walker does not go through the whole
% history.
% If src repo has strictly more stuff than dst, then
% [[haves]] will be the dst heads, the "frontline".




<<[[BaseRepo.fetch_objects()]] sanity check wants>>=
if not isinstance(wants, list):
    raise TypeError("determine_wants() did not return a list")
@
%ocaml: types!

% BaseRepo.fetch_objects.get_parents -> <>
<<[[BaseRepo]] methods>>=
def get_parents(self, sha, commit=None):
    """Retrieve the parents of a specific commit.

    If the specific commit is a graftpoint, the graft parents
    will be returned instead.

    :param sha: SHA of the commit for which to retrieve the parents
    :param commit: Optional commit matching the sha
    :return: List of parents
    """

    <<[[BaseRepo.get_parents()]] look if graftpoint>>
        #// else
        if commit is None:
            commit = self[sha]
        return commit.parents
@
% why this extra commit parameter? sha enough no? or it's to avoid
% reading again from disk?

\subsubsection{Find top common commits}

<<[[BaseObjectStore]] methods>>=
def find_common_revisions(self, graphwalker):
    """Find which revisions this store has in common using graphwalker.

    :param graphwalker: A graphwalker object.
    :return: List of SHAs that are in common
    """
    haves = []
    sha = next(graphwalker)
    while sha:
        if sha in self:
            haves.append(sha)
            graphwalker.ack(sha)
        sha = next(graphwalker)
    return haves
@

% ack() will tell graph walker that there is no need to explore
% the parents of sha. So this will not iterate over the whole graph,
% just enough to find the commot frontline.

% see graphwalker in next section

\subsubsection{Determine the references wanted}

<<[[GitClient.fetch()]] set determine_wants>>=
if determine_wants is None:
    determine_wants = target.object_store.determine_wants_all
@
<<[[BaseRepo.fetch()]] set determine_wants>>=
if determine_wants is None:
    determine_wants = target.object_store.determine_wants_all
@

<<[[BaseObjectStore]] methods>>=
def determine_wants_all(self, refs):
    return [sha for (ref, sha) in refs.items()
            if sha not in self and not ref.endswith(b"^{}") and
            not sha == ZERO_SHA]
@
\l what are refs ending with {}?

<<constant objects.ZERO_SHA>>=
ZERO_SHA = b'0' * 40
@
\l when have this???

% will see some refinements later where can ask only HEAD.


\subsubsection{Find missing objects}

% haves below are set of top commits.
% wants are also set of (starting) commits (comes from refs)

<<[[BaseObjectStore]] methods>>=
def find_missing_objects(self, haves, wants, progress=None,
                         get_tagged=None,
                         get_parents=lambda commit: commit.parents):
    """Find the missing objects required for a set of revisions.

    :param haves: Iterable over SHAs already in common.
    :param wants: Iterable over SHAs of objects to fetch.
    :param progress: Simple progress function that will be called with
        updated progress strings.
    :param get_tagged: Function that returns a dict of pointed-to sha ->
        tag sha for including tags.
    :param get_parents: Optional function for getting the parents of a
        commit.
    :return: Iterator over (sha, path) pairs.
    """
    finder = MissingObjectFinder(self, haves, wants, progress, get_tagged,
                                 get_parents=get_parents)
    return iter(finder.next, None)
@
%ocaml: useless intermediate

%\subsubsection{[[MissingObjectFinder]]}

% there is also a GreenThreadsMissingObjectFinder in Extra

<<class MissingObjectFinder>>=
class MissingObjectFinder(object):
    """Find the objects missing from another object store.

    :param object_store: Object store containing at least all objects to be
        sent
    :param haves: SHA1s of commits not to send (already present in target)
    :param wants: SHA1s of commits to send
    :param progress: Optional function to report progress to.
    :param get_tagged: Function that returns a dict of pointed-to sha -> tag
        sha for including tags.
    :param get_parents: Optional function for getting the parents of a commit.
    :param tagged: dict of pointed-to sha -> tag sha for including tags
    """
    <<[[MissingObjectFinder]] methods>>
@

<<[[MissingObjectFinder]] methods>>=
def __init__(self, object_store, haves, wants, progress=None,
             get_tagged=None, get_parents=lambda commit: commit.parents):
    self.object_store = object_store
    self._get_parents = get_parents

    # process Commits and Tags differently
    # Note, while haves may list commits/tags not available locally,
    # and such SHAs would get filtered out by _split_commits_and_tags,
    # wants shall list only known SHAs, and otherwise
    # _split_commits_and_tags fails with KeyError
    have_commits, have_tags, have_others = (
        _split_commits_and_tags(object_store, haves, True))
    want_commits, want_tags, want_others = (
        _split_commits_and_tags(object_store, wants, False))

    # all_ancestors is a set of commits that shall not be sent
    # (complete repository up to 'haves')
    all_ancestors = object_store._collect_ancestors(
        have_commits, get_parents=self._get_parents)[0]

    # all_missing - complete set of commits between haves and wants
    # common - commits from all_ancestors we hit into while
    # traversing parent hierarchy of wants
    missing_commits, common_commits = object_store._collect_ancestors(
        want_commits, all_ancestors, get_parents=self._get_parents)

    self.sha_done = set()
    # Now, fill sha_done with commits and revisions of
    # files and directories known to be both locally
    # and on target. Thus these commits and files
    # won't get selected for fetch
    for h in common_commits:
        self.sha_done.add(h)
        cmt = object_store[h]
        _collect_filetree_revs(object_store, cmt.tree, self.sha_done)
    <<[[MissingObjectFinder.__init__()]] record have tags>>

    <<[[MissingObjectFinder.__init__()]] set wants as missing commits and more>>

    self.objects_to_send = set([(w, None, False) for w in wants])

    <<[[MissingObjectFinder.__init__()]] set progress>>
    <<[[MissingObjectFinder.__init__()]] set _tagged>>
@
\t why need ancestors of haves? they are already set of commits
% in common and so they must have all the parents too.
\l not slow to each time you fetch read and compute all
\l  the shas of all the past commits?

% put objects_to_send in triple. First is sha, second is useless?
% and third is whether this is a leaf. This is important to avoid
% reading blob objects.


<<[[MissingObjectFinder.__init__()]] set wants as missing commits and more>>=
missing_tags = want_tags.difference(have_tags)
missing_others = want_others.difference(have_others)
# in fact, what we 'want' is commits, tags, and others
# we've found missing
wants = missing_commits.union(missing_tags)
wants = wants.union(missing_others)
@
\l what is missing_others?

<<[[MissingObjectFinder.__init__()]] set progress>>=
if progress is None:
    self.progress = lambda x: None
else:
    self.progress = progress
@


<<[[MissingObjectFinder]] methods>>=
def next(self):
    while True:
        if not self.objects_to_send:
            return None
        (sha, name, leaf) = self.objects_to_send.pop()
        if sha not in self.sha_done:
            break
    <<[[MissingObjectFinder.next()]] if not leaf>>
    <<[[MissingObjectFinder.next()]] if sha tagged>>
    self.sha_done.add(sha)
    <<[[MissingObjectFinder.next()]] report progress>>
    return (sha, name)

@
<<[[MissingObjectFinder]] methods>>=
__next__ = next
@
%ocaml: just List.iter, no need go through iteration thing
\l why return name?

% if blob then no need to recurse, but if a dir or commit
% then need to read object to extra more entries.
<<[[MissingObjectFinder.next()]] if not leaf>>=
if not leaf:
    o = self.object_store[sha]
    if isinstance(o, Commit):
        self.add_todo([(o.tree, "", False)])
    elif isinstance(o, Tree):
        self.add_todo([(s, n, not stat.S_ISDIR(m))
                       for n, m, s in o.iteritems()
                       if not S_ISGITLINK(m)])
    elif isinstance(o, Tag):
        self.add_todo([(o.object[1], None, False)])
@
% 

<<[[MissingObjectFinder]] methods>>=
def add_todo(self, entries):
    self.objects_to_send.update([e for e in entries
                                 if not e[0] in self.sha_done])
@
\l again why need that when you already collect_filetree_rev??


<<[[MissingObjectFinder.next()]] if sha tagged>>=
if sha in self._tagged:
    self.add_todo([(self._tagged[sha], None, True)])
@



<<[[MissingObjectFinder.next()]] report progress>>=
self.progress(("counting objects: %d\r" %
               len(self.sha_done)).encode('ascii'))
@



<<[[BaseObjectStore]] methods>>=
def _collect_ancestors(self, heads, common=set(),
                       get_parents=lambda commit: commit.parents):
    """Collect all ancestors of heads up to (excluding) those in common.

    :param heads: commits to start from
    :param common: commits to end at, or empty set to walk repository
        completely
    :param get_parents: Optional function for getting the parents of a
        commit.
    :return: a tuple (A, B) where A - all commits reachable
        from heads but not present in common, B - common (shared) elements
        that are directly reachable from heads
    """
    bases = set()
    commits = set()
    queue = []
    queue.extend(heads)
    while queue:
        e = queue.pop(0)
        if e in common:
            bases.add(e)
        elif e not in commits:
            commits.add(e)
            cmt = self[e]
            queue.extend(get_parents(cmt))
    return (commits, bases)
@

<<function object_store._collect_filetree_revs>>=
def _collect_filetree_revs(obj_store, tree_sha, kset):
    """Collect SHA1s of files and directories for specified tree.

    :param obj_store: Object store to get objects by SHA from
    :param tree_sha: tree reference to walk
    :param kset: set to fill with references to files and directories
    """
    filetree = obj_store[tree_sha]
    for name, mode, sha in filetree.iteritems():
        if not S_ISGITLINK(mode) and sha not in kset:
            kset.add(sha)
            if stat.S_ISDIR(mode):
                _collect_filetree_revs(obj_store, sha, kset)
@
% so why then need add_todo() again in MissingObjectFinder.next?


\subsubsection{Iterating over objects}

<<[[BaseObjectStore]] methods>>=
def iter_shas(self, shas):
    """Iterate over the objects for the specified shas.

    :param shas: Iterable object with SHAs
    :return: Object iterator
    """
    return ObjectStoreIterator(self, shas)
@

%\subsubsection{[[ObjectStoreIterator]]}

<<class ObjectStoreIterator>>=
class ObjectStoreIterator(ObjectIterator):
    """ObjectIterator that works on top of an ObjectStore."""

    def __init__(self, store, sha_iter):
        """Create a new ObjectIterator.

        :param store: Object store to retrieve from
        :param sha_iter: Iterator over (sha, path) tuples
        """
        self.store = store
        self.sha_iter = sha_iter
        self._shas = []

    def __iter__(self):
        """Yield tuple with next object and path."""
        for sha, path in self.itershas():
            yield self.store[sha], path

    def iterobjects(self):
        """Iterate over just the objects."""
        for o, path in self:
            yield o

    def itershas(self):
        """Iterate over the SHAs."""
        for sha in self._shas:
            yield sha
        for sha in self.sha_iter:
            self._shas.append(sha)
            yield sha

    def __contains__(self, needle):
        """Check if an object is present.

        :note: This checks if the object is present in
            the underlying object store, not if it would
            be yielded by the iterator.

        :param needle: SHA1 of the object to check for
        """
        return needle in self.store

    def __getitem__(self, key):
        """Find an object by SHA1.

        :note: This retrieves the object from the underlying
            object store. It will also succeed if the object would
            not be returned by the iterator.
        """
        return self.store[key]

    def __len__(self):
        """Return the number of objects."""
        return len(list(self.itershas()))
@

<<class ObjectIterator>>=
class ObjectIterator(object):
    """Interface for iterating over objects."""

    def iterobjects(self):
        raise NotImplementedError(self.iterobjects)
@


\subsubsection{Adding Objects}

<<[[BaseObjectStore]] methods>>=
def add_objects(self, objects):
    """Add a set of objects to this object store.

    :param objects: Iterable over a list of (object, path) tuples
    """
    raise NotImplementedError(self.add_objects)
@
% implemented for PackObjects, but could be implemented also in
% DiskObjectStore

\subsubsection{Shallow requests}
% advanced topic? related to graft? related to git clone --depth?

<<[[BaseRepo.fetch_objects()]] she shallows and unshallows>>=
shallows = getattr(graph_walker, 'shallow', frozenset())
unshallows = getattr(graph_walker, 'unshallow', frozenset())
@
<<[[BaseRepo.fetch_objects()]] deal with shallow requests>>=
# Deal with shallow requests separately because the haves do
# not reflect what objects are missing
if shallows or unshallows:
    # TODO: filter the haves commits from iter_shas. the specific
    # commits aren't missing.
    haves = []
@

<<[[BaseRepo.fetch_objects.get_parents()]] no parents if shallows>>=
if commit.id in shallows:
    return []
@

<<[[BaseRepo.fetch_objects()]] if wants nothing>>=
if wants == []:
    # TODO(dborowitz): find a way to short-circuit that doesn't change
    # this interface.

    if shallows or unshallows:
        # Do not send a pack in shallow short-circuit path
        return None

    return []
@

\subsection{Fetching refs}

\subsubsection{Refspecs}


\subsubsection{Selecting the refs}

% use refspecs argument to pull but if None then set to HEAD
% so selected_refs <=> remote_refs?
<<[[porcelain.pull()]] define determine_wants>>=
selected_refs = []
def determine_wants(remote_refs):
    selected_refs.extend(
        parse_reftuples(remote_refs, r.refs, refspecs))
    return [remote_refs[lh] for (lh, rh, force) in selected_refs]
@
% lh = local hash? rh = remote hash?

<<[[porcelain.pull()]] update refs with remote refs>>=
for (lh, rh, force) in selected_refs:
    r.refs[rh] = remote_refs[lh]
if selected_refs:
    r[b'HEAD'] = remote_refs[selected_refs[0][1]]
@



\subsubsection{Parsing ref tuples}

<<function objectspec.parse_reftuples>>=
def parse_reftuples(lh_container, rh_container, refspecs):
    """Parse a list of reftuple specs to a list of reftuples.

    :param lh_container: A RefsContainer object
    :param hh_container: A RefsContainer object
    :param refspecs: A list of refspecs or a string
    :return: A list of refs
    :raise KeyError: If one of the refs can not be found
    """
    if not isinstance(refspecs, list):
        refspecs = [refspecs]
    ret = []
    # TODO: Support * in refspecs
    for refspec in refspecs:
        ret.append(parse_reftuple(lh_container, rh_container, refspec))
    return ret
@

<<function objectspec.parse_reftuple>>=
def parse_reftuple(lh_container, rh_container, refspec):
    """Parse a reftuple spec.

    :param lh_container: A RefsContainer object
    :param hh_container: A RefsContainer object
    :param refspec: A string
    :return: A tuple with left and right ref
    :raise KeyError: If one of the refs can not be found
    """
    if refspec.startswith(b"+"):
        force = True
        refspec = refspec[1:]
    else:
        force = False
    refspec = to_bytes(refspec)
    if b":" in refspec:
        (lh, rh) = refspec.split(b":")
    else:
        lh = rh = refspec
    if lh == b"":
        lh = None
    else:
        lh = parse_ref(lh_container, lh)
    if rh == b"":
        rh = None
    else:
        try:
            rh = parse_ref(rh_container, rh)
        except KeyError:
            # TODO: check force?
            if not b"/" in rh:
                rh = b"refs/heads/" + rh
    return (lh, rh, force)
@


<<function objectspec.parse_ref>>=
def parse_ref(container, refspec):
    """Parse a string referring to a reference.

    :param container: A RefsContainer object
    :param refspec: A string referring to a ref
    :return: A ref
    :raise KeyError: If the ref can not be found
    """
    refspec = to_bytes(refspec)
    possible_refs = [
        refspec,
        b"refs/" + refspec,
        b"refs/tags/" + refspec,
        b"refs/heads/" + refspec,
        b"refs/remotes/" + refspec,
        b"refs/remotes/" + refspec + b"/HEAD"
    ]
    for ref in possible_refs:
        if ref in container:
            return ref
    else:
        raise KeyError(refspec)
@

\subsection{Fetching objects in a pack}

% dead I think.

<<[[LocalGitClient]] methods>>=
def fetch_pack(self, path, determine_wants, graph_walker, pack_data,
               progress=None):
    """Retrieve a pack from a git smart server.

    :param path: Remote path to fetch from
    :param determine_wants: Function determine what refs
        to fetch. Receives dictionary of name->sha, should return
        list of shas to fetch.
    :param graph_walker: Object with next() and ack().
    :param pack_data: Callback called for each bit of data in the pack
    :param progress: Callback for progress reports (strings)
    :return: Dictionary with all remote refs (not just those fetched)
    """
    with self._open_repo(path) as r:
        objects_iter = r.fetch_objects(
            determine_wants, graph_walker, progress)

        # Did the process short-circuit (e.g. in a stateless RPC call)?
        # Note that the client still expects a 0-object pack in most cases.
        if objects_iter is None:
            return
        write_pack_objects(ProtocolFile(None, pack_data), objects_iter)
        return r.get_refs()
@
%dead? LocalGitClient overrides GitClient.fetch so never called from there

<<class ProtocolFile>>=
class ProtocolFile(object):
    """A dummy file for network ops that expect file-like objects."""

    def __init__(self, read, write):
        self.read = read
        self.write = write

    def tell(self):
        pass

    def close(self):
        pass
@



\section{Object store walker}

% used to explore target graph, not source graph.
% To know which (top) commits have in common with source.

\subsection{[[get_graph_walker()]]}

% GitClient.fetch | BaseRepo.fetch -> <>
<<[[BaseRepo]] methods>>=
def get_graph_walker(self, heads=None):
    """Retrieve a graph walker.

    A graph walker is used by a remote repository (or proxy)
    to find out which objects are present in this repository.

    :param heads: Repository heads to use (optional)
    :return: A graph walker object
    """
    if heads is None:
        heads = self.refs.as_dict(b'refs/heads').values()
    return ObjectStoreGraphWalker(heads, self.get_parents)
@
% start from all heads

<<[[RefsContainer]] methods>>=
def as_dict(self, base=None):
    """Return the contents of this container as a dictionary.

    """
    ret = {}
    keys = self.keys(base)
    if base is None:
        base = b''
    else:
        base = base.rstrip(b'/')
    for key in keys:
        try:
            ret[key] = self[(base + b'/' + key).strip(b'/')]
        except KeyError:
            continue  # Unable to resolve

    return ret
@
% self[xxx] so extract sha of head ref

\subsection{[[ObjectStoreGraphWalker]]}

<<class ObjectStoreGraphWalker>>=
class ObjectStoreGraphWalker(object):
    """Graph walker that finds what commits are missing from an object store.

    :ivar heads: Revisions without descendants in the local repo
    :ivar get_parents: Function to retrieve parents in the local repo
    """
    <<[[ObjectStoreGraphWalker]] methods>>
@
%ocaml: simple walk_graph function instead of class

<<[[ObjectStoreGraphWalker]] methods>>=
def __init__(self, local_heads, get_parents):
    """Create a new instance.

    :param local_heads: Heads to start search with
    :param get_parents: Function for finding the parents of a SHA1.
    """
    self.heads = set(local_heads)
    self.get_parents = get_parents
    self.parents = {}
@
% parents hash? just a hdone hashtbl? no because used also in ack()
%  and reset for the parents of the ack'ed commits

<<[[ObjectStoreGraphWalker]] methods>>=
def next(self):
    """Iterate over ancestors of heads in the target."""
    if self.heads:
        ret = self.heads.pop()
        ps = self.get_parents(ret)
        self.parents[ret] = ps
        self.heads.update(
            [p for p in ps if p not in self.parents])
        return ret
    return None
@
<<[[ObjectStoreGraphWalker]] methods>>=
__next__ = next
@
%ocaml: iter function passed instead of yield and next machinery

% Why record also parents of commit? because if later ack this
% commit, then we need to filter its parents from the todos.



% BaseObjectStore.find_common_revisions -> <>
<<[[ObjectStoreGraphWalker]] methods>>=
def ack(self, sha):
    """Ack that a revision and its ancestors are present in the source."""
    <<[[ObjectStoreGraphWalker.ack()]] sanity check sha>>
    ancestors = set([sha])

    # stop if we run out of heads to remove
    while self.heads:
        for a in ancestors:
            if a in self.heads:
                self.heads.remove(a)

        # collect all ancestors
        new_ancestors = set()
        for a in ancestors:
            ps = self.parents.get(a)
            if ps is not None:
                new_ancestors.update(ps)
            self.parents[a] = None

        # no more ancestors; stop
        if not new_ancestors:
            break

        ancestors = new_ancestors
@
% subtle ... 
% but how can get ancestors in heads?

<<[[ObjectStoreGraphWalker.ack()]] sanity check sha>>=
if len(sha) != 40:
    raise ValueError("unexpected sha %r received" % sha)
@


\section{[[git push]]}

% Not really needed. The other guy can just pull from yours.
% In fact restrictions about pushing where can only push
% to a bare repository (unless --force?)

<<function porcelain.push>>=
def push(repo, remote_location, refspecs,
         outstream=default_bytes_out_stream,
         errstream=default_bytes_err_stream):
    """Remote push with dulwich via dulwich.client

    :param repo: Path to repository
    :param remote_location: Location of the remote
    :param refspecs: Refs to push to remote
    :param outstream: A stream file to write output
    :param errstream: A stream file to write errors
    """

    # Open the repo
    with open_repo_closing(repo) as r:

        # Get the client and path
        client, path = get_transport_and_path(remote_location)

        selected_refs = []

        def update_refs(refs):
            selected_refs.extend(parse_reftuples(r.refs, refs, refspecs))
            new_refs = {}
            # TODO: Handle selected_refs == {None: None}
            for (lh, rh, force) in selected_refs:
                if lh is None:
                    new_refs[rh] = ZERO_SHA
                else:
                    new_refs[rh] = r.refs[lh]
            return new_refs

        err_encoding = getattr(errstream, 'encoding', None) or DEFAULT_ENCODING
        remote_location_bytes = client.get_url(path).encode(err_encoding)
        try:
            client.send_pack(
                path, update_refs, r.object_store.generate_pack_contents,
                progress=errstream.write)
            errstream.write(
                b"Push to " + remote_location_bytes + b" successful.\n")
        except (UpdateRefsError, SendPackError) as e:
            errstream.write(b"Push to " + remote_location_bytes +
                            b" failed -> " + e.message.encode(err_encoding) +
                            b"\n")
@



% porcelain.push -> <>
<<[[GitClient]] methods>>=
def get_url(self, path):
    """Retrieves full url to given path.

    :param path: Repository path (as string)
    :return: Url to path (as string)
    """
    raise NotImplementedError(self.get_url)
@
%ocaml: redundant with path

% just for pretty printing, just call from push

<<[[LocalGitClient]] methods>>=
def get_url(self, path):
    return urlparse.urlunsplit(('file', '', path, '', ''))
@

\subsection{Sending objects (in a pack)}


<<[[LocalGitClient]] methods>>=
def send_pack(self, path, update_refs, generate_pack_contents,
              progress=None, write_pack=write_pack_objects):
    """Upload a pack to a remote repository.

    :param path: Repository path (as bytestring)
    :param update_refs: Function to determine changes to remote refs.
        Receive dict with existing remote refs, returns dict with
        changed refs (name -> sha, where sha=ZERO_SHA for deletions)
    :param generate_pack_contents: Function that can return a sequence of
        the shas of the objects to upload.
    :param progress: Optional progress function
    :param write_pack: Function called with (file, iterable of objects) to
        write the objects returned by generate_pack_contents to the server.

    :raises SendPackError: if server rejects the pack data
    :raises UpdateRefsError: if the server supports report-status
                             and rejects ref updates
    :return: new_refs dictionary containing the changes that were made
        {refname: new_ref}, including deleted refs.
    """
    if not progress:
        def progress(x):
            pass

    with self._open_repo(path) as target:
        old_refs = target.get_refs()
        new_refs = update_refs(dict(old_refs))

        have = [sha1 for sha1 in old_refs.values() if sha1 != ZERO_SHA]
        want = []
        for refname, new_sha1 in new_refs.items():
            if (new_sha1 not in have and
                    new_sha1 not in want and
                    new_sha1 != ZERO_SHA):
                want.append(new_sha1)

        if (not want and
                set(new_refs.items()).issubset(set(old_refs.items()))):
            return new_refs

        target.object_store.add_objects(generate_pack_contents(have, want))

        for refname, new_sha1 in new_refs.items():
            old_sha1 = old_refs.get(refname, ZERO_SHA)
            if new_sha1 != ZERO_SHA:
                if not target.refs.set_if_equals(
                        refname, old_sha1, new_sha1):
                    progress('unable to set %s to %s' %
                             (refname, new_sha1))
            else:
                if not target.refs.remove_if_equals(refname, old_sha1):
                    progress('unable to remove %s' % refname)

    return new_refs
@


\section{Cloning a repository, [[git clone]]}

% In end, quite similar to git pull, just pulling everything.

<<function cmd_clone>>=
class cmd_clone(Command):

    def run(self, args):
        opts, args = getopt(args, "", ["bare"])
        opts = dict(opts)

        if args == []:
            print("usage: dulwich clone host:path [PATH]")
            sys.exit(1)

        source = args.pop(0)
        if len(args) > 0:
            target = args.pop(0)
        else:
            target = None

        porcelain.clone(source, target, bare=("--bare" in opts))
@

<<function porcelain.clone>>=
def clone(source, target=None, bare=False, checkout=None,
          errstream=default_bytes_err_stream,
          origin=b"origin"):
    """Clone a local or remote git repository.

    :param source: Path or URL for source repository
    :param target: Path to target repository (optional)
    :param bare: Whether or not to create a bare repository
    :param checkout: Whether or not to check-out HEAD after cloning
    :param errstream: Optional stream to write progress to
    :return: The new repository
    """

    <<[[porcelain.clone()]] sanity checks>>
    client, host_path = get_transport_and_path(source)

    if target is None:
        target = host_path.split("/")[-1]

    if not os.path.exists(target):
        os.mkdir(target)

    <<[[porcelain.clone()]] if bare>>
    else:
        r = Repo.init(target)

    try:
        <<[[porcelain.clone()]] fetch objects>>

        <<[[porcelain.clone()]] import remote refs>>
        <<[[porcelain.clone()]] import remote tags>>
        <<[[porcelain.clone()]] import remote HEAD>>
        <<[[porcelain.clone()]] import config file>>

        if checkout and b"HEAD" in r.refs:
            errstream.write(b'Checking out HEAD\n')
            r.reset_index()
    except:
        r.close()
        raise

    return r
@

<<[[porcelain.clone()]] sanity checks>>=
if checkout is None:
    checkout = (not bare)
if checkout and bare:
    raise ValueError("checkout and bare are incompatible")
@

%deprecated:
% outstream=None,
%     :param outstream: Optional stream to write progress to (deprecated)
%     if outstream is not None:
%         import warnings
%         warnings.warn(
%             "outstream= has been deprecated in favour of errstream=.",
%             DeprecationWarning, stacklevel=3)
%         errstream = outstream



\subsection{Fetching objects}

<<[[porcelain.clone()]] fetch objects>>=
remote_refs = client.fetch(
    host_path, r, determine_wants=r.object_store.determine_wants_all,
    progress=errstream.write)
@

% determine_wants is about the refs, not the objects.

\subsection{Importing refs}

<<[[porcelain.clone()]] import remote refs>>=
r.refs.import_refs(
    b'refs/remotes/' + origin,
    {n[len(b'refs/heads/'):]: v for (n, v) in remote_refs.items()
        if n.startswith(b'refs/heads/')})
@

<<[[porcelain.clone()]] import remote HEAD>>=
if b"HEAD" in remote_refs and not bare:
    # TODO(jelmer): Support symref capability,
    # https://github.com/jelmer/dulwich/issues/485
    r[b"HEAD"] = remote_refs[b"HEAD"]
@

<<[[RefsContainer]] methods>>=
def import_refs(self, base, other):
    for name, value in other.items():
        self[b'/'.join((base, name))] = value
@


\section{Packs}



\chapter{Networking}


<<[[get_transport_and_path()]] try parse location as a URL>>=
# First, try to parse it as a URL
try:
    return get_transport_and_path_from_url(location, **kwargs)
except ValueError:
    pass
<<[[get_transport_and_path()]] try parse location as a ssh URL>>
@

% dispatcher
<<function get_transport_and_path_from_url>>=
def get_transport_and_path_from_url(url, config=None, **kwargs):
    """Obtain a git client from a URL.

    :param url: URL to open (a unicode string)
    :param config: Optional config object
    :param thin_packs: Whether or not thin packs should be retrieved
    :param report_activity: Optional callback for reporting transport
        activity.
    :return: Tuple with client instance and relative path.
    """
    parsed = urlparse.urlparse(url)

    if parsed.scheme == 'git':
        return (TCPGitClient.from_parsedurl(parsed, **kwargs),
                parsed.path)
    <<[[get_transport_and_path_from_url()]] elif ssh>>
    <<[[get_transport_and_path_from_url()]] elif http>>
    <<[[get_transport_and_path_from_url()]] elif file>>

    raise ValueError("unknown scheme '%s'" % parsed.scheme)
@


<<[[GitClient]] methods>>=
@classmethod
def from_parsedurl(cls, parsedurl, **kwargs):
    """Create an instance of this client from a urlparse.parsed object.

    :param parsedurl: Result of urlparse.urlparse()
    :return: A `GitClient` object
    """
    raise NotImplementedError(cls.from_parsedurl)
@

% for file:// we have seen before actually, default to simple /path

<<[[get_transport_and_path_from_url()]] elif file>>=
elif parsed.scheme == 'file':
    return default_local_git_client_cls.from_parsedurl(
        parsed, **kwargs), parsed.path
@

% (pull|...) -> get_transport_and_path -> get_transport_and_path_from_url -> <>
<<[[LocalGitClient]] methods>>=
@classmethod
def from_parsedurl(cls, parsedurl, **kwargs):
    return cls(**kwargs)
@
% but rare to git pull file://path, usually just do git pull /path
%  so does not go through from_parsedurl


\section{[[git://]] protocol}

<<constant protocol.TCP_GIT_PORT>>=
TCP_GIT_PORT = 9418
@

% pkt line. Show example of session

<<class Protocol>>
class Protocol(object):
    """Class for interacting with a remote git process over the wire.

    Parts of the git wire protocol use 'pkt-lines' to communicate. A pkt-line
    consists of the length of the line as a 4-byte hex string, followed by the
    payload data. The length includes the 4-byte header. The special line '0000'
    indicates the end of a section of input and is called a 'flush-pkt'.

    For details on the pkt-line format, see the cgit distribution:
        Documentation/technical/protocol-common.txt
    """

    <<[[Protocol]] methods>>
@


% TCPGitClient._connect -> <>
<<[[Protocol]] methods>>=
def __init__(self, read, write, close=None, report_activity=None):
    self.read = read
    self.write = write
    self._close = close
    self._readahead = None
    <<[[Protocol.__init__()]] set fields>>
@

<<[[Protocol]] methods>>=
def close(self):
    if self._close:
        self._close()
@
<<[[Protocol]] methods>>=
def __enter__(self):
    return self
@
<<[[Protocol]] methods>>=
def __exit__(self, exc_type, exc_val, exc_tb):
    self.close()
@

\subsection{Reading}

<<[[Protocol]] methods>>=
def read_cmd(self):
    """Read a command and some arguments from the git client

    Only used for the TCP git protocol (git://).

    :return: A tuple of (command, [list of arguments]).
    """
    line = self.read_pkt_line()
    splice_at = line.find(b" ")
    cmd, args = line[:splice_at], line[splice_at+1:]
    assert args[-1:] == b"\x00"
    return cmd, args[:-1].split(b"\0")
@


<<[[Protocol]] methods>>=
def read_pkt_line(self):
    """Reads a pkt-line from the remote git process.

    This method may read from the readahead buffer; see unread_pkt_line.

    :return: The next string from the stream, without the length prefix, or
        None for a flush-pkt ('0000').
    """
    if self._readahead is None:
        read = self.read
    else:
        read = self._readahead.read
        self._readahead = None

    try:
        sizestr = read(4)
        if not sizestr:
            raise HangupException()
        size = int(sizestr, 16)
        if size == 0:
            <<[[Protocol.read_pkt_line()]] when size 0, if report activity>>
            return None
        <<[[Protocol.read_pkt_line()]] when size not 0, if report activity>>
        pkt_contents = read(size-4)
    except socket.error as e:
        raise GitProtocolError(e)
    else:
        if len(pkt_contents) + 4 != size:
            raise GitProtocolError(
                'Length of pkt read %04x does not match length prefix %04x' % (len(pkt_contents) + 4, size))
        return pkt_contents

@

<<[[Protocol]] methods>>=
def eof(self):
    """Test whether the protocol stream has reached EOF.

    Note that this refers to the actual stream EOF and not just a flush-pkt.

    :return: True if the stream is at EOF, False otherwise.
    """
    try:
        next_line = self.read_pkt_line()
    except HangupException:
        return True
    self.unread_pkt_line(next_line)
    return False
@

<<[[Protocol]] methods>>=
def unread_pkt_line(self, data):
    """Unread a single line of data into the readahead buffer.

    This method can be used to unread a single pkt-line into a fixed
    readahead buffer.

    :param data: The data to unread, without the length prefix.
    :raise ValueError: If more than one pkt-line is unread.
    """
    if self._readahead is not None:
        raise ValueError('Attempted to unread multiple pkt-lines.')
    self._readahead = BytesIO(pkt_line(data))
@
<<function pkt_line>>=
def pkt_line(data):
    """Wrap data in a pkt-line.

    :param data: The data to wrap, as a str or None.
    :return: The data prefixed with its length in pkt-line format; if data was
        None, returns the flush-pkt ('0000').
    """
    if data is None:
        return b'0000'
    return ('%04x' % (len(data) + 4)).encode('ascii') + data
@


<<[[Protocol]] methods>>=
def read_pkt_seq(self):
    """Read a sequence of pkt-lines from the remote git process.

    :return: Yields each line of data up to but not including the next flush-pkt.
    """
    pkt = self.read_pkt_line()
    while pkt:
        yield pkt
        pkt = self.read_pkt_line()
@


\subsection{Writing}

<<[[Protocol]] methods>>=
def send_cmd(self, cmd, *args):
    """Send a command and some arguments to a git server.

    Only used for the TCP git protocol (git://).

    :param cmd: The remote service to access.
    :param args: List of arguments to send to remove service.
    """
    self.write_pkt_line(cmd + b" " + b"".join([(a + b"\0") for a in args]))
@

<<[[Protocol]] methods>>=
def write_pkt_line(self, line):
    """Sends a pkt-line to the remote git process.

    :param line: A string containing the data to send, without the length
        prefix.
    """
    try:
        line = pkt_line(line)
        self.write(line)
        <<[[Protocol.write_pkt_line()]] if report activity>>
    except socket.error as e:
        raise GitProtocolError(e)
@

<<[[Protocol]] methods>>=
def write_file(self):
    """Return a writable file-like object for this protocol."""

    class ProtocolFile(object):

        def __init__(self, proto):
            self._proto = proto
            self._offset = 0

        def write(self, data):
            self._proto.write(data)
            self._offset += len(data)

        def tell(self):
            return self._offset

        def close(self):
            pass

    return ProtocolFile(self)
@



\section{Capabilities}
\l adv topics? or hard to avoid because first _connect return
\l  refs and capabilities

<<[[GitClient.__init__()]] set capabilities>>=
self._fetch_capabilities = set(FETCH_CAPABILITIES)
self._fetch_capabilities.add(capability_agent())
self._send_capabilities = set(SEND_CAPABILITIES)
self._send_capabilities.add(capability_agent())
@

<<constant client.FETCH_CAPABILITIES>>=
FETCH_CAPABILITIES = ([CAPABILITY_THIN_PACK, 
                       CAPABILITY_MULTI_ACK,
                       CAPABILITY_MULTI_ACK_DETAILED] +
                      COMMON_CAPABILITIES)
@
% see Adv topics.

<<constant client.COMMON_CAPABILITIES>>=
COMMON_CAPABILITIES = [CAPABILITY_OFS_DELTA, CAPABILITY_SIDE_BAND_64K]
@

<<constant client.SEND_CAPABILITIES>>=
SEND_CAPABILITIES = [CAPABILITY_REPORT_STATUS] + COMMON_CAPABILITIES
@


<<function protocol.capability_agent>>=
def capability_agent():
    return CAPABILITY_AGENT + b'=' + agent_string()
@
<<function protocol.agent_string>>=
def agent_string():
    return ('dulwich/%d.%d.%d' % dulwich.__version__).encode('ascii')
@
<<constant protocol.CAPABILITY_AGENT>>=
CAPABILITY_AGENT = b'agent'
@



\section{Client}

\subsection{[[TraditionalGitClient}

<<class TraditionalGitClient>>=
class TraditionalGitClient(GitClient):
    """Traditional Git client."""

    <<[[TraditionalGitClient]] constants>>

    <<[[TraditionalGitClient]] methods>>
@


<<[[TraditionalGitClient]] methods>>=
def __init__(self, path_encoding=DEFAULT_ENCODING, **kwargs):
    <<[[TraditionalGitClient.__init__]] set fields>>
    super(TraditionalGitClient, self).__init__(**kwargs)
@
% super so GitClient which just uses report_activity

% ?? -> <>
<<[[TraditionalGitClient]] methods>>=
def _connect(self, cmd, path):
    """Create a connection to the server.

    This method is abstract - concrete implementations should
    implement their own variant which connects to the server and
    returns an initialized Protocol object with the service ready
    for use and a can_read function which may be used to see if
    reads would block.

    :param cmd: The git service name to which we should connect.
    :param path: The path we should pass to the service. (as bytestirng)
    """
    raise NotImplementedError()
@

\subsection{[[git://]] [[TCPGitClient]]}

<<class TCPGitClient>>=
class TCPGitClient(TraditionalGitClient):
    """A Git Client that works over TCP directly (i.e. git://)."""

    <<[[TCPGitClient]] methods>>
@


<<[[TCPGitClient]] methods>>=
@classmethod
def from_parsedurl(cls, parsedurl, **kwargs):
    return cls(parsedurl.hostname, port=parsedurl.port, **kwargs)
@


<<[[TCPGitClient]] methods>>=
def __init__(self, host, port=None, **kwargs):
    if port is None:
        port = TCP_GIT_PORT
    self._host = host
    self._port = port
    super(TCPGitClient, self).__init__(**kwargs)
@



<<[[TCPGitClient]] methods>>=
def get_url(self, path):
    netloc = self._host
    if self._port is not None and self._port != TCP_GIT_PORT:
        netloc += ":%d" % self._port
    return urlparse.urlunsplit(("git", netloc, path, '', ''))
@
% just for push

% ?? -> <>
<<[[TCPGitClient]] methods>>=
def _connect(self, cmd, path):
    <<[[TCPGitClient._connect()]] sanity check arguments>>
    <<[[TCPGitClient._connect()]] adjust path if not bytes>>
    sockaddrs = socket.getaddrinfo(
        self._host, self._port, socket.AF_UNSPEC, socket.SOCK_STREAM)
    s = None
    err = socket.error("no address found for %s" % self._host)
    for (family, socktype, proto, canonname, sockaddr) in sockaddrs:
        s = socket.socket(family, socktype, proto)
        s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        try:
            s.connect(sockaddr)
            break
        except socket.error as err:
            if s is not None:
                s.close()
            s = None
    if s is None:
        raise err
    # -1 means system default buffering
    rfile = s.makefile('rb', -1)
    # 0 means unbuffered
    wfile = s.makefile('wb', 0)

    def close():
        rfile.close()
        wfile.close()
        s.close()

    proto = Protocol(rfile.read, wfile.write, close,
                     report_activity=self._report_activity)
    if path.startswith(b"/~"):
        path = path[1:]
    # TODO(jelmer): Alternative to ascii?
    proto.send_cmd(
        b'git-' + cmd, path, b'host=' + self._host.encode('ascii'))
    return proto, lambda: _fileno_can_read(s)
@

<<function client._fileno_can_read>>=
def _fileno_can_read(fileno):
    """Check if a file descriptor is readable."""
    return len(select.select([fileno], [], [], 0)[0]) > 0
@

<<[[TCPGitClient._connect()]] sanity check arguments>>=
if not isinstance(cmd, bytes):
    raise TypeError(cmd)
@
%ocaml: types!

\subsection{Fetching remote objects}

% porcelain.pull -> <> (as client <- get_transport_and_path <- porcelain.pull)
<<[[GitClient]] methods>>=
def fetch(self, path, target, determine_wants=None, progress=None):
    """Fetch into a target repository.

    :param path: Path to fetch from (as bytestring)
    :param target: Target repository to fetch into
    :param determine_wants: Optional function to determine what refs
        to fetch. Receives dictionary of name->sha, should return
        list of shas to fetch. Defaults to all shas.
    :param progress: Optional progress function
    :return: Dictionary with all remote refs (not just those fetched)
    """
    <<[[GitClient.fetch()]] set determine_wants>>
    <<[[GitClient.fetch()]] if thin pack capability>>
    else:
        f, commit, abort = target.object_store.add_pack()
    try:
        result = self.fetch_pack(
            path, determine_wants, target.get_graph_walker(), f.write,
            progress)
    except:
        abort()
        raise
    else:
        commit()
    return result
@

% so pass the target graph walker and way to write on target to
% client fetch_pack

\subsection{Fetch pack}

<<[[GitClient]] methods>>=
def fetch_pack(self, path, determine_wants, graph_walker, pack_data,
               progress=None):
    """Retrieve a pack from a git smart server.

    :param path: Remote path to fetch from
    :param determine_wants: Function determine what refs
        to fetch. Receives dictionary of name->sha, should return
        list of shas to fetch.
    :param graph_walker: Object with next() and ack().
    :param pack_data: Callback called for each bit of data in the pack
    :param progress: Callback for progress reports (strings)
    :return: Dictionary with all remote refs (not just those fetched)
    """
    raise NotImplementedError(self.fetch_pack)
@


% pack_data is target add_pack f.write()

%flow:
%  get remote refs, determine wants, tell wants, get objects and pack_data

<<[[TraditionalGitClient]] methods>>=
def fetch_pack(self, path, determine_wants, graph_walker, pack_data,
               progress=None):
    """Retrieve a pack from a git smart server.

    :param path: Remote path to fetch from
    :param determine_wants: Function determine what refs
        to fetch. Receives dictionary of name->sha, should return
        list of shas to fetch.
    :param graph_walker: Object with next() and ack().
    :param pack_data: Callback called for each bit of data in the pack
    :param progress: Callback for progress reports (strings)
    :return: Dictionary with all remote refs (not just those fetched)
    """
    proto, can_read = self._connect(b'upload-pack', path)
    with proto:
        <<[[TraditionalGitClient.fetch_pack()]] getting remote refs>>
        <<[[TraditionalGitClient.fetch_pack()]] determine wants>>
        <<[[TraditionalGitClient.fetch_pack()]] tell wants>>
        <<[[TraditionalGitClient.fetch_pack()]] get and pack objects>>
        return refs
@

% ask git-upload-pack service!


<<[[TraditionalGitClient.fetch_pack()]] determine wants>>=
try:
    wants = determine_wants(refs)
except:
    <<[[TraditionalGitClient.fetch_pack()]] raise if exn>>
if wants is not None:
    wants = [cid for cid in wants if cid != ZERO_SHA]
<<[[TraditionalGitClient.fetch_pack()]] return if no wants>>
@


<<[[TraditionalGitClient.fetch_pack()]] raise if exn>>=
proto.write_pkt_line(None)
raise
@
<<[[TraditionalGitClient.fetch_pack()]] return if no wants>>=
if not wants:
    proto.write_pkt_line(None)
    return refs
@




\subsubsection{[[read_pkt_refs()]]}

<<[[TraditionalGitClient.fetch_pack()]] getting remote refs>>=
refs, server_capabilities = read_pkt_refs(proto)
negotiated_capabilities = (
    self._fetch_capabilities & server_capabilities)

<<[[TraditionalGitClient.fetch_pack()]] return if no refs>>
@

<<[[TraditionalGitClient.fetch_pack()]] return if no refs>>=
if refs is None:
    proto.write_pkt_line(None)
    return refs
@



<<function client.read_pkt_refs>>=
def read_pkt_refs(proto):
    server_capabilities = None
    refs = {}
    # Receive refs from server
    for pkt in proto.read_pkt_seq():
        (sha, ref) = pkt.rstrip(b'\n').split(None, 1)
        if sha == b'ERR':
            raise GitProtocolError(ref)
        if server_capabilities is None:
            (ref, server_capabilities) = extract_capabilities(ref)
        refs[ref] = sha

    if len(refs) == 0:
        return None, set([])
    if refs == {CAPABILITIES_REF: ZERO_SHA}:
        refs = {}
    return refs, set(server_capabilities)
@

\subsubsection{[[_handle_upload_pack_head()]]}

<<[[TraditionalGitClient.fetch_pack()]] tell wants>>=
self._handle_upload_pack_head(
    proto, negotiated_capabilities, graph_walker, wants, can_read)
@


<<[[GitClient]] methods>>=
def _handle_upload_pack_head(self, proto, capabilities, graph_walker,
                             wants, can_read):
    """Handle the head of a 'git-upload-pack' request.

    :param proto: Protocol object to read from
    :param capabilities: List of negotiated capabilities
    :param graph_walker: GraphWalker instance to call .ack() on
    :param wants: List of commits to fetch
    :param can_read: function that returns a boolean that indicates
        whether there is extra graph data to read on proto
    """
    assert isinstance(wants, list) and isinstance(wants[0], bytes)
    proto.write_pkt_line(COMMAND_WANT + b' ' + wants[0] + b' ' +
                         b' '.join(capabilities) + b'\n')
    for want in wants[1:]:
        proto.write_pkt_line(COMMAND_WANT + b' ' + want + b'\n')
    proto.write_pkt_line(None)

    have = next(graph_walker)
    while have:
        proto.write_pkt_line(COMMAND_HAVE + b' ' + have + b'\n')
        if can_read():
            pkt = proto.read_pkt_line()
            parts = pkt.rstrip(b'\n').split(b' ')
            if parts[0] == b'ACK':
                graph_walker.ack(parts[1])
                if parts[2] in (b'continue', b'common'):
                    pass
                elif parts[2] == b'ready':
                    break
                else:
                    raise AssertionError(
                        "%s not in ('continue', 'ready', 'common)" %
                        parts[2])
        have = next(graph_walker)
    proto.write_pkt_line(COMMAND_DONE + b'\n')
@


\subsubsection{[[_handle_upload_pack_tail()]]}

<<[[TraditionalGitClient.fetch_pack()]] get and pack objects>>=
self._handle_upload_pack_tail(
    proto, negotiated_capabilities, graph_walker, pack_data,
    progress)
@


<<[[GitClient]] methods>>=
def _handle_upload_pack_tail(self, proto, capabilities, graph_walker,
                             pack_data, progress=None, rbufsize=_RBUFSIZE):
    """Handle the tail of a 'git-upload-pack' request.

    :param proto: Protocol object to read from
    :param capabilities: List of negotiated capabilities
    :param graph_walker: GraphWalker instance to call .ack() on
    :param pack_data: Function to call with pack data
    :param progress: Optional progress reporting function
    :param rbufsize: Read buffer size
    """
    pkt = proto.read_pkt_line()
    while pkt:
        parts = pkt.rstrip(b'\n').split(b' ')
        if parts[0] == b'ACK':
            graph_walker.ack(parts[1])
        if len(parts) < 3 or parts[2] not in (
                b'ready', b'continue', b'common'):
            break
        pkt = proto.read_pkt_line()
    <<[[GitClient._handle_upload_pack_tail()]] if side band capability>>
    else:
        while True:
            data = proto.read(rbufsize)
            if data == b"":
                break
            pack_data(data)
@


\subsection{Send pack}


<<[[GitClient]] methods>>=
def send_pack(self, path, update_refs, generate_pack_contents,
              progress=None, write_pack=write_pack_objects):
    """Upload a pack to a remote repository.

    :param path: Repository path (as bytestring)
    :param update_refs: Function to determine changes to remote refs.
        Receive dict with existing remote refs, returns dict with
        changed refs (name -> sha, where sha=ZERO_SHA for deletions)
    :param generate_pack_contents: Function that can return a sequence of
        the shas of the objects to upload.
    :param progress: Optional progress function
    :param write_pack: Function called with (file, iterable of objects) to
        write the objects returned by generate_pack_contents to the server.

    :raises SendPackError: if server rejects the pack data
    :raises UpdateRefsError: if the server supports report-status
                             and rejects ref updates
    :return: new_refs dictionary containing the changes that were made
        {refname: new_ref}, including deleted refs.
    """
    raise NotImplementedError(self.send_pack)
@

% ??? -> <>
<<[[TraditionalGitClient]] methods>>=
def send_pack(self, path, update_refs, generate_pack_contents,
              progress=None, write_pack=write_pack_objects):
    """Upload a pack to a remote repository.

    :param path: Repository path (as bytestring)
    :param update_refs: Function to determine changes to remote refs.
        Receive dict with existing remote refs, returns dict with
        changed refs (name -> sha, where sha=ZERO_SHA for deletions)
    :param generate_pack_contents: Function that can return a sequence of
        the shas of the objects to upload.
    :param progress: Optional callback called with progress updates
    :param write_pack: Function called with (file, iterable of objects) to
        write the objects returned by generate_pack_contents to the server.

    :raises SendPackError: if server rejects the pack data
    :raises UpdateRefsError: if the server supports report-status
                             and rejects ref updates
    :return: new_refs dictionary containing the changes that were made
        {refname: new_ref}, including deleted refs.
    """
    proto, unused_can_read = self._connect(b'receive-pack', path)
    with proto:
        old_refs, server_capabilities = read_pkt_refs(proto)
        negotiated_capabilities = (
            self._send_capabilities & server_capabilities)

        <<[[TraditionalGitClient.send_pack()]] if report_status capability>>

        try:
            new_refs = orig_new_refs = update_refs(dict(old_refs))
        except:
            proto.write_pkt_line(None)
            raise

        if CAPABILITY_DELETE_REFS not in server_capabilities:
            # Server does not support deletions. Fail later.
            new_refs = dict(orig_new_refs)
            for ref, sha in orig_new_refs.items():
                if sha == ZERO_SHA:
                    <<[[TraditionalGitClient.send_pack()]] when ZERO_SHA if report>>
                    
                    del new_refs[ref]

        if new_refs is None:
            proto.write_pkt_line(None)
            return old_refs

        if len(new_refs) == 0 and len(orig_new_refs):
            # NOOP - Original new refs filtered out by policy
            proto.write_pkt_line(None)
            <<[[TraditionalGitClient.send_pack()]] when no new refs>>
            return old_refs

        (have, want) = self._handle_receive_pack_head(
            proto, negotiated_capabilities, old_refs, new_refs)
        if (not want and
                set(new_refs.items()).issubset(set(old_refs.items()))):
            return new_refs
        objects = generate_pack_contents(have, want)

        dowrite = len(objects) > 0
        dowrite = dowrite or any(old_refs.get(ref) != sha
                                 for (ref, sha) in new_refs.items()
                                 if sha != ZERO_SHA)
        if dowrite:
            write_pack(proto.write_file(), objects)

        self._handle_receive_pack_tail(
            proto, negotiated_capabilities, progress)
        return new_refs
@


<<[[GitClient]] methods>>=
def _handle_receive_pack_head(self, proto, capabilities, old_refs,
                              new_refs):
    """Handle the head of a 'git-receive-pack' request.

    :param proto: Protocol object to read from
    :param capabilities: List of negotiated capabilities
    :param old_refs: Old refs, as received from the server
    :param new_refs: Refs to change
    :return: (have, want) tuple
    """
    want = []
    have = [x for x in old_refs.values() if not x == ZERO_SHA]
    sent_capabilities = False

    for refname in new_refs:
        if not isinstance(refname, bytes):
            raise TypeError('refname is not a bytestring: %r' % refname)
        old_sha1 = old_refs.get(refname, ZERO_SHA)
        if not isinstance(old_sha1, bytes):
            raise TypeError('old sha1 for %s is not a bytestring: %r' %
                            (refname, old_sha1))
        new_sha1 = new_refs.get(refname, ZERO_SHA)
        if not isinstance(new_sha1, bytes):
            raise TypeError('old sha1 for %s is not a bytestring %r' %
                            (refname, new_sha1))

        if old_sha1 != new_sha1:
            if sent_capabilities:
                proto.write_pkt_line(old_sha1 + b' ' + new_sha1 + b' ' +
                                     refname)
            else:
                proto.write_pkt_line(
                    old_sha1 + b' ' + new_sha1 + b' ' + refname + b'\0' +
                    b' '.join(capabilities))
                sent_capabilities = True
        if new_sha1 not in have and new_sha1 != ZERO_SHA:
            want.append(new_sha1)
    proto.write_pkt_line(None)
    return (have, want)

@

<<[[GitClient]] methods>>=
def _handle_receive_pack_tail(self, proto, capabilities, progress=None):
    """Handle the tail of a 'git-receive-pack' request.

    :param proto: Protocol object to read from
    :param capabilities: List of negotiated capabilities
    :param progress: Optional progress reporting function
    """
    <<[[GitClient._handle_receive_pack_tail()]] if side-band capability>>
    else:
        <<[[GitClient._handle_receive_pack_tail()]] when no side-band, if report status>>

    <<[[GitClient._handle_receive_pack_tail()]] at end, if report status>>
@
% mostly nothing, just report stuff if no side-band.


\section{Server}


<<function cmd_daemon>>=
class cmd_daemon(Command):

    def run(self, args):
        from dulwich import log_utils
        from dulwich.protocol import TCP_GIT_PORT
        parser = optparse.OptionParser()
        parser.add_option("-l", "--listen_address", dest="listen_address",
                          default="localhost",
                          help="Binding IP address.")
        parser.add_option("-p", "--port", dest="port", type=int,
                          default=TCP_GIT_PORT,
                          help="Binding TCP port.")
        options, args = parser.parse_args(args)

        log_utils.default_logging_config()
        if len(args) >= 1:
            gitdir = args[0]
        else:
            gitdir = '.'
        from dulwich import porcelain

        porcelain.daemon(gitdir, address=options.listen_address,
                         port=options.port)
@
% there is also a server.__main__ but not sure we need that.

<<function porcelain.daemon>>=
def daemon(path=".", address=None, port=None):
    """Run a daemon serving Git requests over TCP/IP.

    :param path: Path to the directory to serve.
    :param address: Optional address to listen on (defaults to ::)
    :param port: Optional port to listen on (defaults to TCP_GIT_PORT)
    """
    # TODO(jelmer): Support git-daemon-export-ok and --export-all.
    backend = FileSystemBackend(path)
    server = TCPGitServer(backend, address, port)
    server.serve_forever()
@

\subsection{[[TCPGitServer]]}

<<class TCPGitServer>>=
class TCPGitServer(SocketServer.TCPServer):

    allow_reuse_address = True
    serve = SocketServer.TCPServer.serve_forever

    def _make_handler(self, *args, **kwargs):
        return TCPGitRequestHandler(self.handlers, *args, **kwargs)

    def __init__(self, backend, listen_addr, port=TCP_GIT_PORT, handlers=None):
        self.handlers = dict(DEFAULT_HANDLERS)
        if handlers is not None:
            self.handlers.update(handlers)
        self.backend = backend
        logger.info('Listening for TCP connections on %s:%d', listen_addr, port)
        SocketServer.TCPServer.__init__(self, (listen_addr, port),
                                        self._make_handler)

    def verify_request(self, request, client_address):
        logger.info('Handling request from %s', client_address)
        return True

    def handle_error(self, request, client_address):
        logger.exception('Exception happened during processing of request '
                         'from %s', client_address)
@

<<class TCPGitRequestHandler>>=
class TCPGitRequestHandler(SocketServer.StreamRequestHandler):

    def __init__(self, handlers, *args, **kwargs):
        self.handlers = handlers
        SocketServer.StreamRequestHandler.__init__(self, *args, **kwargs)

    def handle(self):
        proto = ReceivableProtocol(self.connection.recv, self.wfile.write)
        command, args = proto.read_cmd()
        logger.info('Handling %s request, args=%s', command, args)

        cls = self.handlers.get(command, None)
        if not callable(cls):
            raise GitProtocolError('Invalid service %s' % command)
        h = cls(self.server.backend, args, proto)
        h.handle()
@

<<constant DEFAULT_HANDLERS>>=
# Default handler classes for git services.
DEFAULT_HANDLERS = {
  b'git-upload-pack': UploadPackHandler,
  b'git-receive-pack': ReceivePackHandler,
#  b'git-upload-archive': UploadArchiveHandler,
  }
@


\subsection{[[FileSystemBackend]]}

<<class Backend>>=
class Backend(object):
    """A backend for the Git smart server implementation."""

    def open_repository(self, path):
        """Open the repository at a path.

        :param path: Path to the repository
        :raise NotGitRepository: no git repository was found at path
        :return: Instance of BackendRepo
        """
        raise NotImplementedError(self.open_repository)
@

<<class FileSystemBackend>>=
class FileSystemBackend(Backend):
    """Simple backend that looks up Git repositories in the local file system."""

    def __init__(self, root=os.sep):
        super(FileSystemBackend, self).__init__()
        self.root = (os.path.abspath(root) + os.sep).replace(os.sep * 2, os.sep)

    def open_repository(self, path):
        logger.debug('opening repository at %s', path)
        abspath = os.path.abspath(os.path.join(self.root, path)) + os.sep
        normcase_abspath = os.path.normcase(abspath)
        normcase_root = os.path.normcase(self.root)
        if not normcase_abspath.startswith(normcase_root):
            raise NotGitRepository("Path %r not inside root %r" % (path, self.root))
        return Repo(abspath)
@

\subsection{[[Handler]]}

<<class Handler>>=
class Handler(object):
    """Smart protocol command handler base class."""

    def __init__(self, backend, proto, http_req=None):
        self.backend = backend
        self.proto = proto
        self.http_req = http_req

    def handle(self):
        raise NotImplementedError(self.handle)
@

<<class PackHandler>>=
class PackHandler(Handler):
    """Protocol handler for packs."""

    def __init__(self, backend, proto, http_req=None):
        super(PackHandler, self).__init__(backend, proto, http_req)
        self._client_capabilities = None
        # Flags needed for the no-done capability
        self._done_received = False

    @classmethod
    def capability_line(cls):
        return b"".join([b" " + c for c in cls.capabilities()])

    @classmethod
    def capabilities(cls):
        raise NotImplementedError(cls.capabilities)

    @classmethod
    def innocuous_capabilities(cls):
        return (CAPABILITY_INCLUDE_TAG, CAPABILITY_THIN_PACK,
                CAPABILITY_NO_PROGRESS, CAPABILITY_OFS_DELTA,
                capability_agent())

    @classmethod
    def required_capabilities(cls):
        """Return a list of capabilities that we require the client to have."""
        return []

    def set_client_capabilities(self, caps):
        allowable_caps = set(self.innocuous_capabilities())
        allowable_caps.update(self.capabilities())
        for cap in caps:
            if cap not in allowable_caps:
                raise GitProtocolError('Client asked for capability %s that '
                                       'was not advertised.' % cap)
        for cap in self.required_capabilities():
            if cap not in caps:
                raise GitProtocolError('Client does not support required '
                                       'capability %s.' % cap)
        self._client_capabilities = set(caps)
        logger.info('Client capabilities: %s', caps)

    def has_capability(self, cap):
        if self._client_capabilities is None:
            raise GitProtocolError('Server attempted to access capability %s '
                                   'before asking client' % cap)
        return cap in self._client_capabilities

    def notify_done(self):
        self._done_received = True
@

\subsection{[[git-upload-pack]]}
% when pull

<<class UploadPackHandler>>=
class UploadPackHandler(PackHandler):
    """Protocol handler for uploading a pack to the client."""

    def __init__(self, backend, args, proto, http_req=None,
                 advertise_refs=False):
        super(UploadPackHandler, self).__init__(backend, proto,
            http_req=http_req)
        self.repo = backend.open_repository(args[0])
        self._graph_walker = None
        self.advertise_refs = advertise_refs
        # A state variable for denoting that the have list is still
        # being processed, and the client is not accepting any other
        # data (such as side-band, see the progress method here).
        self._processing_have_lines = False

    @classmethod
    def capabilities(cls):
        return (CAPABILITY_MULTI_ACK_DETAILED, CAPABILITY_MULTI_ACK,
                CAPABILITY_SIDE_BAND_64K, CAPABILITY_THIN_PACK,
                CAPABILITY_OFS_DELTA, CAPABILITY_NO_PROGRESS,
                CAPABILITY_INCLUDE_TAG, CAPABILITY_SHALLOW, CAPABILITY_NO_DONE)

    @classmethod
    def required_capabilities(cls):
        return (CAPABILITY_SIDE_BAND_64K, CAPABILITY_THIN_PACK, CAPABILITY_OFS_DELTA)

    def progress(self, message):
        if self.has_capability(CAPABILITY_NO_PROGRESS) or self._processing_have_lines:
            return
        self.proto.write_sideband(SIDE_BAND_CHANNEL_PROGRESS, message)

    def get_tagged(self, refs=None, repo=None):
        """Get a dict of peeled values of tags to their original tag shas.

        :param refs: dict of refname -> sha of possible tags; defaults to all of
            the backend's refs.
        :param repo: optional Repo instance for getting peeled refs; defaults to
            the backend's repo, if available
        :return: dict of peeled_sha -> tag_sha, where tag_sha is the sha of a
            tag whose peeled value is peeled_sha.
        """
        if not self.has_capability(CAPABILITY_INCLUDE_TAG):
            return {}
        if refs is None:
            refs = self.repo.get_refs()
        if repo is None:
            repo = getattr(self.repo, "repo", None)
            if repo is None:
                # Bail if we don't have a Repo available; this is ok since
                # clients must be able to handle if the server doesn't include
                # all relevant tags.
                # TODO: fix behavior when missing
                return {}
        tagged = {}
        for name, sha in refs.items():
            peeled_sha = repo.get_peeled(name)
            if peeled_sha != sha:
                tagged[peeled_sha] = sha
        return tagged

    def handle(self):
        write = lambda x: self.proto.write_sideband(SIDE_BAND_CHANNEL_DATA, x)

        graph_walker = ProtocolGraphWalker(self, self.repo.object_store,
            self.repo.get_peeled)
        objects_iter = self.repo.fetch_objects(
            graph_walker.determine_wants, graph_walker, self.progress,
            get_tagged=self.get_tagged)

        # Note the fact that client is only processing responses related
        # to the have lines it sent, and any other data (including side-
        # band) will be be considered a fatal error.
        self._processing_have_lines = True

        # Did the process short-circuit (e.g. in a stateless RPC call)? Note
        # that the client still expects a 0-object pack in most cases.
        # Also, if it also happens that the object_iter is instantiated
        # with a graph walker with an implementation that talks over the
        # wire (which is this instance of this class) this will actually
        # iterate through everything and write things out to the wire.
        if len(objects_iter) == 0:
            return

        # The provided haves are processed, and it is safe to send side-
        # band data now.
        self._processing_have_lines = False

        if not graph_walker.handle_done(
                not self.has_capability(CAPABILITY_NO_DONE), self._done_received):
            return

        self.progress(b"dul-daemon says what\n")
        self.progress(("counting objects: %d, done.\n" % len(objects_iter)).encode('ascii'))
        write_pack_objects(ProtocolFile(None, write), objects_iter)
        self.progress(b"how was that, then?\n")
        # we are done
        self.proto.write_pkt_line(None)
@

\subsection{[[git-receive-pack]]}
% when push

<<class ReceivePackHandler>>=
class ReceivePackHandler(PackHandler):
    """Protocol handler for downloading a pack from the client."""

    def __init__(self, backend, args, proto, http_req=None,
                 advertise_refs=False):
        super(ReceivePackHandler, self).__init__(backend, proto,
            http_req=http_req)
        self.repo = backend.open_repository(args[0])
        self.advertise_refs = advertise_refs

    @classmethod
    def capabilities(cls):
        return (CAPABILITY_REPORT_STATUS, CAPABILITY_DELETE_REFS, CAPABILITY_QUIET,
                CAPABILITY_OFS_DELTA, CAPABILITY_SIDE_BAND_64K, CAPABILITY_NO_DONE)

    def _apply_pack(self, refs):
        all_exceptions = (IOError, OSError, ChecksumMismatch, ApplyDeltaError,
                          AssertionError, socket.error, zlib.error,
                          ObjectFormatException)
        status = []
        will_send_pack = False

        for command in refs:
            if command[1] != ZERO_SHA:
                will_send_pack = True

        if will_send_pack:
            # TODO: more informative error messages than just the exception string
            try:
                recv = getattr(self.proto, "recv", None)
                self.repo.object_store.add_thin_pack(self.proto.read, recv)
                status.append((b'unpack', b'ok'))
            except all_exceptions as e:
                status.append((b'unpack', str(e).replace('\n', '')))
                # The pack may still have been moved in, but it may contain broken
                # objects. We trust a later GC to clean it up.
        else:
            # The git protocol want to find a status entry related to unpack process
            # even if no pack data has been sent.
            status.append((b'unpack', b'ok'))

        for oldsha, sha, ref in refs:
            ref_status = b'ok'
            try:
                if sha == ZERO_SHA:
                    if not CAPABILITY_DELETE_REFS in self.capabilities():
                        raise GitProtocolError(
                          'Attempted to delete refs without delete-refs '
                          'capability.')
                    try:
                        self.repo.refs.remove_if_equals(ref, oldsha)
                    except all_exceptions:
                        ref_status = b'failed to delete'
                else:
                    try:
                        self.repo.refs.set_if_equals(ref, oldsha, sha)
                    except all_exceptions:
                        ref_status = b'failed to write'
            except KeyError as e:
                ref_status = b'bad ref'
            status.append((ref, ref_status))

        return status

    def _report_status(self, status):
        if self.has_capability(CAPABILITY_SIDE_BAND_64K):
            writer = BufferedPktLineWriter(
              lambda d: self.proto.write_sideband(SIDE_BAND_CHANNEL_DATA, d))
            write = writer.write

            def flush():
                writer.flush()
                self.proto.write_pkt_line(None)
        else:
            write = self.proto.write_pkt_line
            flush = lambda: None

        for name, msg in status:
            if name == b'unpack':
                write(b'unpack ' + msg + b'\n')
            elif msg == b'ok':
                write(b'ok ' + name + b'\n')
            else:
                write(b'ng ' + name + b' ' + msg + b'\n')
        write(None)
        flush()

    def handle(self):
        if self.advertise_refs or not self.http_req:
            refs = sorted(self.repo.get_refs().items())

            if not refs:
                refs = [(CAPABILITIES_REF, ZERO_SHA)]
            self.proto.write_pkt_line(
              refs[0][1] + b' ' + refs[0][0] + b'\0' +
              self.capability_line() + b'\n')
            for i in range(1, len(refs)):
                ref = refs[i]
                self.proto.write_pkt_line(ref[1] + b' ' + ref[0] + b'\n')

            self.proto.write_pkt_line(None)
            if self.advertise_refs:
                return

        client_refs = []
        ref = self.proto.read_pkt_line()

        # if ref is none then client doesnt want to send us anything..
        if ref is None:
            return

        ref, caps = extract_capabilities(ref)
        self.set_client_capabilities(caps)

        # client will now send us a list of (oldsha, newsha, ref)
        while ref:
            client_refs.append(ref.split())
            ref = self.proto.read_pkt_line()

        # backend can now deal with this refs and read a pack using self.read
        status = self._apply_pack(client_refs)

        # when we have read all the pack from the client, send a status report
        # if the client asked for it
        if self.has_capability(CAPABILITY_REPORT_STATUS):
            self._report_status(status)
@



\chapter{Advanced Topics}

\section{Bytes}


<<constant porcelain.DEFAULT_ENCODING>>=
DEFAULT_ENCODING = 'utf-8'
@
% see to_bytes()

<<[[TraditionalGitClient]] constants>>=
DEFAULT_ENCODING = 'utf-8'
@


% def __init__(self, path_encoding=DEFAULT_ENCODING, **kwargs):
<<[[TraditionalGitClient.__init__]] set fields>>=
self._remote_path_encoding = path_encoding
@


<<[[hex_to_sha()]] if hex not bytes>>=
if not isinstance(hex, bytes):
    raise
@

<<[[hex_to_filename()]] possibly decode hex>>=
if getattr(path, 'encode', None) is not None:
    hex = hex.decode('ascii')
@

<<[[DiskRefsContainer.refpath()]] sanitize name>>=
if getattr(self.path, "encode", None) and getattr(name, "decode", None):
    name = name.decode(sys.getfilesystemencoding())
@

<<[[porcelain.clone()]] sanitize source>>=
if not isinstance(source, bytes):
    source = source.encode(DEFAULT_ENCODING)
@


<<[[FixedSha.__init__()]] sanitize hexsha>>=
if getattr(hexsha, 'encode', None) is not None:
    hexsha = hexsha.encode('ascii')
@

<<function objectspec.to_bytes>>=
def to_bytes(text):
    if getattr(text, "encode", None) is not None:
        text = text.encode('ascii')
    return text
@

<<[[Repo.stage()]] sanitize fs_path>>=
if not isinstance(fs_path, bytes):
    fs_path = fs_path.encode(sys.getfilesystemencoding())
@

<<[[LocalGitClient._open_repo()]] sanitize path>>=
if not isinstance(path, str):
    path = path.decode(sys.getfilesystemencoding())
@

<<[[_fs_to_tree_path()]] sanitize fs_path_bytes if not bytes>>=
if fs_encoding is None:
    fs_encoding = sys.getfilesystemencoding()
if not isinstance(fs_path, bytes):
    fs_path_bytes = fs_path.encode(fs_encoding)
@

<<[[blob_from_path_and_stat()]] sanity check fs_path>>=
assert isinstance(fs_path, bytes)
@

<<[[build_index_from_tree()]] sanitize root_path if not bytes>>=
if not isinstance(root_path, bytes):
    root_path = root_path.encode(sys.getfilesystemencoding())
@

<<[[get_unstaged_changes()]] adjust root_path if not bytes>>=
if not isinstance(root_path, bytes):
    root_path = root_path.encode(sys.getfilesystemencoding())
@

<<[[BaseRepo.do_commit()]] set encoding>>=
if encoding is not None:
    c.encoding = encoding
@


<<[[porcelain.show]] define [[decode()]]>>=
if isinstance(o, Commit):
    def decode(x):
        return commit_decode(o, x, default_encoding)
else:
    def decode(x):
        return x.decode(default_encoding)
@

<<[[porcelain.log()]] define [[decode()]]>>=
def decode(x):
    return commit_decode(entry.commit, x)
@

<<function porcelain.commit_decode>>=
def commit_decode(commit, contents, default_encoding=DEFAULT_ENCODING):
    if commit.encoding is not None:
        return contents.decode(commit.encoding, "replace")
    return contents.decode(default_encoding, "replace")
@

<<[[_tree_to_fs_path()]] sanity check tree_path>>=
assert isinstance(tree_path, bytes)
@


<<[[TCPGitClient._connect()]] adjust path if not bytes>>=
if not isinstance(path, bytes):
    path = path.encode(self._remote_path_encoding)
@

\section{Advanced features}

\subsection{Tags}

\subsubsection{[[Tag]]}

<<class Tag>>=
class Tag(ShaFile):
    """A Git Tag object."""

    type_name = b'tag'
    type_num = 4

    __slots__ = ('_tag_timezone_neg_utc', '_name', '_object_sha',
                 '_object_class', '_tag_time', '_tag_timezone',
                 '_tagger', '_message')
    <<[[Tag]] methods>>

@

<<[[Tag]] methods>>=
def __init__(self):
    super(Tag, self).__init__()
    self._tagger = None
    self._tag_time = None
    self._tag_timezone = None
    self._tag_timezone_neg_utc = False
@

<<[[Tag]] methods>>=
<<method Tag._get_object>>
<<method Tag._set_object>>
object = property(_get_object, _set_object)
@

<<method Tag._get_object>>=
def _get_object(self):
    """Get the object pointed to by this tag.

    :return: tuple of (object class, sha).
    """
    return (self._object_class, self._object_sha)
@

<<method Tag._set_object>>=
def _set_object(self, value):
    (self._object_class, self._object_sha) = value
    self._needs_serialization = True

@

<<[[Tag]] methods>>=
name = serializable_property("name", "The name of this tag")
@

<<[[Tag]] methods>>=
tagger = serializable_property("tagger",
    "Returns the name of the person who created this tag")
@

<<[[Tag]] methods>>=
tag_time = serializable_property("tag_time",
    "The creation timestamp of the tag.  As the number of seconds "
    "since the epoch")
@

<<[[Tag]] methods>>=
tag_timezone = serializable_property("tag_timezone",
    "The timezone that tag_time is in.")
@

<<[[Tag]] methods>>=
message = serializable_property(
    "message", "The message attached to this tag")
@

<<constants objects.objects_HEADER>>=
# Header fields for objects
_OBJECT_HEADER = b'object'
_TYPE_HEADER = b'type'
_TAG_HEADER = b'tag'
_TAGGER_HEADER = b'tagger'
@
%bug? should be called tag?

<<[[Tag]] methods>>=
def check(self):
    """Check this object for internal consistency.

    :raise ObjectFormatException: if the object is malformed in some way
    """
    super(Tag, self).check()
    self._check_has_member("_object_sha", "missing object sha")
    self._check_has_member("_object_class", "missing object type")
    self._check_has_member("_name", "missing tag name")

    if not self._name:
        raise ObjectFormatException("empty tag name")

    check_hexsha(self._object_sha, "invalid object sha")

    if getattr(self, "_tagger", None):
        check_identity(self._tagger, "invalid tagger")

    last = None
    for field, _ in _parse_message(self._chunked_text):
        if field == _OBJECT_HEADER and last is not None:
            raise ObjectFormatException("unexpected object")
        elif field == _TYPE_HEADER and last != _OBJECT_HEADER:
            raise ObjectFormatException("unexpected type")
        elif field == _TAG_HEADER and last != _TYPE_HEADER:
            raise ObjectFormatException("unexpected tag name")
        elif field == _TAGGER_HEADER and last != _TAG_HEADER:
            raise ObjectFormatException("unexpected tagger")
        last = field

@



<<[[Tag]] methods>>=
def _deserialize(self, chunks):
    """Grab the metadata attached to the tag"""
    self._tagger = None
    self._tag_time = None
    self._tag_timezone = None
    self._tag_timezone_neg_utc = False
    for field, value in _parse_message(chunks):
        if field == _OBJECT_HEADER:
            self._object_sha = value
        elif field == _TYPE_HEADER:
            obj_class = object_class(value)
            if not obj_class:
                raise ObjectFormatException("Not a known type: %s" % value)
            self._object_class = obj_class
        elif field == _TAG_HEADER:
            self._name = value
        elif field == _TAGGER_HEADER:
            try:
                sep = value.index(b'> ')
            except ValueError:
                self._tagger = value
                self._tag_time = None
                self._tag_timezone = None
                self._tag_timezone_neg_utc = False
            else:
                self._tagger = value[0:sep+1]
                try:
                    (timetext, timezonetext) = value[sep+2:].rsplit(b' ', 1)
                    self._tag_time = int(timetext)
                    self._tag_timezone, self._tag_timezone_neg_utc = \
                            parse_timezone(timezonetext)
                except ValueError as e:
                    raise ObjectFormatException(e)
        elif field is None:
            self._message = value
        else:
            raise ObjectFormatException("Unknown field %s" % field)

@

<<[[Tag]] methods>>=
def _serialize(self):
    chunks = []
    chunks.append(git_line(_OBJECT_HEADER, self._object_sha))
    chunks.append(git_line(_TYPE_HEADER, self._object_class.type_name))
    chunks.append(git_line(_TAG_HEADER, self._name))
    if self._tagger:
        if self._tag_time is None:
            chunks.append(git_line(_TAGGER_HEADER, self._tagger))
        else:
            chunks.append(git_line(
                _TAGGER_HEADER, self._tagger,
                str(self._tag_time).encode('ascii'),
                format_timezone(self._tag_timezone, self._tag_timezone_neg_utc)))
    if self._message is not None:
        chunks.append(b'\n') # To close headers
        chunks.append(self._message)
    return chunks

@


<<function porcelain.show_tag>>=
def show_tag(repo, tag, decode, outstream=sys.stdout):
    """Print a tag to a stream.

    :param repo: A `Repo` object
    :param tag: A `Tag` object
    :param decode: Function for decoding bytes to unicode string
    :param outstream: Stream to write to
    """
    print_tag(tag, decode, outstream)
    show_object(repo, repo[tag.object[1]], outstream)
@

<<function porcelain.print_tag>>=
def print_tag(tag, decode, outstream=sys.stdout):
    """Write a human-readable tag.

    :param tag: A `Tag` object
    :param decode: Function for decoding bytes to unicode string
    :param outstream: A stream to write to
    """
    outstream.write("Tagger: " + decode(tag.tagger) + "\n")
    outstream.write("Date:   " + decode(tag.tag_time) + "\n")
    outstream.write("\n")
    outstream.write(decode(tag.message) + "\n")
    outstream.write("\n")
@


<<[[Tag]] methods>>=
@classmethod
def from_path(cls, filename):
    tag = ShaFile.from_path(filename)
    if not isinstance(tag, cls):
        raise NotTagError(filename)
    return tag

@
%dead?

\subsubsection{[[git tag]]}

<<function cmd_tag>>=
class cmd_tag(Command):

    def run(self, args):
        opts, args = getopt(args, '', [])
        if len(args) < 2:
            print('Usage: dulwich tag NAME')
            sys.exit(1)

        porcelain.tag('.', args[0])
@
% should call tag_create here instead

%deprecated:
%<<function porcelain.tag>>=
%def tag(*args, **kwargs):
%    import warnings
%    warnings.warn("tag has been deprecated in favour of tag_create.",
%                  DeprecationWarning)
%    return tag_create(*args, **kwargs)
%@

<<function porcelain.tag_create>>=
def tag_create(
        repo, tag, author=None, message=None, annotated=False,
        objectish="HEAD", tag_time=None, tag_timezone=None):
    """Creates a tag in git via dulwich calls:

    :param repo: Path to repository
    :param tag: tag string
    :param author: tag author (optional, if annotated is set)
    :param message: tag message (optional)
    :param annotated: whether to create an annotated tag
    :param objectish: object the tag should point at, defaults to HEAD
    :param tag_time: Optional time for annotated tag
    :param tag_timezone: Optional timezone for annotated tag
    """

    with open_repo_closing(repo) as r:
        object = parse_object(r, objectish)

        if annotated:
            # Create the tag object
            tag_obj = Tag()
            if author is None:
                # TODO(jelmer): Don't use repo private method.
                author = r._get_user_identity()
            tag_obj.tagger = author
            tag_obj.message = message
            tag_obj.name = tag
            tag_obj.object = (type(object), object.id)
            if tag_time is None:
                tag_time = int(time.time())
            tag_obj.tag_time = tag_time
            if tag_timezone is None:
                # TODO(jelmer) Use current user timezone rather than UTC
                tag_timezone = 0
            elif isinstance(tag_timezone, str):
                tag_timezone = parse_timezone(tag_timezone)
            tag_obj.tag_timezone = tag_timezone
            r.object_store.add_object(tag_obj)
            tag_id = tag_obj.id
        else:
            tag_id = object.id

        r.refs[b'refs/tags/' + tag] = tag_id
@

<<function porcelain.tag_list>>=
def tag_list(repo, outstream=sys.stdout):
    """List all tags.

    :param repo: Path to repository
    :param outstream: Stream to write tags to
    """
    with open_repo_closing(repo) as r:
        tags = sorted(r.refs.as_dict(b"refs/tags"))
        return tags
@

<<function porcelain.tag_delete>>=
def tag_delete(repo, name):
    """Remove a tag.

    :param repo: Path to repository
    :param name: Name of tag to remove
    """
    with open_repo_closing(repo) as r:
        if isinstance(name, bytes):
            names = [name]
        elif isinstance(name, list):
            names = name
        else:
            raise TypeError("Unexpected tag name type %r" % name)
        for name in names:
            del r.refs[b"refs/tags/" + name]
@

\subsubsection{[[git clone]] and tags}

<<constant refs.ANNOTATED_TAG_SUFFIX>>=
ANNOTATED_TAG_SUFFIX = b'^{}'
@

<<[[porcelain.clone()]] import remote tags>>=
r.refs.import_refs(
    b'refs/tags',
    {n[len(b'refs/tags/'):]: v for (n, v) in remote_refs.items()
        if n.startswith(b'refs/tags/') and
        not n.endswith(ANNOTATED_TAG_SUFFIX)})
@

% when iterate over objects in Walker from git log for example
<<[[_CommitTimeQueue._push()]] if tag>>=
if isinstance(obj, Tag):
    self._push(obj.object[1])
    return
@

\subsubsection{[[git pull]] and tags}

<<function object_store._split_commits_and_tags>>=
def _split_commits_and_tags(obj_store, lst, ignore_unknown=False):
    """Split object id list into three lists with commit, tag, and other SHAs.

    Commits referenced by tags are included into commits
    list as well. Only SHA1s known in this repository will get
    through, and unless ignore_unknown argument is True, KeyError
    is thrown for SHA1 missing in the repository

    :param obj_store: Object store to get objects by SHA1 from
    :param lst: Collection of commit and tag SHAs
    :param ignore_unknown: True to skip SHA1 missing in the repository
        silently.
    :return: A tuple of (commits, tags, others) SHA1s
    """
    commits = set()
    tags = set()
    others = set()
    for e in lst:
        try:
            o = obj_store[e]
        except KeyError:
            if not ignore_unknown:
                raise
        else:
            if isinstance(o, Commit):
                commits.add(e)
            elif isinstance(o, Tag):
                tags.add(e)
                tagged = o.object[1]
                c, t, o = _split_commits_and_tags(
                    obj_store, [tagged], ignore_unknown=ignore_unknown)
                commits |= c
                tags |= t
                others |= o
            else:
                others.add(e)
    return (commits, tags, others)
@

<<[[MissingObjectFinder.__init__()]] record have tags>>=
# record tags we have as visited, too
for t in have_tags:
    self.sha_done.add(t)
@

<<[[MissingObjectFinder.__init__()]] set _tagged>>=
self._tagged = get_tagged and get_tagged() or {}
@

\subsection{Reflog}

% but code of dulwich does not maintain reflog. When you
% update a ref, it should update the reflog of this ref!

% <empty> -> <>
<<function read_reflog>>=
def read_reflog(f):
    """Read reflog.

    :param f: File-like object
    :returns: Iterator over Entry objects
    """
    for l in f:
        yield parse_reflog_line(l)
@
%dead: because API.
% In fact code that commits should update the reflog.

<<type reflog.Entry>>=
Entry = collections.namedtuple(
    'Entry', ['old_sha', 'new_sha', 'committer', 'timestamp', 'timezone',
              'message'])

@

<<function parse_reflog_line>>=
def parse_reflog_line(line):
    """Parse a reflog line.

    :param line: Line to parse
    :return: Tuple of (old_sha, new_sha, committer, timestamp, timezone,
        message)
    """
    (begin, message) = line.split(b'\t', 1)
    (old_sha, new_sha, rest) = begin.split(b' ', 2)
    (committer, timestamp_str, timezone_str) = rest.rsplit(b' ', 2)
    return Entry(old_sha, new_sha, committer, int(timestamp_str),
                 parse_timezone(timezone_str)[0], message)
@

% <empty> -> <>
<<function format_reflog_line>>=
def format_reflog_line(old_sha, new_sha, committer, timestamp, timezone,
                       message):
    """Generate a single reflog line.

    :param old_sha: Old Commit SHA
    :param new_sha: New Commit SHA
    :param committer: Committer name and e-mail
    :param timestamp: Timestamp
    :param timezone: Timezone
    :param message: Message
    """
    if old_sha is None:
        old_sha = ZERO_SHA
    return (old_sha + b' ' + new_sha + b' ' + committer + b' ' +
            str(timestamp).encode('ascii') + b' ' +
            format_timezone(timezone) + b'\t' + message)

@

\subsection{Stash}
% again, just a ref?

\subsubsection{[[git stash]]}
% pretty useful in the end

\subsection{Grafts}

% I used this feature to represent the full history of Linux from 0.01 to 2.6!

<<[[BaseRepo.__init__()]] grafts>>=
self._graftpoints = {}
@

\subsubsection{Reading graft files}

<<[[Repo.__init__()]] grafts>>=
self._graftpoints = {}
graft_file = self.get_named_file(os.path.join("info", "grafts"),
                                 basedir=self.commondir())
if graft_file:
    with graft_file:
        self._graftpoints.update(parse_graftpoints(graft_file))
@

<<[[Repo.__init__()]] grafts>>=
graft_file = self.get_named_file("shallow",
                                 basedir=self.commondir())
if graft_file:
    with graft_file:
        self._graftpoints.update(parse_graftpoints(graft_file))
@
% shallow? deprecated format?

<<function parse_graftpoints>>=
def parse_graftpoints(graftpoints):
    """Convert a list of graftpoints into a dict

    :param graftpoints: Iterator of graftpoint lines

    Each line is formatted as:
        <commit sha1> <parent sha1> [<parent sha1>]*

    Resulting dictionary is:
        <commit sha1>: [<parent sha1>*]

    https://git.wiki.kernel.org/index.php/GraftPoint
    """
    grafts = {}
    for l in graftpoints:
        raw_graft = l.split(None, 1)

        commit = raw_graft[0]
        if len(raw_graft) == 2:
            parents = raw_graft[1].split()
        else:
            parents = []

        for sha in [commit] + parents:
            check_hexsha(sha, 'Invalid graftpoint')

        grafts[commit] = parents
    return grafts
@

\subsubsection{Writing graft files}

<<[[BaseRepo]] methods>>=
def _add_graftpoints(self, updated_graftpoints):
    """Add or modify graftpoints

    :param updated_graftpoints: Dict of commit shas to list of parent shas
    """

    # Simple validation
    for commit, parents in updated_graftpoints.items():
        for sha in [commit] + parents:
            check_hexsha(sha, 'Invalid graftpoint')

    self._graftpoints.update(updated_graftpoints)
@
%dead? API

<<[[BaseRepo]] methods>>=
def _remove_graftpoints(self, to_remove=[]):
    """Remove graftpoints

    :param to_remove: List of commit shas
    """
    for sha in to_remove:
        del self._graftpoints[sha]
@
%dead? API


<<function serialize_graftpoints>>=
def serialize_graftpoints(graftpoints):
    """Convert a dictionary of grafts into string

    The graft dictionary is:
        <commit sha1>: [<parent sha1>*]

    Each line is formatted as:
        <commit sha1> <parent sha1> [<parent sha1>]*

    https://git.wiki.kernel.org/index.php/GraftPoint

    """
    graft_lines = []
    for commit, parents in graftpoints.items():
        if parents:
            graft_lines.append(commit + b' ' + b' '.join(parents))
        else:
            graft_lines.append(commit)
    return b'\n'.join(graft_lines)

@
%dead? API?

\subsubsection{Using graft file}

% walker? -> <>
<<[[BaseRepo.get_parents()]] look if graftpoint>>=
try:
    return self._graftpoints[sha]
except KeyError:
@


\subsection{Submodules}


<<constant S_IFGITLINK>>=
S_IFGITLINK = 0o160000
@
% hack to encode submodule?

<<function objects.S_ISGITLINK>>=
def S_ISGITLINK(m):
    """Check if a mode indicates a submodule.

    :param m: Mode to check
    :return: a ``boolean``
    """
    return (stat.S_IFMT(m) == S_IFGITLINK)
@
% `` ``

<<[[index.cleanup_mode()]] if gitlink>>=
elif S_ISGITLINK(mode):
    return S_IFGITLINK
@

<<[[build_index_from_tree()]] if gitlink>>=
# TODO(jelmer): Merge new index into working tree
if S_ISGITLINK(entry.mode):
    if not os.path.isdir(full_path):
        os.mkdir(full_path)
    st = os.lstat(full_path)
    # TODO(jelmer): record and return submodule paths
@


<<[[build_index_from_tree()]] if gitlink or not honor filemode>>=
if not honor_filemode or S_ISGITLINK(entry.mode):
    # we can not use tuple slicing to build a new tuple,
    # because on windows that will convert the times to
    # longs, which causes errors further along
    st_tuple = (entry.mode, st.st_ino, st.st_dev, st.st_nlink,
                st.st_uid, st.st_gid, st.st_size, st.st_atime,
                st.st_mtime, st.st_ctime)
    st = st.__class__(st_tuple)
@

<<[[write_object_diff()]] if gitlink>>=
elif S_ISGITLINK(mode):
    return Blob.from_string(b"Submodule commit " + hexsha + b"\n")
@


\subsection{hooks, [[.git/hooks/]]}

<<[[BaseRepo.__init__()]] hooks>>=
self.hooks = {}
@

<<class Hook>>=
class Hook(object):
    """Generic hook object."""

    <<[[Hook]] methods>>
@

<<[[Hook]] methods>>=
def execute(self, *args):
    """Execute the hook with the given args

    :param args: argument list to hook
    :raise HookError: hook execution failure
    :return: a hook may return a useful value
    """
    raise NotImplementedError(self.execute)
@

<<class ShellHook>>=
class ShellHook(Hook):
    """Hook by executable file

    Implements standard githooks(5) [0]:

    [0] http://www.kernel.org/pub/software/scm/git/docs/githooks.html
    """

    <<[[ShellHook]] methods>>
@

<<[[ShellHook]] methods>>=
def __init__(self, name, path, numparam,
             pre_exec_callback=None, post_exec_callback=None):
    """Setup shell hook definition

    :param name: name of hook for error messages
    :param path: absolute path to executable file
    :param numparam: number of requirements parameters
    :param pre_exec_callback: closure for setup before execution
        Defaults to None. Takes in the variable argument list from the
        execute functions and returns a modified argument list for the
        shell hook.
    :param post_exec_callback: closure for cleanup after execution
        Defaults to None. Takes in a boolean for hook success and the
        modified argument list and returns the final hook return value
        if applicable
    """
    self.name = name
    self.filepath = path
    self.numparam = numparam

    self.pre_exec_callback = pre_exec_callback
    self.post_exec_callback = post_exec_callback
@

%win32:
%    if sys.version_info[0] == 2 and sys.platform == 'win32':
%        # Python 2 on windows does not support unicode file paths
%        # http://bugs.python.org/issue1759845
%        self.filepath = self.filepath.encode(sys.getfilesystemencoding())

<<[[ShellHook]] methods>>=
def execute(self, *args):
    """Execute the hook with given args"""

    if len(args) != self.numparam:
        raise HookError("Hook %s executed with wrong number of args. \
                        Expected %d. Saw %d. args: %s"
                        % (self.name, self.numparam, len(args), args))

    if (self.pre_exec_callback is not None):
        args = self.pre_exec_callback(*args)

    try:
        ret = subprocess.call([self.filepath] + list(args))
        if ret != 0:
            if (self.post_exec_callback is not None):
                self.post_exec_callback(0, *args)
            raise HookError("Hook %s exited with non-zero status"
                            % (self.name))
        if (self.post_exec_callback is not None):
            return self.post_exec_callback(1, *args)
    except OSError:  # no file. silent failure.
        if (self.post_exec_callback is not None):
            self.post_exec_callback(0, *args)
@


<<[[Repo.__init__()]] hooks>>=
self.hooks['pre-commit'] = PreCommitShellHook(self.controldir())
self.hooks['commit-msg'] = CommitMsgShellHook(self.controldir())
self.hooks['post-commit'] = PostCommitShellHook(self.controldir())
@


<<class PreCommitShellHook>>=
class PreCommitShellHook(ShellHook):
    """pre-commit shell hook"""

    def __init__(self, controldir):
        filepath = os.path.join(controldir, 'hooks', 'pre-commit')

        ShellHook.__init__(self, 'pre-commit', filepath, 0)
@

<<class PostCommitShellHook>>=
class PostCommitShellHook(ShellHook):
    """post-commit shell hook"""

    def __init__(self, controldir):
        filepath = os.path.join(controldir, 'hooks', 'post-commit')

        ShellHook.__init__(self, 'post-commit', filepath, 0)
@

<<class CommitMsgShellHook>>=
class CommitMsgShellHook(ShellHook):
    """commit-msg shell hook

    :param args[0]: commit message
    :return: new commit message or None
    """

    def __init__(self, controldir):
        filepath = os.path.join(controldir, 'hooks', 'commit-msg')

        def prepare_msg(*args):
            (fd, path) = tempfile.mkstemp()

            with os.fdopen(fd, 'wb') as f:
                f.write(args[0])

            return (path,)

        def clean_msg(success, *args):
            if success:
                with open(args[0], 'rb') as f:
                    new_msg = f.read()
                os.unlink(args[0])
                return new_msg
            os.unlink(args[0])

        ShellHook.__init__(self, 'commit-msg', filepath, 1,
                           prepare_msg, clean_msg)
@




<<[[BaseRepo.do_commit()]] execute pre-commit hook>>=
try:
    self.hooks['pre-commit'].execute()
except HookError as e:
    raise CommitError(e)
except KeyError:  # no hook defined, silent fallthrough
    pass
@

<<[[BaseRepo.do_commit()]] execute commit-msg hook>>=
try:
    c.message = self.hooks['commit-msg'].execute(message)
    if c.message is None:
        c.message = message
except HookError as e:
    raise CommitError(e)
except KeyError:  # no hook defined, message not modified
    c.message = message
@

<<[[BaseRepo.do_commit()]] execute post-commit hook>>=
try:
    self.hooks['post-commit'].execute()
except HookError as e:  # silent failure
    warnings.warn("post-commit hook failed: %s" % e, UserWarning)
except KeyError:  # no hook defined, silent fallthrough
    pass
@


\subsection{Configuration file, [[.git/config]]}

% ex of use:
<<[[Repo.reset_index()]] set [[honor_filemode]] using config file>>=
config = self.get_config()
honor_filemode = config.get_boolean(
    'core', 'filemode', os.name != "nt")
@

\subsubsection{Initialization}

<<[[BaseRepo.__init_files()]] create config file>>=
f = BytesIO()
cf = ConfigFile()
cf.set(b"core", b"repositoryformatversion", b"0")
if self._determine_file_mode():
    cf.set(b"core", b"filemode", True)
else:
    cf.set(b"core", b"filemode", False)

cf.set(b"core", b"bare", bare)
cf.set(b"core", b"logallrefupdates", True)
cf.write_to_file(f)
self._put_named_file('config', f.getvalue())
@

<<[[porcelain.clone()]] import config file>>=
target_config = r.get_config()
<<[[porcelain.clone()]] sanitize source>>
target_config.set((b'remote', b'origin'), b'url', source)
target_config.set(
    (b'remote', b'origin'), b'fetch',
    b'+refs/heads/*:refs/remotes/origin/*')
target_config.write_to_path()
@



<<[[BaseRepo]] methods>>=
def _determine_file_mode(self):
    """Probe the file-system to determine whether permissions can be trusted.

    :return: True if permissions can be trusted, False otherwise.
    """
    raise NotImplementedError(self._determine_file_mode)
@
<<[[Repo]] methods>>=
def _determine_file_mode(self):
    """Probe the file-system to determine whether permissions can be trusted.

    :return: True if permissions can be trusted, False otherwise.
    """
    fname = os.path.join(self.path, '.probe-permissions')
    with open(fname, 'w') as f:
        f.write('')

    st1 = os.lstat(fname)
    os.chmod(fname, st1.st_mode ^ stat.S_IXUSR)
    st2 = os.lstat(fname)

    os.unlink(fname)

    mode_differs = st1.st_mode != st2.st_mode
    st2_has_exec = (st2.st_mode & stat.S_IXUSR) != 0

    return mode_differs and st2_has_exec
@


<<[[BaseRepo]] methods>>=
def get_config(self):
    """Retrieve the config object.

    :return: `ConfigFile` object for the ``.git/config`` file.
    """
    raise NotImplementedError(self.get_config)
@

% porcelain.clone | Repo.reset_index -> <>
<<[[Repo]] methods>>=
def get_config(self):
    """Retrieve the config object.

    :return: `ConfigFile` object for the ``.git/config`` file.
    """
    from dulwich.config import ConfigFile
    path = os.path.join(self._controldir, 'config')
    try:
        return ConfigFile.from_path(path)
    except (IOError, OSError) as e:
        if e.errno != errno.ENOENT:
            raise
        ret = ConfigFile()
        ret.path = path
        return ret
@
%``

\subsubsection{[[ConfigFile]]}

<<class ConfigFile>>=
class ConfigFile(ConfigDict):
    """A Git configuration file, like .git/config or ~/.gitconfig.
    """
    <<[[ConfigFile]] methods>>
@

<<class ConfigDict>>=
class ConfigDict(Config, MutableMapping):
    """Git configuration stored in a dictionary."""

    <<[[ConfigDict]] methods>>
@

<<class Config>>=
class Config(object):
    """A Git configuration."""

    <<[[Config]] methods>>
@



<<[[Config]] methods>>=
def get(self, section, name):
    """Retrieve the contents of a configuration setting.

    :param section: Tuple with section name and optional subsection namee
    :param subsection: Subsection name
    :return: Contents of the setting
    :raise KeyError: if the value is not set
    """
    raise NotImplementedError(self.get)
@

<<[[Config]] methods>>=
def get_boolean(self, section, name, default=None):
    """Retrieve a configuration setting as boolean.

    :param section: Tuple with section name and optional subsection namee
    :param name: Name of the setting, including section and possible
        subsection.
    :return: Contents of the setting
    :raise KeyError: if the value is not set
    """
    try:
        value = self.get(section, name)
    except KeyError:
        return default
    if value.lower() == b"true":
        return True
    elif value.lower() == b"false":
        return False
    raise ValueError("not a valid boolean string: %r" % value)
@

<<[[Config]] methods>>=
def set(self, section, name, value):
    """Set a configuration value.

    :param section: Tuple with section name and optional subsection namee
    :param name: Name of the configuration value, including section
        and optional subsection
    :param: Value of the setting
    """
    raise NotImplementedError(self.set)
@

<<[[Config]] methods>>=
def iteritems(self, section):
    """Iterate over the configuration pairs for a specific section.

    :param section: Tuple with section name and optional subsection namee
    :return: Iterator over (name, value) pairs
    """
    raise NotImplementedError(self.iteritems)
@

<<[[Config]] methods>>=
def itersections(self):
    """Iterate over the sections.

    :return: Iterator over section tuples
    """
    raise NotImplementedError(self.itersections)
@

<<[[Config]] methods>>=
def has_section(self, name):
    """Check if a specified section exists.

    :param name: Name of section to check for
    :return: boolean indicating whether the section exists
    """
    return (name in self.itersections())
@

<<[[ConfigDict]] methods>>=
def __init__(self, values=None):
    """Create a new ConfigDict."""
    if values is None:
        values = OrderedDict()
    self._values = values
@


<<[[ConfigDict]] methods>>=
def __eq__(self, other):
    return (
        isinstance(other, self.__class__) and
        other._values == self._values)

@

<<[[ConfigDict]] methods>>=
def __getitem__(self, key):
    return self._values.__getitem__(key)

@

<<[[ConfigDict]] methods>>=
def __setitem__(self, key, value):
    return self._values.__setitem__(key, value)

@

<<[[ConfigDict]] methods>>=
def __delitem__(self, key):
    return self._values.__delitem__(key)

@

<<[[ConfigDict]] methods>>=
def __iter__(self):
    return self._values.__iter__()

@

<<[[ConfigDict]] methods>>=
def __len__(self):
    return self._values.__len__()

@

<<[[ConfigDict]] methods>>=
@classmethod
def _parse_setting(cls, name):
    parts = name.split(".")
    if len(parts) == 3:
        return (parts[0], parts[1], parts[2])
    else:
        return (parts[0], None, parts[1])

@

<<[[ConfigDict]] methods>>=
def get(self, section, name):
    if not isinstance(section, tuple):
        section = (section, )
    if len(section) > 1:
        try:
            return self._values[section][name]
        except KeyError:
            pass
    return self._values[(section[0],)][name]

@

<<[[ConfigDict]] methods>>=
def set(self, section, name, value):
    if not isinstance(section, tuple):
        section = (section, )
    if not isinstance(name, bytes):
        raise TypeError(name)
    if type(value) not in (bool, bytes):
        raise TypeError(value)
    self._values.setdefault(section, OrderedDict())[name] = value

@

<<[[ConfigDict]] methods>>=
def iteritems(self, section):
    return self._values.get(section, OrderedDict()).items()

@

<<[[ConfigDict]] methods>>=
def itersections(self):
    return self._values.keys()
@



\subsubsection{Parsing}

<<[[ConfigFile]] methods>>=
@classmethod
def from_file(cls, f):
    """Read configuration from a file-like object."""
    ret = cls()
    section = None
    setting = None
    for lineno, line in enumerate(f.readlines()):
        line = line.lstrip()
        if setting is None:
            # Parse section header ("[bla]")
            if len(line) > 0 and line[:1] == b"[":
                line = _strip_comments(line).rstrip()
                last = line.index(b"]")
                if last == -1:
                    raise ValueError("expected trailing ]")
                pts = line[1:last].split(b" ", 1)
                line = line[last+1:]
                pts[0] = pts[0].lower()
                if len(pts) == 2:
                    if pts[1][:1] != b"\"" or pts[1][-1:] != b"\"":
                        raise ValueError(
                            "Invalid subsection %r" % pts[1])
                    else:
                        pts[1] = pts[1][1:-1]
                    if not _check_section_name(pts[0]):
                        raise ValueError("invalid section name %r" %
                                         pts[0])
                    section = (pts[0], pts[1])
                else:
                    if not _check_section_name(pts[0]):
                        raise ValueError(
                            "invalid section name %r" % pts[0])
                    pts = pts[0].split(b".", 1)
                    if len(pts) == 2:
                        section = (pts[0], pts[1])
                    else:
                        section = (pts[0], )
                ret._values[section] = OrderedDict()
            if _strip_comments(line).strip() == b"":
                continue
            if section is None:
                raise ValueError("setting %r without section" % line)
            try:
                setting, value = line.split(b"=", 1)
            except ValueError:
                setting = line
                value = b"true"
            setting = setting.strip().lower()
            if not _check_variable_name(setting):
                raise ValueError("invalid variable name %s" % setting)
            if value.endswith(b"\\\n"):
                continuation = value[:-2]
            else:
                continuation = None
                value = _parse_string(value)
                ret._values[section][setting] = value
                setting = None
        else:  # continuation line
            if line.endswith(b"\\\n"):
                continuation += line[:-2]
            else:
                continuation += line
                value = _parse_string(continuation)
                ret._values[section][setting] = value
                continuation = None
                setting = None
    return ret
@

<<function config._strip_comments>>=
def _strip_comments(line):
    line = line.split(b"#")[0]
    line = line.split(b";")[0]
    return line
@

<<function config._check_variable_name>>=
def _check_variable_name(name):
    for i in range(len(name)):
        c = name[i:i+1]
        if not c.isalnum() and c != b'-':
            return False
    return True
@

<<function config._check_section_name>>=
def _check_section_name(name):
    for i in range(len(name)):
        c = name[i:i+1]
        if not c.isalnum() and c not in (b'-', b'.'):
            return False
    return True
@

<<function config._parse_string>>=
def _parse_string(value):
    value = bytearray(value.strip())
    ret = bytearray()
    whitespace = bytearray()
    in_quotes = False
    i = 0
    while i < len(value):
        c = value[i]
        if c == ord(b"\\"):
            i += 1
            try:
                v = _ESCAPE_TABLE[value[i]]
            except IndexError:
                raise ValueError(
                    "escape character in %r at %d before end of string" %
                    (value, i))
            except KeyError:
                raise ValueError(
                    "escape character followed by unknown character "
                    "%s at %d in %r" % (value[i], i, value))
            if whitespace:
                ret.extend(whitespace)
                whitespace = bytearray()
            ret.append(v)
        elif c == ord(b"\""):
            in_quotes = (not in_quotes)
        elif c in _COMMENT_CHARS and not in_quotes:
            # the rest of the line is a comment
            break
        elif c in _WHITESPACE_CHARS:
            whitespace.append(c)
        else:
            if whitespace:
                ret.extend(whitespace)
                whitespace = bytearray()
            ret.append(c)
        i += 1

    if in_quotes:
        raise ValueError("missing end quote")

    return bytes(ret)
@

<<constant config._ESCAPE_TABLE>>=
_ESCAPE_TABLE = {
    ord(b"\\"): ord(b"\\"),
    ord(b"\""): ord(b"\""),
    ord(b"n"): ord(b"\n"),
    ord(b"t"): ord(b"\t"),
    ord(b"b"): ord(b"\b"),
    }
@
<<constant config._COMMENT_CHARS>>=
_COMMENT_CHARS = [ord(b"#"), ord(b";")]
@
<<constant config._WHITESPACE_CHARS>>=
_WHITESPACE_CHARS = [ord(b"\t"), ord(b" ")]
@

<<[[ConfigFile]] methods>>=
@classmethod
def from_path(cls, path):
    """Read configuration from a file on disk."""
    with GitFile(path, 'rb') as f:
        ret = cls.from_file(f)
        ret.path = path
        return ret
@

\subsubsection{Writing}

<<[[ConfigFile]] methods>>=
def write_to_path(self, path=None):
    """Write configuration to a file on disk."""
    if path is None:
        path = self.path
    with GitFile(path, 'wb') as f:
        self.write_to_file(f)
@

<<[[ConfigFile]] methods>>=
def write_to_file(self, f):
    """Write configuration to a file-like object."""
    for section, values in self._values.items():
        try:
            section_name, subsection_name = section
        except ValueError:
            (section_name, ) = section
            subsection_name = None
        if subsection_name is None:
            f.write(b"[" + section_name + b"]\n")
        else:
            f.write(b"[" + section_name +
                    b" \"" + subsection_name + b"\"]\n")
        for key, value in values.items():
            if value is True:
                value = b"true"
            elif value is False:
                value = b"false"
            else:
                value = _format_string(value)
            f.write(b"\t" + key + b" = " + value + b"\n")
@

<<function config._format_string>>=
def _format_string(value):
    if (value.startswith(b" ") or
            value.startswith(b"\t") or
            value.endswith(b" ") or
            b'#' in value or
            value.endswith(b"\t")):
        return b'"' + _escape_value(value) + b'"'
    else:
        return _escape_value(value)
@

<<function config._escape_value>>=
def _escape_value(value):
    """Escape a value."""
    value = value.replace(b"\\", b"\\\\")
    value = value.replace(b"\n", b"\\n")
    value = value.replace(b"\t", b"\\t")
    value = value.replace(b"\"", b"\\\"")
    return value
@



\subsubsection{Stacked config, [[~/.gitconfig]] and [[.git/config]]}

<<class StackedConfig>>=
class StackedConfig(Config):
    """Configuration which reads from multiple config files.."""

    <<[[StackedConfig]] methods>>
@

<<[[StackedConfig]] methods>>=
def __init__(self, backends, writable=None):
    self.backends = backends
    self.writable = writable
@


<<[[StackedConfig]] methods>>=
@classmethod
def default_backends(cls):
    """Retrieve the default configuration.

    See git-config(1) for details on the files searched.
    """
    paths = []
    paths.append(os.path.expanduser("~/.gitconfig"))

    xdg_config_home = os.environ.get(
        "XDG_CONFIG_HOME", os.path.expanduser("~/.config/"),
    )
    paths.append(os.path.join(xdg_config_home, "git", "config"))

    if "GIT_CONFIG_NOSYSTEM" not in os.environ:
        paths.append("/etc/gitconfig")

    backends = []
    for path in paths:
        try:
            cf = ConfigFile.from_path(path)
        except (IOError, OSError) as e:
            if e.errno != errno.ENOENT:
                raise
            else:
                continue
        backends.append(cf)
    return backends

@

<<[[StackedConfig]] methods>>=
def get(self, section, name):
    for backend in self.backends:
        try:
            return backend.get(section, name)
        except KeyError:
            pass
    raise KeyError(name)

@

<<[[StackedConfig]] methods>>=
def set(self, section, name, value):
    if self.writable is None:
        raise NotImplementedError(self.set)
    return self.writable.set(section, name, value)
@

<<function config.parse_submodules>>=
def parse_submodules(config):
    """Parse a gitmodules GitConfig file, returning submodules.

   :param config: A `ConfigFile`
   :return: list of tuples (submodule path, url, name),
       where name is quoted part of the section's name.
    """
    for section in config.keys():
        section_kind, section_name = section
        if section_kind == b'submodule':
            sm_path = config.get(section, b'path')
            sm_url = config.get(section, b'url')
            yield (sm_path, sm_url, section_name)
@


\subsection{Ignore file, [[.gitignore]]}


% Seems unused though ... many os.walk do not filter files based
% on information in .ignore I think.

<<class IgnoreFilter>>=
class IgnoreFilter(object):

    def __init__(self, patterns):
        self._patterns = []
        for pattern in patterns:
            self.append_pattern(pattern)

    def append_pattern(self, pattern):
        """Add a pattern to the set."""
        self._patterns.append(pattern)

    def is_ignored(self, path):
        """Check whether a path is ignored.

        For directories, include a trailing slash.

        :return: None if file is not mentioned, True if it is included, False
            if it is explicitly excluded.
        """
        status = None
        for pattern in self._patterns:
            if pattern[0:1] == b'!':
                if match_pattern(path, pattern[1:]):
                    status = False
            else:
                if pattern[0:1] == b'\\':
                    pattern = pattern[1:]
                if match_pattern(path, pattern):
                    status = True
        return status

@

<<function ignore.match_pattern>>=
def match_pattern(path, pattern):
    """Match a gitignore-style pattern against a path.

    :param path: Path to match
    :param pattern: Pattern to match
    :return: bool indicating whether the pattern matched
    """
    re_pattern = translate(pattern)
    return re.match(re_pattern, path)
@


<<function ignore.translate>>=
def translate(pat):
    """Translate a shell PATTERN to a regular expression.

    There is no way to quote meta-characters.

    Originally copied from fnmatch in Python 2.7, but modified for Dulwich
    to cope with features in Git ignore patterns.
    """

    res = b'(?ms)'

    if b'/' not in pat[:-1]:
        # If there's no slash, this is a filename-based match
        res = res + b'(.*/)?'

    if pat.startswith(b'**/'):
        # Leading **/
        pat = pat[2:]
        res = res + b'(.*/)?'

    if pat.startswith(b'/'):
        pat = pat[1:]

    i, n = 0, len(pat)

    while i < n:
        if pat[i:i+3] == b'/**':
            res = res + b'(/.*)?'
            i = i+3
            continue
        c = pat[i:i+1]
        i = i+1
        if c == b'*':
            res = res + b'[^/]+'
        elif c == b'?':
            res = res + b'.'
        elif c == b'[':
            j = i
            if j < n and pat[j:j+1] == b'!':
                j = j+1
            if j < n and pat[j:j+1] == b']':
                j = j+1
            while j < n and pat[j:j+1] != b']':
                j = j+1
            if j >= n:
                res = res + b'\\['
            else:
                stuff = pat[i:j].replace(b'\\', b'\\\\')
                i = j+1
                if stuff.startswith(b'!'):
                    stuff = b'^' + stuff[1:]
                elif stuff.startswith(b'^'):
                    stuff = b'\\' + stuff
                res = res + b'[' + stuff + b']'
        else:
            res = res + re.escape(c)

    if not res.endswith(b'/'):
        res = res + b'/?'

    return res + b'\Z'
@

<<class IgnoreFilterStack>>=
class IgnoreFilterStack(object):
    """Check for ignore status in multiple filters."""

    def __init__(self, filters):
        self._filters = filters

    def is_ignored(self, path):
        """Check whether a path is explicitly included or excluded in ignores.

        :param path: Path to check
        :return: None if the file is not mentioned, True if it is included,
            False if it is explicitly excluded.
        """
        status = None
        for filter in self._filters:
            status = filter.is_ignored(path)
            if status is not None:
                return status
        return status
@

%\section{Advanced diff capabilities}
\subsection{Rename detection}

<<[[Walker.__init__()]] rename detector setting>>=
if follow and not rename_detector:
    rename_detector = RenameDetector(store)
self.rename_detector = rename_detector
self.follow = follow
@

<<[[diff_tree.tree_changes()]] if rename detection>>=
if (rename_detector is not None and tree1_id is not None and
        tree2_id is not None):
    for change in rename_detector.changes_with_renames(
            tree1_id, tree2_id, want_unchanged=want_unchanged):
        yield change
    return
@

<<class RenameDetector>>=
class RenameDetector(object):
    """Object for handling rename detection between two trees."""

    def __init__(self, store, rename_threshold=RENAME_THRESHOLD,
                 max_files=MAX_FILES,
                 rewrite_threshold=REWRITE_THRESHOLD,
                 find_copies_harder=False):
        """Initialize the rename detector.

        :param store: An ObjectStore for looking up objects.
        :param rename_threshold: The threshold similarity score for considering
            an add/delete pair to be a rename/copy; see _similarity_score.
        :param max_files: The maximum number of adds and deletes to consider,
            or None for no limit. The detector is guaranteed to compare no more
            than max_files ** 2 add/delete pairs. This limit is provided
            because rename detection can be quadratic in the project size. If
            the limit is exceeded, no content rename detection is attempted.
        :param rewrite_threshold: The threshold similarity score below which a
            modify should be considered a delete/add, or None to not break
            modifies; see _similarity_score.
        :param find_copies_harder: If True, consider unmodified files when
            detecting copies.
        """
        self._store = store
        self._rename_threshold = rename_threshold
        self._rewrite_threshold = rewrite_threshold
        self._max_files = max_files
        self._find_copies_harder = find_copies_harder
        self._want_unchanged = False

    def _reset(self):
        self._adds = []
        self._deletes = []
        self._changes = []

    def _should_split(self, change):
        if (self._rewrite_threshold is None or change.type != CHANGE_MODIFY or
                change.old.sha == change.new.sha):
            return False
        old_obj = self._store[change.old.sha]
        new_obj = self._store[change.new.sha]
        return _similarity_score(old_obj, new_obj) < self._rewrite_threshold

    def _add_change(self, change):
        if change.type == CHANGE_ADD:
            self._adds.append(change)
        elif change.type == CHANGE_DELETE:
            self._deletes.append(change)
        elif self._should_split(change):
            self._deletes.append(TreeChange.delete(change.old))
            self._adds.append(TreeChange.add(change.new))
        elif ((self._find_copies_harder and change.type == CHANGE_UNCHANGED)
              or change.type == CHANGE_MODIFY):
            # Treat all modifies as potential deletes for rename detection,
            # but don't split them (to avoid spurious renames). Setting
            # find_copies_harder means we treat unchanged the same as
            # modified.
            self._deletes.append(change)
        else:
            self._changes.append(change)

    def _collect_changes(self, tree1_id, tree2_id):
        want_unchanged = self._find_copies_harder or self._want_unchanged
        for change in tree_changes(self._store, tree1_id, tree2_id,
                                   want_unchanged=want_unchanged):
            self._add_change(change)

    def _prune(self, add_paths, delete_paths):
        self._adds = [a for a in self._adds if a.new.path not in add_paths]
        self._deletes = [d for d in self._deletes
                         if d.old.path not in delete_paths]

    def _find_exact_renames(self):
        add_map = defaultdict(list)
        for add in self._adds:
            add_map[add.new.sha].append(add.new)
        delete_map = defaultdict(list)
        for delete in self._deletes:
            # Keep track of whether the delete was actually marked as a delete.
            # If not, it needs to be marked as a copy.
            is_delete = delete.type == CHANGE_DELETE
            delete_map[delete.old.sha].append((delete.old, is_delete))

        add_paths = set()
        delete_paths = set()
        for sha, sha_deletes in delete_map.items():
            sha_adds = add_map[sha]
            for (old, is_delete), new in zip(sha_deletes, sha_adds):
                if stat.S_IFMT(old.mode) != stat.S_IFMT(new.mode):
                    continue
                if is_delete:
                    delete_paths.add(old.path)
                add_paths.add(new.path)
                new_type = is_delete and CHANGE_RENAME or CHANGE_COPY
                self._changes.append(TreeChange(new_type, old, new))

            num_extra_adds = len(sha_adds) - len(sha_deletes)
            # TODO(dborowitz): Less arbitrary way of dealing with extra copies.
            old = sha_deletes[0][0]
            if num_extra_adds > 0:
                for new in sha_adds[-num_extra_adds:]:
                    add_paths.add(new.path)
                    self._changes.append(TreeChange(CHANGE_COPY, old, new))
        self._prune(add_paths, delete_paths)

    def _should_find_content_renames(self):
        return len(self._adds) * len(self._deletes) <= self._max_files ** 2

    def _rename_type(self, check_paths, delete, add):
        if check_paths and delete.old.path == add.new.path:
            # If the paths match, this must be a split modify, so make sure it
            # comes out as a modify.
            return CHANGE_MODIFY
        elif delete.type != CHANGE_DELETE:
            # If it's in deletes but not marked as a delete, it must have been
            # added due to find_copies_harder, and needs to be marked as a
            # copy.
            return CHANGE_COPY
        return CHANGE_RENAME

    def _find_content_rename_candidates(self):
        candidates = self._candidates = []
        # TODO: Optimizations:
        #  - Compare object sizes before counting blocks.
        #  - Skip if delete's S_IFMT differs from all adds.
        #  - Skip if adds or deletes is empty.
        # Match C git's behavior of not attempting to find content renames if
        # the matrix size exceeds the threshold.
        if not self._should_find_content_renames():
            return

        block_cache = {}
        check_paths = self._rename_threshold is not None
        for delete in self._deletes:
            if S_ISGITLINK(delete.old.mode):
                continue  # Git links don't exist in this repo.
            old_sha = delete.old.sha
            old_obj = self._store[old_sha]
            block_cache[old_sha] = _count_blocks(old_obj)
            for add in self._adds:
                if stat.S_IFMT(delete.old.mode) != stat.S_IFMT(add.new.mode):
                    continue
                new_obj = self._store[add.new.sha]
                score = _similarity_score(old_obj, new_obj,
                                          block_cache=block_cache)
                if score > self._rename_threshold:
                    new_type = self._rename_type(check_paths, delete, add)
                    rename = TreeChange(new_type, delete.old, add.new)
                    candidates.append((-score, rename))

    def _choose_content_renames(self):
        # Sort scores from highest to lowest, but keep names in ascending
        # order.
        self._candidates.sort()

        delete_paths = set()
        add_paths = set()
        for _, change in self._candidates:
            new_path = change.new.path
            if new_path in add_paths:
                continue
            old_path = change.old.path
            orig_type = change.type
            if old_path in delete_paths:
                change = TreeChange(CHANGE_COPY, change.old, change.new)

            # If the candidate was originally a copy, that means it came from a
            # modified or unchanged path, so we don't want to prune it.
            if orig_type != CHANGE_COPY:
                delete_paths.add(old_path)
            add_paths.add(new_path)
            self._changes.append(change)
        self._prune(add_paths, delete_paths)

    def _join_modifies(self):
        if self._rewrite_threshold is None:
            return

        modifies = {}
        delete_map = dict((d.old.path, d) for d in self._deletes)
        for add in self._adds:
            path = add.new.path
            delete = delete_map.get(path)
            if (delete is not None and
                    stat.S_IFMT(delete.old.mode) == stat.S_IFMT(add.new.mode)):
                modifies[path] = TreeChange(CHANGE_MODIFY, delete.old, add.new)

        self._adds = [a for a in self._adds if a.new.path not in modifies]
        self._deletes = [a for a in self._deletes if a.new.path not in
                         modifies]
        self._changes += modifies.values()

    def _sorted_changes(self):
        result = []
        result.extend(self._adds)
        result.extend(self._deletes)
        result.extend(self._changes)
        result.sort(key=_tree_change_key)
        return result

    def _prune_unchanged(self):
        if self._want_unchanged:
            return
        self._deletes = [
            d for d in self._deletes if d.type != CHANGE_UNCHANGED]

    def changes_with_renames(self, tree1_id, tree2_id, want_unchanged=False):
        """Iterate TreeChanges between two tree SHAs, with rename detection."""
        self._reset()
        self._want_unchanged = want_unchanged
        self._collect_changes(tree1_id, tree2_id)
        self._find_exact_renames()
        self._find_content_rename_candidates()
        self._choose_content_renames()
        self._join_modifies()
        self._prune_unchanged()
        return self._sorted_changes()

@

<<function diff_tree._tree_change_key>>=
def _tree_change_key(entry):
    # Sort by old path then new path. If only one exists, use it for both keys.
    path1 = entry.old.path
    path2 = entry.new.path
    if path1 is None:
        path1 = path2
    if path2 is None:
        path2 = path1
    return (path1, path2)
@

<<constant diff_tree.MAX_FILES>>=
MAX_FILES = 200
@

<<constant diff_tree._MAX_SCORE>>=
_MAX_SCORE = 100
@

<<constant diff_tree.RENAME_THRESHOLD>>=
RENAME_THRESHOLD = 60
@
<<constant diff_tree.REWRITE_THRESHOLD>>=
REWRITE_THRESHOLD = None
@

<<function diff_tree._similarity_score>>=
def _similarity_score(obj1, obj2, block_cache=None):
    """Compute a similarity score for two objects.

    :param obj1: The first object to score.
    :param obj2: The second object to score.
    :param block_cache: An optional dict of SHA to block counts to cache
        results between calls.
    :return: The similarity score between the two objects, defined as the
        number of bytes in common between the two objects divided by the
        maximum size, scaled to the range 0-100.
    """
    if block_cache is None:
        block_cache = {}
    if obj1.id not in block_cache:
        block_cache[obj1.id] = _count_blocks(obj1)
    if obj2.id not in block_cache:
        block_cache[obj2.id] = _count_blocks(obj2)

    common_bytes = _common_bytes(block_cache[obj1.id], block_cache[obj2.id])
    max_size = max(obj1.raw_length(), obj2.raw_length())
    if not max_size:
        return _MAX_SCORE
    return int(float(common_bytes) * _MAX_SCORE / max_size)
@

<<function diff_tree._common_bytes>>=
def _common_bytes(blocks1, blocks2):
    """Count the number of common bytes in two block count dicts.

    :param block1: The first dict of block hashcode -> total bytes.
    :param block2: The second dict of block hashcode -> total bytes.
    :return: The number of bytes in common between blocks1 and blocks2. This is
        only approximate due to possible hash collisions.
    """
    # Iterate over the smaller of the two dicts, since this is symmetrical.
    if len(blocks1) > len(blocks2):
        blocks1, blocks2 = blocks2, blocks1
    score = 0
    for block, count1 in blocks1.items():
        count2 = blocks2.get(block)
        if count2:
            score += min(count1, count2)
    return score
@

<<constant diff_tree._BLOCK_SIZE>>=
_BLOCK_SIZE = 64
@

<<function diff_tree._count_blocks>>=
def _count_blocks(obj):
    """Count the blocks in an object.

    Splits the data into blocks either on lines or <=64-byte chunks of lines.

    :param obj: The object to count blocks for.
    :return: A dict of block hashcode -> total bytes occurring.
    """
    block_counts = defaultdict(int)
    block = BytesIO()
    n = 0

    # Cache attrs as locals to avoid expensive lookups in the inner loop.
    block_write = block.write
    block_seek = block.seek
    block_truncate = block.truncate
    block_getvalue = block.getvalue

    for c in chain(*obj.as_raw_chunks()):
        if sys.version_info[0] == 3:
            c = c.to_bytes(1, 'big')
        block_write(c)
        n += 1
        if c == b'\n' or n == _BLOCK_SIZE:
            value = block_getvalue()
            block_counts[hash(value)] += len(value)
            block_seek(0)
            block_truncate()
            n = 0
    if n > 0:
        last_block = block_getvalue()
        block_counts[hash(last_block)] += len(last_block)
    return block_counts
@


% also used for git log, when go back in history and you asked
%  git log /path/to/file 
% we want to then track /path/to/old/file if we detected
% this file was renamed at some point.

<<[[Walker._change_matches()]] if follow, remember renamed file>>=
if self.follow and change.type in RENAME_CHANGE_TYPES:
    self.paths.add(old_path)
    self.paths.remove(new_path)
@

\section{Optimizations}

\subsection{LRU cache}

% Needs that for?

<<constant lru_cache._null_key>>=
_null_key = object()
@

<<class _LRUNode>>=
class _LRUNode(object):
    """This maintains the linked-list which is the lru internals."""

    __slots__ = ('prev', 'next_key', 'key', 'value', 'cleanup', 'size')

    def __init__(self, key, value, cleanup=None):
        self.prev = None
        self.next_key = _null_key
        self.key = key
        self.value = value
        self.cleanup = cleanup
        # TODO: We could compute this 'on-the-fly' like we used to, and remove
        #       one pointer from this object, we just need to decide if it
        #       actually costs us much of anything in normal usage
        self.size = None

    def __repr__(self):
        if self.prev is None:
            prev_key = None
        else:
            prev_key = self.prev.key
        return '%s(%r n:%r p:%r)' % (self.__class__.__name__, self.key,
                                     self.next_key, prev_key)

    def run_cleanup(self):
        if self.cleanup is not None:
            self.cleanup(self.key, self.value)
        self.cleanup = None
        # Just make sure to break any refcycles, etc
        self.value = None
@

<<class LRUCache>>=
class LRUCache(object):
    """A class which manages a cache of entries, removing unused ones."""

    def __init__(self, max_cache=100, after_cleanup_count=None):
        self._cache = {}
        # The "HEAD" of the lru linked list
        self._most_recently_used = None
        # The "TAIL" of the lru linked list
        self._least_recently_used = None
        self._update_max_cache(max_cache, after_cleanup_count)

    def __contains__(self, key):
        return key in self._cache

    def __getitem__(self, key):
        cache = self._cache
        node = cache[key]
        # Inlined from _record_access to decrease the overhead of __getitem__
        # We also have more knowledge about structure if __getitem__ is
        # succeeding, then we know that self._most_recently_used must not be
        # None, etc.
        mru = self._most_recently_used
        if node is mru:
            # Nothing to do, this node is already at the head of the queue
            return node.value
        # Remove this node from the old location
        node_prev = node.prev
        next_key = node.next_key
        # benchmarking shows that the lookup of _null_key in globals is faster
        # than the attribute lookup for (node is self._least_recently_used)
        if next_key is _null_key:
            # 'node' is the _least_recently_used, because it doesn't have a
            # 'next' item. So move the current lru to the previous node.
            self._least_recently_used = node_prev
        else:
            node_next = cache[next_key]
            node_next.prev = node_prev
        node_prev.next_key = next_key
        # Insert this node at the front of the list
        node.next_key = mru.key
        mru.prev = node
        self._most_recently_used = node
        node.prev = None
        return node.value

    def __len__(self):
        return len(self._cache)

    def _walk_lru(self):
        """Walk the LRU list, only meant to be used in tests."""
        node = self._most_recently_used
        if node is not None:
            if node.prev is not None:
                raise AssertionError('the _most_recently_used entry is not'
                                     ' supposed to have a previous entry'
                                     ' %s' % (node,))
        while node is not None:
            if node.next_key is _null_key:
                if node is not self._least_recently_used:
                    raise AssertionError('only the last node should have'
                                         ' no next value: %s' % (node,))
                node_next = None
            else:
                node_next = self._cache[node.next_key]
                if node_next.prev is not node:
                    raise AssertionError('inconsistency found, node.next.prev'
                                         ' != node: %s' % (node,))
            if node.prev is None:
                if node is not self._most_recently_used:
                    raise AssertionError('only the _most_recently_used should'
                                         ' not have a previous node: %s'
                                         % (node,))
            else:
                if node.prev.next_key != node.key:
                    raise AssertionError('inconsistency found, node.prev.next'
                                         ' != node: %s' % (node,))
            yield node
            node = node_next

    def add(self, key, value, cleanup=None):
        """Add a new value to the cache.

        Also, if the entry is ever removed from the cache, call
        cleanup(key, value).

        :param key: The key to store it under
        :param value: The object to store
        :param cleanup: None or a function taking (key, value) to indicate
                        'value' should be cleaned up.
        """
        if key is _null_key:
            raise ValueError('cannot use _null_key as a key')
        if key in self._cache:
            node = self._cache[key]
            node.run_cleanup()
            node.value = value
            node.cleanup = cleanup
        else:
            node = _LRUNode(key, value, cleanup=cleanup)
            self._cache[key] = node
        self._record_access(node)

        if len(self._cache) > self._max_cache:
            # Trigger the cleanup
            self.cleanup()

    def cache_size(self):
        """Get the number of entries we will cache."""
        return self._max_cache

    def get(self, key, default=None):
        node = self._cache.get(key, None)
        if node is None:
            return default
        self._record_access(node)
        return node.value

    def keys(self):
        """Get the list of keys currently cached.

        Note that values returned here may not be available by the time you
        request them later. This is simply meant as a peak into the current
        state.

        :return: An unordered list of keys that are currently cached.
        """
        return self._cache.keys()

    def items(self):
        """Get the key:value pairs as a dict."""
        return dict((k, n.value) for k, n in self._cache.items())

    def cleanup(self):
        """Clear the cache until it shrinks to the requested size.

        This does not completely wipe the cache, just makes sure it is under
        the after_cleanup_count.
        """
        # Make sure the cache is shrunk to the correct size
        while len(self._cache) > self._after_cleanup_count:
            self._remove_lru()

    def __setitem__(self, key, value):
        """Add a value to the cache, there will be no cleanup function."""
        self.add(key, value, cleanup=None)

    def _record_access(self, node):
        """Record that key was accessed."""
        # Move 'node' to the front of the queue
        if self._most_recently_used is None:
            self._most_recently_used = node
            self._least_recently_used = node
            return
        elif node is self._most_recently_used:
            # Nothing to do, this node is already at the head of the queue
            return
        # We've taken care of the tail pointer, remove the node, and insert it
        # at the front
        # REMOVE
        if node is self._least_recently_used:
            self._least_recently_used = node.prev
        if node.prev is not None:
            node.prev.next_key = node.next_key
        if node.next_key is not _null_key:
            node_next = self._cache[node.next_key]
            node_next.prev = node.prev
        # INSERT
        node.next_key = self._most_recently_used.key
        self._most_recently_used.prev = node
        self._most_recently_used = node
        node.prev = None

    def _remove_node(self, node):
        if node is self._least_recently_used:
            self._least_recently_used = node.prev
        self._cache.pop(node.key)
        # If we have removed all entries, remove the head pointer as well
        if self._least_recently_used is None:
            self._most_recently_used = None
        node.run_cleanup()
        # Now remove this node from the linked list
        if node.prev is not None:
            node.prev.next_key = node.next_key
        if node.next_key is not _null_key:
            node_next = self._cache[node.next_key]
            node_next.prev = node.prev
        # And remove this node's pointers
        node.prev = None
        node.next_key = _null_key

    def _remove_lru(self):
        """Remove one entry from the lru, and handle consequences.

        If there are no more references to the lru, then this entry should be
        removed from the cache.
        """
        self._remove_node(self._least_recently_used)

    def clear(self):
        """Clear out all of the cache."""
        # Clean up in LRU order
        while self._cache:
            self._remove_lru()

    def resize(self, max_cache, after_cleanup_count=None):
        """Change the number of entries that will be cached."""
        self._update_max_cache(max_cache,
                               after_cleanup_count=after_cleanup_count)

    def _update_max_cache(self, max_cache, after_cleanup_count=None):
        self._max_cache = max_cache
        if after_cleanup_count is None:
            self._after_cleanup_count = self._max_cache * 8 / 10
        else:
            self._after_cleanup_count = min(after_cleanup_count,
                                            self._max_cache)
        self.cleanup()
@

<<class LRUSizeCache>>=
class LRUSizeCache(LRUCache):
    """An LRUCache that removes things based on the size of the values.

    This differs in that it doesn't care how many actual items there are,
    it just restricts the cache to be cleaned up after so much data is stored.

    The size of items added will be computed using compute_size(value), which
    defaults to len() if not supplied.
    """

    def __init__(self, max_size=1024*1024, after_cleanup_size=None,
                 compute_size=None):
        """Create a new LRUSizeCache.

        :param max_size: The max number of bytes to store before we start
            clearing out entries.
        :param after_cleanup_size: After cleaning up, shrink everything to this
            size.
        :param compute_size: A function to compute the size of the values. We
            use a function here, so that you can pass 'len' if you are just
            using simple strings, or a more complex function if you are using
            something like a list of strings, or even a custom object.
            The function should take the form "compute_size(value) => integer".
            If not supplied, it defaults to 'len()'
        """
        self._value_size = 0
        self._compute_size = compute_size
        if compute_size is None:
            self._compute_size = len
        self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
        LRUCache.__init__(self, max_cache=max(int(max_size/512), 1))

    def add(self, key, value, cleanup=None):
        """Add a new value to the cache.

        Also, if the entry is ever removed from the cache, call
        cleanup(key, value).

        :param key: The key to store it under
        :param value: The object to store
        :param cleanup: None or a function taking (key, value) to indicate
                        'value' should be cleaned up.
        """
        if key is _null_key:
            raise ValueError('cannot use _null_key as a key')
        node = self._cache.get(key, None)
        value_len = self._compute_size(value)
        if value_len >= self._after_cleanup_size:
            # The new value is 'too big to fit', as it would fill up/overflow
            # the cache all by itself
            if node is not None:
                # We won't be replacing the old node, so just remove it
                self._remove_node(node)
            if cleanup is not None:
                cleanup(key, value)
            return
        if node is None:
            node = _LRUNode(key, value, cleanup=cleanup)
            self._cache[key] = node
        else:
            self._value_size -= node.size
        node.size = value_len
        self._value_size += value_len
        self._record_access(node)

        if self._value_size > self._max_size:
            # Time to cleanup
            self.cleanup()

    def cleanup(self):
        """Clear the cache until it shrinks to the requested size.

        This does not completely wipe the cache, just makes sure it is under
        the after_cleanup_size.
        """
        # Make sure the cache is shrunk to the correct size
        while self._value_size > self._after_cleanup_size:
            self._remove_lru()

    def _remove_node(self, node):
        self._value_size -= node.size
        LRUCache._remove_node(self, node)

    def resize(self, max_size, after_cleanup_size=None):
        """Change the number of bytes that will be cached."""
        self._update_max_size(max_size, after_cleanup_size=after_cleanup_size)
        max_cache = max(int(max_size/512), 1)
        self._update_max_cache(max_cache)

    def _update_max_size(self, max_size, after_cleanup_size=None):
        self._max_size = max_size
        if after_cleanup_size is None:
            self._after_cleanup_size = self._max_size * 8 // 10
        else:
            self._after_cleanup_size = min(after_cleanup_size, self._max_size)
@

\section{Pack}

% kinda an optimization.
% Complex code.

<<constant object_store.PACKDIR>>=
PACKDIR = 'pack'
@

%https://git-scm.com/book/en/v2/Git-Internals-Packfiles

\subsection{[[Pack]]}

<<class Pack>>=
class Pack(object):
    """A Git pack object."""

    <<[[Pack]] methods>>
@

<<[[Pack]] methods>>=
def __init__(self, basename, resolve_ext_ref=None):
    self._basename = basename

    self._data = None
    self._idx = None

    self._idx_path = self._basename + '.idx'
    self._data_path = self._basename + '.pack'

    self._data_load = lambda: PackData(self._data_path)
    self._idx_load = lambda: load_pack_index(self._idx_path)

    self.resolve_ext_ref = resolve_ext_ref
@

% data and idx.


<<[[Pack]] methods>>=
@classmethod
def from_lazy_objects(self, data_fn, idx_fn):
    """Create a new pack object from callables to load pack data and
    index objects."""
    ret = Pack('')
    ret._data_load = data_fn
    ret._idx_load = idx_fn
    return ret
@

<<[[Pack]] methods>>=
@classmethod
def from_objects(self, data, idx):
    """Create a new pack object from pack data and index objects."""
    ret = Pack('')
    ret._data_load = lambda: data
    ret._idx_load = lambda: idx
    return ret
@

<<[[Pack]] methods>>=
def name(self):
    """The SHA over the SHAs of the objects in this pack."""
    return self.index.objects_sha1()
@

<<[[Pack]] methods>>=
@property
def data(self):
    """The pack data object being used."""
    if self._data is None:
        self._data = self._data_load()
        self._data.pack = self
        self.check_length_and_checksum()
    return self._data
@

<<[[Pack]] methods>>=
@property
def index(self):
    """The index being used.

    :note: This may be an in-memory index
    """
    if self._idx is None:
        self._idx = self._idx_load()
    return self._idx
@

<<[[Pack]] methods>>=
def close(self):
    if self._data is not None:
        self._data.close()
    if self._idx is not None:
        self._idx.close()
@

<<[[Pack]] methods>>=
def __enter__(self):
    return self
@

<<[[Pack]] methods>>=
def __exit__(self, exc_type, exc_val, exc_tb):
    self.close()
@

<<[[Pack]] methods>>=
def __eq__(self, other):
    return isinstance(self, type(other)) and self.index == other.index
@

<<[[Pack]] methods>>=
def __len__(self):
    """Number of entries in this pack."""
    return len(self.index)
@


<<[[Pack]] methods>>=
def __iter__(self):
    """Iterate over all the sha1s of the objects in this pack."""
    return iter(self.index)
@

<<[[Pack]] methods>>=
def check_length_and_checksum(self):
    """Sanity check the length and checksum of the pack index and data."""
    assert len(self.index) == len(self.data)
    idx_stored_checksum = self.index.get_pack_checksum()
    data_stored_checksum = self.data.get_stored_checksum()
    if idx_stored_checksum != data_stored_checksum:
        raise ChecksumMismatch(sha_to_hex(idx_stored_checksum),
                               sha_to_hex(data_stored_checksum))
@

<<[[Pack]] methods>>=
def check(self):
    """Check the integrity of this pack.

    :raise ChecksumMismatch: if a checksum for the index or data is wrong
    """
    self.index.check()
    self.data.check()
    for obj in self.iterobjects():
        obj.check()
    # TODO: object connectivity checks
@

<<[[Pack]] methods>>=
def get_stored_checksum(self):
    return self.data.get_stored_checksum()
@

<<[[Pack]] methods>>=
def __contains__(self, sha1):
    """Check whether this pack contains a particular SHA1."""
    try:
        self.index.object_index(sha1)
        return True
    except KeyError:
        return False
@

<<[[Pack]] methods>>=
def get_raw(self, sha1):
    offset = self.index.object_index(sha1)
    obj_type, obj = self.data.get_object_at(offset)
    type_num, chunks = self.data.resolve_object(offset, obj_type, obj)
    return type_num, b''.join(chunks)
@

<<[[Pack]] methods>>=
def __getitem__(self, sha1):
    """Retrieve the specified SHA1."""
    type, uncomp = self.get_raw(sha1)
    return ShaFile.from_raw_string(type, uncomp, sha=sha1)
@

<<[[Pack]] methods>>=
def iterobjects(self):
    """Iterate over the objects in this pack."""
    return iter(PackInflater.for_pack_data(
        self.data, resolve_ext_ref=self.resolve_ext_ref))
@

<<[[Pack]] methods>>=
def pack_tuples(self):
    """Provide an iterable for use with write_pack_objects.

    :return: Object that can iterate over (object, path) tuples
        and provides __len__
    """
    class PackTupleIterable(object):

        def __init__(self, pack):
            self.pack = pack

        def __len__(self):
            return len(self.pack)

        def __iter__(self):
            return ((o, None) for o in self.pack.iterobjects())

    return PackTupleIterable(self)
@

<<[[Pack]] methods>>=
def keep(self, msg=None):
    """Add a .keep file for the pack, preventing git from garbage collecting it.

    :param msg: A message written inside the .keep file; can be used later
        to determine whether or not a .keep file is obsolete.
    :return: The path of the .keep file, as a string.
    """
    keepfile_name = '%s.keep' % self._basename
    with GitFile(keepfile_name, 'wb') as keepfile:
        if msg:
            keepfile.write(msg)
            keepfile.write(b'\n')
    return keepfile_name
@

\subsection{Reading}

\subsection{Writing}

<<function pack.write_pack>>=
def write_pack(filename, objects, deltify=None, delta_window_size=None):
    """Write a new pack data file.

    :param filename: Path to the new pack file (without .pack extension)
    :param objects: Iterable of (object, path) tuples to write.
        Should provide __len__
    :param window_size: Delta window size
    :param deltify: Whether to deltify pack objects
    :return: Tuple with checksum of pack file and index file
    """
    with GitFile(filename + '.pack', 'wb') as f:
        entries, data_sum = write_pack_objects(
            f, objects, delta_window_size=delta_window_size, deltify=deltify)
    entries = sorted([(k, v[0], v[1]) for (k, v) in entries.items()])
    with GitFile(filename + '.idx', 'wb') as f:
        return data_sum, write_pack_index_v2(f, entries, data_sum)
@

<<function pack.write_pack_header>>=
def write_pack_header(f, num_objects):
    """Write a pack header for the given number of objects."""
    f.write(b'PACK')                          # Pack header
    f.write(struct.pack(b'>L', 2))            # Pack version
    f.write(struct.pack(b'>L', num_objects))  # Number of objects in pack
@

<<function pack.write_pack_object>>=
def write_pack_object(f, type, object, sha=None):
    """Write pack object to a file.

    :param f: File to write to
    :param type: Numeric type of the object
    :param object: Object to write
    :return: Tuple with offset at which the object was written, and crc32
    """
    if type in DELTA_TYPES:
        delta_base, object = object
    else:
        delta_base = None
    header = bytes(pack_object_header(type, delta_base, len(object)))
    comp_data = zlib.compress(object)
    crc32 = 0
    for data in (header, comp_data):
        f.write(data)
        if sha is not None:
            sha.update(data)
        crc32 = binascii.crc32(data, crc32)
    return crc32 & 0xffffffff
@

<<function pack_object_header>>=
def pack_object_header(type_num, delta_base, size):
    """Create a pack object header for the given object info.

    :param type_num: Numeric type of the object.
    :param delta_base: Delta base offset or ref, or None for whole objects.
    :param size: Uncompressed object size.
    :return: A header for a packed object.
    """
    header = []
    c = (type_num << 4) | (size & 15)
    size >>= 4
    while size:
        header.append(c | 0x80)
        c = size & 0x7f
        size >>= 7
    header.append(c)
    if type_num == OFS_DELTA:
        ret = [delta_base & 0x7f]
        delta_base >>= 7
        while delta_base:
            delta_base -= 1
            ret.insert(0, 0x80 | (delta_base & 0x7f))
            delta_base >>= 7
        header.extend(ret)
    elif type_num == REF_DELTA:
        assert len(delta_base) == 20
        header += delta_base
    return bytearray(header)
@

<<function pack.write_pack_objects>>=
def write_pack_objects(f, objects, delta_window_size=None, deltify=False):
    """Write a new pack data file.

    :param f: File to write to
    :param objects: Iterable of (object, path) tuples to write.
        Should provide __len__
    :param window_size: Sliding window size for searching for deltas;
                        Set to None for default window size.
    :param deltify: Whether to deltify objects
    :return: Dict mapping id -> (offset, crc32 checksum), pack checksum
    """
    if deltify:
        pack_contents = deltify_pack_objects(objects, delta_window_size)
    else:
        pack_contents = (
            (o.type_num, o.sha().digest(), None, o.as_raw_string())
            for (o, path) in objects)

    return write_pack_data(f, len(objects), pack_contents)
@

<<function pack.write_pack_data>>=
def write_pack_data(f, num_records, records):
    """Write a new pack data file.

    :param f: File to write to
    :param num_records: Number of records
    :param records: Iterator over type_num, object_id, delta_base, raw
    :return: Dict mapping id -> (offset, crc32 checksum), pack checksum
    """
    # Write the pack
    entries = {}
    f = SHA1Writer(f)
    write_pack_header(f, num_records)
    for type_num, object_id, delta_base, raw in records:
        offset = f.offset()
        if delta_base is not None:
            try:
                base_offset, base_crc32 = entries[delta_base]
            except KeyError:
                type_num = REF_DELTA
                raw = (delta_base, raw)
            else:
                type_num = OFS_DELTA
                raw = (offset - base_offset, raw)
        crc32 = write_pack_object(f, type_num, raw)
        entries[object_id] = (offset, crc32)
    return entries, f.write_sha()
@

<<constant pack.OFS_DELTA>>=
OFS_DELTA = 6
@
<<constant pack.REF_DELTA>>=
REF_DELTA = 7
@

<<constant pack.DELTA_TYPES>>=
DELTA_TYPES = (OFS_DELTA, REF_DELTA)
@

\subsection{Modifications}

\subsubsection{[[ObjectStore]]}

% path at this point is objects dir?
<<[[DiskObjectStore.init()]] create pack dir>>=
os.mkdir(os.path.join(path, PACKDIR))
@

<<[[DiskObjectStore.__init__()]] set pack fields>>=
self.pack_dir = os.path.join(self.path, PACKDIR)
self._pack_cache_time = 0
self._pack_cache = {}
@


<<[[BaseObjectStore]] methods>>=
@property
def packs(self):
    """Iterable of pack objects."""
    raise NotImplementedError

@

<<[[BaseObjectStore]] methods>>=
def contains_packed(self, sha):
    """Check if a particular object is present by SHA1 and is packed."""
    raise NotImplementedError(self.contains_packed)

@


<<[[PackBasedObjectStore]] methods>>=
def contains_packed(self, sha):
    """Check if a particular object is present by SHA1 and is packed.

    This does not check alternates.
    """
    for pack in self.packs:
        if sha in pack:
            return True
    return False

@

<<[[PackBasedObjectStore]] methods>>=
def __contains__(self, sha):
    """Check if a particular object is present by SHA1.

    This method makes no distinction between loose and packed objects.
    """
    if self.contains_packed(sha) or self.contains_loose(sha):
        return True
    for alternate in self.alternates:
        if sha in alternate:
            return True
    return False

@

<<[[PackBasedObjectStore]] methods>>=
def _pack_cache_stale(self):
    """Check whether the pack cache is stale."""
    raise NotImplementedError(self._pack_cache_stale)

@

<<[[PackBasedObjectStore]] methods>>=
def _add_known_pack(self, base_name, pack):
    """Add a newly appeared pack to the cache by path.

    """
    self._pack_cache[base_name] = pack

@

<<[[PackBasedObjectStore]] methods>>=
def close(self):
    pack_cache = self._pack_cache
    self._pack_cache = {}
    while pack_cache:
        (name, pack) = pack_cache.popitem()
        pack.close()

@

<<[[PackBasedObjectStore]] methods>>=
@property
def packs(self):
    """List with pack objects."""
    if self._pack_cache is None or self._pack_cache_stale():
        self._update_pack_cache()

    return self._pack_cache.values()

@

<<[[PackBasedObjectStore]] methods>>=
def _iter_alternate_objects(self):
    """Iterate over the SHAs of all the objects in alternate stores."""
    for alternate in self.alternates:
        for alternate_object in alternate:
            yield alternate_object

@


<<[[PackBasedObjectStore]] methods>>=
def _get_loose_object(self, sha):
    raise NotImplementedError(self._get_loose_object)

@


<<[[PackBasedObjectStore]] methods>>=
def pack_loose_objects(self):
    """Pack loose objects.

    :return: Number of objects packed
    """
    objects = set()
    for sha in self._iter_loose_objects():
        objects.add((self._get_loose_object(sha), None))
    self.add_objects(list(objects))
    for obj, path in objects:
        self._remove_loose_object(obj.id)
    return len(objects)
@

<<[[PackBasedObjectStore]] methods>>=
def _iter_loose_objects(self):
    """Iterate over the SHAs of all loose objects."""
    raise NotImplementedError(self._iter_loose_objects)
@

<<[[DiskObjectStore]] methods>>=
def _iter_loose_objects(self):
    for base in os.listdir(self.path):
        if len(base) != 2:
            continue
        for rest in os.listdir(os.path.join(self.path, base)):
            yield (base+rest).encode(sys.getfilesystemencoding())
@

<<[[PackBasedObjectStore]] methods>>=
def _remove_loose_object(self, sha):
    raise NotImplementedError(self._remove_loose_object)
@
<<[[DiskObjectStore]] methods>>=
def _remove_loose_object(self, sha):
    os.remove(self._get_shafile_path(sha))
@



<<[[PackBasedObjectStore]] methods>>=
def add_objects(self, objects):
    """Add a set of objects to this object store.

    :param objects: Iterable over (object, path) tuples, should support
        __len__.
    :return: Pack object of the objects written.
    """
    if len(objects) == 0:
        # Don't bother writing an empty pack file
        return
    f, commit, abort = self.add_pack()
    try:
        write_pack_objects(f, objects)
    except:
        abort()
        raise
    else:
        return commit()

@


<<[[PackBasedObjectStore]] methods>>=
def __iter__(self):
    """Iterate over the SHAs that are present in this store."""
    iterables = (list(self.packs) + [self._iter_loose_objects()] +
                 [self._iter_alternate_objects()])
    return chain(*iterables)

@

<<[[BaseObjectStore]] methods>>=
def contains_loose(self, sha):
    """Check if a particular object is present by SHA1 and is loose."""
    raise NotImplementedError(self.contains_loose)
@
<<[[PackBasedObjectStore]] methods>>=
def contains_loose(self, sha):
    """Check if a particular object is present by SHA1 and is loose.

    This does not check alternates.
    """
    return self._get_loose_object(sha) is not None
@

<<[[PackBasedObjectStore.get_raw()]] look in packs>>=
for pack in self.packs:
    try:
        return pack.get_raw(sha)
    except KeyError:
        pass
@




<<[[DiskObjectStore]] methods>>=
def _update_pack_cache(self):
    try:
        pack_dir_contents = os.listdir(self.pack_dir)
    except OSError as e:
        if e.errno == errno.ENOENT:
            self._pack_cache_time = 0
            self.close()
            return
        raise
    self._pack_cache_time = os.stat(self.pack_dir).st_mtime
    pack_files = set()
    for name in pack_dir_contents:
        assert isinstance(name, basestring if sys.version_info[0] == 2 else str)
        if name.startswith("pack-") and name.endswith(".pack"):
            # verify that idx exists first (otherwise the pack was not yet
            # fully written)
            idx_name = os.path.splitext(name)[0] + ".idx"
            if idx_name in pack_dir_contents:
                pack_name = name[:-len(".pack")]
                pack_files.add(pack_name)

    # Open newly appeared pack files
    for f in pack_files:
        if f not in self._pack_cache:
            self._pack_cache[f] = Pack(os.path.join(self.pack_dir, f))
    # Remove disappeared pack files
    for f in set(self._pack_cache) - pack_files:
        self._pack_cache.pop(f).close()

@

<<[[DiskObjectStore]] methods>>=
def _pack_cache_stale(self):
    try:
        return os.stat(self.pack_dir).st_mtime > self._pack_cache_time
    except OSError as e:
        if e.errno == errno.ENOENT:
            return True
        raise

@

<<[[DiskObjectStore]] methods>>=
def _get_pack_basepath(self, entries):
    suffix = iter_sha1(entry[0] for entry in entries)
    # TODO: Handle self.pack_dir being bytes
    suffix = suffix.decode('ascii')
    return os.path.join(self.pack_dir, "pack-" + suffix)
@

<<function pack.iter_sha1>>=
def iter_sha1(iter):
    """Return the hexdigest of the SHA1 over a set of names.

    :param iter: Iterator over string objects
    :return: 40-byte hex sha1 digest
    """
    sha = sha1()
    for name in iter:
        sha.update(name)
    return sha.hexdigest().encode('ascii')
@



<<[[DiskObjectStore]] methods>>=
def move_in_pack(self, path):
    """Move a specific file containing a pack into the pack directory.

    :note: The file should be on the same file system as the
        packs directory.

    :param path: Path to the pack file.
    """
    with PackData(path) as p:
        entries = p.sorted_entries()
        basename = self._get_pack_basepath(entries)
        with GitFile(basename+".idx", "wb") as f:
            write_pack_index_v2(f, entries, p.get_stored_checksum())
    os.rename(path, basename + ".pack")
    final_pack = Pack(basename)
    self._add_known_pack(basename, final_pack)
    return final_pack

@

<<[[DiskObjectStore]] methods>>=
def add_pack(self):
    """Add a new pack to this object store.

    :return: Fileobject to write to, a commit function to
        call when the pack is finished and an abort
        function.
    """
    fd, path = tempfile.mkstemp(dir=self.pack_dir, suffix=".pack")
    f = os.fdopen(fd, 'wb')

    def commit():
        os.fsync(fd)
        f.close()
        if os.path.getsize(path) > 0:
            return self.move_in_pack(path)
        else:
            os.remove(path)
            return None

    def abort():
        f.close()
        os.remove(path)
    return f, commit, abort

@


<<[[BaseObjectStore]] methods>>=
def generate_pack_contents(self, have, want, progress=None):
    """Iterate over the contents of a pack file.

    :param have: List of SHA1s of objects that should not be sent
    :param want: List of SHA1s of objects that should be sent
    :param progress: Optional progress reporting method
    """
    return self.iter_shas(self.find_missing_objects(have, want, progress))
@


<<[[PackBasedObjectStore]] methods>>=
def __init__(self):
    self._pack_cache = {}
@



\subsubsection{[[RefsContainer]]}

<<[[DiskRefsContainer.__init__()]] set pack fields>>=
self._packed_refs = None
self._peeled_refs = None
@

<<[[DiskRefsContainer.subkeys()]] look in packed refs>>=
for key in self.get_packed_refs():
    if key.startswith(base):
        subkeys.add(key[len(base):].strip(b'/'))
@

<<[[DiskRefsContainer.allkeys()]] look in packed refs>>=
allkeys.update(self.get_packed_refs())
@

<<[[RefsContainer.read_ref]] read packed refs if no loose ref>>=
if not contents:
    contents = self.get_packed_refs().get(refname, None)
@

<<[[RefsContainer]] methods>>=
def get_packed_refs(self):
    """Get contents of the packed-refs file.

    :return: Dictionary mapping ref names to SHA1s

    :note: Will return an empty dictionary when no packed-refs file is
        present.
    """
    raise NotImplementedError(self.get_packed_refs)
@

<<[[DiskRefsContainer]] methods>>=
def get_packed_refs(self):
    """Get contents of the packed-refs file.

    :return: Dictionary mapping ref names to SHA1s

    :note: Will return an empty dictionary when no packed-refs file is
        present.
    """
    # TODO: invalidate the cache on repacking
    if self._packed_refs is None:
        # set both to empty because we want _peeled_refs to be
        # None if and only if _packed_refs is also None.
        self._packed_refs = {}
        self._peeled_refs = {}
        path = os.path.join(self.path, 'packed-refs')
        try:
            f = GitFile(path, 'rb')
        except IOError as e:
            if e.errno == errno.ENOENT:
                return {}
            raise
        with f:
            first_line = next(iter(f)).rstrip()
            if (first_line.startswith(b'# pack-refs') and b' peeled' in
                    first_line):
                for sha, name, peeled in read_packed_refs_with_peeled(f):
                    self._packed_refs[name] = sha
                    if peeled:
                        self._peeled_refs[name] = peeled
            else:
                f.seek(0)
                for sha, name in read_packed_refs(f):
                    self._packed_refs[name] = sha
    return self._packed_refs

@

<<[[DiskRefsContainer.set_if_equals()]] read packed refs, if no loose ref>>=
if orig_ref is None:
    orig_ref = self.get_packed_refs().get(realname, ZERO_SHA)
@

<<[[DiskRefsContainer.remove_if_equals()]] read packed refs, if no loose ref>>=
if orig_ref is None:
    orig_ref = self.get_packed_refs().get(name, ZERO_SHA)
@

<<function refs.read_packed_refs_with_peeled>>=
def read_packed_refs_with_peeled(f):
    """Read a packed refs file including peeled refs.

    Assumes the "# pack-refs with: peeled" line was already read. Yields tuples
    with ref names, SHA1s, and peeled SHA1s (or None).

    :param f: file-like object to read from, seek'ed to the second line
    """
    last = None
    for l in f:
        if l[0] == b'#':
            continue
        l = l.rstrip(b'\r\n')
        if l.startswith(b'^'):
            if not last:
                raise PackedRefsException("unexpected peeled ref line")
            if not valid_hexsha(l[1:]):
                raise PackedRefsException("Invalid hex sha %r" % l[1:])
            sha, name = _split_ref_line(last)
            last = None
            yield (sha, name, l[1:])
        else:
            if last:
                sha, name = _split_ref_line(last)
                yield (sha, name, None)
            last = l
    if last:
        sha, name = _split_ref_line(last)
        yield (sha, name, None)
@

<<function refs._split_ref_line>>=
def _split_ref_line(line):
    """Split a single ref line into a tuple of SHA1 and name."""
    fields = line.rstrip(b'\n\r').split(b' ')
    if len(fields) != 2:
        raise PackedRefsException("invalid ref line %r" % line)
    sha, name = fields
    if not valid_hexsha(sha):
        raise PackedRefsException("Invalid hex sha %r" % sha)
    if not check_ref_format(name):
        raise PackedRefsException("invalid ref name %r" % name)
    return (sha, name)
@


<<function refs.read_packed_refs>>=
def read_packed_refs(f):
    """Read a packed refs file.

    :param f: file-like object to read from
    :return: Iterator over tuples with SHA1s and ref names.
    """
    for l in f:
        if l.startswith(b'#'):
            # Comment
            continue
        if l.startswith(b'^'):
            raise PackedRefsException(
              "found peeled ref in packed-refs without peeled")
        yield _split_ref_line(l)
@

<<[[DiskRefsContainer]] methods>>=
def _remove_packed_ref(self, name):
    if self._packed_refs is None:
        return
    filename = os.path.join(self.path, 'packed-refs')
    # reread cached refs from disk, while holding the lock
    f = GitFile(filename, 'wb')
    try:
        self._packed_refs = None
        self.get_packed_refs()

        if name not in self._packed_refs:
            return

        del self._packed_refs[name]
        if name in self._peeled_refs:
            del self._peeled_refs[name]
        write_packed_refs(f, self._packed_refs, self._peeled_refs)
        f.close()
    finally:
        f.abort()
@

<<function refs.write_packed_refs>>=
def write_packed_refs(f, packed_refs, peeled_refs=None):
    """Write a packed refs file.

    :param f: empty file-like object to write to
    :param packed_refs: dict of refname to sha of packed refs to write
    :param peeled_refs: dict of refname to peeled value of sha
    """
    if peeled_refs is None:
        peeled_refs = {}
    else:
        f.write(b'# pack-refs with: peeled\n')
    for refname in sorted(packed_refs.keys()):
        f.write(git_line(packed_refs[refname], refname))
        if refname in peeled_refs:
            f.write(b'^' + peeled_refs[refname] + b'\n')
@



\subsection{Delta}

<<constant pack.DEFAULT_PACK_DELTA_WINDOW_SIZE>>=
DEFAULT_PACK_DELTA_WINDOW_SIZE = 10
@

<<constant pack._MAX_COPY_LEN>>=
# The length of delta compression copy operations in version 2 packs is limited
# to 64K.  To copy more, we use several copy operations.  Version 3 packs allow
# 24-bit lengths in copy operations, but we always make version 2 packs.
_MAX_COPY_LEN = 0xffff
@

<<function pack.create_delta>>=
def create_delta(base_buf, target_buf):
    """Use python difflib to work out how to transform base_buf to target_buf.

    :param base_buf: Base buffer
    :param target_buf: Target buffer
    """
    assert isinstance(base_buf, bytes)
    assert isinstance(target_buf, bytes)
    out_buf = bytearray()
    # write delta header
    out_buf += _delta_encode_size(len(base_buf))
    out_buf += _delta_encode_size(len(target_buf))
    # write out delta opcodes
    seq = difflib.SequenceMatcher(a=base_buf, b=target_buf)
    for opcode, i1, i2, j1, j2 in seq.get_opcodes():
        # Git patch opcodes don't care about deletes!
        # if opcode == 'replace' or opcode == 'delete':
        #    pass
        if opcode == 'equal':
            # If they are equal, unpacker will use data from base_buf
            # Write out an opcode that says what range to use
            copy_start = i1
            copy_len = i2 - i1
            while copy_len > 0:
                to_copy = min(copy_len, _MAX_COPY_LEN)
                out_buf += _encode_copy_operation(copy_start, to_copy)
                copy_start += to_copy
                copy_len -= to_copy
        if opcode == 'replace' or opcode == 'insert':
            # If we are replacing a range or adding one, then we just
            # output it to the stream (prefixed by its size)
            s = j2 - j1
            o = j1
            while s > 127:
                out_buf.append(127)
                out_buf += bytearray(target_buf[o:o+127])
                s -= 127
                o += 127
            out_buf.append(s)
            out_buf += bytearray(target_buf[o:o+s])
    return bytes(out_buf)
@

<<function pack._delta_encode_size>>=
def _delta_encode_size(size):
    ret = bytearray()
    c = size & 0x7f
    size >>= 7
    while size:
        ret.append(c | 0x80)
        c = size & 0x7f
        size >>= 7
    ret.append(c)
    return ret
@

<<function pack._encode_copy_operation>>=
def _encode_copy_operation(start, length):
    scratch = []
    op = 0x80
    for i in range(4):
        if start & 0xff << i*8:
            scratch.append((start >> i*8) & 0xff)
            op |= 1 << i
    for i in range(2):
        if length & 0xff << i*8:
            scratch.append((length >> i*8) & 0xff)
            op |= 1 << (4+i)
    return bytearray([op] + scratch)
@


<<function pack.deltify_pack_objects>>=
def deltify_pack_objects(objects, window_size=None):
    """Generate deltas for pack objects.

    :param objects: An iterable of (object, path) tuples to deltify.
    :param window_size: Window size; None for default
    :return: Iterator over type_num, object id, delta_base, content
        delta_base is None for full text entries
    """
    if window_size is None:
        window_size = DEFAULT_PACK_DELTA_WINDOW_SIZE
    # Build a list of objects ordered by the magic Linus heuristic
    # This helps us find good objects to diff against us
    magic = []
    for obj, path in objects:
        magic.append((obj.type_num, path, -obj.raw_length(), obj))
    magic.sort()

    possible_bases = deque()

    for type_num, path, neg_length, o in magic:
        raw = o.as_raw_string()
        winner = raw
        winner_base = None
        for base in possible_bases:
            if base.type_num != type_num:
                continue
            delta = create_delta(base.as_raw_string(), raw)
            if len(delta) < len(winner):
                winner_base = base.sha().digest()
                winner = delta
        yield type_num, o.sha().digest(), winner_base, winner
        possible_bases.appendleft(o)
        while len(possible_bases) > window_size:
            possible_bases.pop()
@

<<class DeltaChainIterator>>=
class DeltaChainIterator(object):
    """Abstract iterator over pack data based on delta chains.

    Each object in the pack is guaranteed to be inflated exactly once,
    regardless of how many objects reference it as a delta base. As a result,
    memory usage is proportional to the length of the longest delta chain.

    Subclasses can override _result to define the result type of the iterator.
    By default, results are UnpackedObjects with the following members set:

    * offset
    * obj_type_num
    * obj_chunks
    * pack_type_num
    * delta_base     (for delta types)
    * comp_chunks    (if _include_comp is True)
    * decomp_chunks
    * decomp_len
    * crc32          (if _compute_crc32 is True)
    """

    _compute_crc32 = False
    _include_comp = False

    def __init__(self, file_obj, resolve_ext_ref=None):
        self._file = file_obj
        self._resolve_ext_ref = resolve_ext_ref
        self._pending_ofs = defaultdict(list)
        self._pending_ref = defaultdict(list)
        self._full_ofs = []
        self._shas = {}
        self._ext_refs = []

    @classmethod
    def for_pack_data(cls, pack_data, resolve_ext_ref=None):
        walker = cls(None, resolve_ext_ref=resolve_ext_ref)
        walker.set_pack_data(pack_data)
        for unpacked in pack_data._iter_unpacked():
            walker.record(unpacked)
        return walker

    def record(self, unpacked):
        type_num = unpacked.pack_type_num
        offset = unpacked.offset
        if type_num == OFS_DELTA:
            base_offset = offset - unpacked.delta_base
            self._pending_ofs[base_offset].append(offset)
        elif type_num == REF_DELTA:
            self._pending_ref[unpacked.delta_base].append(offset)
        else:
            self._full_ofs.append((offset, type_num))

    def set_pack_data(self, pack_data):
        self._file = pack_data._file

    def _walk_all_chains(self):
        for offset, type_num in self._full_ofs:
            for result in self._follow_chain(offset, type_num, None):
                yield result
        for result in self._walk_ref_chains():
            yield result
        assert not self._pending_ofs

    def _ensure_no_pending(self):
        if self._pending_ref:
            raise KeyError([sha_to_hex(s) for s in self._pending_ref])

    def _walk_ref_chains(self):
        if not self._resolve_ext_ref:
            self._ensure_no_pending()
            return

        for base_sha, pending in sorted(self._pending_ref.items()):
            if base_sha not in self._pending_ref:
                continue
            try:
                type_num, chunks = self._resolve_ext_ref(base_sha)
            except KeyError:
                # Not an external ref, but may depend on one. Either it will
                # get popped via a _follow_chain call, or we will raise an
                # error below.
                continue
            self._ext_refs.append(base_sha)
            self._pending_ref.pop(base_sha)
            for new_offset in pending:
                for result in self._follow_chain(new_offset, type_num, chunks):
                    yield result

        self._ensure_no_pending()

    def _result(self, unpacked):
        return unpacked

    def _resolve_object(self, offset, obj_type_num, base_chunks):
        self._file.seek(offset)
        unpacked, _ = unpack_object(
          self._file.read, include_comp=self._include_comp,
          compute_crc32=self._compute_crc32)
        unpacked.offset = offset
        if base_chunks is None:
            assert unpacked.pack_type_num == obj_type_num
        else:
            assert unpacked.pack_type_num in DELTA_TYPES
            unpacked.obj_type_num = obj_type_num
            unpacked.obj_chunks = apply_delta(base_chunks,
                                              unpacked.decomp_chunks)
        return unpacked

    def _follow_chain(self, offset, obj_type_num, base_chunks):
        # Unlike PackData.get_object_at, there is no need to cache offsets as
        # this approach by design inflates each object exactly once.
        todo = [(offset, obj_type_num, base_chunks)]
        for offset, obj_type_num, base_chunks in todo:
            unpacked = self._resolve_object(offset, obj_type_num, base_chunks)
            yield self._result(unpacked)

            unblocked = chain(self._pending_ofs.pop(unpacked.offset, []),
                              self._pending_ref.pop(unpacked.sha(), []))
            todo.extend(
                (new_offset, unpacked.obj_type_num, unpacked.obj_chunks)
                for new_offset in unblocked)

    def __iter__(self):
        return self._walk_all_chains()

    def ext_refs(self):
        return self._ext_refs
@

<<function pack.apply_delta>>=
def apply_delta(src_buf, delta):
    """Based on the similar function in git's patch-delta.c.

    :param src_buf: Source buffer
    :param delta: Delta instructions
    """
    if not isinstance(src_buf, bytes):
        src_buf = b''.join(src_buf)
    if not isinstance(delta, bytes):
        delta = b''.join(delta)
    out = []
    index = 0
    delta_length = len(delta)

    def get_delta_header_size(delta, index):
        size = 0
        i = 0
        while delta:
            cmd = ord(delta[index:index+1])
            index += 1
            size |= (cmd & ~0x80) << i
            i += 7
            if not cmd & 0x80:
                break
        return size, index
    src_size, index = get_delta_header_size(delta, index)
    dest_size, index = get_delta_header_size(delta, index)
    assert src_size == len(src_buf), '%d vs %d' % (src_size, len(src_buf))
    while index < delta_length:
        cmd = ord(delta[index:index+1])
        index += 1
        if cmd & 0x80:
            cp_off = 0
            for i in range(4):
                if cmd & (1 << i):
                    x = ord(delta[index:index+1])
                    index += 1
                    cp_off |= x << (i * 8)
            cp_size = 0
            # Version 3 packs can contain copy sizes larger than 64K.
            for i in range(3):
                if cmd & (1 << (4+i)):
                    x = ord(delta[index:index+1])
                    index += 1
                    cp_size |= x << (i * 8)
            if cp_size == 0:
                cp_size = 0x10000
            if (cp_off + cp_size < cp_size or
                    cp_off + cp_size > src_size or
                    cp_size > dest_size):
                break
            out.append(src_buf[cp_off:cp_off+cp_size])
        elif cmd != 0:
            out.append(delta[index:index+cmd])
            index += cmd
        else:
            raise ApplyDeltaError('Invalid opcode 0')

    if index != delta_length:
        raise ApplyDeltaError('delta not empty: %r' % delta[index:])

    if dest_size != chunks_length(out):
        raise ApplyDeltaError('dest size incorrect')

    return out
@

<<function pack.chunks_length>>=
def chunks_length(chunks):
    if isinstance(chunks, bytes):
        return len(chunks)
    else:
        return sum(imap(len, chunks))
@



\subsection{[[PackData]]}

<<class PackData>>=
class PackData(object):
    """The data contained in a packfile.

    Pack files can be accessed both sequentially for exploding a pack, and
    directly with the help of an index to retrieve a specific object.

    The objects within are either complete or a delta against another.

    The header is variable length. If the MSB of each byte is set then it
    indicates that the subsequent byte is still part of the header.
    For the first byte the next MS bits are the type, which tells you the type
    of object, and whether it is a delta. The LS byte is the lowest bits of the
    size. For each subsequent byte the LS 7 bits are the next MS bits of the
    size, i.e. the last byte of the header contains the MS bits of the size.

    For the complete objects the data is stored as zlib deflated data.
    The size in the header is the uncompressed object size, so to uncompress
    you need to just keep feeding data to zlib until you get an object back,
    or it errors on bad data. This is done here by just giving the complete
    buffer from the start of the deflated object on. This is bad, but until I
    get mmap sorted out it will have to do.

    Currently there are no integrity checks done. Also no attempt is made to
    try and detect the delta case, or a request for an object at the wrong
    position.  It will all just throw a zlib or KeyError.
    """

    <<[[PackData]] methods>>
@

<<[[PackData]] methods>>=
def __init__(self, filename, file=None, size=None):
    """Create a PackData object representing the pack in the given filename.

    The file must exist and stay readable until the object is disposed of.
    It must also stay the same size. It will be mapped whenever needed.

    Currently there is a restriction on the size of the pack as the python
    mmap implementation is flawed.
    """
    self._filename = filename
    self._size = size
    self._header_size = 12
    if file is None:
        self._file = GitFile(self._filename, 'rb')
    else:
        self._file = file
    (version, self._num_objects) = read_pack_header(self._file.read)
    self._offset_cache = LRUSizeCache(
        1024*1024*20, compute_size=_compute_object_size)
    self.pack = None

@property
def filename(self):
    return os.path.basename(self._filename)

@classmethod
def from_file(cls, file, size):
    return cls(str(file), file=file, size=size)

@classmethod
def from_path(cls, path):
    return cls(filename=path)

def close(self):
    self._file.close()

def __enter__(self):
    return self

def __exit__(self, exc_type, exc_val, exc_tb):
    self.close()

def _get_size(self):
    if self._size is not None:
        return self._size
    self._size = os.path.getsize(self._filename)
    if self._size < self._header_size:
        errmsg = ('%s is too small for a packfile (%d < %d)' %
                  (self._filename, self._size, self._header_size))
        raise AssertionError(errmsg)
    return self._size

def __len__(self):
    """Returns the number of objects in this pack."""
    return self._num_objects

def calculate_checksum(self):
    """Calculate the checksum for this pack.

    :return: 20-byte binary SHA1 digest
    """
    return compute_file_sha(self._file, end_ofs=-20).digest()

def get_ref(self, sha):
    """Get the object for a ref SHA, only looking in this pack."""
    # TODO: cache these results
    if self.pack is None:
        raise KeyError(sha)
    try:
        offset = self.pack.index.object_index(sha)
    except KeyError:
        offset = None
    if offset:
        type, obj = self.get_object_at(offset)
    elif self.pack is not None and self.pack.resolve_ext_ref:
        type, obj = self.pack.resolve_ext_ref(sha)
    else:
        raise KeyError(sha)
    return offset, type, obj

def resolve_object(self, offset, type, obj, get_ref=None):
    """Resolve an object, possibly resolving deltas when necessary.

    :return: Tuple with object type and contents.
    """
    # Walk down the delta chain, building a stack of deltas to reach
    # the requested object.
    base_offset = offset
    base_type = type
    base_obj = obj
    delta_stack = []
    while base_type in DELTA_TYPES:
        prev_offset = base_offset
        if get_ref is None:
            get_ref = self.get_ref
        if base_type == OFS_DELTA:
            (delta_offset, delta) = base_obj
            # TODO: clean up asserts and replace with nicer error messages
            assert (
                isinstance(base_offset, int)
                or isinstance(base_offset, long))
            assert (
                isinstance(delta_offset, int)
                or isinstance(base_offset, long))
            base_offset = base_offset - delta_offset
            base_type, base_obj = self.get_object_at(base_offset)
            assert isinstance(base_type, int)
        elif base_type == REF_DELTA:
            (basename, delta) = base_obj
            assert isinstance(basename, bytes) and len(basename) == 20
            base_offset, base_type, base_obj = get_ref(basename)
            assert isinstance(base_type, int)
        delta_stack.append((prev_offset, base_type, delta))

    # Now grab the base object (mustn't be a delta) and apply the
    # deltas all the way up the stack.
    chunks = base_obj
    for prev_offset, delta_type, delta in reversed(delta_stack):
        chunks = apply_delta(chunks, delta)
        # TODO(dborowitz): This can result in poor performance if
        # large base objects are separated from deltas in the pack.
        # We should reorganize so that we apply deltas to all
        # objects in a chain one after the other to optimize cache
        # performance.
        if prev_offset is not None:
            self._offset_cache[prev_offset] = base_type, chunks
    return base_type, chunks

def iterobjects(self, progress=None, compute_crc32=True):
    self._file.seek(self._header_size)
    for i in range(1, self._num_objects + 1):
        offset = self._file.tell()
        unpacked, unused = unpack_object(
          self._file.read, compute_crc32=compute_crc32)
        if progress is not None:
            progress(i, self._num_objects)
        yield (offset, unpacked.pack_type_num, unpacked._obj(),
               unpacked.crc32)
        # Back up over unused data.
        self._file.seek(-len(unused), SEEK_CUR)

def _iter_unpacked(self):
    # TODO(dborowitz): Merge this with iterobjects, if we can change its
    # return type.
    self._file.seek(self._header_size)

    if self._num_objects is None:
        return

    for _ in range(self._num_objects):
        offset = self._file.tell()
        unpacked, unused = unpack_object(
          self._file.read, compute_crc32=False)
        unpacked.offset = offset
        yield unpacked
        # Back up over unused data.
        self._file.seek(-len(unused), SEEK_CUR)

def iterentries(self, progress=None):
    """Yield entries summarizing the contents of this pack.

    :param progress: Progress function, called with current and total
        object count.
    :return: iterator of tuples with (sha, offset, crc32)
    """
    num_objects = self._num_objects
    resolve_ext_ref = (
        self.pack.resolve_ext_ref if self.pack is not None else None)
    indexer = PackIndexer.for_pack_data(
        self, resolve_ext_ref=resolve_ext_ref)
    for i, result in enumerate(indexer):
        if progress is not None:
            progress(i, num_objects)
        yield result

def sorted_entries(self, progress=None):
    """Return entries in this pack, sorted by SHA.

    :param progress: Progress function, called with current and total
        object count
    :return: List of tuples with (sha, offset, crc32)
    """
    ret = sorted(self.iterentries(progress=progress))
    return ret

def create_index_v1(self, filename, progress=None):
    """Create a version 1 file for this data file.

    :param filename: Index filename.
    :param progress: Progress report function
    :return: Checksum of index file
    """
    entries = self.sorted_entries(progress=progress)
    with GitFile(filename, 'wb') as f:
        return write_pack_index_v1(f, entries, self.calculate_checksum())

def create_index_v2(self, filename, progress=None):
    """Create a version 2 index file for this data file.

    :param filename: Index filename.
    :param progress: Progress report function
    :return: Checksum of index file
    """
    entries = self.sorted_entries(progress=progress)
    with GitFile(filename, 'wb') as f:
        return write_pack_index_v2(f, entries, self.calculate_checksum())

def create_index(self, filename, progress=None,
                 version=2):
    """Create an  index file for this data file.

    :param filename: Index filename.
    :param progress: Progress report function
    :return: Checksum of index file
    """
    if version == 1:
        return self.create_index_v1(filename, progress)
    elif version == 2:
        return self.create_index_v2(filename, progress)
    else:
        raise ValueError('unknown index format %d' % version)

def get_stored_checksum(self):
    """Return the expected checksum stored in this pack."""
    self._file.seek(-20, SEEK_END)
    return self._file.read(20)

def check(self):
    """Check the consistency of this pack."""
    actual = self.calculate_checksum()
    stored = self.get_stored_checksum()
    if actual != stored:
        raise ChecksumMismatch(stored, actual)

def get_object_at(self, offset):
    """Given an offset in to the packfile return the object that is there.

    Using the associated index the location of an object can be looked up,
    and then the packfile can be asked directly for that object using this
    function.
    """
    try:
        return self._offset_cache[offset]
    except KeyError:
        pass
    assert offset >= self._header_size
    self._file.seek(offset)
    unpacked, _ = unpack_object(self._file.read)
    return (unpacked.pack_type_num, unpacked._obj())
@


<<function pack._compute_object_size>>=
def _compute_object_size(value):
    """Compute the size of a unresolved object for use with LRUSizeCache."""
    (num, obj) = value
    if num in DELTA_TYPES:
        return chunks_length(obj[1])
    return chunks_length(obj)
@

<<function read_pack_header>>=
def read_pack_header(read):
    """Read the header of a pack file.

    :param read: Read function
    :return: Tuple of (pack version, number of objects). If no data is
        available to read, returns (None, None).
    """
    header = read(12)
    if not header:
        return None, None
    if header[:4] != b'PACK':
        raise AssertionError('Invalid pack header %r' % header)
    (version,) = unpack_from(b'>L', header, 4)
    if version not in (2, 3):
        raise AssertionError('Version was %d' % version)
    (num_objects,) = unpack_from(b'>L', header, 8)
    return (version, num_objects)
@


<<function pack.compute_file_sha>>=
def compute_file_sha(f, start_ofs=0, end_ofs=0, buffer_size=1 << 16):
    """Hash a portion of a file into a new SHA.

    :param f: A file-like object to read from that supports seek().
    :param start_ofs: The offset in the file to start reading at.
    :param end_ofs: The offset in the file to end reading at, relative to the
        end of the file.
    :param buffer_size: A buffer size for reading.
    :return: A new SHA object updated with data read from the file.
    """
    sha = sha1()
    f.seek(0, SEEK_END)
    length = f.tell()
    if (end_ofs < 0 and length + end_ofs < start_ofs) or end_ofs > length:
        raise AssertionError(
            "Attempt to read beyond file length. "
            "start_ofs: %d, end_ofs: %d, file length: %d" % (
                start_ofs, end_ofs, length))
    todo = length + end_ofs - start_ofs
    f.seek(start_ofs)
    while todo:
        data = f.read(min(todo, buffer_size))
        sha.update(data)
        todo -= len(data)
    return sha
@

\subsection{[[UnpackObject]]}

<<class UnpackedObject>>=
class UnpackedObject(object):
    """Class encapsulating an object unpacked from a pack file.

    These objects should only be created from within unpack_object. Most
    members start out as empty and are filled in at various points by
    read_zlib_chunks, unpack_object, DeltaChainIterator, etc.

    End users of this object should take care that the function they're getting
    this object from is guaranteed to set the members they need.
    """

    __slots__ = [
      'offset',         # Offset in its pack.
      '_sha',           # Cached binary SHA.
      'obj_type_num',   # Type of this object.
      'obj_chunks',     # Decompressed and delta-resolved chunks.
      'pack_type_num',  # Type of this object in the pack (may be a delta).
      'delta_base',     # Delta base offset or SHA.
      'comp_chunks',    # Compressed object chunks.
      'decomp_chunks',  # Decompressed object chunks.
      'decomp_len',     # Decompressed length of this object.
      'crc32',          # CRC32.
      ]

    # TODO(dborowitz): read_zlib_chunks and unpack_object could very well be
    # methods of this object.
    def __init__(self, pack_type_num, delta_base, decomp_len, crc32):
        self.offset = None
        self._sha = None
        self.pack_type_num = pack_type_num
        self.delta_base = delta_base
        self.comp_chunks = None
        self.decomp_chunks = []
        self.decomp_len = decomp_len
        self.crc32 = crc32

        if pack_type_num in DELTA_TYPES:
            self.obj_type_num = None
            self.obj_chunks = None
        else:
            self.obj_type_num = pack_type_num
            self.obj_chunks = self.decomp_chunks
            self.delta_base = delta_base

    def sha(self):
        """Return the binary SHA of this object."""
        if self._sha is None:
            self._sha = obj_sha(self.obj_type_num, self.obj_chunks)
        return self._sha

    def sha_file(self):
        """Return a ShaFile from this object."""
        return ShaFile.from_raw_chunks(self.obj_type_num, self.obj_chunks)

    # Only provided for backwards compatibility with code that expects either
    # chunks or a delta tuple.
    def _obj(self):
        """Return the decompressed chunks, or (delta base, delta chunks)."""
        if self.pack_type_num in DELTA_TYPES:
            return (self.delta_base, self.decomp_chunks)
        else:
            return self.decomp_chunks

    def __eq__(self, other):
        if not isinstance(other, UnpackedObject):
            return False
        for slot in self.__slots__:
            if getattr(self, slot) != getattr(other, slot):
                return False
        return True

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        data = ['%s=%r' % (s, getattr(self, s)) for s in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(data))
@

<<function pack.obj_sha>>=
def obj_sha(type, chunks):
    """Compute the SHA for a numeric type and object chunks."""
    sha = sha1()
    sha.update(object_header(type, chunks_length(chunks)))
    if isinstance(chunks, bytes):
        sha.update(chunks)
    else:
        for chunk in chunks:
            sha.update(chunk)
    return sha.digest()
@

<<[[ShaFile]] methods>>=
@staticmethod
def from_raw_chunks(type_num, chunks, sha=None):
    """Creates an object of the indicated type from the raw chunks given.

    :param type_num: The numeric type of the object.
    :param chunks: An iterable of the raw uncompressed contents.
    :param sha: Optional known sha for the object
    """
    obj = object_class(type_num)()
    obj.set_raw_chunks(chunks, sha)
    return obj
@

\subsection{[[PackIndex]]}

<<function pack.load_pack_index>>=
def load_pack_index(path):
    """Load an index file by path.

    :param filename: Path to the index file
    :return: A PackIndex loaded from the given path
    """
    with GitFile(path, 'rb') as f:
        return load_pack_index_file(path, f)
@

<<function pack.load_pack_index_file>>=
def load_pack_index_file(path, f):
    """Load an index file from a file-like object.

    :param path: Path for the index file
    :param f: File-like object
    :return: A PackIndex loaded from the given file
    """
    contents, size = _load_file_contents(f)
    if contents[:4] == b'\377tOc':
        version = struct.unpack(b'>L', contents[4:8])[0]
        if version == 2:
            return PackIndex2(
                path, file=f, contents=contents, size=size)
        else:
            raise KeyError('Unknown pack index format %d' % version)
    else:
        return PackIndex1(path, file=f, contents=contents, size=size)
@

<<function pack._load_file_contents>>=
def _load_file_contents(f, size=None):
    try:
        fd = f.fileno()
    except (UnsupportedOperation, AttributeError):
        fd = None
    # Attempt to use mmap if possible
    if fd is not None:
        if size is None:
            size = os.fstat(fd).st_size
        if has_mmap:
            try:
                contents = mmap.mmap(fd, size, access=mmap.ACCESS_READ)
            except mmap.error:
                # Perhaps a socket?
                pass
            else:
                return contents, size
    contents = f.read()
    size = len(contents)
    return contents, size
@


<<class PackIndex>>=
class PackIndex(object):
    """An index in to a packfile.

    Given a sha id of an object a pack index can tell you the location in the
    packfile of that object if it has it.
    """

    def __eq__(self, other):
        if not isinstance(other, PackIndex):
            return False

        for (name1, _, _), (name2, _, _) in izip(self.iterentries(),
                                                 other.iterentries()):
            if name1 != name2:
                return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __len__(self):
        """Return the number of entries in this pack index."""
        raise NotImplementedError(self.__len__)

    def __iter__(self):
        """Iterate over the SHAs in this pack."""
        return imap(sha_to_hex, self._itersha())

    def iterentries(self):
        """Iterate over the entries in this pack index.

        :return: iterator over tuples with object name, offset in packfile and
            crc32 checksum.
        """
        raise NotImplementedError(self.iterentries)

    def get_pack_checksum(self):
        """Return the SHA1 checksum stored for the corresponding packfile.

        :return: 20-byte binary digest
        """
        raise NotImplementedError(self.get_pack_checksum)

    def object_index(self, sha):
        """Return the index in to the corresponding packfile for the object.

        Given the name of an object it will return the offset that object
        lives at within the corresponding pack file. If the pack file doesn't
        have the object then None will be returned.
        """
        if len(sha) == 40:
            sha = hex_to_sha(sha)
        return self._object_index(sha)

    def _object_index(self, sha):
        """See object_index.

        :param sha: A *binary* SHA string. (20 characters long)_
        """
        raise NotImplementedError(self._object_index)

    def objects_sha1(self):
        """Return the hex SHA1 over all the shas of all objects in this pack.

        :note: This is used for the filename of the pack.
        """
        return iter_sha1(self._itersha())

    def _itersha(self):
        """Yield all the SHA1's of the objects in the index, sorted."""
        raise NotImplementedError(self._itersha)
@


<<class FilePackIndex>>=
class FilePackIndex(PackIndex):
    """Pack index that is based on a file.

    To do the loop it opens the file, and indexes first 256 4 byte groups
    with the first byte of the sha id. The value in the four byte group indexed
    is the end of the group that shares the same starting byte. Subtract one
    from the starting byte and index again to find the start of the group.
    The values are sorted by sha id within the group, so do the math to find
    the start and end offset and then bisect in to find if the value is
    present.
    """

    def __init__(self, filename, file=None, contents=None, size=None):
        """Create a pack index object.

        Provide it with the name of the index file to consider, and it will map
        it whenever required.
        """
        self._filename = filename
        # Take the size now, so it can be checked each time we map the file to
        # ensure that it hasn't changed.
        if file is None:
            self._file = GitFile(filename, 'rb')
        else:
            self._file = file
        if contents is None:
            self._contents, self._size = _load_file_contents(self._file, size)
        else:
            self._contents, self._size = (contents, size)

    def __eq__(self, other):
        # Quick optimization:
        if (isinstance(other, FilePackIndex) and
                self._fan_out_table != other._fan_out_table):
            return False

        return super(FilePackIndex, self).__eq__(other)

    def close(self):
        self._file.close()
        if getattr(self._contents, "close", None) is not None:
            self._contents.close()

    def __len__(self):
        """Return the number of entries in this pack index."""
        return self._fan_out_table[-1]

    def _unpack_entry(self, i):
        """Unpack the i-th entry in the index file.

        :return: Tuple with object name (SHA), offset in pack file and CRC32
            checksum (if known).
        """
        raise NotImplementedError(self._unpack_entry)

    def _unpack_name(self, i):
        """Unpack the i-th name from the index file."""
        raise NotImplementedError(self._unpack_name)

    def _unpack_offset(self, i):
        """Unpack the i-th object offset from the index file."""
        raise NotImplementedError(self._unpack_offset)

    def _unpack_crc32_checksum(self, i):
        """Unpack the crc32 checksum for the ith object from the index file.
        """
        raise NotImplementedError(self._unpack_crc32_checksum)

    def _itersha(self):
        for i in range(len(self)):
            yield self._unpack_name(i)

    def iterentries(self):
        """Iterate over the entries in this pack index.

        :return: iterator over tuples with object name, offset in packfile and
            crc32 checksum.
        """
        for i in range(len(self)):
            yield self._unpack_entry(i)

    def _read_fan_out_table(self, start_offset):
        ret = []
        for i in range(0x100):
            fanout_entry = self._contents[
                start_offset+i*4:start_offset+(i+1)*4]
            ret.append(struct.unpack('>L', fanout_entry)[0])
        return ret

    def check(self):
        """Check that the stored checksum matches the actual checksum."""
        actual = self.calculate_checksum()
        stored = self.get_stored_checksum()
        if actual != stored:
            raise ChecksumMismatch(stored, actual)

    def calculate_checksum(self):
        """Calculate the SHA1 checksum over this pack index.

        :return: This is a 20-byte binary digest
        """
        return sha1(self._contents[:-20]).digest()

    def get_pack_checksum(self):
        """Return the SHA1 checksum stored for the corresponding packfile.

        :return: 20-byte binary digest
        """
        return bytes(self._contents[-40:-20])

    def get_stored_checksum(self):
        """Return the SHA1 checksum stored for this index.

        :return: 20-byte binary digest
        """
        return bytes(self._contents[-20:])

    def _object_index(self, sha):
        """See object_index.

        :param sha: A *binary* SHA string. (20 characters long)_
        """
        assert len(sha) == 20
        idx = ord(sha[:1])
        if idx == 0:
            start = 0
        else:
            start = self._fan_out_table[idx-1]
        end = self._fan_out_table[idx]
        i = bisect_find_sha(start, end, sha, self._unpack_name)
        if i is None:
            raise KeyError(sha)
        return self._unpack_offset(i)

@


<<function pack.bisect_find_sha>>=
def bisect_find_sha(start, end, sha, unpack_name):
    """Find a SHA in a data blob with sorted SHAs.

    :param start: Start index of range to search
    :param end: End index of range to search
    :param sha: Sha to find
    :param unpack_name: Callback to retrieve SHA by index
    :return: Index of the SHA, or None if it wasn't found
    """
    assert start <= end
    while start <= end:
        i = (start + end) // 2
        file_sha = unpack_name(i)
        if file_sha < sha:
            start = i + 1
        elif file_sha > sha:
            end = i - 1
        else:
            return i
    return None
@

\subsubsection{Index pack v1}

<<class PackIndex1>>=
class PackIndex1(FilePackIndex):
    """Version 1 Pack Index file."""

    def __init__(self, filename, file=None, contents=None, size=None):
        super(PackIndex1, self).__init__(filename, file, contents, size)
        self.version = 1
        self._fan_out_table = self._read_fan_out_table(0)

    def _unpack_entry(self, i):
        (offset, name) = unpack_from('>L20s', self._contents,
                                     (0x100 * 4) + (i * 24))
        return (name, offset, None)

    def _unpack_name(self, i):
        offset = (0x100 * 4) + (i * 24) + 4
        return self._contents[offset:offset+20]

    def _unpack_offset(self, i):
        offset = (0x100 * 4) + (i * 24)
        return unpack_from('>L', self._contents, offset)[0]

    def _unpack_crc32_checksum(self, i):
        # Not stored in v1 index files
        return None

@

<<function write_pack_index_v1>>=
def write_pack_index_v1(f, entries, pack_checksum):
    """Write a new pack index file.

    :param f: A file-like object to write to
    :param entries: List of tuples with object name (sha), offset_in_pack,
        and crc32_checksum.
    :param pack_checksum: Checksum of the pack file.
    :return: The SHA of the written index file
    """
    f = SHA1Writer(f)
    fan_out_table = defaultdict(lambda: 0)
    for (name, offset, entry_checksum) in entries:
        fan_out_table[ord(name[:1])] += 1
    # Fan-out table
    for i in range(0x100):
        f.write(struct.pack('>L', fan_out_table[i]))
        fan_out_table[i+1] += fan_out_table[i]
    for (name, offset, entry_checksum) in entries:
        if not (offset <= 0xffffffff):
            raise TypeError("pack format 1 only supports offsets < 2Gb")
        f.write(struct.pack('>L20s', offset, name))
    assert len(pack_checksum) == 20
    f.write(pack_checksum)
    return f.write_sha()
@

\subsubsection{Index pack v2}

<<function write_pack_index>>=
write_pack_index = write_pack_index_v2
@

<<class PackIndex2>>=
class PackIndex2(FilePackIndex):
    """Version 2 Pack Index file."""

    def __init__(self, filename, file=None, contents=None, size=None):
        super(PackIndex2, self).__init__(filename, file, contents, size)
        if self._contents[:4] != b'\377tOc':
            raise AssertionError('Not a v2 pack index file')
        (self.version, ) = unpack_from(b'>L', self._contents, 4)
        if self.version != 2:
            raise AssertionError('Version was %d' % self.version)
        self._fan_out_table = self._read_fan_out_table(8)
        self._name_table_offset = 8 + 0x100 * 4
        self._crc32_table_offset = self._name_table_offset + 20 * len(self)
        self._pack_offset_table_offset = (self._crc32_table_offset +
                                          4 * len(self))
        self._pack_offset_largetable_offset = (
            self._pack_offset_table_offset + 4 * len(self))

    def _unpack_entry(self, i):
        return (self._unpack_name(i), self._unpack_offset(i),
                self._unpack_crc32_checksum(i))

    def _unpack_name(self, i):
        offset = self._name_table_offset + i * 20
        return self._contents[offset:offset+20]

    def _unpack_offset(self, i):
        offset = self._pack_offset_table_offset + i * 4
        offset = unpack_from('>L', self._contents, offset)[0]
        if offset & (2**31):
            offset = self._pack_offset_largetable_offset + (offset&(2**31-1)) * 8
            offset = unpack_from('>Q', self._contents, offset)[0]
        return offset

    def _unpack_crc32_checksum(self, i):
        return unpack_from('>L', self._contents,
                           self._crc32_table_offset + i * 4)[0]

@

<<function write_pack_index_v2>>=
def write_pack_index_v2(f, entries, pack_checksum):
    """Write a new pack index file.

    :param f: File-like object to write to
    :param entries: List of tuples with object name (sha), offset_in_pack, and
        crc32_checksum.
    :param pack_checksum: Checksum of the pack file.
    :return: The SHA of the index file written
    """
    f = SHA1Writer(f)
    f.write(b'\377tOc')  # Magic!
    f.write(struct.pack('>L', 2))
    fan_out_table = defaultdict(lambda: 0)
    for (name, offset, entry_checksum) in entries:
        fan_out_table[ord(name[:1])] += 1
    # Fan-out table
    largetable = []
    for i in range(0x100):
        f.write(struct.pack(b'>L', fan_out_table[i]))
        fan_out_table[i+1] += fan_out_table[i]
    for (name, offset, entry_checksum) in entries:
        f.write(name)
    for (name, offset, entry_checksum) in entries:
        f.write(struct.pack(b'>L', entry_checksum))
    for (name, offset, entry_checksum) in entries:
        if offset < 2**31:
            f.write(struct.pack(b'>L', offset))
        else:
            f.write(struct.pack(b'>L', 2**31 + len(largetable)))
            largetable.append(offset)
    for offset in largetable:
        f.write(struct.pack(b'>Q', offset))
    assert len(pack_checksum) == 20
    f.write(pack_checksum)
    return f.write_sha()
@

\subsection{[[unpack_object()]]}

<<constant pack._ZLIB_BUFSIZE>>=
_ZLIB_BUFSIZE = 4096
@

<<function unpack_object>>=
def unpack_object(read_all, read_some=None, compute_crc32=False,
                  include_comp=False, zlib_bufsize=_ZLIB_BUFSIZE):
    """Unpack a Git object.

    :param read_all: Read function that blocks until the number of requested
        bytes are read.
    :param read_some: Read function that returns at least one byte, but may not
        return the number of bytes requested.
    :param compute_crc32: If True, compute the CRC32 of the compressed data. If
        False, the returned CRC32 will be None.
    :param include_comp: If True, include compressed data in the result.
    :param zlib_bufsize: An optional buffer size for zlib operations.
    :return: A tuple of (unpacked, unused), where unused is the unused data
        leftover from decompression, and unpacked in an UnpackedObject with
        the following attrs set:

        * obj_chunks     (for non-delta types)
        * pack_type_num
        * delta_base     (for delta types)
        * comp_chunks    (if include_comp is True)
        * decomp_chunks
        * decomp_len
        * crc32          (if compute_crc32 is True)
    """
    if read_some is None:
        read_some = read_all
    if compute_crc32:
        crc32 = 0
    else:
        crc32 = None

    bytes, crc32 = take_msb_bytes(read_all, crc32=crc32)
    type_num = (bytes[0] >> 4) & 0x07
    size = bytes[0] & 0x0f
    for i, byte in enumerate(bytes[1:]):
        size += (byte & 0x7f) << ((i * 7) + 4)

    raw_base = len(bytes)
    if type_num == OFS_DELTA:
        bytes, crc32 = take_msb_bytes(read_all, crc32=crc32)
        raw_base += len(bytes)
        if bytes[-1] & 0x80:
            raise AssertionError
        delta_base_offset = bytes[0] & 0x7f
        for byte in bytes[1:]:
            delta_base_offset += 1
            delta_base_offset <<= 7
            delta_base_offset += (byte & 0x7f)
        delta_base = delta_base_offset
    elif type_num == REF_DELTA:
        delta_base = read_all(20)
        if compute_crc32:
            crc32 = binascii.crc32(delta_base, crc32)
        raw_base += 20
    else:
        delta_base = None

    unpacked = UnpackedObject(type_num, delta_base, size, crc32)
    unused = read_zlib_chunks(read_some, unpacked, buffer_size=zlib_bufsize,
                              include_comp=include_comp)
    return unpacked, unused
@

<<function pack.take_msb_bytes>>=
def take_msb_bytes(read, crc32=None):
    """Read bytes marked with most significant bit.

    :param read: Read function
    """
    ret = []
    while len(ret) == 0 or ret[-1] & 0x80:
        b = read(1)
        if crc32 is not None:
            crc32 = binascii.crc32(b, crc32)
        ret.append(ord(b[:1]))
    return ret, crc32
@

<<function pack.read_zlib_chunks>>=
def read_zlib_chunks(read_some, unpacked, include_comp=False,
                     buffer_size=_ZLIB_BUFSIZE):
    """Read zlib data from a buffer.

    This function requires that the buffer have additional data following the
    compressed data, which is guaranteed to be the case for git pack files.

    :param read_some: Read function that returns at least one byte, but may
        return less than the requested size.
    :param unpacked: An UnpackedObject to write result data to. If its crc32
        attr is not None, the CRC32 of the compressed bytes will be computed
        using this starting CRC32.
        After this function, will have the following attrs set:
        * comp_chunks    (if include_comp is True)
        * decomp_chunks
        * decomp_len
        * crc32
    :param include_comp: If True, include compressed data in the result.
    :param buffer_size: Size of the read buffer.
    :return: Leftover unused data from the decompression.
    :raise zlib.error: if a decompression error occurred.
    """
    if unpacked.decomp_len <= -1:
        raise ValueError('non-negative zlib data stream size expected')
    decomp_obj = zlib.decompressobj()

    comp_chunks = []
    decomp_chunks = unpacked.decomp_chunks
    decomp_len = 0
    crc32 = unpacked.crc32

    while True:
        add = read_some(buffer_size)
        if not add:
            raise zlib.error('EOF before end of zlib stream')
        comp_chunks.append(add)
        decomp = decomp_obj.decompress(add)
        decomp_len += len(decomp)
        decomp_chunks.append(decomp)
        unused = decomp_obj.unused_data
        if unused:
            left = len(unused)
            if crc32 is not None:
                crc32 = binascii.crc32(add[:-left], crc32)
            if include_comp:
                comp_chunks[-1] = add[:-left]
            break
        elif crc32 is not None:
            crc32 = binascii.crc32(add, crc32)
    if crc32 is not None:
        crc32 &= 0xffffffff

    if decomp_len != unpacked.decomp_len:
        raise zlib.error('decompressed data does not match expected size')

    unpacked.crc32 = crc32
    if include_comp:
        unpacked.comp_chunks = comp_chunks
    return unused
@

\subsection{Pack commands}

\subsubsection{[[git pack-objects]]}

<<function cmd_pack_objects>>=
class cmd_pack_objects(Command):

    def run(self, args):
        opts, args = getopt(args, '', ['stdout'])
        opts = dict(opts)
        if len(args) < 1 and not '--stdout' in args:
            print('Usage: dulwich pack-objects basename')
            sys.exit(1)
        object_ids = [l.strip() for l in sys.stdin.readlines()]
        basename = args[0]
        if '--stdout' in opts:
            packf = getattr(sys.stdout, 'buffer', sys.stdout)
            idxf = None
            close = []
        else:
            packf = open(basename + '.pack', 'w')
            idxf = open(basename + '.idx', 'w')
            close = [packf, idxf]

        porcelain.pack_objects('.', object_ids, packf, idxf)
        for f in close:
            f.close()
@

<<function porcelain.pack_objects>>=
def pack_objects(repo, object_ids, packf, idxf, delta_window_size=None):
    """Pack objects into a file.

    :param repo: Path to the repository
    :param object_ids: List of object ids to write
    :param packf: File-like object to write to
    :param idxf: File-like object to write to (can be None)
    """
    with open_repo_closing(repo) as r:
        entries, data_sum = write_pack_objects(
            packf,
            r.object_store.iter_shas((oid, None) for oid in object_ids),
            delta_window_size=delta_window_size)
    if idxf is not None:
        entries = sorted([(k, v[0], v[1]) for (k, v) in entries.items()])
        write_pack_index(idxf, entries, data_sum)
@

\subsubsection{[[git repack]]}

<<function cmd_repack>>=
class cmd_repack(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])
        opts = dict(opts)

        porcelain.repack('.')

@

<<function porcelain.repack>>=
def repack(repo):
    """Repack loose files in a repository.

    Currently this only packs loose objects.

    :param repo: Path to the repository
    """
    with open_repo_closing(repo) as r:
        r.object_store.pack_loose_objects()
@

\subsubsection{[[git fetch-pack]]}

% similar to git pull, but will not update the references.
\t but then lost? graph walker will not find them back?


<<function cmd_fetch_pack>>=
class cmd_fetch_pack(Command):

    def run(self, args):
        opts, args = getopt(args, "", ["all"])
        opts = dict(opts)

        client, path = get_transport_and_path(args.pop(0))
        r = Repo(".")
        if "--all" in opts:
            determine_wants = r.object_store.determine_wants_all
        else:
            determine_wants = lambda x: [y for y in args if not y in r.object_store]
        client.fetch(path, r, determine_wants)
@

\subsubsection{[[git receive-pack]]}

<<function cmd_receive_pack>>=
class cmd_receive_pack(Command):

    def run(self, args):
        parser = optparse.OptionParser()
        options, args = parser.parse_args(args)
        if len(args) >= 1:
            gitdir = args[0]
        else:
            gitdir = '.'

        porcelain.receive_pack(gitdir)
@

<<function porcelain.receive_pack>>=
def receive_pack(path=".", inf=None, outf=None):
    """Receive a pack file after negotiating its contents using smart protocol.

    :param path: Path to the repository
    :param inf: Input stream to communicate with client
    :param outf: Output stream to communicate with client
    """
    if outf is None:
        outf = getattr(sys.stdout, 'buffer', sys.stdout)
    if inf is None:
        inf = getattr(sys.stdin, 'buffer', sys.stdin)
    path = os.path.expanduser(path)
    backend = FileSystemBackend(path)

    def send_fn(data):
        outf.write(data)
        outf.flush()
    proto = Protocol(inf.read, send_fn)
    handler = ReceivePackHandler(backend, [path], proto)
    # FIXME: Catch exceptions and write a single-line summary to outf.
    handler.handle()
    return 0
@

\subsubsection{[[git upload-pack]]}

<<function cmd_upload_pack>>=
class cmd_upload_pack(Command):

    def run(self, args):
        parser = optparse.OptionParser()
        options, args = parser.parse_args(args)
        if len(args) >= 1:
            gitdir = args[0]
        else:
            gitdir = '.'

        porcelain.upload_pack(gitdir)
@

<<function porcelain.upload_pack>>=
def upload_pack(path=".", inf=None, outf=None):
    """Upload a pack file after negotiating its contents using smart protocol.

    :param path: Path to the repository
    :param inf: Input stream to communicate with client
    :param outf: Output stream to communicate with client
    """
    if outf is None:
        outf = getattr(sys.stdout, 'buffer', sys.stdout)
    if inf is None:
        inf = getattr(sys.stdin, 'buffer', sys.stdin)
    path = os.path.expanduser(path)
    backend = FileSystemBackend(path)

    def send_fn(data):
        outf.write(data)
        outf.flush()
    proto = Protocol(inf.read, send_fn)
    handler = UploadPackHandler(backend, [path], proto)
    # FIXME: Catch exceptions and write a single-line summary to outf.
    handler.handle()
    return 0
@

\section{Fast Import/export}
% another opti? why need that?

<<class GitFastExporter>>=
class GitFastExporter(object):
    """Generate a fast-export output stream for Git objects."""

    def __init__(self, outf, store):
        self.outf = outf
        self.store = store
        self.markers = {}
        self._marker_idx = 0

    def print_cmd(self, cmd):
        self.outf.write(getattr(cmd, "__bytes__", cmd.__repr__)() + b"\n")

    def _allocate_marker(self):
        self._marker_idx+=1
        return ("%d" % (self._marker_idx,)).encode('ascii')

    def _export_blob(self, blob):
        marker = self._allocate_marker()
        self.markers[marker] = blob.id
        return (commands.BlobCommand(marker, blob.data), marker)

    def emit_blob(self, blob):
        (cmd, marker) = self._export_blob(blob)
        self.print_cmd(cmd)
        return marker

    def _iter_files(self, base_tree, new_tree):
        for ((old_path, new_path), (old_mode, new_mode),
            (old_hexsha, new_hexsha)) in \
                self.store.tree_changes(base_tree, new_tree):
            if new_path is None:
                yield commands.FileDeleteCommand(old_path)
                continue
            if not stat.S_ISDIR(new_mode):
                blob = self.store[new_hexsha]
                marker = self.emit_blob(blob)
            if old_path != new_path and old_path is not None:
                yield commands.FileRenameCommand(old_path, new_path)
            if old_mode != new_mode or old_hexsha != new_hexsha:
                prefixed_marker = b':' + marker
                yield commands.FileModifyCommand(
                    new_path, new_mode, prefixed_marker, None
                )

    def _export_commit(self, commit, ref, base_tree=None):
        file_cmds = list(self._iter_files(base_tree, commit.tree))
        marker = self._allocate_marker()
        if commit.parents:
            from_ = commit.parents[0]
            merges = commit.parents[1:]
        else:
            from_ = None
            merges = []
        author, author_email = split_email(commit.author)
        committer, committer_email = split_email(commit.committer)
        cmd = commands.CommitCommand(ref, marker,
            (author, author_email, commit.author_time, commit.author_timezone),
            (committer, committer_email, commit.commit_time,
                commit.commit_timezone),
            commit.message, from_, merges, file_cmds)
        return (cmd, marker)

    def emit_commit(self, commit, ref, base_tree=None):
        cmd, marker = self._export_commit(commit, ref, base_tree)
        self.print_cmd(cmd)
        return marker
@

<<function fastexport.split_email>>=
def split_email(text):
    (name, email) = text.rsplit(b" <", 1)
    return (name, email.rstrip(b">"))
@

<<class GitImportProcessor>>=
class GitImportProcessor(processor.ImportProcessor):
    """An import processor that imports into a Git repository using Dulwich.

    """
    # FIXME: Batch creation of objects?

    def __init__(self, repo, params=None, verbose=False, outf=None):
        processor.ImportProcessor.__init__(self, params, verbose)
        self.repo = repo
        self.last_commit = None
        self.markers = {}
        self._contents = {}

    def import_stream(self, stream):
        p = parser.ImportParser(stream)
        self.process(p.iter_commands)
        return self.markers

    def blob_handler(self, cmd):
        """Process a BlobCommand."""
        blob = Blob.from_string(cmd.data)
        self.repo.object_store.add_object(blob)
        if cmd.mark:
            self.markers[cmd.mark] = blob.id

    def checkpoint_handler(self, cmd):
        """Process a CheckpointCommand."""
        pass

    def commit_handler(self, cmd):
        """Process a CommitCommand."""
        commit = Commit()
        if cmd.author is not None:
            author = cmd.author
        else:
            author = cmd.committer
        (author_name, author_email, author_timestamp, author_timezone) = author
        (committer_name, committer_email, commit_timestamp,
            commit_timezone) = cmd.committer
        commit.author = author_name + b" <" + author_email + b">"
        commit.author_timezone = author_timezone
        commit.author_time = int(author_timestamp)
        commit.committer = committer_name + b" <" + committer_email + b">"
        commit.commit_timezone = commit_timezone
        commit.commit_time = int(commit_timestamp)
        commit.message = cmd.message
        commit.parents = []
        if cmd.from_:
            self._reset_base(cmd.from_)
        for filecmd in cmd.iter_files():
            if filecmd.name == b"filemodify":
                if filecmd.data is not None:
                    blob = Blob.from_string(filecmd.data)
                    self.repo.object_store.add(blob)
                    blob_id = blob.id
                else:
                    assert filecmd.dataref.startswith(b":"), \
                        "non-marker refs not supported yet (%r)" % filecmd.dataref
                    blob_id = self.markers[filecmd.dataref[1:]]
                self._contents[filecmd.path] = (filecmd.mode, blob_id)
            elif filecmd.name == b"filedelete":
                del self._contents[filecmd.path]
            elif filecmd.name == b"filecopy":
                self._contents[filecmd.dest_path] = self._contents[
                    filecmd.src_path]
            elif filecmd.name == b"filerename":
                self._contents[filecmd.new_path] = self._contents[
                    filecmd.old_path]
                del self._contents[filecmd.old_path]
            elif filecmd.name == b"filedeleteall":
                self._contents = {}
            else:
                raise Exception("Command %s not supported" % filecmd.name)
        commit.tree = commit_tree(self.repo.object_store,
            ((path, hexsha, mode) for (path, (mode, hexsha)) in
                self._contents.items()))
        if self.last_commit is not None:
            commit.parents.append(self.last_commit)
        commit.parents += cmd.merges
        self.repo.object_store.add_object(commit)
        self.repo[cmd.ref] = commit.id
        self.last_commit = commit.id
        if cmd.mark:
            self.markers[cmd.mark] = commit.id

    def progress_handler(self, cmd):
        """Process a ProgressCommand."""
        pass

    def _reset_base(self, commit_id):
        if self.last_commit == commit_id:
            return
        self.last_commit = commit_id
        self._contents = {}
        tree_id = self.repo[commit_id].tree
        for (path, mode, hexsha) in (
                self.repo.object_store.iter_tree_contents(tree_id)):
            self._contents[path] = (mode, hexsha)

    def reset_handler(self, cmd):
        """Process a ResetCommand."""
        self._reset_base(cmd.from_)
        self.repo.refs[cmd.ref] = cmd.from_

    def tag_handler(self, cmd):
        """Process a TagCommand."""
        tag = Tag()
        tag.tagger = cmd.tagger
        tag.message = cmd.message
        tag.name = cmd.tag
        self.repo.add_object(tag)
        self.repo.refs["refs/tags/" + tag.name] = tag.id

    def feature_handler(self, cmd):
        """Process a FeatureCommand."""
        raise fastimport_errors.UnknownFeature(cmd.feature_name)
@



\section{Alternates}

\t ??? related to pack files?

<<[[PackBasedObjectStore]] methods>>=
@property
def alternates(self):
    return []
@

<<[[DiskObjectStore.__init__()]] set alternates>>=
self._alternates = None
@

<<[[PackBasedObjectStore.get_raw()]] look in alternates>>=
for alternate in self.alternates:
    try:
        return alternate.get_raw(hexsha)
    except KeyError:
        pass
@


<<[[DiskObjectStore]] methods>>=
@property
def alternates(self):
    if self._alternates is not None:
        return self._alternates
    self._alternates = []
    for path in self._read_alternate_paths():
        self._alternates.append(DiskObjectStore(path))
    return self._alternates

@

<<[[DiskObjectStore]] methods>>=
def _read_alternate_paths(self):
    try:
        f = GitFile(os.path.join(self.path, INFODIR, "alternates"), 'rb')
    except (OSError, IOError) as e:
        if e.errno == errno.ENOENT:
            return
        raise
    with f:
        for l in f.readlines():
            l = l.rstrip(b"\n")
            if l[0] == b"#":
                continue
            if os.path.isabs(l):
                yield l.decode(sys.getfilesystemencoding())
            else:
                yield os.path.join(self.path, l).decode(
                    sys.getfilesystemencoding())

@

<<[[DiskObjectStore]] methods>>=
def add_alternate_path(self, path):
    """Add an alternate path to this object store.
    """
    try:
        os.mkdir(os.path.join(self.path, INFODIR))
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    alternates_path = os.path.join(self.path, INFODIR, "alternates")
    with GitFile(alternates_path, 'wb') as f:
        try:
            orig_f = open(alternates_path, 'rb')
        except (OSError, IOError) as e:
            if e.errno != errno.ENOENT:
                raise
        else:
            with orig_f:
                f.write(orig_f.read())
        f.write(path.encode(sys.getfilesystemencoding()) + b"\n")

    if not os.path.isabs(path):
        path = os.path.join(self.path, path)
    self.alternates.append(DiskObjectStore(path))

@

\section{Peeled}

% seems related to tags, so move with Tags?

<<[[BaseObjectStore]] methods>>=
def peel_sha(self, sha):
    """Peel all tags from a SHA.

    :param sha: The object SHA to peel.
    :return: The fully-peeled SHA1 of a tag object, after peeling all
        intermediate tags; if the original ref does not point to a tag,
        this will equal the original SHA1.
    """
    obj = self[sha]
    obj_class = object_class(obj.type_name)
    while obj_class is Tag:
        obj_class, sha = obj.object
        obj = self[sha]
    return obj

@

<<[[RefsContainer]] methods>>=
def get_peeled(self, name):
    """Return the cached peeled value of a ref, if available.

    :param name: Name of the ref to peel
    :return: The peeled value of the ref. If the ref is known not point to a
        tag, this will be the SHA the ref refers to. If the ref may point to
        a tag, but no cached information is available, None is returned.
    """
    return None
@
<<[[BaseRepo]] methods>>=
def get_peeled(self, ref):
    """Get the peeled value of a ref.

    :param ref: The refname to peel.
    :return: The fully-peeled SHA1 of a tag object, after peeling all
        intermediate tags; if the original ref does not point to a tag,
        this will equal the original SHA1.
    """
    cached = self.refs.get_peeled(ref)
    if cached is not None:
        return cached
    return self.object_store.peel_sha(self.refs[ref]).id
@

<<[[DiskRefsContainer]] methods>>=
def get_peeled(self, name):
    """Return the cached peeled value of a ref, if available.

    :param name: Name of the ref to peel
    :return: The peeled value of the ref. If the ref is known not point to a
        tag, this will be the SHA the ref refers to. If the ref may point to
        a tag, but no cached information is available, None is returned.
    """
    self.get_packed_refs()
    if self._peeled_refs is None or name not in self._packed_refs:
        # No cache: no peeled refs were read, or this ref is loose
        return None
    if name in self._peeled_refs:
        return self._peeled_refs[name]
    else:
        # Known not peelable
        return self[name]

@


\section{Other clients}

\subsection{[[ssh://]] client}

<<[[get_transport_and_path_from_url()]] elif ssh>>=
elif parsed.scheme in ('git+ssh', 'ssh'):
    return SSHGitClient.from_parsedurl(parsed, **kwargs), parsed.path
@

<<[[get_transport_and_path()]] try parse location as a ssh URL>>=
# First, try to parse it as a URL
try:
    return get_transport_and_path_from_url(location, **kwargs)
except ValueError:
    pass

if ':' in location and '@' not in location:
    # SSH with no user@, zero or one leading slash.
    (hostname, path) = location.split(':', 1)
    return SSHGitClient(hostname, **kwargs), path
elif ':' in location:
    # SSH with user@host:foo.
    user_host, path = location.split(':', 1)
    if '@' in user_host:
        user, host = user_host.rsplit('@', 1)
    else:
        user = None
        host = user_host
    return SSHGitClient(host, username=user, **kwargs), path
@



<<class SSHGitClient>>=
class SSHGitClient(TraditionalGitClient):

    <<[[SSHGitClient]] methods>>
@

<<[[SSHGitClient]] methods>>=
def __init__(self, host, port=None, username=None, vendor=None, **kwargs):
    self.host = host
    self.port = port
    self.username = username
    super(SSHGitClient, self).__init__(**kwargs)
    self.alternative_paths = {}
    if vendor is not None:
        self.ssh_vendor = vendor
    else:
        self.ssh_vendor = get_ssh_vendor()
@

<<[[SSHGitClient]] methods>>=
def get_url(self, path):
    netloc = self.host
    if self.port is not None:
        netloc += ":%d" % self.port

    if self.username is not None:
        netloc = urlquote(self.username, '@/:') + "@" + netloc

    return urlparse.urlunsplit(('ssh', netloc, path, '', ''))

@classmethod
def from_parsedurl(cls, parsedurl, **kwargs):
    return cls(host=parsedurl.hostname, port=parsedurl.port,
               username=parsedurl.username, **kwargs)

def _get_cmd_path(self, cmd):
    cmd = self.alternative_paths.get(cmd, b'git-' + cmd)
    assert isinstance(cmd, bytes)
    return cmd

def _connect(self, cmd, path):
    if not isinstance(cmd, bytes):
        raise TypeError(cmd)
    if isinstance(path, bytes):
        path = path.decode(self._remote_path_encoding)
    if path.startswith("/~"):
        path = path[1:]
    argv = (self._get_cmd_path(cmd).decode(self._remote_path_encoding) +
            " '" + path + "'")
    con = self.ssh_vendor.run_command(
        self.host, argv, port=self.port, username=self.username)
    return (Protocol(con.read, con.write, con.close,
                     report_activity=self._report_activity),
            con.can_read)
@

<<global get_ssh_vendor>>=
# Can be overridden by users
get_ssh_vendor = SubprocessSSHVendor
@

<<class SSHVendor>>=
class SSHVendor(object):
    """A client side SSH implementation."""

    def run_command(self, host, command, username=None, port=None):
        """Connect to an SSH server.

        Run a command remotely and return a file-like object for interaction
        with the remote command.

        :param host: Host name
        :param command: Command to run (as argv array)
        :param username: Optional ame of user to log in as
        :param port: Optional SSH port to use
        """
        raise NotImplementedError(self.run_command)
@

%deprecated:
%    def connect_ssh(self, host, command, username=None, port=None):
%        # This function was deprecated in 0.9.1
%        import warnings
%        warnings.warn(
%            "SSHVendor.connect_ssh has been renamed to SSHVendor.run_command",
%            DeprecationWarning)
%        return self.run_command(host, command, username=username, port=port)

<<class SubprocessSSHVendor>>=
class SubprocessSSHVendor(SSHVendor):
    """SSH vendor that shells out to the local 'ssh' command."""

    def run_command(self, host, command, username=None, port=None):
        # FIXME: This has no way to deal with passwords..
        args = ['ssh', '-x']
        if port is not None:
            args.extend(['-p', str(port)])
        if username is not None:
            host = '%s@%s' % (username, host)
        args.append(host)
        proc = subprocess.Popen(args + [command], bufsize=0,
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE)
        return SubprocessWrapper(proc)
@

<<class SubprocessWrapper>>=
class SubprocessWrapper(object):
    """A socket-like object that talks to a subprocess via pipes."""

    def __init__(self, proc):
        self.proc = proc
        if sys.version_info[0] == 2:
            self.read = proc.stdout.read
        else:
            self.read = BufferedReader(proc.stdout).read
        self.write = proc.stdin.write

    def can_read(self):
            return _fileno_can_read(self.proc.stdout.fileno())

    def close(self):
        self.proc.stdin.close()
        self.proc.stdout.close()
        if self.proc.stderr:
            self.proc.stderr.close()
        self.proc.wait()
@

%win32:
%        if sys.platform == 'win32':
%            from msvcrt import get_osfhandle
%            handle = get_osfhandle(self.proc.stdout.fileno())
%            return _win32_peek_avail(handle) != 0
%        else:

%def _win32_peek_avail(handle):
%    """Wrapper around PeekNamedPipe to check how many bytes are available."""
%    from ctypes import byref, wintypes, windll
%    c_avail = wintypes.DWORD()
%    c_message = wintypes.DWORD()
%    success = windll.kernel32.PeekNamedPipe(
%        handle, None, 0, None, byref(c_avail),
%        byref(c_message))
%    if not success:
%        raise OSError(wintypes.GetLastError())
%    return c_avail.value


\subsection{[[http://]] client}

<<[[get_transport_and_path_from_url()]] elif http>>=
elif parsed.scheme in ('http', 'https'):
    return HttpGitClient.from_parsedurl(
        parsed, config=config, **kwargs), parsed.path
@

<<class HttpGitClient>>=
class HttpGitClient(GitClient):

    def __init__(self, base_url, dumb=None, opener=None, config=None,
                 username=None, password=None, **kwargs):
        self._base_url = base_url.rstrip("/") + "/"
        self._username = username
        self._password = password
        self.dumb = dumb
        if opener is None:
            self.opener = default_urllib2_opener(config)
        else:
            self.opener = opener
        if username is not None:
            pass_man = urllib2.HTTPPasswordMgrWithDefaultRealm()
            pass_man.add_password(None, base_url, username, password)
            self.opener.add_handler(urllib2.HTTPBasicAuthHandler(pass_man))
        GitClient.__init__(self, **kwargs)

    def get_url(self, path):
        return self._get_url(path).rstrip("/")

    @classmethod
    def from_parsedurl(cls, parsedurl, **kwargs):
        auth, host = urllib2.splituser(parsedurl.netloc)
        password = parsedurl.password
        if password is not None:
            password = urlunquote(password)
        username = parsedurl.username
        if username is not None:
            username = urlunquote(username)
        # TODO(jelmer): This also strips the username
        parsedurl = parsedurl._replace(netloc=host)
        return cls(urlparse.urlunparse(parsedurl),
                   password=password, username=username, **kwargs)

    def __repr__(self):
        return "%s(%r, dumb=%r)" % (
            type(self).__name__, self._base_url, self.dumb)

    def _get_url(self, path):
        if not isinstance(path, str):
            # TODO(jelmer): this is unrelated to the local filesystem;
            # This is not necessarily the right encoding to decode the path
            # with.
            path = path.decode(sys.getfilesystemencoding())
        return urlparse.urljoin(self._base_url, path).rstrip("/") + "/"

    def _http_request(self, url, headers={}, data=None):
        req = urllib2.Request(url, headers=headers, data=data)
        try:
            resp = self.opener.open(req)
        except urllib2.HTTPError as e:
            if e.code == 404:
                raise NotGitRepository()
            if e.code != 200:
                raise GitProtocolError("unexpected http response %d" % e.code)
        return resp

    def _discover_references(self, service, url):
        assert url[-1] == "/"
        url = urlparse.urljoin(url, "info/refs")
        headers = {}
        if self.dumb is not False:
            url += "?service=%s" % service.decode('ascii')
            headers["Content-Type"] = "application/x-%s-request" % (
                service.decode('ascii'))
        resp = self._http_request(url, headers)
        try:
            content_type = resp.info().gettype()
        except AttributeError:
            content_type = resp.info().get_content_type()
        try:
            self.dumb = (not content_type.startswith("application/x-git-"))
            if not self.dumb:
                proto = Protocol(resp.read, None)
                # The first line should mention the service
                try:
                    [pkt] = list(proto.read_pkt_seq())
                except ValueError:
                    raise GitProtocolError(
                        "unexpected number of packets received")
                if pkt.rstrip(b'\n') != (b'# service=' + service):
                    raise GitProtocolError(
                        "unexpected first line %r from smart server" % pkt)
                return read_pkt_refs(proto)
            else:
                return read_info_refs(resp), set()
        finally:
            resp.close()

    def _smart_request(self, service, url, data):
        assert url[-1] == "/"
        url = urlparse.urljoin(url, service)
        headers = {
            "Content-Type": "application/x-%s-request" % service
        }
        resp = self._http_request(url, headers, data)
        try:
            content_type = resp.info().gettype()
        except AttributeError:
            content_type = resp.info().get_content_type()
        if content_type != (
                "application/x-%s-result" % service):
            raise GitProtocolError("Invalid content-type from server: %s"
                                   % content_type)
        return resp

    def send_pack(self, path, update_refs, generate_pack_contents,
                  progress=None, write_pack=write_pack_objects):
        """Upload a pack to a remote repository.

        :param path: Repository path (as bytestring)
        :param update_refs: Function to determine changes to remote refs.
            Receive dict with existing remote refs, returns dict with
            changed refs (name -> sha, where sha=ZERO_SHA for deletions)
        :param generate_pack_contents: Function that can return a sequence of
            the shas of the objects to upload.
        :param progress: Optional progress function
        :param write_pack: Function called with (file, iterable of objects) to
            write the objects returned by generate_pack_contents to the server.

        :raises SendPackError: if server rejects the pack data
        :raises UpdateRefsError: if the server supports report-status
                                 and rejects ref updates
        :return: new_refs dictionary containing the changes that were made
            {refname: new_ref}, including deleted refs.
        """
        url = self._get_url(path)
        old_refs, server_capabilities = self._discover_references(
            b"git-receive-pack", url)
        negotiated_capabilities = self._send_capabilities & server_capabilities

        if CAPABILITY_REPORT_STATUS in negotiated_capabilities:
            self._report_status_parser = ReportStatusParser()

        new_refs = update_refs(dict(old_refs))
        if new_refs is None:
            # Determine wants function is aborting the push.
            return old_refs
        if self.dumb:
            raise NotImplementedError(self.fetch_pack)
        req_data = BytesIO()
        req_proto = Protocol(None, req_data.write)
        (have, want) = self._handle_receive_pack_head(
            req_proto, negotiated_capabilities, old_refs, new_refs)
        if not want and set(new_refs.items()).issubset(set(old_refs.items())):
            return new_refs
        objects = generate_pack_contents(have, want)
        if len(objects) > 0:
            write_pack(req_proto.write_file(), objects)
        resp = self._smart_request("git-receive-pack", url,
                                   data=req_data.getvalue())
        try:
            resp_proto = Protocol(resp.read, None)
            self._handle_receive_pack_tail(
                resp_proto, negotiated_capabilities, progress)
            return new_refs
        finally:
            resp.close()

    def fetch_pack(self, path, determine_wants, graph_walker, pack_data,
                   progress=None):
        """Retrieve a pack from a git smart server.

        :param determine_wants: Callback that returns list of commits to fetch
        :param graph_walker: Object with next() and ack().
        :param pack_data: Callback called for each bit of data in the pack
        :param progress: Callback for progress reports (strings)
        :return: Dictionary with all remote refs (not just those fetched)
        """
        url = self._get_url(path)
        refs, server_capabilities = self._discover_references(
            b"git-upload-pack", url)
        negotiated_capabilities = (
            self._fetch_capabilities & server_capabilities)
        wants = determine_wants(refs)
        if wants is not None:
            wants = [cid for cid in wants if cid != ZERO_SHA]
        if not wants:
            return refs
        if self.dumb:
            raise NotImplementedError(self.send_pack)
        req_data = BytesIO()
        req_proto = Protocol(None, req_data.write)
        self._handle_upload_pack_head(
                req_proto, negotiated_capabilities, graph_walker, wants,
                lambda: False)
        resp = self._smart_request(
            "git-upload-pack", url, data=req_data.getvalue())
        try:
            resp_proto = Protocol(resp.read, None)
            self._handle_upload_pack_tail(
                resp_proto, negotiated_capabilities, graph_walker, pack_data,
                progress)
            return refs
        finally:
            resp.close()

    def get_refs(self, path):
        """Retrieve the current refs from a git smart server."""
        url = self._get_url(path)
        refs, _ = self._discover_references(
            b"git-upload-pack", url)
        return refs
@


<<function client.default_user_agent_string>>=
def default_user_agent_string():
    return "dulwich/%s" % ".".join([str(x) for x in dulwich.__version__])
@

<<function client.default_urllib2_opener>>=
def default_urllib2_opener(config):
    if config is not None:
        proxy_server = config.get("http", "proxy")
    else:
        proxy_server = None
    handlers = []
    if proxy_server is not None:
        handlers.append(urllib2.ProxyHandler({"http": proxy_server}))
    opener = urllib2.build_opener(*handlers)
    if config is not None:
        user_agent = config.get("http", "useragent")
    else:
        user_agent = None
    if user_agent is None:
        user_agent = default_user_agent_string()
    opener.addheaders = [('User-agent', user_agent)]
    return opener
@

%\subsection{Info refs}

<<function refs.read_info_refs>>=
def read_info_refs(f):
    ret = {}
    for l in f.readlines():
        (sha, name) = l.rstrip(b"\r\n").split(b"\t", 1)
        ret[name] = sha
    return ret
@

<<function refs.write_info_refs>>=
def write_info_refs(refs, store):
    """Generate info refs."""
    for name, sha in sorted(refs.items()):
        # get_refs() includes HEAD as a special case, but we don't want to
        # advertise it
        if name == b'HEAD':
            continue
        try:
            o = store[sha]
        except KeyError:
            continue
        peeled = store.peel_sha(sha)
        yield o.id + b'\t' + name + b'\n'
        if o.id != peeled.id:
            yield peeled.id + b'\t' + name + ANNOTATED_TAG_SUFFIX + b'\n'
@

\section{Other servers}

%\subsection{[[git daemon]]}

%\subsection{[[git web-daemon]]}

\subsection{[[http://]] server}
% git smart http protocol

% also cgit? nice web interface to explore repo?

<<function cmd_web_daemon>>=
class cmd_web_daemon(Command):

    def run(self, args):
        from dulwich import log_utils
        parser = optparse.OptionParser()
        parser.add_option("-l", "--listen_address", dest="listen_address",
                          default="",
                          help="Binding IP address.")
        parser.add_option("-p", "--port", dest="port", type=int,
                          default=8000,
                          help="Binding TCP port.")
        options, args = parser.parse_args(args)

        log_utils.default_logging_config()
        if len(args) >= 1:
            gitdir = args[0]
        else:
            gitdir = '.'
        from dulwich import porcelain
        porcelain.web_daemon(gitdir, address=options.listen_address,
                             port=options.port)

@

<<function porcelain.web_daemon>>=
def web_daemon(path=".", address=None, port=None):
    """Run a daemon serving Git requests over HTTP.

    :param path: Path to the directory to serve
    :param address: Optional address to listen on (defaults to ::)
    :param port: Optional port to listen on (defaults to 80)
    """
    from dulwich.web import (
        make_wsgi_chain,
        make_server,
        WSGIRequestHandlerLogger,
        WSGIServerLogger)

    backend = FileSystemBackend(path)
    app = make_wsgi_chain(backend)
    server = make_server(address, port, app,
                         handler_class=WSGIRequestHandlerLogger,
                         server_class=WSGIServerLogger)
    server.serve_forever()
@


\section{Advanced client/server capabilities}

\subsection{Report status}
% mv in Debugging appendix?

<<[[GitClient.__init__()]] set fields>>=
self._report_status_parser = None
@

<<[[TraditionalGitClient.send_pack()]] if report_status capability>>=
if CAPABILITY_REPORT_STATUS in negotiated_capabilities:
    self._report_status_parser = ReportStatusParser()
report_status_parser = self._report_status_parser
@

<<[[TraditionalGitClient.send_pack()]] when ZERO_SHA if report>>=
if CAPABILITY_REPORT_STATUS in negotiated_capabilities:
    report_status_parser._ref_statuses.append(
        b'ng ' + sha +
        b' remote does not support deleting refs')
    report_status_parser._ref_status_ok = False
@

<<[[TraditionalGitClient.send_pack()]] when no new refs>>=
if report_status_parser is not None:
    report_status_parser.check()
@

<<[[GitClient._handle_receive_pack_tail()]] when side-band, if report status>>=
if CAPABILITY_REPORT_STATUS in capabilities:
    channel_callbacks[1] = PktLineParser(
        self._report_status_parser.handle_packet).parse
@

<<[[GitClient._handle_receive_pack_tail()]] when no side-band, if report status>>=
if CAPABILITY_REPORT_STATUS in capabilities:
    for pkt in proto.read_pkt_seq():
        self._report_status_parser.handle_packet(pkt)
@

<<[[GitClient._handle_receive_pack_tail()]] at end, if report status>>=
if self._report_status_parser is not None:
    self._report_status_parser.check()
@


<<class ReportStatusParser>>=
class ReportStatusParser(object):
    """Handle status as reported by servers with 'report-status' capability.
    """

    def __init__(self):
        self._done = False
        self._pack_status = None
        self._ref_status_ok = True
        self._ref_statuses = []

    def check(self):
        """Check if there were any errors and, if so, raise exceptions.

        :raise SendPackError: Raised when the server could not unpack
        :raise UpdateRefsError: Raised when refs could not be updated
        """
        if self._pack_status not in (b'unpack ok', None):
            raise SendPackError(self._pack_status)
        if not self._ref_status_ok:
            ref_status = {}
            ok = set()
            for status in self._ref_statuses:
                if b' ' not in status:
                    # malformed response, move on to the next one
                    continue
                status, ref = status.split(b' ', 1)

                if status == b'ng':
                    if b' ' in ref:
                        ref, status = ref.split(b' ', 1)
                else:
                    ok.add(ref)
                ref_status[ref] = status
            # TODO(jelmer): don't assume encoding of refs is ascii.
            raise UpdateRefsError(', '.join([
                ref.decode('ascii') for ref in ref_status if ref not in ok]) +
                ' failed to update', ref_status=ref_status)

    def handle_packet(self, pkt):
        """Handle a packet.

        :raise GitProtocolError: Raised when packets are received after a
            flush packet.
        """
        if self._done:
            raise GitProtocolError("received more data after status report")
        if pkt is None:
            self._done = True
            return
        if self._pack_status is None:
            self._pack_status = pkt.strip()
        else:
            ref_status = pkt.strip()
            self._ref_statuses.append(ref_status)
            if not ref_status.startswith(b'ok '):
                self._ref_status_ok = False
@

\subsection{Quiet}

<<[[GitClient.__init__()]] adjust capabilities>>=
if quiet:
    self._send_capabilities.add(CAPABILITY_QUIET)
@

\subsection{Thin pack}

<<[[GitClient.__init__()]] adjust capabilities>>=
if not thin_packs:
    self._fetch_capabilities.remove(CAPABILITY_THIN_PACK)
@

<<[[GitClient.fetch()]] if thin pack capability>>=
if CAPABILITY_THIN_PACK in self._fetch_capabilities:
    # TODO(jelmer): Avoid reading entire file into memory and
    # only processing it after the whole file has been fetched.
    f = BytesIO()

    def commit():
        if f.tell():
            f.seek(0)
            target.object_store.add_thin_pack(f.read, None)

    def abort():
        pass
@

<<[[DiskObjectStore]] methods>>=
def add_thin_pack(self, read_all, read_some):
    """Add a new thin pack to this object store.

    Thin packs are packs that contain deltas with parents that exist
    outside the pack. They should never be placed in the object store
    directly, and always indexed and completed as they are copied.

    :param read_all: Read function that blocks until the number of
        requested bytes are read.
    :param read_some: Read function that returns at least one byte, but may
        not return the number of bytes requested.
    :return: A Pack object pointing at the now-completed thin pack in the
        objects/pack directory.
    """
    fd, path = tempfile.mkstemp(dir=self.path, prefix='tmp_pack_')
    with os.fdopen(fd, 'w+b') as f:
        indexer = PackIndexer(f, resolve_ext_ref=self.get_raw)
        copier = PackStreamCopier(read_all, read_some, f,
                                  delta_iter=indexer)
        copier.verify()
        return self._complete_thin_pack(f, path, copier, indexer)

@


<<[[DiskObjectStore]] methods>>=
def _complete_thin_pack(self, f, path, copier, indexer):
    """Move a specific file containing a pack into the pack directory.

    :note: The file should be on the same file system as the
        packs directory.

    :param f: Open file object for the pack.
    :param path: Path to the pack file.
    :param copier: A PackStreamCopier to use for writing pack data.
    :param indexer: A PackIndexer for indexing the pack.
    """
    entries = list(indexer)

    # Update the header with the new number of objects.
    f.seek(0)
    write_pack_header(f, len(entries) + len(indexer.ext_refs()))

    # Must flush before reading (http://bugs.python.org/issue3207)
    f.flush()

    # Rescan the rest of the pack, computing the SHA with the new header.
    new_sha = compute_file_sha(f, end_ofs=-20)

    # Must reposition before writing (http://bugs.python.org/issue3207)
    f.seek(0, os.SEEK_CUR)

    # Complete the pack.
    for ext_sha in indexer.ext_refs():
        assert len(ext_sha) == 20
        type_num, data = self.get_raw(ext_sha)
        offset = f.tell()
        crc32 = write_pack_object(f, type_num, data, sha=new_sha)
        entries.append((ext_sha, offset, crc32))
    pack_sha = new_sha.digest()
    f.write(pack_sha)
    f.close()

    # Move the pack in.
    entries.sort()
    pack_base_name = self._get_pack_basepath(entries)

    os.rename(path, pack_base_name + '.pack')

    # Write the index.
    index_file = GitFile(pack_base_name + '.idx', 'wb')
    try:
        write_pack_index_v2(index_file, entries, pack_sha)
        index_file.close()
    finally:
        index_file.abort()

    # Add the pack to the store and return it.
    final_pack = Pack(pack_base_name)
    final_pack.check_length_and_checksum()
    self._add_known_pack(pack_base_name, final_pack)
    return final_pack
@

%win32:
%    if sys.platform == 'win32':
%        try:
%            os.rename(path, pack_base_name + '.pack')
%        except WindowsError:
%            os.remove(pack_base_name + '.pack')
%            os.rename(path, pack_base_name + '.pack')
%    else:

<<class PackStreamReader>>=
class PackStreamReader(object):
    """Class to read a pack stream.

    The pack is read from a ReceivableProtocol using read() or recv() as
    appropriate.
    """

    def __init__(self, read_all, read_some=None, zlib_bufsize=_ZLIB_BUFSIZE):
        self.read_all = read_all
        if read_some is None:
            self.read_some = read_all
        else:
            self.read_some = read_some
        self.sha = sha1()
        self._offset = 0
        self._rbuf = BytesIO()
        # trailer is a deque to avoid memory allocation on small reads
        self._trailer = deque()
        self._zlib_bufsize = zlib_bufsize

    def _read(self, read, size):
        """Read up to size bytes using the given callback.

        As a side effect, update the verifier's hash (excluding the last 20
        bytes read).

        :param read: The read callback to read from.
        :param size: The maximum number of bytes to read; the particular
            behavior is callback-specific.
        """
        data = read(size)

        # maintain a trailer of the last 20 bytes we've read
        n = len(data)
        self._offset += n
        tn = len(self._trailer)
        if n >= 20:
            to_pop = tn
            to_add = 20
        else:
            to_pop = max(n + tn - 20, 0)
            to_add = n
        self.sha.update(
            bytes(bytearray([self._trailer.popleft() for _ in range(to_pop)])))
        self._trailer.extend(data[-to_add:])

        # hash everything but the trailer
        self.sha.update(data[:-to_add])
        return data

    def _buf_len(self):
        buf = self._rbuf
        start = buf.tell()
        buf.seek(0, SEEK_END)
        end = buf.tell()
        buf.seek(start)
        return end - start

    @property
    def offset(self):
        return self._offset - self._buf_len()

    def read(self, size):
        """Read, blocking until size bytes are read."""
        buf_len = self._buf_len()
        if buf_len >= size:
            return self._rbuf.read(size)
        buf_data = self._rbuf.read()
        self._rbuf = BytesIO()
        return buf_data + self._read(self.read_all, size - buf_len)

    def recv(self, size):
        """Read up to size bytes, blocking until one byte is read."""
        buf_len = self._buf_len()
        if buf_len:
            data = self._rbuf.read(size)
            if size >= buf_len:
                self._rbuf = BytesIO()
            return data
        return self._read(self.read_some, size)

    def __len__(self):
        return self._num_objects

    def read_objects(self, compute_crc32=False):
        """Read the objects in this pack file.

        :param compute_crc32: If True, compute the CRC32 of the compressed
            data. If False, the returned CRC32 will be None.
        :return: Iterator over UnpackedObjects with the following members set:
            offset
            obj_type_num
            obj_chunks (for non-delta types)
            delta_base (for delta types)
            decomp_chunks
            decomp_len
            crc32 (if compute_crc32 is True)
        :raise ChecksumMismatch: if the checksum of the pack contents does not
            match the checksum in the pack trailer.
        :raise zlib.error: if an error occurred during zlib decompression.
        :raise IOError: if an error occurred writing to the output file.
        """
        pack_version, self._num_objects = read_pack_header(self.read)
        if pack_version is None:
            return

        for i in range(self._num_objects):
            offset = self.offset
            unpacked, unused = unpack_object(
              self.read, read_some=self.recv, compute_crc32=compute_crc32,
              zlib_bufsize=self._zlib_bufsize)
            unpacked.offset = offset

            # prepend any unused data to current read buffer
            buf = BytesIO()
            buf.write(unused)
            buf.write(self._rbuf.read())
            buf.seek(0)
            self._rbuf = buf

            yield unpacked

        if self._buf_len() < 20:
            # If the read buffer is full, then the last read() got the whole
            # trailer off the wire. If not, it means there is still some of the
            # trailer to read. We need to read() all 20 bytes; N come from the
            # read buffer and (20 - N) come from the wire.
            self.read(20)

        pack_sha = bytearray(self._trailer)
        if pack_sha != self.sha.digest():
            raise ChecksumMismatch(sha_to_hex(pack_sha), self.sha.hexdigest())
@


<<class PackIndexer>>=
class PackIndexer(DeltaChainIterator):
    """Delta chain iterator that yields index entries."""

    _compute_crc32 = True

    def _result(self, unpacked):
        return unpacked.sha(), unpacked.offset, unpacked.crc32
@

<<class PackInflater>>=
class PackInflater(DeltaChainIterator):
    """Delta chain iterator that yields ShaFile objects."""

    def _result(self, unpacked):
        return unpacked.sha_file()
@

<<class PackStreamCopier>>=
class PackStreamCopier(PackStreamReader):
    """Class to verify a pack stream as it is being read.

    The pack is read from a ReceivableProtocol using read() or recv() as
    appropriate and written out to the given file-like object.
    """

    def __init__(self, read_all, read_some, outfile, delta_iter=None):
        """Initialize the copier.

        :param read_all: Read function that blocks until the number of
            requested bytes are read.
        :param read_some: Read function that returns at least one byte, but may
            not return the number of bytes requested.
        :param outfile: File-like object to write output through.
        :param delta_iter: Optional DeltaChainIterator to record deltas as we
            read them.
        """
        super(PackStreamCopier, self).__init__(read_all, read_some=read_some)
        self.outfile = outfile
        self._delta_iter = delta_iter

    def _read(self, read, size):
        """Read data from the read callback and write it to the file."""
        data = super(PackStreamCopier, self)._read(read, size)
        self.outfile.write(data)
        return data

    def verify(self):
        """Verify a pack stream and write it to the output file.

        See PackStreamReader.iterobjects for a list of exceptions this may
        throw.
        """
        if self._delta_iter:
            for unpacked in self.read_objects():
                self._delta_iter.record(unpacked)
        else:
            for _ in self.read_objects():
                pass
@

\subsection{Side band 64k}

<<[[GitClient._handle_upload_pack_tail()]] if side band capability>>=
if CAPABILITY_SIDE_BAND_64K in capabilities:
    if progress is None:
        # Just ignore progress data

        def progress(x):
            pass
    self._read_side_band64k_data(proto, {
        SIDE_BAND_CHANNEL_DATA: pack_data,
        SIDE_BAND_CHANNEL_PROGRESS: progress}
    )
@

<<[[GitClient._handle_receive_pack_tail()]] if side-band capability>>=
if b"side-band-64k" in capabilities:
    if progress is None:
        def progress(x):
            pass
    channel_callbacks = {2: progress}
    <<[[GitClient._handle_receive_pack_tail()]] when side-band, if report status>>
    self._read_side_band64k_data(proto, channel_callbacks)
@




<<[[GitClient]] methods>>=
def _read_side_band64k_data(self, proto, channel_callbacks):
    """Read per-channel data.

    This requires the side-band-64k capability.

    :param proto: Protocol object to read from
    :param channel_callbacks: Dictionary mapping channels to packet
        handlers to use. None for a callback discards channel data.
    """
    for pkt in proto.read_pkt_seq():
        channel = ord(pkt[:1])
        pkt = pkt[1:]
        try:
            cb = channel_callbacks[channel]
        except KeyError:
            raise AssertionError('Invalid sideband channel %d' % channel)
        else:
            if cb is not None:
                cb(pkt)
@

<<[[Protocol]] methods>>=
def write_sideband(self, channel, blob):
    """Write multiplexed data to the sideband.

    :param channel: An int specifying the channel to write to.
    :param blob: A blob of data (as a string) to send on this channel.
    """
    # a pktline can be a max of 65520. a sideband line can therefore be
    # 65520-5 = 65515
    # WTF: Why have the len in ASCII, but the channel in binary.
    while blob:
        self.write_pkt_line(bytes(bytearray([channel])) + blob[:65515])
        blob = blob[65515:]
@




% ?? -> <>
<<[[TraditionalGitClient]] methods>>=
def archive(self, path, committish, write_data, progress=None,
            write_error=None):
    proto, can_read = self._connect(b'upload-archive', path)
    with proto:
        proto.write_pkt_line(b"argument " + committish)
        proto.write_pkt_line(None)
        pkt = proto.read_pkt_line()
        if pkt == b"NACK\n":
            return
        elif pkt == b"ACK\n":
            pass
        elif pkt.startswith(b"ERR "):
            raise GitProtocolError(pkt[4:].rstrip(b"\n"))
        else:
            raise AssertionError("invalid response %r" % pkt)
        ret = proto.read_pkt_line()
        if ret is not None:
            raise AssertionError("expected pkt tail")
        self._read_side_band64k_data(proto, {
            SIDE_BAND_CHANNEL_DATA: write_data,
            SIDE_BAND_CHANNEL_PROGRESS: progress,
            SIDE_BAND_CHANNEL_FATAL: write_error})
@
%dead?


\section{Other repository format}

\subsection{Bare repository}

% convenient when want to have a centralized repo and
% people push to it. If non-bare repo then git refuses to push
% because the index and worktree would be inconsistent.

<<[[porcelain.init()]] if bare>>=
if bare:
    return Repo.init_bare(path)
@
% when git init --bare

<<[[porcelain.clone()]] if bare>>=
if bare:
    r = Repo.init_bare(target)
@

<<[[Repo.__init__()]] else if no [[.git/objects/]] directory>>=
elif (os.path.isdir(os.path.join(root, OBJECTDIR)) and
      os.path.isdir(os.path.join(root, REFSDIR))):
    self.bare = True
    self._controldir = root
<<[[Repo.__init__()]] else if [[.git]] is a file>>
@
% when objects/ directly at root, not under hidden_path (controldir).



<<[[Repo]] methods>>=
@classmethod
def init_bare(cls, path, mkdir=False):
    """Create a new bare repository.

    ``path`` should already exist and be an empty directory.

    :param path: Path to create bare repository in
    :return: a `Repo` instance
    """
    if mkdir:
        os.mkdir(path)
    return cls._init_maybe_bare(path, True)
@
%``

<<[[Repo]] methods>>=
create = init_bare
@

<<constant repo.COMMONDIR>>=
COMMONDIR = 'commondir'
@

<<[[Repo.__init__()]] if commondir>>=
commondir = self.get_named_file(COMMONDIR)
if commondir is not None:
    with commondir:
        self._commondir = os.path.join(
            self.controldir(),
            commondir.read().rstrip(b"\r\n").decode(
                sys.getfilesystemencoding()))
@

\subsection{[[.git]] file}
% linked working tree? see docstring of commondir()

<<[[Repo.__init__()]] else if [[.git]] is a file>>=
elif os.path.isfile(hidden_path):
    self.bare = False
    with open(hidden_path, 'r') as f:
        path = read_gitfile(f)
    self.bare = False
    self._controldir = os.path.join(root, path)
@

<<function repo.read_gitfile>>=
def read_gitfile(f):
    """Read a ``.git`` file.

    The first line of the file should start with "gitdir: "

    :param f: File-like object to read from
    :return: A path
    """
    cs = f.read()
    if not cs.startswith("gitdir: "):
        raise ValueError("Expected file to start with 'gitdir: '")
    return cs[len("gitdir: "):].rstrip("\n")
@


\section{Other commands}

\subsection{[[git fetch]]}

<<function cmd_fetch>>=
class cmd_fetch(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])
        opts = dict(opts)

        client, path = get_transport_and_path(args.pop(0))
        r = Repo(".")
        if "--all" in opts:
            determine_wants = r.object_store.determine_wants_all
        refs = client.fetch(path, r, progress=sys.stdout.write)
        print("Remote refs:")
        for item in refs.items():
            print("%s -> %s" % item)
@


<<function porcelain.fetch>>=
def fetch(repo, remote_location, outstream=sys.stdout,
          errstream=default_bytes_err_stream):
    """Fetch objects from a remote server.

    :param repo: Path to the repository
    :param remote_location: String identifying a remote server
    :param outstream: Output stream (defaults to stdout)
    :param errstream: Error stream (defaults to stderr)
    :return: Dictionary with refs on the remote
    """
    with open_repo_closing(repo) as r:
        client, path = get_transport_and_path(remote_location)
        remote_refs = client.fetch(path, r, progress=errstream.write)
    return remote_refs
@
%dead?

\subsection{[[git symbolic-ref]]}

<<function cmd_symbolic_ref>>=
class cmd_symbolic_ref(Command):

    def run(self, args):
        opts, args = getopt(args, "", ["ref-name", "force"])
        if not args:
            print("Usage: dulwich symbolic-ref REF_NAME [--force]")
            sys.exit(1)

        ref_name = args.pop(0)
        porcelain.symbolic_ref(".", ref_name=ref_name, force='--force' in args)

@

<<function porcelain.symbolic_ref>>=
def symbolic_ref(repo, ref_name, force=False):
    """Set git symbolic ref into HEAD.

    :param repo: path to the repository
    :param ref_name: short name of the new ref
    :param force: force settings without checking if it exists in refs/heads
    """
    with open_repo_closing(repo) as repo_obj:
        ref_path = b'refs/heads/' + ref_name
        if not force and ref_path not in repo_obj.refs.keys():
            raise ValueError('fatal: ref `%s` is not a ref' % ref_name)
        repo_obj.refs.set_symbolic_ref(b'HEAD', ref_path)

@


\subsection{[[git rev-list]]}

% 'git log' used to be a shell script calling git rev-list

<<function cmd_rev_list>>=
class cmd_rev_list(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])
        if len(args) < 1:
            print('Usage: dulwich rev-list COMMITID...')
            sys.exit(1)

        porcelain.rev_list('.', args)

@

<<function porcelain.rev_list>>=
def rev_list(repo, commits, outstream=sys.stdout):
    """Lists commit objects in reverse chronological order.

    :param repo: Path to repository
    :param commits: Commits over which to iterate
    :param outstream: Stream to write to
    """
    with open_repo_closing(repo) as r:
        for entry in r.get_walker(include=[r[c].id for c in commits]):
            outstream.write(entry.commit.id + b"\n")

@

\subsection{[[git diff-tree]]}

<<function cmd_diff_tree>>=
class cmd_diff_tree(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])
        if len(args) < 2:
            print("Usage: dulwich diff-tree OLD-TREE NEW-TREE")
            sys.exit(1)

        porcelain.diff_tree(".", args[0], args[1])
@

<<function porcelain.diff_tree>>=
def diff_tree(repo, old_tree, new_tree, outstream=sys.stdout):
    """Compares the content and mode of blobs found via two tree objects.

    :param repo: Path to repository
    :param old_tree: Id of old tree
    :param new_tree: Id of new tree
    :param outstream: Stream to write to
    """
    with open_repo_closing(repo) as r:
        write_tree_diff(outstream, r.object_store, old_tree, new_tree)
@

\subsection{[[git commit-tree]]}
%? to commit without author and commiter??

<<function cmd_commit_tree>>=
class cmd_commit_tree(Command):

    def run(self, args):
        opts, args = getopt(args, "", ["message"])
        if args == []:
            print("usage: dulwich commit-tree tree")
            sys.exit(1)
        opts = dict(opts)

        porcelain.commit_tree(".", tree=args[0], message=opts["--message"])
@

<<function porcelain.commit_tree>>=
def commit_tree(repo, tree, message=None, author=None, committer=None):
    """Create a new commit object.

    :param repo: Path to repository
    :param tree: An existing tree object
    :param author: Optional author name and email
    :param committer: Optional committer name and email
    """
    with open_repo_closing(repo) as r:
        return r.do_commit(
            message=message, tree=tree, committer=committer, author=author)
@

\subsection{[[git ls-tree]]}

% pretty simple.

<<function cmd_ls_tree>>=
class cmd_ls_tree(Command):

    def run(self, args):
        parser = optparse.OptionParser()
        parser.add_option("-r", "--recursive", action="store_true",
                          help="Recusively list tree contents.")
        parser.add_option("--name-only", action="store_true",
                          help="Only display name.")
        options, args = parser.parse_args(args)
        try:
            treeish = args.pop(0)
        except IndexError:
            treeish = None

        porcelain.ls_tree(
            '.', treeish, outstream=sys.stdout, recursive=options.recursive,
            name_only=options.name_only)
@

<<function porcelain.ls_tree>>=
def ls_tree(repo, tree_ish=None, outstream=sys.stdout, recursive=False,
            name_only=False):
    """List contents of a tree.

    :param repo: Path to the repository
    :param tree_ish: Tree id to list
    :param outstream: Output stream (defaults to stdout)
    :param recursive: Whether to recursively list files
    :param name_only: Only print item name
    """
    def list_tree(store, treeid, base):
        for (name, mode, sha) in store[treeid].iteritems():
            if base:
                name = posixpath.join(base, name)
            if name_only:
                outstream.write(name + b"\n")
            else:
                outstream.write(pretty_format_tree_entry(name, mode, sha))
            if stat.S_ISDIR(mode):
                list_tree(store, sha, name)
    if tree_ish is None:
        tree_ish = "HEAD"
    with open_repo_closing(repo) as r:
        c = r[tree_ish]
        treeid = c.tree
        list_tree(r.object_store, treeid, "")
@
%bug: always recurse, even if did not ask for

<<function object.pretty_format_tree_entry>>=
def pretty_format_tree_entry(name, mode, hexsha, encoding="utf-8"):
    """Pretty format tree entry.

    :param name: Name of the directory entry
    :param mode: Mode of entry
    :param hexsha: Hexsha of the referenced object
    :return: string describing the tree entry
    """
    if mode & stat.S_IFDIR:
        kind = "tree"
    else:
        kind = "blob"
    return "%04o %s %s\t%s\n" % (
            mode, kind, hexsha.decode('ascii'),
            name.decode(encoding, 'replace'))
@

\subsection{[[git remote add]]}

<<function cmd_remote>>=
class cmd_remote(Command):

    subcommands = {
        "add": cmd_remote_add,
    }

    def run(self, args):
        if not args:
            print("Supported subcommands: %s" % ', '.join(self.subcommands.keys()))
            return False
        cmd = args[0]
        try:
            cmd_kls = self.subcommands[cmd]
        except KeyError:
            print('No such subcommand: %s' % args[0])
            return False
        return cmd_kls(args[1:])

@

<<function cmd_remote_add>>=
class cmd_remote_add(Command):

    def run(self, args):
        parser = optparse.OptionParser()
        options, args = parser.parse_args(args)

        porcelain.remote_add('.', args[0], args[1])

@



<<function porcelain.remote_add>>=
def remote_add(repo, name, url):
    """Add a remote.

    :param repo: Path to the repository
    :param name: Remote name
    :param url: Remote URL
    """
    if not isinstance(name, bytes):
        name = name.encode(DEFAULT_ENCODING)
    if not isinstance(url, bytes):
        url = url.encode(DEFAULT_ENCODING)

    with open_repo_closing(repo) as r:
        c = r.get_config()
        section = (b'remote', name)
        if c.has_section(section):
            raise RemoteExists(section)
        c.set(section, b"url", url)
        c.write_to_path()
@

<<exception RemoteExists>>=
class RemoteExists(Exception):
    """Raised when the remote already exists."""
@


\subsection{[[git ls-remote]]}

<<function cmd_ls_remote>>=
class cmd_ls_remote(Command):

    def run(self, args):
        opts, args = getopt(args, '', [])
        if len(args) < 1:
            print('Usage: dulwich ls-remote URL')
            sys.exit(1)

        refs = porcelain.ls_remote(args[0])
        for ref in sorted(refs):
            sys.stdout.write("%s\t%s\n" % (ref, refs[ref]))
@

<<function porcelain.ls_remote>>=
def ls_remote(remote):
    """List the refs in a remote.

    :param remote: Remote repository location
    :return: Dictionary with remote refs
    """
    client, host_path = get_transport_and_path(remote)
    return client.get_refs(host_path)
@

% porcelain.ls_remote -> <>
<<[[GitClient]] methods>>=
def get_refs(self, path):
    """Retrieve the current refs from a git smart server.

    :param path: Path to the repo to fetch from. (as bytestring)
    """
    raise NotImplementedError(self.get_refs)
@
<<[[LocalGitClient]] methods>>=
def get_refs(self, path):
    """Retrieve the current refs from a git smart server."""

    with self._open_repo(path) as target:
        return target.get_refs()
@
%simple

<<[[TraditionalGitClient]] methods>>=
def get_refs(self, path):
    """Retrieve the current refs from a git smart server."""
    # stock `git ls-remote` uses upload-pack
    proto, _ = self._connect(b'upload-pack', path)
    with proto:
        refs, _ = read_pkt_refs(proto)
        proto.write_pkt_line(None)
        return refs
@
% abuse upload-pack




\subsection{[[git archive]]}

% create tarball from git repo

<<function cmd_archive>>=
class cmd_archive(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])
        client, path = get_transport_and_path(args.pop(0))
        location = args.pop(0)
        committish = args.pop(0)
        porcelain.archive(location, committish, outstream=sys.stdout,
            errstream=sys.stderr)
@

<<function porcelain.archive>>=
def archive(repo, committish=None, outstream=default_bytes_out_stream,
            errstream=default_bytes_err_stream):
    """Create an archive.

    :param repo: Path of repository for which to generate an archive.
    :param committish: Commit SHA1 or ref to use
    :param outstream: Output stream (defaults to stdout)
    :param errstream: Error stream (defaults to stderr)
    """

    if committish is None:
        committish = "HEAD"
    with open_repo_closing(repo) as repo_obj:
        c = repo_obj[committish]
        for chunk in tar_stream(
                repo_obj.object_store, repo_obj.object_store[c.tree],
                c.commit_time):
            outstream.write(chunk)
@


<<function archive.tar_stream>>=
def tar_stream(store, tree, mtime, format=''):
    """Generate a tar stream for the contents of a Git tree.

    Returns a generator that lazily assembles a .tar.gz archive, yielding it in
    pieces (bytestrings). To obtain the complete .tar.gz binary file, simply
    concatenate these chunks.

    :param store: Object store to retrieve objects from
    :param tree: Tree object for the tree root
    :param mtime: UNIX timestamp that is assigned as the modification time for
        all files
    :param format: Optional compression format for tarball
    :return: Bytestrings
    """
    buf = BytesIO()
    with closing(tarfile.open(None, "w:%s" % format, buf)) as tar:
        for entry_abspath, entry in _walk_tree(store, tree):
            try:
                blob = store[entry.sha]
            except KeyError:
                # Entry probably refers to a submodule, which we don't yet support.
                continue
            data = ChunkedBytesIO(blob.chunked)

            info = tarfile.TarInfo()
            info.name = entry_abspath.decode('ascii') # tarfile only works with ascii.
            info.size = blob.raw_length()
            info.mode = entry.mode
            info.mtime = mtime

            tar.addfile(info, data)
            yield buf.getvalue()
            buf.truncate(0)
            buf.seek(0)
    yield buf.getvalue()
@

<<class ChunkedBytesIO>>=
class ChunkedBytesIO(object):
    """Turn a list of bytestrings into a file-like object.

    This is similar to creating a `BytesIO` from a concatenation of the
    bytestring list, but saves memory by NOT creating one giant bytestring first::

        BytesIO(b''.join(list_of_bytestrings)) =~= ChunkedBytesIO(list_of_bytestrings)
    """
    def __init__(self, contents):
        self.contents = contents
        self.pos = (0, 0)

    def read(self, maxbytes=None):
        if maxbytes < 0:
            maxbytes = float('inf')

        buf = []
        chunk, cursor = self.pos

        while chunk < len(self.contents):
            if maxbytes < len(self.contents[chunk]) - cursor:
                buf.append(self.contents[chunk][cursor:cursor+maxbytes])
                cursor += maxbytes
                self.pos = (chunk, cursor)
                break
            else:
                buf.append(self.contents[chunk][cursor:])
                maxbytes -= len(self.contents[chunk]) - cursor
                chunk += 1
                cursor = 0
                self.pos = (chunk, cursor)
        return b''.join(buf)
@

<<function archive._walk_tree>>=
def _walk_tree(store, tree, root=b''):
    """Recursively walk a dulwich Tree, yielding tuples of
    (absolute path, TreeEntry) along the way.
    """
    for entry in tree.iteritems():
        entry_abspath = posixpath.join(root, entry.path)
        if stat.S_ISDIR(entry.mode):
            for _ in _walk_tree(store, store[entry.sha], entry_abspath):
                yield _
        else:
            yield (entry_abspath, entry)
@


\subsection{[[git grep]]}

% pretty useful




\subsection{[[git update-server-info]]}
%?? real git command? or dulwich specific?

<<function cmd_update_server_info>>=
class cmd_update_server_info(Command):

    def run(self, args):
        porcelain.update_server_info(".")

@

<<function porcelain.update_server_info>>=
def update_server_info(repo="."):
    """Update server info files for a repository.

    :param repo: path to the repository
    """
    with open_repo_closing(repo) as r:
        server_update_server_info(r)
@


\chapter{Conclusion}

\appendix

\chapter{Debugging}

\section{[[__repr__]]}

<<[[Repo]] methods>>=
def __repr__(self):
    return "<Repo at %r>" % self.path
@

<<[[DiskObjectStore]] methods>>=
def __repr__(self):
    return "<%s(%r)>" % (self.__class__.__name__, self.path)
@

<<[[DiskRefsContainer]] methods>>=
def __repr__(self):
    return "%s(%r)" % (self.__class__.__name__, self.path)
@

<<[[ShaFile]] methods>>=
def __repr__(self):
    return "<%s %s>" % (self.__class__.__name__, self.id)
@

<<[[Index]] methods>>=
def __repr__(self):
    return "%s(%r)" % (self.__class__.__name__, self._filename)
@

<<[[Pack]] methods>>=
def __repr__(self):
    return '%s(%r)' % (self.__class__.__name__, self._basename)
@

<<[[ConfigDict]] methods>>=
def __repr__(self):
    return "%s(%r)" % (self.__class__.__name__, self._values)
@

<<[[StackedConfig]] methods>>=
def __repr__(self):
    return "<%s for %r>" % (self.__class__.__name__, self.backends)
@

<<[[WalkEntry]] methods>>=
def __repr__(self):
    return '<WalkEntry commit=%s, changes=%r>' % (
      self.commit.id, self.changes())
@



\section{Mocks}

<<class MemoryRepo>>=
class MemoryRepo(BaseRepo):
    """Repo that stores refs, objects, and named files in memory.

    MemoryRepos are always bare: they have no working tree and no index, since
    those have a stronger dependency on the filesystem.
    """

    def __init__(self):
        from dulwich.config import ConfigFile
        BaseRepo.__init__(self, MemoryObjectStore(), DictRefsContainer({}))
        self._named_files = {}
        self.bare = True
        self._config = ConfigFile()
        self._description = None

    def set_description(self, description):
        self._description = description

    def get_description(self):
        return self._description

    def _determine_file_mode(self):
        """Probe the file-system to determine whether permissions can be trusted.

        :return: True if permissions can be trusted, False otherwise.
        """
        return sys.platform != 'win32'

    def _put_named_file(self, path, contents):
        """Write a file to the control dir with the given name and contents.

        :param path: The path to the file, relative to the control dir.
        :param contents: A string to write to the file.
        """
        self._named_files[path] = contents

    def get_named_file(self, path):
        """Get a file from the control dir with a specific name.

        Although the filename should be interpreted as a filename relative to
        the control dir in a disk-baked Repo, the object returned need not be
        pointing to a file in that location.

        :param path: The path to the file, relative to the control dir.
        :return: An open file object, or None if the file does not exist.
        """
        contents = self._named_files.get(path, None)
        if contents is None:
            return None
        return BytesIO(contents)

    def open_index(self):
        """Fail to open index for this repo, since it is bare.

        :raise NoIndexPresent: Raised when no index is present
        """
        raise NoIndexPresent()

    def get_config(self):
        """Retrieve the config object.

        :return: `ConfigFile` object.
        """
        return self._config

    @classmethod
    def init_bare(cls, objects, refs):
        """Create a new bare repository in memory.

        :param objects: Objects for the new repository,
            as iterable
        :param refs: Refs as dictionary, mapping names
            to object SHA1s
        """
        ret = cls()
        for obj in objects:
            ret.object_store.add_object(obj)
        for refname, sha in refs.items():
            ret.refs[refname] = sha
        ret._init_files(bare=True)
        return ret
@


<<class MemoryObjectStore>>=
class MemoryObjectStore(BaseObjectStore):
    """Object store that keeps all objects in memory."""

    def __init__(self):
        super(MemoryObjectStore, self).__init__()
        self._data = {}

    def _to_hexsha(self, sha):
        if len(sha) == 40:
            return sha
        elif len(sha) == 20:
            return sha_to_hex(sha)
        else:
            raise ValueError("Invalid sha %r" % (sha,))

    def contains_loose(self, sha):
        """Check if a particular object is present by SHA1 and is loose."""
        return self._to_hexsha(sha) in self._data

    def contains_packed(self, sha):
        """Check if a particular object is present by SHA1 and is packed."""
        return False

    def __iter__(self):
        """Iterate over the SHAs that are present in this store."""
        return iter(self._data.keys())

    @property
    def packs(self):
        """List with pack objects."""
        return []

    def get_raw(self, name):
        """Obtain the raw text for an object.

        :param name: sha for the object.
        :return: tuple with numeric type and object contents.
        """
        obj = self[self._to_hexsha(name)]
        return obj.type_num, obj.as_raw_string()

    def __getitem__(self, name):
        return self._data[self._to_hexsha(name)].copy()

    def __delitem__(self, name):
        """Delete an object from this store, for testing only."""
        del self._data[self._to_hexsha(name)]

    def add_object(self, obj):
        """Add a single object to this object store.

        """
        self._data[obj.id] = obj.copy()

    def add_objects(self, objects):
        """Add a set of objects to this object store.

        :param objects: Iterable over a list of (object, path) tuples
        """
        for obj, path in objects:
            self.add_object(obj)

    def add_pack(self):
        """Add a new pack to this object store.

        Because this object store doesn't support packs, we extract and add the
        individual objects.

        :return: Fileobject to write to and a commit function to
            call when the pack is finished.
        """
        f = BytesIO()

        def commit():
            p = PackData.from_file(BytesIO(f.getvalue()), f.tell())
            f.close()
            for obj in PackInflater.for_pack_data(p, self.get_raw):
                self.add_object(obj)

        def abort():
            pass
        return f, commit, abort

    def _complete_thin_pack(self, f, indexer):
        """Complete a thin pack by adding external references.

        :param f: Open file object for the pack.
        :param indexer: A PackIndexer for indexing the pack.
        """
        entries = list(indexer)

        # Update the header with the new number of objects.
        f.seek(0)
        write_pack_header(f, len(entries) + len(indexer.ext_refs()))

        # Rescan the rest of the pack, computing the SHA with the new header.
        new_sha = compute_file_sha(f, end_ofs=-20)

        # Complete the pack.
        for ext_sha in indexer.ext_refs():
            assert len(ext_sha) == 20
            type_num, data = self.get_raw(ext_sha)
            write_pack_object(f, type_num, data, sha=new_sha)
        pack_sha = new_sha.digest()
        f.write(pack_sha)

    def add_thin_pack(self, read_all, read_some):
        """Add a new thin pack to this object store.

        Thin packs are packs that contain deltas with parents that exist
        outside the pack. Because this object store doesn't support packs, we
        extract and add the individual objects.

        :param read_all: Read function that blocks until the number of
            requested bytes are read.
        :param read_some: Read function that returns at least one byte, but may
            not return the number of bytes requested.
        """
        f, commit, abort = self.add_pack()
        try:
            indexer = PackIndexer(f, resolve_ext_ref=self.get_raw)
            copier = PackStreamCopier(read_all, read_some, f,
                                      delta_iter=indexer)
            copier.verify()
            self._complete_thin_pack(f, indexer)
        except:
            abort()
            raise
        else:
            commit()
@

<<[[ShaFile]] methods>>=
def copy(self):
    """Create a new copy of this SHA1 object from its raw string"""
    obj_class = object_class(self.get_type())
    return obj_class.from_raw_string(
        self.get_type(),
        self.as_raw_string(),
        self.id)
@

<<class DictRefsContainer>>=
class DictRefsContainer(RefsContainer):
    """RefsContainer backed by a simple dict.

    This container does not support symbolic or packed references and is not
    threadsafe.
    """

    def __init__(self, refs):
        self._refs = refs
        self._peeled = {}

    def allkeys(self):
        return self._refs.keys()

    def read_loose_ref(self, name):
        return self._refs.get(name, None)

    def get_packed_refs(self):
        return {}

    def set_symbolic_ref(self, name, other):
        self._refs[name] = SYMREF + other

    def set_if_equals(self, name, old_ref, new_ref):
        if old_ref is not None and self._refs.get(name, ZERO_SHA) != old_ref:
            return False
        realnames, _ = self.follow(name)
        for realname in realnames:
            self._check_refname(realname)
            self._refs[realname] = new_ref
        return True

    def add_if_new(self, name, ref):
        if name in self._refs:
            return False
        self._refs[name] = ref
        return True

    def remove_if_equals(self, name, old_ref):
        if old_ref is not None and self._refs.get(name, ZERO_SHA) != old_ref:
            return False
        try:
            del self._refs[name]
        except KeyError:
            pass
        return True

    def get_peeled(self, name):
        return self._peeled.get(name)

    def _update(self, refs):
        """Update multiple refs; intended only for testing."""
        # TODO(dborowitz): replace this with a public function that uses
        # set_if_equal.
        self._refs.update(refs)

    def _update_peeled(self, peeled):
        """Update cached peeled refs; intended only for testing."""
        self._peeled.update(peeled)
@

<<class MemoryPackIndex>>=
class MemoryPackIndex(PackIndex):
    """Pack index that is stored entirely in memory."""

    def __init__(self, entries, pack_checksum=None):
        """Create a new MemoryPackIndex.

        :param entries: Sequence of name, idx, crc32 (sorted)
        :param pack_checksum: Optional pack checksum
        """
        self._by_sha = {}
        for name, idx, crc32 in entries:
            self._by_sha[name] = idx
        self._entries = entries
        self._pack_checksum = pack_checksum

    def get_pack_checksum(self):
        return self._pack_checksum

    def __len__(self):
        return len(self._entries)

    def _object_index(self, sha):
        return self._by_sha[sha][0]

    def _itersha(self):
        return iter(self._by_sha)

    def iterentries(self):
        return iter(self._entries)
@

\section{[[git dump-index]]}

% not a git command
<<function cmd_dump_index>>=
class cmd_dump_index(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])

        if args == []:
            print("Usage: dulwich dump-index FILENAME")
            sys.exit(1)

        filename = args[0]
        idx = Index(filename)

        for o in idx:
            print(o, idx[o])
@

\section{[[git dump-pack]]}

<<function cmd_dump_pack>>=
class cmd_dump_pack(Command):

    def run(self, args):
        opts, args = getopt(args, "", [])

        if args == []:
            print("Usage: dulwich dump-pack FILENAME")
            sys.exit(1)

        basename, _ = os.path.splitext(args[0])
        x = Pack(basename)
        print("Object names checksum: %s" % x.name())
        print("Checksum: %s" % sha_to_hex(x.get_stored_checksum()))
        if not x.check():
            print("CHECKSUM DOES NOT MATCH")
        print("Length: %d" % len(x))
        for name in x:
            try:
                print("\t%s" % x[name])
            except KeyError as k:
                print("\t%s: Unable to resolve base %s" % (name, k))
            except ApplyDeltaError as e:
                print("\t%s: Unable to apply delta: %r" % (name, e))
@


\section{Transport activity report}

<<[[GitClient.__init__()]] set fields>>=
self._report_activity = report_activity
@
<<[[LocalGitClient.__init__()]] set fields>>=
self._report_activity = report_activity
@
<<[[Protocol.__init__()]] set fields>>=
self.report_activity = report_activity
@

<<[[Protocol.read_pkt_line()]] when size 0, if report activity>>=
if self.report_activity:
    self.report_activity(4, 'read')
@

<<[[Protocol.read_pkt_line()]] when size not 0, if report activity>>=
if self.report_activity:
    self.report_activity(size, 'read')
@

<<[[Protocol.write_pkt_line()]] if report activity>>=
if self.report_activity:
    self.report_activity(len(line), 'write')
@

%\section{Status report}
% ?


\chapter{Error Management}


<<errors>>=
class ChecksumMismatch(Exception):
    """A checksum didn't match the expected contents."""

    def __init__(self, expected, got, extra=None):
        if len(expected) == 20:
            expected = binascii.hexlify(expected)
        if len(got) == 20:
            got = binascii.hexlify(got)
        self.expected = expected
        self.got = got
        self.extra = extra
        if self.extra is None:
            Exception.__init__(self,
                "Checksum mismatch: Expected %s, got %s" % (expected, got))
        else:
            Exception.__init__(self,
                "Checksum mismatch: Expected %s, got %s; %s" %
                (expected, got, extra))
@

<<errors>>=
class MissingCommitError(Exception):
    """Indicates that a commit was not found in the repository"""

    def __init__(self, sha, *args, **kwargs):
        self.sha = sha
        Exception.__init__(self, "%s is not in the revision store" % sha)
@

<<errors>>=
class ObjectMissing(Exception):
    """Indicates that a requested object is missing."""

    def __init__(self, sha, *args, **kwargs):
        Exception.__init__(self, "%s is not in the pack" % sha)


@

<<errors>>=
class ApplyDeltaError(Exception):
    """Indicates that applying a delta failed."""

    def __init__(self, *args, **kwargs):
        Exception.__init__(self, *args, **kwargs)


@

<<errors>>=
class NotGitRepository(Exception):
    """Indicates that no Git repository was found."""

    def __init__(self, *args, **kwargs):
        Exception.__init__(self, *args, **kwargs)
@


<<errors>>=
class NoIndexPresent(Exception):
    """No index is present."""
@

<<errors>>=
class CommitError(Exception):
    """An error occurred while performing a commit."""
@

<<errors>>=
class RefFormatError(Exception):
    """Indicates an invalid ref name."""
@

<<errors>>=
class HookError(Exception):
    """An error occurred while executing a hook."""
@





<<exception WrongObjectException>>=
class WrongObjectException(Exception):
    """Baseclass for all the _ is not a _ exceptions on objects.

    Do not instantiate directly.

    Subclasses should define a type_name attribute that indicates what
    was expected if they were raised.
    """

    def __init__(self, sha, *args, **kwargs):
        Exception.__init__(self, "%s is not a %s" % (sha, self.type_name))
@

<<[[WrongObjectException]] errors>>=
class NotCommitError(WrongObjectException):
    """Indicates that the sha requested does not point to a commit."""

    type_name = 'commit'
@

<<[[WrongObjectException]] errors>>=
class NotTreeError(WrongObjectException):
    """Indicates that the sha requested does not point to a tree."""

    type_name = 'tree'
@

<<[[WrongObjectException]] errors>>=
class NotTagError(WrongObjectException):
    """Indicates that the sha requested does not point to a tag."""

    type_name = 'tag'
@

<<[[WrongObjectException]] errors>>=
class NotBlobError(WrongObjectException):
    """Indicates that the sha requested does not point to a blob."""

    type_name = 'blob'
@




<<exception GitProtocolError>>=
class GitProtocolError(Exception):
    """Git protocol exception."""

    def __init__(self, *args, **kwargs):
        Exception.__init__(self, *args, **kwargs)
@

<<[[GitProtocolError]] errors>>=
class SendPackError(GitProtocolError):
    """An error occurred during send_pack."""

    def __init__(self, *args, **kwargs):
        Exception.__init__(self, *args, **kwargs)
@

<<[[GitProtocolError]] errors>>=
class UpdateRefsError(GitProtocolError):
    """The server reported errors updating refs."""

    def __init__(self, *args, **kwargs):
        self.ref_status = kwargs.pop('ref_status')
        Exception.__init__(self, *args, **kwargs)
@

<<[[GitProtocolError]] errors>>=
class HangupException(GitProtocolError):
    """Hangup exception."""

    def __init__(self):
        Exception.__init__(self,
            "The remote server unexpectedly closed the connection.")
@

<<[[GitProtocolError]] errors>>=
class UnexpectedCommandError(GitProtocolError):
    """Unexpected command received in a proto line."""

    def __init__(self, command):
        if command is None:
            command = 'flush-pkt'
        else:
            command = 'command %s' % command
        GitProtocolError.__init__(self, 'Protocol got unexpected %s' % command)
@


<<exception FileFormatException>>=
class FileFormatException(Exception):
    """Base class for exceptions relating to reading git file formats."""
@

<<[[FileFormatException]] errors>>=
class PackedRefsException(FileFormatException):
    """Indicates an error parsing a packed-refs file."""
@

<<[[FileFormatException]] errors>>=
class ObjectFormatException(FileFormatException):
    """Indicates an error parsing an object."""
@


\end{document}

\part{Extra}

\section{[[dulwich.py]]}

<<[[dulwich.py]] toplevel, interrupt signal>>=
def signal_int(signal, frame):
    sys.exit(1)

signal.signal(signal.SIGINT, signal_int)
@
%not equivalent to default behavior?

%bug? it's '.' not '>' below in the top comment.

%-------------------------------------------------------------------------
<<dulwich.py>>=
#!/usr/bin/python -u
#
# dulwich - Simple command-line interface to Dulwich
# Copyright (C) 2008-2011 Jelmer Vernooij <jelmer@samba.org>
# vim: expandtab
#
<<dulwich license>>
"""Simple command-line interface to Dulwich>

This is a very simple command-line wrapper for Dulwich. It is by
no means intended to be a full-blown Git command-line interface but just
a way to test Dulwich.
"""

import os
import sys
from getopt import getopt
import optparse
import signal

<<[[dulwich.py]] toplevel, interrupt signal>>

from dulwich import porcelain
from dulwich.client import get_transport_and_path
from dulwich.errors import ApplyDeltaError
from dulwich.index import Index
from dulwich.pack import Pack, sha_to_hex
from dulwich.patch import write_tree_diff
from dulwich.repo import Repo

<<class Command>>


<<function cmd_archive>>

<<function cmd_add>>

<<function cmd_rm>>

<<function cmd_fetch_pack>>

<<function cmd_fetch>>

<<function cmd_log>>

<<function cmd_diff>>

<<function cmd_dump_pack>>

<<function cmd_dump_index>>

<<function cmd_init>>

<<function cmd_clone>>

<<function cmd_commit>>

<<function cmd_commit_tree>>

<<function cmd_update_server_info>>

<<function cmd_symbolic_ref>>

<<function cmd_show>>

<<function cmd_diff_tree>>

<<function cmd_rev_list>>

<<function cmd_tag>>

<<function cmd_repack>>

<<function cmd_reset>>

<<function cmd_daemon>>

<<function cmd_web_daemon>>

<<function cmd_receive_pack>>

<<function cmd_upload_pack>>

<<function cmd_status>>

<<function cmd_ls_remote>>

<<function cmd_ls_tree>>

<<function cmd_pack_objects>>

<<function cmd_pull>>

<<function cmd_remote_add>>

<<function cmd_remote>>

<<function cmd_help>>

<<constant commands>>

<<toplevel main>>

@

\section{[[dulwich/]]}

\subsection{[[__init__.py]]}

<<dulwich/__init__.py>>=
# __init__.py -- The git module of dulwich
# Copyright (C) 2007 James Westby <jw+debian@jameswestby.net>
# Copyright (C) 2008 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>

"""Python implementation of the Git file formats and protocols."""

__version__ = (0, 17, 4)
@
% purpose of this file?

\subsection{[[archive.py]]}

<<dulwich/archive.py>>=
# archive.py -- Creating an archive from a tarball
# Copyright (C) 2015 Jonas Haag <jonas@lophus.org>
# Copyright (C) 2015 Jelmer Vernooij <jelmer@jelmer.uk>
#
<<dulwich license>>
"""Generates tarballs for Git trees.

"""

import posixpath
import stat
import tarfile
from io import BytesIO
from contextlib import closing

<<class ChunkedBytesIO>>

<<function archive.tar_stream>>

<<function archive._walk_tree>>
@

\subsection{[[client.py]]}


%<<[[GitClient]] methods>>=
%def _parse_status_report(self, proto):
%    unpack = proto.read_pkt_line().strip()
%    if unpack != b'unpack ok':
%        st = True
%        # flush remaining error data
%        while st is not None:
%            st = proto.read_pkt_line()
%        raise SendPackError(unpack)
%    statuses = []
%    errs = False
%    ref_status = proto.read_pkt_line()
%    while ref_status:
%        ref_status = ref_status.strip()
%        statuses.append(ref_status)
%        if not ref_status.startswith(b'ok '):
%            errs = True
%        ref_status = proto.read_pkt_line()
%
%    if errs:
%        ref_status = {}
%        ok = set()
%        for status in statuses:
%            if b' ' not in status:
%                # malformed response, move on to the next one
%                continue
%            status, ref = status.split(b' ', 1)
%
%            if status == b'ng':
%                if b' ' in ref:
%                    ref, status = ref.split(b' ', 1)
%            else:
%                ok.add(ref)
%            ref_status[ref] = status
%        raise UpdateRefsError(', '.join([
%            ref for ref in ref_status if ref not in ok]) +
%            b' failed to update', ref_status=ref_status)
%
%@
% dead? deprecated by ReportStatusParser?

<<class SubprocessGitClient>>=
class SubprocessGitClient(TraditionalGitClient):
    """Git client that talks to a server using a subprocess."""

    def __init__(self, **kwargs):
        self._connection = None
        self._stderr = None
        self._stderr = kwargs.get('stderr')
        if 'stderr' in kwargs:
            del kwargs['stderr']
        super(SubprocessGitClient, self).__init__(**kwargs)

    @classmethod
    def from_parsedurl(cls, parsedurl, **kwargs):
        return cls(**kwargs)

    git_command = None

    def _connect(self, service, path):
        if not isinstance(service, bytes):
            raise TypeError(service)
        if isinstance(path, bytes):
            path = path.decode(self._remote_path_encoding)
        if self.git_command is None:
            git_command = find_git_command()
        argv = git_command + [service.decode('ascii'), path]
        p = SubprocessWrapper(
            subprocess.Popen(argv, bufsize=0, stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE,
                             stderr=self._stderr))
        return Protocol(p.read, p.write, p.close,
                        report_activity=self._report_activity), p.can_read
@
%dead? used only in 1 test.

<<function find_git_command>>=
def find_git_command():
    """Find command to run for system Git (usually C Git).
    """
    if sys.platform == 'win32':  # support .exe, .bat and .cmd
        try:  # to avoid overhead
            import win32api
        except ImportError:  # run through cmd.exe with some overhead
            return ['cmd', '/c', 'git']
        else:
            status, git = win32api.FindExecutable('git')
            return [git]
    else:
        return ['git']
@

<<function ParamikoSSHVendor>>=
def ParamikoSSHVendor(**kwargs):
    import warnings
    warnings.warn(
        "ParamikoSSHVendor has been moved to dulwich.contrib.paramiko_vendor.",
        DeprecationWarning)
    from dulwich.contrib.paramiko_vendor import ParamikoSSHVendor
    return ParamikoSSHVendor(**kwargs)
@
%dead? used by contrib/ code. seems very specific.

% ----------------------------------------------------------------------
<<dulwich/client.py>>=
# client.py -- Implementation of the client side git protocols
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Client side support for the Git protocol.

The Dulwich client supports the following capabilities:

 * thin-pack
 * multi_ack_detailed
 * multi_ack
 * side-band-64k
 * ofs-delta
 * quiet
 * report-status
 * delete-refs

Known capabilities that are not supported:

 * shallow
 * no-progress
 * include-tag
"""

from contextlib import closing
from io import BytesIO, BufferedReader
import dulwich
import select
import socket
import subprocess
import sys

try:
    from urllib import quote as urlquote
    from urllib import unquote as urlunquote
except ImportError:
    from urllib.parse import quote as urlquote
    from urllib.parse import unquote as urlunquote

try:
    import urllib2
    import urlparse
except ImportError:
    import urllib.request as urllib2
    import urllib.parse as urlparse

from dulwich.errors import (
    GitProtocolError,
    NotGitRepository,
    SendPackError,
    UpdateRefsError,
    )
from dulwich.protocol import (
    _RBUFSIZE,
    capability_agent,
    CAPABILITY_DELETE_REFS,
    CAPABILITY_MULTI_ACK,
    CAPABILITY_MULTI_ACK_DETAILED,
    CAPABILITY_OFS_DELTA,
    CAPABILITY_QUIET,
    CAPABILITY_REPORT_STATUS,
    CAPABILITY_SIDE_BAND_64K,
    CAPABILITY_THIN_PACK,
    CAPABILITIES_REF,
    COMMAND_DONE,
    COMMAND_HAVE,
    COMMAND_WANT,
    SIDE_BAND_CHANNEL_DATA,
    SIDE_BAND_CHANNEL_PROGRESS,
    SIDE_BAND_CHANNEL_FATAL,
    PktLineParser,
    Protocol,
    ProtocolFile,
    TCP_GIT_PORT,
    ZERO_SHA,
    extract_capabilities,
    )
from dulwich.pack import (
    write_pack_objects,
    )
from dulwich.refs import (
    read_info_refs,
    )

<<function client._fileno_can_read>>

<<constant client.COMMON_CAPABILITIES>>
<<constant client.FETCH_CAPABILITIES>>
<<constant client.SEND_CAPABILITIES>>

<<class ReportStatusParser>>

<<function client.read_pkt_refs>>

<<class GitClient>>

<<class TraditionalGitClient>>

<<class TCPGitClient>>

<<class SubprocessWrapper>>

<<function find_git_command>>

<<class SubprocessGitClient>>

<<class LocalGitClient>>

<<class default_local_git_client_cls>>

<<class SSHVendor>>

<<class SubprocessSSHVendor>>

<<function ParamikoSSHVendor>>

<<global get_ssh_vendor>>

<<class SSHGitClient>>


<<function client.default_user_agent_string>>

<<function client.default_urllib2_opener>>

<<class HttpGitClient>>

<<function get_transport_and_path_from_url>>

<<function client.get_transport_and_path>>
@

\subsection{[[config.py]]}

<<dulwich/config.py>>=
# config.py - Reading and writing Git config files
# Copyright (C) 2011-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Reading and writing Git configuration files.

TODO:
 * preserve formatting when updating configuration files
 * treat subsection names as case-insensitive for [branch.foo] style
   subsections
"""

import errno
import os

from collections import (
    OrderedDict,
    MutableMapping,
    )

from dulwich.file import GitFile

<<class Config>>

<<class ConfigDict>>

<<function config._format_string>>

<<constant config._ESCAPE_TABLE>>
<<constant config._COMMENT_CHARS>>
<<constant config._WHITESPACE_CHARS>>

<<function config._parse_string>>

<<function config._escape_value>>

<<function config._check_variable_name>>

<<function config._check_section_name>>

<<function config._strip_comments>>


<<class ConfigFile>>

<<class StackedConfig>>

<<function config.parse_submodules>>

@

\subsection{[[diff_tree.py]]}

<<diff_tree.py>>=
# diff_tree.py -- Utilities for diffing files and trees.
# Copyright (C) 2010 Google, Inc.
#
<<dulwich license>>
"""Utilities for diffing files and trees."""

import sys
from collections import (
    defaultdict,
    namedtuple,
    )

from io import BytesIO
from itertools import chain
import stat

from dulwich.objects import (
    S_ISGITLINK,
    TreeEntry,
    )

<<type CHANGE>>

<<constant diff_tree.RENAME_CHANGE_TYPES>>

<<constant diff_tree._NULL_ENTRY>>

<<constant diff_tree._MAX_SCORE>>
<<constant diff_tree.RENAME_THRESHOLD>>
<<constant diff_tree.MAX_FILES>>
<<constant diff_tree.REWRITE_THRESHOLD>>

<<class TreeChange>>

<<constant diff_tree._tree_entries>>

<<constant diff_tree._merge_entries>>

<<function diff_tree._is_tree>>

<<function diff_tree.walk_trees>>

<<function diff_tree._skip_tree>>

<<function diff_tree.tree_changes>>


def _all_eq(seq, key, value):
    for e in seq:
        if key(e) != value:
            return False
    return True


def _all_same(seq, key):
    return _all_eq(seq[1:], key, key(seq[0]))

<<diff.tree_changes_for_merge>>

<<constant diff_tree._BLOCK_SIZE>>

<<function diff_tree._count_blocks>>

<<function diff_tree._common_bytes>>

<<function diff_tree._similarity_score>>

<<function diff_tree._tree_change_key>>

<<class RenameDetector>>

# Hold on to the pure-python implementations for testing.
_is_tree_py = _is_tree
_merge_entries_py = _merge_entries
_count_blocks_py = _count_blocks
try:
    # Try to import C versions
    from dulwich._diff_tree import _is_tree, _merge_entries, _count_blocks
except ImportError:
    pass
@

\subsection{[[errors.py]]}

<<dulwich/errors.py>>=
# errors.py -- errors for dulwich
# Copyright (C) 2007 James Westby <jw+debian@jameswestby.net>
# Copyright (C) 2009-2012 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Dulwich-related exception classes and utility functions."""

import binascii

<<errors>>

<<exception WrongObjectException>>

<<[[WrongObjectException]] errors>>

<<exception GitProtocolError>>

<<[[GitProtocolError]] errors>>

<<exception FileFormatException>>

<<[[FileFormatException]] errors>>
@

\subsection{[[fastexport.py]]}

<<fastexport.py>>=
# __init__.py -- Fast export/import functionality
# Copyright (C) 2010-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>

"""Fast export/import functionality."""

import sys

from dulwich.index import (
    commit_tree,
    )
from dulwich.objects import (
    Blob,
    Commit,
    Tag,
    )
from fastimport import __version__ as fastimport_version
if fastimport_version <= (0, 9, 5) and sys.version_info[0] == 3 and sys.version_info[1] < 5:
    raise ImportError("Older versions of fastimport don't support python3<3.5")
from fastimport import (
    commands,
    errors as fastimport_errors,
    parser,
    processor,
    )

import stat

<<function fastexport.split_email>>

<<class GitFastExporter>>

<<class GitImportProcessor>>

@

\subsection{[[file.py]]}

%---------------------------------------------------------------------------
<<dulwich/file.py>>=
# file.py -- Safe access to git files
# Copyright (C) 2010 Google, Inc.
#
<<dulwich license>>
"""Safe access to git files."""

import errno
import io
import os
import sys
import tempfile

<<function file.ensure_dir_exists>>

<<function GitFile>>

<<class _GitFile>>
@


\subsection{[[greenthreads.py]]}

<<greenthreads.py>>=
# greenthreads.py -- Utility module for querying an ObjectStore with gevent
# Copyright (C) 2013 eNovance SAS <licensing@enovance.com>
#
# Author: Fabien Boucher <fabien.boucher@enovance.com>
#
<<dulwich license>>
"""Utility module for querying an ObjectStore with gevent."""

import gevent
from gevent import pool

from dulwich.objects import (
    Commit,
    Tag,
    )
from dulwich.object_store import (
    MissingObjectFinder,
    _collect_filetree_revs,
    ObjectStoreIterator,
    )


def _split_commits_and_tags(obj_store, lst,
                            ignore_unknown=False, pool=None):
    """Split object id list into two list with commit SHA1s and tag SHA1s.

    Same implementation as object_store._split_commits_and_tags
    except we use gevent to parallelize object retrieval.
    """
    commits = set()
    tags = set()

    def find_commit_type(sha):
        try:
            o = obj_store[sha]
        except KeyError:
            if not ignore_unknown:
                raise
        else:
            if isinstance(o, Commit):
                commits.add(sha)
            elif isinstance(o, Tag):
                tags.add(sha)
                commits.add(o.object[1])
            else:
                raise KeyError('Not a commit or a tag: %s' % sha)
    jobs = [pool.spawn(find_commit_type, s) for s in lst]
    gevent.joinall(jobs)
    return (commits, tags)


class GreenThreadsMissingObjectFinder(MissingObjectFinder):
    """Find the objects missing from another object store.

    Same implementation as object_store.MissingObjectFinder
    except we use gevent to parallelize object retrieval.
    """
    def __init__(self, object_store, haves, wants,
                 progress=None, get_tagged=None,
                 concurrency=1, get_parents=None):

        def collect_tree_sha(sha):
            self.sha_done.add(sha)
            cmt = object_store[sha]
            _collect_filetree_revs(object_store, cmt.tree, self.sha_done)

        self.object_store = object_store
        p = pool.Pool(size=concurrency)

        have_commits, have_tags = \
            _split_commits_and_tags(object_store, haves,
                                    True, p)
        want_commits, want_tags = \
            _split_commits_and_tags(object_store, wants,
                                    False, p)
        all_ancestors = object_store._collect_ancestors(have_commits)[0]
        missing_commits, common_commits = \
            object_store._collect_ancestors(want_commits, all_ancestors)

        self.sha_done = set()
        jobs = [p.spawn(collect_tree_sha, c) for c in common_commits]
        gevent.joinall(jobs)
        for t in have_tags:
            self.sha_done.add(t)
        missing_tags = want_tags.difference(have_tags)
        wants = missing_commits.union(missing_tags)
        self.objects_to_send = set([(w, None, False) for w in wants])
        if progress is None:
            self.progress = lambda x: None
        else:
            self.progress = progress
        self._tagged = get_tagged and get_tagged() or {}


class GreenThreadsObjectStoreIterator(ObjectStoreIterator):
    """ObjectIterator that works on top of an ObjectStore.

    Same implementation as object_store.ObjectStoreIterator
    except we use gevent to parallelize object retrieval.
    """
    def __init__(self, store, shas, finder, concurrency=1):
        self.finder = finder
        self.p = pool.Pool(size=concurrency)
        super(GreenThreadsObjectStoreIterator, self).__init__(store, shas)

    def retrieve(self, args):
        sha, path = args
        return self.store[sha], path

    def __iter__(self):
        for sha, path in self.p.imap_unordered(self.retrieve,
                                               self.itershas()):
            yield sha, path

    def __len__(self):
        if len(self._shas) > 0:
            return len(self._shas)
        while len(self.finder.objects_to_send):
            jobs = []
            for _ in range(0, len(self.finder.objects_to_send)):
                jobs.append(self.p.spawn(self.finder.next))
            gevent.joinall(jobs)
            for j in jobs:
                if j.value is not None:
                    self._shas.append(j.value)
        return len(self._shas)
@

\subsection{[[hooks.py]]}

<<dulwich/hooks.py>>=
# hooks.py -- for dealing with git hooks
# Copyright (C) 2012-2013 Jelmer Vernooij and others.
#
<<dulwich license>>
"""Access to hooks."""

import os
import subprocess
import sys
import tempfile

from dulwich.errors import (
    HookError,
)

<<class Hook>>

<<class ShellHook>>


<<class PreCommitShellHook>>

<<class PostCommitShellHook>>

<<class CommitMsgShellHook>>
@

\subsection{[[ignore.py]]}


<<function ignore.read_ignore_patterns>>=
def read_ignore_patterns(f):
    """Read a git ignore file.

    :param f: File-like object to read from
    :return: List of patterns
    """

    for l in f:
        l = l.rstrip(b"\n")

        # Ignore blank lines, they're used for readability.
        if not l:
            continue

        if l.startswith(b'#'):
            # Comment
            continue

        # Trailing spaces are ignored unless they are quoted with a backslash.
        while l.endswith(b' ') and not l.endswith(b'\\ '):
            l = l[:-1]
        l = l.replace(b'\\ ', b' ')

        yield l
@
%dead?

%-------------------------------------------------------------------------
<<ignore.py>>=
# Copyright (C) 2017 Jelmer Vernooij <jelmer@jelmer.uk>
#
<<dulwich license>>
"""Parsing of gitignore files.

For details for the matching rules, see https://git-scm.com/docs/gitignore
"""

import re

<<function ignore.translate>>

<<function ignore.read_ignore_patterns>>

<<function ignore.match_pattern>>

<<class IgnoreFilter>>

<<class IgnoreFilterStack>>
@

\subsection{[[index.py]]}


<<[[Index]] methods>>=
@property
def path(self):
    return self._filename

@

<<[[Index]] methods>>=
def __len__(self):
    """Number of entries in this index file."""
    return len(self._byname)
@

<<[[Index]] methods>>=
def __iter__(self):
    """Iterate over the paths in this index."""
    return iter(self._byname)
@

<<[[Index]] methods>>=
def get_sha1(self, path):
    """Return the (git object) SHA1 for the object at a path."""
    return self[path].sha
@

<<[[Index]] methods>>=
def get_mode(self, path):
    """Return the POSIX file mode for the object at a path."""
    return self[path].mode

@




<<[[Index]] methods>>=
def iteritems(self):
    return self._byname.items()

@

<<[[Index]] methods>>=
def update(self, entries):
    for name, value in entries.items():
        self[name] = value

@

<<function read_index_dict>>=
def read_index_dict(f):
    """Read an index file and return it as a dictionary.

    :param f: File object to read from
    """
    ret = {}
    for x in read_index(f):
        ret[x[0]] = IndexEntry(*x[1:])
    return ret
@
%dead?

%deprecated:
%def commit_index(object_store, index):
%    """Create a new tree from an index.
%
%    :param object_store: Object store to save the tree in
%    :param index: Index file
%    :note: This function is deprecated, use index.commit() instead.
%    :return: Root tree sha.
%    """
%    return commit_tree(object_store, index.iterblobs())

% -----------------------------------------------------------------------
<<dulwich/index.py>>=
# index.py -- File parser/writer for the git index file
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Parser for the git index file format."""

import collections
import errno
import os
import stat
import struct
import sys

from dulwich.file import GitFile
from dulwich.objects import (
    Blob,
    S_IFGITLINK,
    S_ISGITLINK,
    Tree,
    hex_to_sha,
    sha_to_hex,
    )
from dulwich.pack import (
    SHA1Reader,
    SHA1Writer,
    )

<<type IndexEntry>>

<<function index.pathsplit>>

<<function index.pathjoin>>

<<function index.read_cache_time>>

<<function index.write_cache_time>>

<<function index.read_cache_entry>>

<<function index.write_cache_entry>>

<<function read_index>>

<<function read_index_dict>>

<<function write_index>>

<<function write_index_dict>>

<<function index.cleanup_mode>>

<<class Index>>

<<function index.commit_tree>>

<<function index.changes_from_tree>>

<<function index.index_entry_from_stat>>


<<function build_file_from_blob>>

<<constant index.INVALID_DOTNAMES>>


<<function index.validate_path_element_default>>

<<function index.validate_path>>


<<function build_index_from_tree>>

<<function index.blob_from_path_and_stat>>

<<function index.get_unstaged_changes>>

<<function index._tree_to_fs_path>>

<<function index._fs_to_tree_path>>
@

\subsection{[[log_utils.py]]}

% used only for server

<<log_utils.py>>=
# log_utils.py -- Logging utilities for Dulwich
# Copyright (C) 2010 Google, Inc.
#
<<dulwich license>>
"""Logging utilities for Dulwich.

Any module that uses logging needs to do compile-time initialization to set up
the logging environment. Since Dulwich is also used as a library, clients may
not want to see any logging output. In that case, we need to use a special
handler to suppress spurious warnings like "No handlers could be found for
logger dulwich.foo".

For details on the _NullHandler approach, see:
http://docs.python.org/library/logging.html#configuring-logging-for-a-library

For many modules, the only function from the logging module they need is
getLogger; this module exports that function for convenience. If a calling
module needs something else, it can import the standard logging module
directly.
"""

import logging
import sys

getLogger = logging.getLogger


class _NullHandler(logging.Handler):
    """No-op logging handler to avoid unexpected logging warnings."""

    def emit(self, record):
        pass


_NULL_HANDLER = _NullHandler()
_DULWICH_LOGGER = getLogger('dulwich')
_DULWICH_LOGGER.addHandler(_NULL_HANDLER)


def default_logging_config():
    """Set up the default Dulwich loggers."""
    remove_null_handler()
    logging.basicConfig(level=logging.INFO, stream=sys.stderr,
                        format='%(asctime)s %(levelname)s: %(message)s')


def remove_null_handler():
    """Remove the null handler from the Dulwich loggers.

    If a caller wants to set up logging using something other than
    default_logging_config, calling this function first is a minor optimization
    to avoid the overhead of using the _NullHandler.
    """
    _DULWICH_LOGGER.removeHandler(_NULL_HANDLER)
@

\subsection{[[lru_cache.py]]}

<<dulwich/lru_cache.py>>=
# lru_cache.py -- Simple LRU cache for dulwich
# Copyright (C) 2006, 2008 Canonical Ltd
#
<<dulwich license>>
"""A simple least-recently-used (LRU) cache."""

<<constant lru_cache._null_key>>

<<class _LRUNode>>

<<class LRUCache>>

<<class LRUSizeCache>>

@

\subsection{[[object_store.py]]}

<<[[BaseObjectStore]] methods>>=
def __contains__(self, sha):
    """Check if a particular object is present by SHA1.

    This method makes no distinction between loose and packed objects.
    """
    return self.contains_packed(sha) or self.contains_loose(sha)
@

<<[[BaseObjectStore]] methods>>=
def __iter__(self):
    """Iterate over the SHAs that are present in this store."""
    raise NotImplementedError(self.__iter__)

@



<<class ObjectImporter>>=
class ObjectImporter(object):
    """Interface for importing objects."""

    def __init__(self, count):
        """Create a new ObjectImporter.

        :param count: Number of objects that's going to be imported.
        """
        self.count = count

    def add_object(self, object):
        """Add an object."""
        raise NotImplementedError(self.add_object)

    def finish(self, object):
        """Finish the import and write objects to disk."""
        raise NotImplementedError(self.finish)
@
%dead?

<<function object_store.tree_lookup_path>>=
def tree_lookup_path(lookup_obj, root_sha, path):
    """Look up an object in a Git tree.

    :param lookup_obj: Callback for retrieving object by SHA1
    :param root_sha: SHA1 of the root tree
    :param path: Path to lookup
    :return: A tuple of (mode, SHA) of the resulting path.
    """
    tree = lookup_obj(root_sha)
    if not isinstance(tree, Tree):
        raise NotTreeError(root_sha)
    return tree.lookup_path(lookup_obj, path)
@
%dead?

% ----------------------------------------------------------------------------

<<object_store.py>>=
# object_store.py -- Object store for git objects
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@samba.org>
#                         and others
#
<<dulwich license>>

"""Git object store interfaces and implementation."""


from io import BytesIO
import errno
from itertools import chain
import os
import stat
import sys
import tempfile

from dulwich.diff_tree import (
    tree_changes,
    walk_trees,
    )
from dulwich.errors import (
    NotTreeError,
    )
from dulwich.file import GitFile
from dulwich.objects import (
    Commit,
    ShaFile,
    Tag,
    Tree,
    ZERO_SHA,
    hex_to_sha,
    sha_to_hex,
    hex_to_filename,
    S_ISGITLINK,
    object_class,
    )
from dulwich.pack import (
    Pack,
    PackData,
    PackInflater,
    iter_sha1,
    write_pack_header,
    write_pack_index_v2,
    write_pack_object,
    write_pack_objects,
    compute_file_sha,
    PackIndexer,
    PackStreamCopier,
    )

INFODIR = 'info'
<<constant object_store.PACKDIR>>

<<class BaseObjectStore>>

<<class PackBasedObjectStore>>

<<class DiskObjectStore>>

<<class MemoryObjectStore>>

<<class ObjectImporter>>

<<class ObjectIterator>>

<<class ObjectStoreIterator>>

<<function object_store.tree_lookup_path>>

<<function object_store._collect_filetree_revs>>

<<function object_store._split_commits_and_tags>>

<<class MissingObjectFinder>>

<<class ObjectStoreGraphWalker>>
@

\subsection{[[objects.py]]}


<<[[ShaFile]] methods>>=
def __str__(self):
    """Return raw string serialization of this object."""
    return self.as_raw_string()

@

<<[[ShaFile]] methods>>=
def __hash__(self):
    """Return unique hash for this object."""
    return hash(self.id)

@

<<[[ShaFile]] methods>>=
def as_pretty_string(self):
    """Return a string representing this object, fit for display."""
    return self.as_raw_string()
@
%dead?



%deprecated:
%<<[[ShaFile]] methods>>=
%def get_type(self):
%    """Return the type number for this object class."""
%    return self.type_num
%
%@
%<<[[ShaFile]] methods>>=
%def set_type(self, type):
%    """Set the type number for this object class."""
%    self.type_num = type
%
%@
%
%<<[[ShaFile]] methods>>=
%# DEPRECATED: use type_num or type_name as needed.
%type = property(get_type, set_type)
%@


<<[[ShaFile]] methods>>=
def __ne__(self, other):
    return not isinstance(other, ShaFile) or self.id != other.id

@

<<[[ShaFile]] methods>>=
def __eq__(self, other):
    """Return True if the SHAs of the two objects match.

    It doesn't make sense to talk about an order on ShaFiles, so we don't
    override the rich comparison methods (__le__, etc.).
    """
    return isinstance(other, ShaFile) and self.id == other.id

@

<<[[ShaFile]] methods>>=
def __lt__(self, other):
    if not isinstance(other, ShaFile):
        raise TypeError
    return self.id < other.id
@
<<[[ShaFile]] methods>>=
def __le__(self, other):
    if not isinstance(other, ShaFile):
        raise TypeError
    return self.id <= other.id
@
<<[[ShaFile]] methods>>=
def __cmp__(self, other):
    if not isinstance(other, ShaFile):
        raise TypeError
    return cmp(self.id, other.id)
@






<<[[Tree]] methods>>=
def __contains__(self, name):
    return name in self._entries

@


<<[[Tree]] methods>>=
def __len__(self):
    return len(self._entries)

@

<<[[Tree]] methods>>=
def __iter__(self):
    return iter(self._entries)

@



<<[[Tree]] methods>>=
def items(self):
    """Return the sorted entries in this tree.

    :return: List with (name, mode, sha) tuples
    """
    return list(self.iteritems())

@




<<[[Tree]] methods>>=
def as_pretty_string(self):
    text = []
    for name, mode, hexsha in self.iteritems():
        text.append(pretty_format_tree_entry(name, mode, hexsha))
    return "".join(text)
@
%dead?


%-----------------------------------------------------------------------
<<dulwich/objects.py>>=
# objects.py -- Access to base git objects
# Copyright (C) 2007 James Westby <jw+debian@jameswestby.net>
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Access to base git objects."""

import binascii
from io import BytesIO
from collections import namedtuple
import os
import posixpath
import stat
import warnings
import zlib
from hashlib import sha1

from dulwich.errors import (
    ChecksumMismatch,
    NotBlobError,
    NotCommitError,
    NotTagError,
    NotTreeError,
    ObjectFormatException,
    )
from dulwich.file import GitFile

<<constant objects.ZERO_SHA>>

<<constants objects.commits_HEADER>>

<<constants objects.objects_HEADER>>


<<constant S_IFGITLINK>>

<<function objects.S_ISGITLINK>>

<<function objects._decompress>>

<<function sha_to_hex>>

<<function hex_to_sha>>

<<function valid_hexsha>>

<<function hex_to_filename>>

<<function objects.object_header>>

<<function serializable_property>>

<<function objects.object_class>>

<<function objects.check_hexsha>>

<<function objects.check_identity>>

<<function objects.git_line>>

<<class FixedSha>>

<<class ShaFile>>

<<class Blob>>

<<function objects._parse_message>>

<<class Tag>>

<<class TreeEntry>>

<<function object.parse_tree>>

<<function object.serialize_tree>>

<<function object.sorted_tree_items>>

<<function object.key_entry>>

<<function object.key_entry_name_order>>

<<function object.pretty_format_tree_entry>>

<<class Tree>>


<<function objects.parse_timezone>>

<<function objects.format_timezone>>

<<function objects.parse_commit>>

<<class Commit>>


<<constant OBJECT_CLASSES>>

<<global _TYPE_MAP>>

<<[[objects.py]] toplevel>>


# Hold on to the pure-python implementations for testing
_parse_tree_py = parse_tree
_sorted_tree_items_py = sorted_tree_items
try:
    # Try to import C versions
    from dulwich._objects import parse_tree, sorted_tree_items
except ImportError:
    pass
@

\subsection{[[objectspec.py]]}

<<function objectspec.parse_refs>>=
def parse_refs(container, refspecs):
    """Parse a list of refspecs to a list of refs.

    :param container: A RefsContainer object
    :param refspecs: A list of refspecs or a string
    :return: A list of refs
    :raise KeyError: If one of the refs can not be found
    """
    # TODO: Support * in refspecs
    if not isinstance(refspecs, list):
        refspecs = [refspecs]
    ret = []
    for refspec in refspecs:
        ret.append(parse_ref(container, refspec))
    return ret
@
%dead?

<<function objectspec.parse_commit_range>>=
def parse_commit_range(repo, committishs):
    """Parse a string referring to a range of commits.

    :param repo: A `Repo` object
    :param committishs: A string referring to a range of commits.
    :return: An iterator over `Commit` objects
    :raise KeyError: When the reference commits can not be found
    :raise ValueError: If the range can not be parsed
    """
    committishs = to_bytes(committishs)
    # TODO(jelmer): Support more than a single commit..
    return iter([parse_commit(repo, committishs)])
@
%dead?

<<function objectspec.parse_commit>>=
def parse_commit(repo, committish):
    """Parse a string referring to a single commit.

    :param repo: A` Repo` object
    :param commitish: A string referring to a single commit.
    :return: A Commit object
    :raise KeyError: When the reference commits can not be found
    :raise ValueError: If the range can not be parsed
    """
    committish = to_bytes(committish)
    return repo[committish] # For now..
@
%dead? diff with Commit.parse_commit?

%------------------------------------------------------------------------
<<objectspec.py>>=
# objectspec.py -- Object specification
# Copyright (C) 2014 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Object specification."""


<<function objectspec.to_bytes>>

<<function objectspec.parse_object>>

<<function objectspec.parse_ref>>

<<function objectspec.parse_reftuple>>

<<function objectspec.parse_reftuples>>

<<function objectspec.parse_refs>>

<<function objectspec.parse_commit_range>>

<<function objectspec.parse_commit>>

# TODO: parse_path_in_tree(), which handles e.g. v1.0:Documentation
@

\subsection{[[pack.py]]}

<<dulwich/pack.py>>=
# pack.py -- For dealing with packed git objects.
# Copyright (C) 2007 James Westby <jw+debian@jameswestby.net>
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Classes for dealing with packed git objects.

A pack is a compact representation of a bunch of objects, stored
using deltas where possible.

They have two parts, the pack file, which stores the data, and an index
that tells you where the data is.

To find an object you look in all of the index files 'til you find a
match for the object name. You then use the pointer got from this as
a pointer in to the corresponding packfile.
"""

from collections import defaultdict

import binascii
from io import BytesIO, UnsupportedOperation
from collections import (
    deque,
    )
import difflib
import struct

from itertools import chain
try:
    from itertools import imap, izip
except ImportError:
    # Python3
    imap = map
    izip = zip

import os
import sys

try:
    import mmap
except ImportError:
    has_mmap = False
else:
    has_mmap = True

# For some reason the above try, except fails to set has_mmap = False for plan9
if sys.platform == 'Plan9':
    has_mmap = False

from hashlib import sha1
from os import (
    SEEK_CUR,
    SEEK_END,
    )
from struct import unpack_from
import zlib

from dulwich.errors import (
    ApplyDeltaError,
    ChecksumMismatch,
    )
from dulwich.file import GitFile
from dulwich.lru_cache import (
    LRUSizeCache,
    )
from dulwich.objects import (
    ShaFile,
    hex_to_sha,
    sha_to_hex,
    object_header,
    )

<<constant pack.OFS_DELTA>>
<<constant pack.REF_DELTA>>

<<constant pack.DELTA_TYPES>>

<<constant pack.DEFAULT_PACK_DELTA_WINDOW_SIZE>>


<<function pack.take_msb_bytes>>

<<class UnpackedObject>>

<<constant pack._ZLIB_BUFSIZE>>

<<function pack.read_zlib_chunks>>

<<function pack.iter_sha1>>

<<function pack.load_pack_index>>

<<function pack._load_file_contents>>

<<function pack.load_pack_index_file>>

<<function pack.bisect_find_sha>>


<<class PackIndex>>

<<class MemoryPackIndex>>

<<class FilePackIndex>>

<<class PackIndex1>>

<<class PackIndex2>>

<<function read_pack_header>>

<<function pack.chunks_length>>

<<function unpack_object>>

<<function pack._compute_object_size>>


<<class PackStreamReader>>

<<class PackStreamCopier>>


<<function pack.obj_sha>>

<<function pack.compute_file_sha>>

<<class PackData>>

<<class DeltaChainIterator>>

<<class PackIndexer>>

<<class PackInflater>>

<<class SHA1Reader>>

<<class SHA1Writer>>


<<function pack_object_header>>

<<function pack.write_pack_object>>

<<function pack.write_pack>>

<<function pack.write_pack_header>>

<<function pack.deltify_pack_objects>>

<<function pack.write_pack_objects>>

<<function pack.write_pack_data>>


<<function write_pack_index_v1>>

<<function pack._delta_encode_size>>

<<constant pack._MAX_COPY_LEN>>


<<function pack._encode_copy_operation>>

<<function pack.create_delta>>

<<function pack.apply_delta>>

<<function write_pack_index_v2>>

<<function write_pack_index>>

<<class Pack>>


try:
    from dulwich._pack import apply_delta, bisect_find_sha
except ImportError:
    pass
@

\subsection{[[patch.py]]}

<<function patch.write_blob_diff>>=
# TODO(jelmer): Support writing unicode, rather than bytes.
def write_blob_diff(f, old_file, new_file):
    """Write blob diff.

    :param f: File-like object to write to
    :param old_file: (path, mode, hexsha) tuple (None if nonexisting)
    :param new_file: (path, mode, hexsha) tuple (None if nonexisting)

    :note: The use of write_object_diff is recommended over this function.
    """
    (old_path, old_mode, old_blob) = old_file
    (new_path, new_mode, new_blob) = new_file
    old_path = patch_filename(old_path, b"a")
    new_path = patch_filename(new_path, b"b")
    def lines(blob):
        if blob is not None:
            return blob.splitlines()
        else:
            return []
    f.writelines(gen_diff_header(
        (old_path, new_path), (old_mode, new_mode),
        (getattr(old_blob, "id", None), getattr(new_blob, "id", None))))
    old_contents = lines(old_blob)
    new_contents = lines(new_blob)
    f.writelines(unified_diff(old_contents, new_contents,
        old_path, new_path))
@
%dead?

<<[[Blob]] methods>>=
def splitlines(self):
    """Return list of lines in this blob.

    This preserves the original line endings.
    """
    chunks = self.chunked
    if not chunks:
        return []
    if len(chunks) == 1:
        return chunks[0].splitlines(True)
    remaining = None
    ret = []
    for chunk in chunks:
        lines = chunk.splitlines(True)
        if len(lines) > 1:
            ret.append((remaining or b"") + lines[0])
            ret.extend(lines[1:-1])
            remaining = lines[-1]
        elif len(lines) == 1:
            if remaining is None:
                remaining = lines.pop()
            else:
                remaining += lines.pop()
    if remaining is not None:
        ret.append(remaining)
    return ret
@
%dead?


<<function patch.git_am_patch_split>>=
def git_am_patch_split(f, encoding=None):
    """Parse a git-am-style patch and split it up into bits.

    :param f: File-like object to parse
    :param encoding: Encoding to use when creating Git objects
    :return: Tuple with commit object, diff contents and git version
    """
    encoding = encoding or getattr(f, "encoding", "ascii")
    contents = f.read()
    if isinstance(contents, bytes) and getattr(email.parser, "BytesParser", None):
        parser = email.parser.BytesParser()
        msg = parser.parsebytes(contents)
    else:
        parser = email.parser.Parser()
        msg = parser.parsestr(contents)
    return parse_patch_message(msg, encoding)
@
%dead?

<<function patch.write_commit_patch>>=
def write_commit_patch(f, commit, contents, progress, version=None, encoding=None):
    """Write a individual file patch.

    :param commit: Commit object
    :param progress: Tuple with current patch number and total.
    :return: tuple with filename and contents
    """
    encoding = encoding or getattr(f, "encoding", "ascii")
    if isinstance(contents, str):
        contents = contents.encode(encoding)
    (num, total) = progress
    f.write(b"From " + commit.id + b" " + time.ctime(commit.commit_time).encode(encoding) + b"\n")
    f.write(b"From: " + commit.author + b"\n")
    f.write(b"Date: " + time.strftime("%a, %d %b %Y %H:%M:%S %Z").encode(encoding) + b"\n")
    f.write(("Subject: [PATCH %d/%d] " % (num, total)).encode(encoding) + commit.message + b"\n")
    f.write(b"\n")
    f.write(b"---\n")
    try:
        import subprocess
        p = subprocess.Popen(["diffstat"], stdout=subprocess.PIPE,
                             stdin=subprocess.PIPE)
    except (ImportError, OSError):
        pass # diffstat not available?
    else:
        (diffstat, _) = p.communicate(contents)
        f.write(diffstat)
        f.write(b"\n")
    f.write(contents)
    f.write(b"-- \n")
    if version is None:
        from dulwich import __version__ as dulwich_version
        f.write(b"Dulwich %d.%d.%d\n" % dulwich_version)
    else:
        f.write(version.encode(encoding) + b"\n")
@
%dead?

<<function patch.get_summary>>=
def get_summary(commit):
    """Determine the summary line for use in a filename.

    :param commit: Commit
    :return: Summary string
    """
    return commit.message.splitlines()[0].replace(" ", "-")
@
%dead?

<<function patch.parse_patch_message>>=
def parse_patch_message(msg, encoding=None):
    """Extract a Commit object and patch from an e-mail message.

    :param msg: An email message (email.message.Message)
    :param encoding: Encoding to use to encode Git commits
    :return: Tuple with commit object, diff contents and git version
    """
    c = Commit()
    c.author = msg["from"].encode(encoding)
    c.committer = msg["from"].encode(encoding)
    try:
        patch_tag_start = msg["subject"].index("[PATCH")
    except ValueError:
        subject = msg["subject"]
    else:
        close = msg["subject"].index("] ", patch_tag_start)
        subject = msg["subject"][close+2:]
    c.message = (subject.replace("\n", "") + "\n").encode(encoding)
    first = True

    body = msg.get_payload(decode=True)
    lines = body.splitlines(True)
    line_iter = iter(lines)

    for l in line_iter:
        if l == b"---\n":
            break
        if first:
            if l.startswith(b"From: "):
                c.author = l[len(b"From: "):].rstrip()
            else:
                c.message += b"\n" + l
            first = False
        else:
            c.message += l
    diff = b""
    for l in line_iter:
        if l == b"-- \n":
            break
        diff += l
    try:
        version = next(line_iter).rstrip(b"\n")
    except StopIteration:
        version = None
    return c, diff, version
@
%dead?

%---------------------------------------------------------------------------
<<patch.py>>=
# patch.py -- For dealing with packed-style patches.
# Copyright (C) 2009-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Classes for dealing with git am-style patches.

These patches are basically unified diffs with some extra metadata tacked
on.
"""

from difflib import SequenceMatcher
import email.parser
import time

from dulwich.objects import (
    Blob,
    Commit,
    S_ISGITLINK,
    )

FIRST_FEW_BYTES = 8000

<<function patch.write_commit_patch>>

<<function patch.get_summary>>


<<function patch.unified_diff>>

<<function patch.is_binary>>

<<function patch.shortid>>

<<function patch.patch_filename>>

<<function patch.write_object_diff>>

<<function patch.gen_diff_header>>

<<function patch.write_blob_diff>>

<<function patch.write_tree_diff>>

<<function patch.git_am_patch_split>>

<<function patch.parse_patch_message>>
@

\subsection{[[porcelain.py]]}

%deprecated:
%def list_tags(*args, **kwargs):
%    import warnings
%    warnings.warn("list_tags has been deprecated in favour of tag_list.",
%                  DeprecationWarning)
%    return tag_list(*args, **kwargs)


<<function open_repo>>=
def open_repo(path_or_repo):
    """Open an argument that can be a repository or a path for a repository."""
    if isinstance(path_or_repo, BaseRepo):
        return path_or_repo
    return Repo(path_or_repo)
@
%dead?

%-------------------------------------------------------------------------
<<dulwich/porcelain.py>>=
# porcelain.py -- Porcelain-like layer on top of Dulwich
# Copyright (C) 2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Simple wrapper that provides porcelain-like functions on top of Dulwich.

Currently implemented:
 * archive
 * add
 * branch{_create,_delete,_list}
 * clone
 * commit
 * commit-tree
 * daemon
 * diff-tree
 * fetch
 * init
 * ls-remote
 * ls-tree
 * pull
 * push
 * rm
 * remote{_add}
 * receive-pack
 * reset
 * rev-list
 * tag{_create,_delete,_list}
 * upload-pack
 * update-server-info
 * status
 * symbolic-ref

These functions are meant to behave similarly to the git subcommands.
Differences in behaviour are considered bugs.
"""

from collections import namedtuple
from contextlib import (
    closing,
    contextmanager,
)
import os
import posixpath
import stat
import sys
import time

from dulwich.archive import (
    tar_stream,
    )
from dulwich.client import (
    get_transport_and_path,
    )
from dulwich.diff_tree import (
    CHANGE_ADD,
    CHANGE_DELETE,
    CHANGE_MODIFY,
    CHANGE_RENAME,
    CHANGE_COPY,
    RENAME_CHANGE_TYPES,
    )
from dulwich.errors import (
    SendPackError,
    UpdateRefsError,
    )
from dulwich.index import get_unstaged_changes
from dulwich.objects import (
    Commit,
    Tag,
    format_timezone,
    parse_timezone,
    pretty_format_tree_entry,
    )
from dulwich.objectspec import (
    parse_object,
    parse_reftuples,
    )
from dulwich.pack import (
    write_pack_index,
    write_pack_objects,
    )
from dulwich.patch import write_tree_diff
from dulwich.protocol import (
    Protocol,
    ZERO_SHA,
    )
from dulwich.refs import ANNOTATED_TAG_SUFFIX
from dulwich.repo import (BaseRepo, Repo)
from dulwich.server import (
    FileSystemBackend,
    TCPGitServer,
    ReceivePackHandler,
    UploadPackHandler,
    update_server_info as server_update_server_info,
    )


<<type GitStatus>>

<<constant default_bytes_out_stream>>
<<constant default_bytes_err_stream>>

<<constant porcelain.DEFAULT_ENCODING>>

<<exception RemoteExists>>

<<function open_repo>>

<<function _noop_context_manager>>

<<function porcelain.open_repo_closing>>



<<function porcelain.archive>>

<<function porcelain.update_server_info>>

<<function porcelain.symbolic_ref>>

<<function porcelain.commit>>

<<function porcelain.commit_tree>>

<<function porcelain.init>>

<<function porcelain.clone>>

<<function porcelain.add>>

<<function porcelain.rm>>

<<function porcelain.commit_decode>>

<<function porcelain.print_commit>>

<<function porcelain.print_tag>>

<<function porcelain.show_blob>>

<<function porcelain.show_commit>>

<<function porcelain.show_tree>>

<<function porcelain.show_tag>>

<<function porcelain.show_object>>

<<function porcelain.print_name_status>>

<<function porcelain.log>>

<<function porcelain.show>>

<<function porcelain.diff_tree>>

<<function porcelain.rev_list>>

<<function porcelain.tag_create>>

<<function porcelain.tag_list>>

<<function porcelain.tag_delete>>

<<function porcelain.reset>>

<<function porcelain.push>>

<<function porcelain.pull>>

<<function porcelain.status>>

<<function porcelain.get_untracked_paths>>


<<function porcelain.get_tree_changes>>

<<function porcelain.daemon>>

<<function porcelain.web_daemon>>

<<function porcelain.upload_pack>>

<<function porcelain.receive_pack>>

<<function porcelain.branch_delete>>

<<function porcelain.branch_create>>

<<function porcelain.branch_list>>

<<function porcelain.fetch>>

<<function porcelain.ls_remote>>

<<function porcelain.repack>>

<<function porcelain.pack_objects>>

<<function porcelain.ls_tree>>

<<function porcelain.remote_add>>

@

\subsection{[[protocol.py]]}

<<protocol.py>>=
# protocol.py -- Shared parts of the git protocols
# Copyright (C) 2008 John Carr <john.carr@unrouted.co.uk>
# Copyright (C) 2008-2012 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Generic functions for talking the git smart server protocol."""

from io import BytesIO
from os import (
    SEEK_END,
    )
import socket

import dulwich
from dulwich.errors import (
    HangupException,
    GitProtocolError,
    )

<<constant protocol.TCP_GIT_PORT>>

ZERO_SHA = b"0" * 40

SINGLE_ACK = 0
MULTI_ACK = 1
MULTI_ACK_DETAILED = 2

# pack data
SIDE_BAND_CHANNEL_DATA = 1
# progress messages
SIDE_BAND_CHANNEL_PROGRESS = 2
# fatal error message just before stream aborts
SIDE_BAND_CHANNEL_FATAL = 3

CAPABILITY_DELETE_REFS = b'delete-refs'
CAPABILITY_INCLUDE_TAG = b'include-tag'
CAPABILITY_MULTI_ACK = b'multi_ack'
CAPABILITY_MULTI_ACK_DETAILED = b'multi_ack_detailed'
CAPABILITY_NO_DONE = b'no-done'
CAPABILITY_NO_PROGRESS = b'no-progress'
CAPABILITY_OFS_DELTA = b'ofs-delta'
CAPABILITY_QUIET = b'quiet'
CAPABILITY_REPORT_STATUS = b'report-status'
CAPABILITY_SHALLOW = b'shallow'
CAPABILITY_SIDE_BAND_64K = b'side-band-64k'
CAPABILITY_THIN_PACK = b'thin-pack'
<<constant protocol.CAPABILITY_AGENT>>

# Magic ref that is used to attach capabilities to when
# there are no refs. Should always be ste to ZERO_SHA.
CAPABILITIES_REF = b'capabilities^{}'


<<function protocol.agent_string>>

<<function protocol.capability_agent>>

COMMAND_DEEPEN = b'deepen'
COMMAND_SHALLOW = b'shallow'
COMMAND_UNSHALLOW = b'unshallow'
COMMAND_DONE = b'done'
COMMAND_WANT = b'want'
COMMAND_HAVE = b'have'

<<class ProtocolFile>>

<<function pkt_line>>

<<class Protocol>>


_RBUFSIZE = 8192  # Default read buffer size.


class ReceivableProtocol(Protocol):
    """Variant of Protocol that allows reading up to a size without blocking.

    This class has a recv() method that behaves like socket.recv() in addition
    to a read() method.

    If you want to read n bytes from the wire and block until exactly n bytes
    (or EOF) are read, use read(n). If you want to read at most n bytes from the
    wire but don't care if you get less, use recv(n). Note that recv(n) will
    still block until at least one byte is read.
    """

    def __init__(self, recv, write, report_activity=None, rbufsize=_RBUFSIZE):
        super(ReceivableProtocol, self).__init__(self.read, write,
                                                 report_activity)
        self._recv = recv
        self._rbuf = BytesIO()
        self._rbufsize = rbufsize

    def read(self, size):
        # From _fileobj.read in socket.py in the Python 2.6.5 standard library,
        # with the following modifications:
        #  - omit the size <= 0 branch
        #  - seek back to start rather than 0 in case some buffer has been
        #    consumed.
        #  - use SEEK_END instead of the magic number.
        # Copyright (c) 2001-2010 Python Software Foundation; All Rights Reserved
        # Licensed under the Python Software Foundation License.
        # TODO: see if buffer is more efficient than cBytesIO.
        assert size > 0

        # Our use of BytesIO rather than lists of string objects returned by
        # recv() minimizes memory usage and fragmentation that occurs when
        # rbufsize is large compared to the typical return value of recv().
        buf = self._rbuf
        start = buf.tell()
        buf.seek(0, SEEK_END)
        # buffer may have been partially consumed by recv()
        buf_len = buf.tell() - start
        if buf_len >= size:
            # Already have size bytes in our buffer?  Extract and return.
            buf.seek(start)
            rv = buf.read(size)
            self._rbuf = BytesIO()
            self._rbuf.write(buf.read())
            self._rbuf.seek(0)
            return rv

        self._rbuf = BytesIO()  # reset _rbuf.  we consume it via buf.
        while True:
            left = size - buf_len
            # recv() will malloc the amount of memory given as its
            # parameter even though it often returns much less data
            # than that.  The returned data string is short lived
            # as we copy it into a BytesIO and free it.  This avoids
            # fragmentation issues on many platforms.
            data = self._recv(left)
            if not data:
                break
            n = len(data)
            if n == size and not buf_len:
                # Shortcut.  Avoid buffer data copies when:
                # - We have no data in our buffer.
                # AND
                # - Our call to recv returned exactly the
                #   number of bytes we were asked to read.
                return data
            if n == left:
                buf.write(data)
                del data  # explicit free
                break
            assert n <= left, "_recv(%d) returned %d bytes" % (left, n)
            buf.write(data)
            buf_len += n
            del data  # explicit free
            #assert buf_len == buf.tell()
        buf.seek(start)
        return buf.read()

    def recv(self, size):
        assert size > 0

        buf = self._rbuf
        start = buf.tell()
        buf.seek(0, SEEK_END)
        buf_len = buf.tell()
        buf.seek(start)

        left = buf_len - start
        if not left:
            # only read from the wire if our read buffer is exhausted
            data = self._recv(self._rbufsize)
            if len(data) == size:
                # shortcut: skip the buffer if we read exactly size bytes
                return data
            buf = BytesIO()
            buf.write(data)
            buf.seek(0)
            del data  # explicit free
            self._rbuf = buf
        return buf.read(size)


def extract_capabilities(text):
    """Extract a capabilities list from a string, if present.

    :param text: String to extract from
    :return: Tuple with text with capabilities removed and list of capabilities
    """
    if not b"\0" in text:
        return text, []
    text, capabilities = text.rstrip().split(b"\0")
    return (text, capabilities.strip().split(b" "))


def extract_want_line_capabilities(text):
    """Extract a capabilities list from a want line, if present.

    Note that want lines have capabilities separated from the rest of the line
    by a space instead of a null byte. Thus want lines have the form:

        want obj-id cap1 cap2 ...

    :param text: Want line to extract from
    :return: Tuple with text with capabilities removed and list of capabilities
    """
    split_text = text.rstrip().split(b" ")
    if len(split_text) < 3:
        return text, []
    return (b" ".join(split_text[:2]), split_text[2:])


def ack_type(capabilities):
    """Extract the ack type from a capabilities list."""
    if b'multi_ack_detailed' in capabilities:
        return MULTI_ACK_DETAILED
    elif b'multi_ack' in capabilities:
        return MULTI_ACK
    return SINGLE_ACK


class BufferedPktLineWriter(object):
    """Writer that wraps its data in pkt-lines and has an independent buffer.

    Consecutive calls to write() wrap the data in a pkt-line and then buffers it
    until enough lines have been written such that their total length (including
    length prefix) reach the buffer size.
    """

    def __init__(self, write, bufsize=65515):
        """Initialize the BufferedPktLineWriter.

        :param write: A write callback for the underlying writer.
        :param bufsize: The internal buffer size, including length prefixes.
        """
        self._write = write
        self._bufsize = bufsize
        self._wbuf = BytesIO()
        self._buflen = 0

    def write(self, data):
        """Write data, wrapping it in a pkt-line."""
        line = pkt_line(data)
        line_len = len(line)
        over = self._buflen + line_len - self._bufsize
        if over >= 0:
            start = line_len - over
            self._wbuf.write(line[:start])
            self.flush()
        else:
            start = 0
        saved = line[start:]
        self._wbuf.write(saved)
        self._buflen += len(saved)

    def flush(self):
        """Flush all data from the buffer."""
        data = self._wbuf.getvalue()
        if data:
            self._write(data)
        self._len = 0
        self._wbuf = BytesIO()


class PktLineParser(object):
    """Packet line parser that hands completed packets off to a callback.
    """

    def __init__(self, handle_pkt):
        self.handle_pkt = handle_pkt
        self._readahead = BytesIO()

    def parse(self, data):
        """Parse a fragment of data and call back for any completed packets.
        """
        self._readahead.write(data)
        buf = self._readahead.getvalue()
        if len(buf) < 4:
            return
        while len(buf) >= 4:
            size = int(buf[:4], 16)
            if size == 0:
                self.handle_pkt(None)
                buf = buf[4:]
            elif size <= len(buf):
                self.handle_pkt(buf[4:size])
                buf = buf[size:]
            else:
                break
        self._readahead = BytesIO()
        self._readahead.write(buf)

    def get_tail(self):
        """Read back any unused data."""
        return self._readahead.getvalue()
@

\subsection{[[reflog.py]]}

<<dulwich/reflog.py>>=
# reflog.py -- Parsing and writing reflog files
# Copyright (C) 2015 Jelmer Vernooij and others.
#
<<dulwich license>>
"""Utilities for reading and generating reflogs.
"""

import collections

from dulwich.objects import (
    format_timezone,
    parse_timezone,
    ZERO_SHA,
    )

<<type reflog.Entry>>

<<function format_reflog_line>>

<<function parse_reflog_line>>

<<function read_reflog>>
@

\subsection{[[refs.py]]}

%deprecated:
%<<[[RefsContainer]] methods>>=
%def _follow(self, name):
%    import warnings
%    warnings.warn(
%        "RefsContainer._follow is deprecated. Use RefsContainer.follow instead.",
%        DeprecationWarning)
%    refnames, contents = self.follow(name)
%    if not refnames:
%        return (None, contents)
%    return (refnames[-1], contents)
%@

<<[[RefsContainer]] methods>>=
def __contains__(self, refname):
    if self.read_ref(refname):
        return True
    return False

@


<<class InfoRefsContainer>>=
class InfoRefsContainer(RefsContainer):
    """Refs container that reads refs from a info/refs file."""

    def __init__(self, f):
        self._refs = {}
        self._peeled = {}
        for l in f.readlines():
            sha, name = l.rstrip(b'\n').split(b'\t')
            if name.endswith(ANNOTATED_TAG_SUFFIX):
                name = name[:-3]
                if not check_ref_format(name):
                    raise ValueError("invalid ref name %r" % name)
                self._peeled[name] = sha
            else:
                if not check_ref_format(name):
                    raise ValueError("invalid ref name %r" % name)
                self._refs[name] = sha

    def allkeys(self):
        return self._refs.keys()

    def read_loose_ref(self, name):
        return self._refs.get(name, None)

    def get_packed_refs(self):
        return {}

    def get_peeled(self, name):
        try:
            return self._peeled[name]
        except KeyError:
            return self._refs[name]
@
%dead?

<<constant refs.LOCAL_BRANCH_PREFIX>>=
LOCAL_BRANCH_PREFIX = b'refs/heads/'
@
%dead?

<<function is_local_branch>>=
is_local_branch = lambda x: x.startswith(b'refs/heads/')
@
%dead?

%--------------------------------------------------------------------------
<<refs.py>>=
# refs.py -- For dealing with git refs
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>

"""Ref handling.

"""
import errno
import os
import sys

from dulwich.errors import (
    PackedRefsException,
    RefFormatError,
    )
from dulwich.objects import (
    git_line,
    valid_hexsha,
    ZERO_SHA,
    )
from dulwich.file import (
    GitFile,
    ensure_dir_exists,
    )

<<constant refs.SYMREF>>
<<constant refs.LOCAL_BRANCH_PREFIX>>
<<constant refs.BAD_REF_CHARS>>
<<constant refs.ANNOTATED_TAG_SUFFIX>>

<<function refs.check_ref_format>>

<<class RefsContainer>>

<<class DictRefsContainer>>

<<class InfoRefsContainer>>

<<class DiskRefsContainer>>

<<function refs._split_ref_line>>

<<function refs.read_packed_refs>>

<<function refs.read_packed_refs_with_peeled>>

<<function refs.write_packed_refs>>

<<function refs.read_info_refs>>

<<function refs.write_info_refs>>

<<function is_local_branch>>
@

\subsection{[[repo.py]]}


<<[[Repo]] methods>>=
@classmethod
def discover(cls, start='.'):
    """Iterate parent directories to discover a repository

    Return a Repo object for the first parent directory that looks like a
    Git repository.

    :param start: The directory to start discovery from (defaults to '.')
    """
    remaining = True
    path = os.path.abspath(start)
    while remaining:
        try:
            return cls(path)
        except NotGitRepository:
            path, remaining = os.path.split(path)
    raise NotGitRepository(
        "No git repository was found at %(path)s" % dict(path=start)
    )
@
%dead?

<<[[Repo]] methods>>=
def controldir(self):
    """Return the path of the control directory."""
    return self._controldir
@



<<[[Repo]] methods>>=
def clone(self, target_path, mkdir=True, bare=False,
          origin=b"origin"):
    """Clone this repository.

    :param target_path: Target path
    :param mkdir: Create the target directory
    :param bare: Whether to create a bare repository
    :param origin: Base name for refs in target repository
        cloned from this repository
    :return: Created repository as `Repo`
    """
    if not bare:
        target = self.init(target_path, mkdir=mkdir)
    else:
        target = self.init_bare(target_path, mkdir=mkdir)
    self.fetch(target)
    target.refs.import_refs(
        b'refs/remotes/' + origin, self.refs.as_dict(b'refs/heads'))
    target.refs.import_refs(
        b'refs/tags', self.refs.as_dict(b'refs/tags'))
    try:
        target.refs.add_if_new(DEFAULT_REF, self.refs[DEFAULT_REF])
    except KeyError:
        pass
    target_config = target.get_config()
    encoded_path = self.path
    if not isinstance(encoded_path, bytes):
        encoded_path = encoded_path.encode(sys.getfilesystemencoding())
    target_config.set((b'remote', b'origin'), b'url', encoded_path)
    target_config.set((b'remote', b'origin'), b'fetch',
                      b'+refs/heads/*:refs/remotes/origin/*')
    target_config.write_to_path()

    # Update target head
    head_chain, head_sha = self.refs.follow(b'HEAD')
    if head_chain and head_sha is not None:
        target.refs.set_symbolic_ref(b'HEAD', head_chain[-1])
        target[b'HEAD'] = head_sha

        if not bare:
            # Checkout HEAD to target dir
            target.reset_index()

    return target
@
% dead? vs porcelain.clone?



<<[[Repo]] methods>>=
def get_description(self):
    """Retrieve the description of this repository.

    :return: A string describing the repository or None.
    """
    path = os.path.join(self._controldir, 'description')
    try:
        with GitFile(path, 'rb') as f:
            return f.read()
    except (IOError, OSError) as e:
        if e.errno != errno.ENOENT:
            raise
        return None
@


<<[[Repo]] methods>>=
def set_description(self, description):
    """Set the description for this repository.

    :param description: Text to set as description for this repository.
    """

    self._put_named_file('description', description)
@


<<constant repo.GITDIR>>=
GITDIR = 'gitdir'
@
<<constant repo.WORKTREES>>=
WORKTREES = 'worktrees'
@

<<[[Repo]] methods>>=
@classmethod
def _init_new_working_directory(cls, path, main_repo, identifier=None,
                                mkdir=False):
    """Create a new working directory linked to a repository.

    :param path: Path in which to create the working tree.
    :param main_repo: Main repository to reference
    :param identifier: Worktree identifier
    :param mkdir: Whether to create the directory
    :return: `Repo` instance
    """
    if mkdir:
        os.mkdir(path)
    if identifier is None:
        identifier = os.path.basename(path)
    main_worktreesdir = os.path.join(main_repo.controldir(), WORKTREES)
    worktree_controldir = os.path.join(main_worktreesdir, identifier)
    gitdirfile = os.path.join(path, CONTROLDIR)
    with open(gitdirfile, 'wb') as f:
        f.write(b'gitdir: ' +
                worktree_controldir.encode(sys.getfilesystemencoding()) +
                b'\n')
    try:
        os.mkdir(main_worktreesdir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    try:
        os.mkdir(worktree_controldir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    with open(os.path.join(worktree_controldir, GITDIR), 'wb') as f:
        f.write(gitdirfile.encode(sys.getfilesystemencoding()) + b'\n')
    with open(os.path.join(worktree_controldir, COMMONDIR), 'wb') as f:
        f.write(b'../..\n')
    with open(os.path.join(worktree_controldir, 'HEAD'), 'wb') as f:
        f.write(main_repo.head() + b'\n')
    r = cls(path)
    r.reset_index()
    return r
@
%dead?


<<[[Repo]] methods>>=
def __enter__(self):
    return self
@
<<[[Repo]] methods>>=
def __exit__(self, exc_type, exc_val, exc_tb):
    self.close()
@


<<[[BaseRepo]] methods>>=
def head(self):
    """Return the SHA1 pointed at by HEAD."""
    return self.refs[b'HEAD']

@
%dead?

<<[[BaseRepo]] methods>>=
def _get_object(self, sha, cls):
    assert len(sha) in (20, 40)
    ret = self.get_object(sha)
    if not isinstance(ret, cls):
        if cls is Commit:
            raise NotCommitError(ret)
        elif cls is Blob:
            raise NotBlobError(ret)
        elif cls is Tree:
            raise NotTreeError(ret)
        elif cls is Tag:
            raise NotTagError(ret)
        else:
            raise Exception("Type invalid: %r != %r" % (
              ret.type_name, cls.type_name))
    return ret
@
%dead?

<<[[BaseRepo]] methods>>=
def get_object(self, sha):
    """Retrieve the object with the specified SHA.

    :param sha: SHA to retrieve
    :return: A ShaFile object
    :raise KeyError: when the object can not be found
    """
    return self.object_store[sha]
@
%dead?



<<[[BaseRepo]] methods>>=
def get_description(self):
    """Retrieve the description for this repository.

    :return: String with the description of the repository
        as set by the user.
    """
    raise NotImplementedError(self.get_description)

@

<<[[BaseRepo]] methods>>=
def set_description(self, description):
    """Set the description for this repository.

    :param description: Text to set as description for this repository.
    """
    raise NotImplementedError(self.set_description)

@

<<[[BaseRepo]] methods>>=
def get_config_stack(self):
    """Return a config stack for this repository.

    This stack accesses the configuration for both this repository
    itself (.git/config) and the global configuration, which usually
    lives in ~/.gitconfig.

    :return: `Config` instance for this repository
    """
    from dulwich.config import StackedConfig
    backends = [self.get_config()] + StackedConfig.default_backends()
    return StackedConfig(backends, writable=backends[0])

@


<<[[BaseRepo]] methods>>=
def __contains__(self, name):
    """Check if a specific Git object or ref is present.

    :param name: Git object SHA1 or ref name
    """
    if len(name) in (20, 40):
        return name in self.object_store or name in self.refs
    else:
        return name in self.refs

@

%---------------------------------------------------------------------------

<<dulwich/repo.py>>=
# repo.py -- For dealing with git repositories.
# Copyright (C) 2007 James Westby <jw+debian@jameswestby.net>
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>

"""Repository access.

This module contains the base class for git repositories
(BaseRepo) and an implementation which uses a repository on
local disk (Repo).

"""

from io import BytesIO
import errno
import os
import sys
import stat

from dulwich.errors import (
    NoIndexPresent,
    NotBlobError,
    NotCommitError,
    NotGitRepository,
    NotTreeError,
    NotTagError,
    CommitError,
    RefFormatError,
    HookError,
    )
from dulwich.file import (
    GitFile,
    )
from dulwich.object_store import (
    DiskObjectStore,
    MemoryObjectStore,
    ObjectStoreGraphWalker,
    )
from dulwich.objects import (
    check_hexsha,
    Blob,
    Commit,
    ShaFile,
    Tag,
    Tree,
    )

from dulwich.hooks import (
    PreCommitShellHook,
    PostCommitShellHook,
    CommitMsgShellHook,
    )

from dulwich.refs import (
    check_ref_format,
    RefsContainer,
    DictRefsContainer,
    InfoRefsContainer,
    DiskRefsContainer,
    read_packed_refs,
    read_packed_refs_with_peeled,
    write_packed_refs,
    SYMREF,
    )


import warnings

<<constant repo.CONTROLDIR>>

<<constant repo.OBJECTDIR>>

<<constant repo.REFSDIR>>
<<constant repo.REFSDIR_TAGS>>
<<constant repo.REFSDIR_HEADS>>

<<constant repo.INDEX_FILENAME>>

<<constant repo.COMMONDIR>>
<<constant repo.GITDIR>>
<<constant repo.WORKTREES>>

<<constant repo.BASE_DIRECTORIES>>

<<constant repo.DEFAULT_REF>>

<<function parse_graftpoints>>

<<function serialize_graftpoints>>

<<class BaseRepo>>

<<function repo.read_gitfile>>

<<class Repo>>

<<class MemoryRepo>>
@


\subsection{[[server.py]]}

<<class BackendRepo>>=
class BackendRepo(object):
    """Repository abstraction used by the Git server.

    The methods required here are a subset of those provided by
    dulwich.repo.Repo.
    """

    object_store = None
    refs = None

    def get_refs(self):
        """
        Get all the refs in the repository

        :return: dict of name -> sha
        """
        raise NotImplementedError

    def get_peeled(self, name):
        """Return the cached peeled value of a ref, if available.

        :param name: Name of the ref to peel
        :return: The peeled value of the ref. If the ref is known not point to
            a tag, this will be the SHA the ref refers to. If no cached
            information about a tag is available, this method may return None,
            but it should attempt to peel the tag if possible.
        """
        return None

    def fetch_objects(self, determine_wants, graph_walker, progress,
                      get_tagged=None):
        """
        Yield the objects required for a list of commits.

        :param progress: is a callback to send progress messages to the client
        :param get_tagged: Function that returns a dict of pointed-to sha -> tag
            sha for including tags.
        """
        raise NotImplementedError
@
%dead?


%---------------------------------------------------------------------
<<dulwich/server.py>>=
# server.py -- Implementation of the server side git protocols
# Copyright (C) 2008 John Carr <john.carr@unrouted.co.uk>
# Coprygith (C) 2011-2012 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""Git smart network protocol server implementation.

For more detailed implementation on the network protocol, see the
Documentation/technical directory in the cgit distribution, and in particular:

* Documentation/technical/protocol-capabilities.txt
* Documentation/technical/pack-protocol.txt

Currently supported capabilities:

 * include-tag
 * thin-pack
 * multi_ack_detailed
 * multi_ack
 * side-band-64k
 * ofs-delta
 * no-progress
 * report-status
 * delete-refs
 * shallow
"""

import collections
import os
import socket
import sys
import zlib

try:
    import SocketServer
except ImportError:
    import socketserver as SocketServer

from dulwich.errors import (
    ApplyDeltaError,
    ChecksumMismatch,
    GitProtocolError,
    NotGitRepository,
    UnexpectedCommandError,
    ObjectFormatException,
    )
from dulwich import log_utils
from dulwich.objects import (
    Commit,
    valid_hexsha,
    )
from dulwich.pack import (
    write_pack_objects,
    )
from dulwich.protocol import (
    BufferedPktLineWriter,
    capability_agent,
    CAPABILITIES_REF,
    CAPABILITY_DELETE_REFS,
    CAPABILITY_INCLUDE_TAG,
    CAPABILITY_MULTI_ACK_DETAILED,
    CAPABILITY_MULTI_ACK,
    CAPABILITY_NO_DONE,
    CAPABILITY_NO_PROGRESS,
    CAPABILITY_OFS_DELTA,
    CAPABILITY_QUIET,
    CAPABILITY_REPORT_STATUS,
    CAPABILITY_SHALLOW,
    CAPABILITY_SIDE_BAND_64K,
    CAPABILITY_THIN_PACK,
    COMMAND_DEEPEN,
    COMMAND_DONE,
    COMMAND_HAVE,
    COMMAND_SHALLOW,
    COMMAND_UNSHALLOW,
    COMMAND_WANT,
    MULTI_ACK,
    MULTI_ACK_DETAILED,
    Protocol,
    ProtocolFile,
    ReceivableProtocol,
    SIDE_BAND_CHANNEL_DATA,
    SIDE_BAND_CHANNEL_PROGRESS,
    SIDE_BAND_CHANNEL_FATAL,
    SINGLE_ACK,
    TCP_GIT_PORT,
    ZERO_SHA,
    ack_type,
    extract_capabilities,
    extract_want_line_capabilities,
    )
from dulwich.refs import (
    ANNOTATED_TAG_SUFFIX,
    write_info_refs,
    )
from dulwich.repo import (
    Repo,
    )


logger = log_utils.getLogger(__name__)

<<class Backend>>

<<class BackendRepo>>

class DictBackend(Backend):
    """Trivial backend that looks up Git repositories in a dictionary."""

    def __init__(self, repos):
        self.repos = repos

    def open_repository(self, path):
        logger.debug('Opening repository at %s', path)
        try:
            return self.repos[path]
        except KeyError:
            raise NotGitRepository(
                "No git repository was found at %(path)s" % dict(path=path)
            )

<<class FileSystemBackend>>

<<class Handler>>

<<class PackHandler>>

<<class UploadPackHandler>>


def _split_proto_line(line, allowed):
    """Split a line read from the wire.

    :param line: The line read from the wire.
    :param allowed: An iterable of command names that should be allowed.
        Command names not listed below as possible return values will be
        ignored.  If None, any commands from the possible return values are
        allowed.
    :return: a tuple having one of the following forms:
        ('want', obj_id)
        ('have', obj_id)
        ('done', None)
        (None, None)  (for a flush-pkt)

    :raise UnexpectedCommandError: if the line cannot be parsed into one of the
        allowed return values.
    """
    if not line:
        fields = [None]
    else:
        fields = line.rstrip(b'\n').split(b' ', 1)
    command = fields[0]
    if allowed is not None and command not in allowed:
        raise UnexpectedCommandError(command)
    if len(fields) == 1 and command in (COMMAND_DONE, None):
        return (command, None)
    elif len(fields) == 2:
        if command in (COMMAND_WANT, COMMAND_HAVE, COMMAND_SHALLOW,
                       COMMAND_UNSHALLOW):
            if not valid_hexsha(fields[1]):
                raise GitProtocolError("Invalid sha")
            return tuple(fields)
        elif command == COMMAND_DEEPEN:
            return command, int(fields[1])
    raise GitProtocolError('Received invalid line from client: %r' % line)


def _find_shallow(store, heads, depth):
    """Find shallow commits according to a given depth.

    :param store: An ObjectStore for looking up objects.
    :param heads: Iterable of head SHAs to start walking from.
    :param depth: The depth of ancestors to include. A depth of one includes
        only the heads themselves.
    :return: A tuple of (shallow, not_shallow), sets of SHAs that should be
        considered shallow and unshallow according to the arguments. Note that
        these sets may overlap if a commit is reachable along multiple paths.
    """
    parents = {}
    def get_parents(sha):
        result = parents.get(sha, None)
        if not result:
            result = store[sha].parents
            parents[sha] = result
        return result

    todo = []  # stack of (sha, depth)
    for head_sha in heads:
        obj = store.peel_sha(head_sha)
        if isinstance(obj, Commit):
            todo.append((obj.id, 1))

    not_shallow = set()
    shallow = set()
    while todo:
        sha, cur_depth = todo.pop()
        if cur_depth < depth:
            not_shallow.add(sha)
            new_depth = cur_depth + 1
            todo.extend((p, new_depth) for p in get_parents(sha))
        else:
            shallow.add(sha)

    return shallow, not_shallow


def _want_satisfied(store, haves, want, earliest):
    o = store[want]
    pending = collections.deque([o])
    while pending:
        commit = pending.popleft()
        if commit.id in haves:
            return True
        if commit.type_name != b"commit":
            # non-commit wants are assumed to be satisfied
            continue
        for parent in commit.parents:
            parent_obj = store[parent]
            # TODO: handle parents with later commit times than children
            if parent_obj.commit_time >= earliest:
                pending.append(parent_obj)
    return False


def _all_wants_satisfied(store, haves, wants):
    """Check whether all the current wants are satisfied by a set of haves.

    :param store: Object store to retrieve objects from
    :param haves: A set of commits we know the client has.
    :param wants: A set of commits the client wants
    :note: Wants are specified with set_wants rather than passed in since
        in the current interface they are determined outside this class.
    """
    haves = set(haves)
    if haves:
        earliest = min([store[h].commit_time for h in haves])
    else:
        earliest = 0
    for want in wants:
        if not _want_satisfied(store, haves, want, earliest):
            return False

    return True


class ProtocolGraphWalker(object):
    """A graph walker that knows the git protocol.

    As a graph walker, this class implements ack(), next(), and reset(). It
    also contains some base methods for interacting with the wire and walking
    the commit tree.

    The work of determining which acks to send is passed on to the
    implementation instance stored in _impl. The reason for this is that we do
    not know at object creation time what ack level the protocol requires. A
    call to set_ack_level() is required to set up the implementation, before any
    calls to next() or ack() are made.
    """
    def __init__(self, handler, object_store, get_peeled):
        self.handler = handler
        self.store = object_store
        self.get_peeled = get_peeled
        self.proto = handler.proto
        self.http_req = handler.http_req
        self.advertise_refs = handler.advertise_refs
        self._wants = []
        self.shallow = set()
        self.client_shallow = set()
        self.unshallow = set()
        self._cached = False
        self._cache = []
        self._cache_index = 0
        self._impl = None

    def determine_wants(self, heads):
        """Determine the wants for a set of heads.

        The given heads are advertised to the client, who then specifies which
        refs he wants using 'want' lines. This portion of the protocol is the
        same regardless of ack type, and in fact is used to set the ack type of
        the ProtocolGraphWalker.

        If the client has the 'shallow' capability, this method also reads and
        responds to the 'shallow' and 'deepen' lines from the client. These are
        not part of the wants per se, but they set up necessary state for
        walking the graph. Additionally, later code depends on this method
        consuming everything up to the first 'have' line.

        :param heads: a dict of refname->SHA1 to advertise
        :return: a list of SHA1s requested by the client
        """
        values = set(heads.values())
        if self.advertise_refs or not self.http_req:
            for i, (ref, sha) in enumerate(sorted(heads.items())):
                line = sha + b' ' + ref
                if not i:
                    line += b'\x00' + self.handler.capability_line()
                self.proto.write_pkt_line(line + b'\n')
                peeled_sha = self.get_peeled(ref)
                if peeled_sha != sha:
                    self.proto.write_pkt_line(
                        peeled_sha + b' ' + ref + ANNOTATED_TAG_SUFFIX + b'\n')

            # i'm done..
            self.proto.write_pkt_line(None)

            if self.advertise_refs:
                return []

        # Now client will sending want want want commands
        want = self.proto.read_pkt_line()
        if not want:
            return []
        line, caps = extract_want_line_capabilities(want)
        self.handler.set_client_capabilities(caps)
        self.set_ack_type(ack_type(caps))
        allowed = (COMMAND_WANT, COMMAND_SHALLOW, COMMAND_DEEPEN, None)
        command, sha = _split_proto_line(line, allowed)

        want_revs = []
        while command == COMMAND_WANT:
            if sha not in values:
                raise GitProtocolError(
                  'Client wants invalid object %s' % sha)
            want_revs.append(sha)
            command, sha = self.read_proto_line(allowed)

        self.set_wants(want_revs)
        if command in (COMMAND_SHALLOW, COMMAND_DEEPEN):
            self.unread_proto_line(command, sha)
            self._handle_shallow_request(want_revs)

        if self.http_req and self.proto.eof():
            # The client may close the socket at this point, expecting a
            # flush-pkt from the server. We might be ready to send a packfile at
            # this point, so we need to explicitly short-circuit in this case.
            return []

        return want_revs

    def unread_proto_line(self, command, value):
        if isinstance(value, int):
            value = str(value).encode('ascii')
        self.proto.unread_pkt_line(command + b' ' + value)

    def ack(self, have_ref):
        if len(have_ref) != 40:
            raise ValueError("invalid sha %r" % have_ref)
        return self._impl.ack(have_ref)

    def reset(self):
        self._cached = True
        self._cache_index = 0

    def next(self):
        if not self._cached:
            if not self._impl and self.http_req:
                return None
            return next(self._impl)
        self._cache_index += 1
        if self._cache_index > len(self._cache):
            return None
        return self._cache[self._cache_index]

    __next__ = next

    def read_proto_line(self, allowed):
        """Read a line from the wire.

        :param allowed: An iterable of command names that should be allowed.
        :return: A tuple of (command, value); see _split_proto_line.
        :raise UnexpectedCommandError: If an error occurred reading the line.
        """
        return _split_proto_line(self.proto.read_pkt_line(), allowed)

    def _handle_shallow_request(self, wants):
        while True:
            command, val = self.read_proto_line((COMMAND_DEEPEN, COMMAND_SHALLOW))
            if command == COMMAND_DEEPEN:
                depth = val
                break
            self.client_shallow.add(val)
        self.read_proto_line((None,))  # consume client's flush-pkt

        shallow, not_shallow = _find_shallow(self.store, wants, depth)

        # Update self.shallow instead of reassigning it since we passed a
        # reference to it before this method was called.
        self.shallow.update(shallow - not_shallow)
        new_shallow = self.shallow - self.client_shallow
        unshallow = self.unshallow = not_shallow & self.client_shallow

        for sha in sorted(new_shallow):
            self.proto.write_pkt_line(COMMAND_SHALLOW + b' ' + sha)
        for sha in sorted(unshallow):
            self.proto.write_pkt_line(COMMAND_UNSHALLOW + b' ' + sha)

        self.proto.write_pkt_line(None)

    def notify_done(self):
        # relay the message down to the handler.
        self.handler.notify_done()

    def send_ack(self, sha, ack_type=b''):
        if ack_type:
            ack_type = b' ' + ack_type
        self.proto.write_pkt_line(b'ACK ' + sha + ack_type + b'\n')

    def send_nak(self):
        self.proto.write_pkt_line(b'NAK\n')

    def handle_done(self, done_required, done_received):
        # Delegate this to the implementation.
        return self._impl.handle_done(done_required, done_received)

    def set_wants(self, wants):
        self._wants = wants

    def all_wants_satisfied(self, haves):
        """Check whether all the current wants are satisfied by a set of haves.

        :param haves: A set of commits we know the client has.
        :note: Wants are specified with set_wants rather than passed in since
            in the current interface they are determined outside this class.
        """
        return _all_wants_satisfied(self.store, haves, self._wants)

    def set_ack_type(self, ack_type):
        impl_classes = {
          MULTI_ACK: MultiAckGraphWalkerImpl,
          MULTI_ACK_DETAILED: MultiAckDetailedGraphWalkerImpl,
          SINGLE_ACK: SingleAckGraphWalkerImpl,
          }
        self._impl = impl_classes[ack_type](self)


_GRAPH_WALKER_COMMANDS = (COMMAND_HAVE, COMMAND_DONE, None)


class SingleAckGraphWalkerImpl(object):
    """Graph walker implementation that speaks the single-ack protocol."""

    def __init__(self, walker):
        self.walker = walker
        self._common = []

    def ack(self, have_ref):
        if not self._common:
            self.walker.send_ack(have_ref)
            self._common.append(have_ref)

    def next(self):
        command, sha = self.walker.read_proto_line(_GRAPH_WALKER_COMMANDS)
        if command in (None, COMMAND_DONE):
            # defer the handling of done
            self.walker.notify_done()
            return None
        elif command == COMMAND_HAVE:
            return sha

    __next__ = next

    def handle_done(self, done_required, done_received):
        if not self._common:
            self.walker.send_nak()

        if done_required and not done_received:
            # we are not done, especially when done is required; skip
            # the pack for this request and especially do not handle
            # the done.
            return False

        if not done_received and not self._common:
            # Okay we are not actually done then since the walker picked
            # up no haves.  This is usually triggered when client attempts
            # to pull from a source that has no common base_commit.
            # See: test_server.MultiAckDetailedGraphWalkerImplTestCase.\
            #          test_multi_ack_stateless_nodone
            return False

        return True


class MultiAckGraphWalkerImpl(object):
    """Graph walker implementation that speaks the multi-ack protocol."""

    def __init__(self, walker):
        self.walker = walker
        self._found_base = False
        self._common = []

    def ack(self, have_ref):
        self._common.append(have_ref)
        if not self._found_base:
            self.walker.send_ack(have_ref, b'continue')
            if self.walker.all_wants_satisfied(self._common):
                self._found_base = True
        # else we blind ack within next

    def next(self):
        while True:
            command, sha = self.walker.read_proto_line(_GRAPH_WALKER_COMMANDS)
            if command is None:
                self.walker.send_nak()
                # in multi-ack mode, a flush-pkt indicates the client wants to
                # flush but more have lines are still coming
                continue
            elif command == COMMAND_DONE:
                self.walker.notify_done()
                return None
            elif command == COMMAND_HAVE:
                if self._found_base:
                    # blind ack
                    self.walker.send_ack(sha, b'continue')
                return sha

    __next__ = next

    def handle_done(self, done_required, done_received):
        if done_required and not done_received:
            # we are not done, especially when done is required; skip
            # the pack for this request and especially do not handle
            # the done.
            return False

        if not done_received and not self._common:
            # Okay we are not actually done then since the walker picked
            # up no haves.  This is usually triggered when client attempts
            # to pull from a source that has no common base_commit.
            # See: test_server.MultiAckDetailedGraphWalkerImplTestCase.\
            #          test_multi_ack_stateless_nodone
            return False

        # don't nak unless no common commits were found, even if not
        # everything is satisfied
        if self._common:
            self.walker.send_ack(self._common[-1])
        else:
            self.walker.send_nak()
        return True


class MultiAckDetailedGraphWalkerImpl(object):
    """Graph walker implementation speaking the multi-ack-detailed protocol."""

    def __init__(self, walker):
        self.walker = walker
        self._common = []

    def ack(self, have_ref):
        # Should only be called iff have_ref is common
        self._common.append(have_ref)
        self.walker.send_ack(have_ref, b'common')

    def next(self):
        while True:
            command, sha = self.walker.read_proto_line(_GRAPH_WALKER_COMMANDS)
            if command is None:
                if self.walker.all_wants_satisfied(self._common):
                    self.walker.send_ack(self._common[-1], b'ready')
                self.walker.send_nak()
                if self.walker.http_req:
                    # The HTTP version of this request a flush-pkt always
                    # signifies an end of request, so we also return
                    # nothing here as if we are done (but not really, as
                    # it depends on whether no-done capability was
                    # specified and that's handled in handle_done which
                    # may or may not call post_nodone_check depending on
                    # that).
                    return None
            elif command == COMMAND_DONE:
                # Let the walker know that we got a done.
                self.walker.notify_done()
                break
            elif command == COMMAND_HAVE:
                # return the sha and let the caller ACK it with the
                # above ack method.
                return sha
        # don't nak unless no common commits were found, even if not
        # everything is satisfied

    __next__ = next

    def handle_done(self, done_required, done_received):
        if done_required and not done_received:
            # we are not done, especially when done is required; skip
            # the pack for this request and especially do not handle
            # the done.
            return False

        if not done_received and not self._common:
            # Okay we are not actually done then since the walker picked
            # up no haves.  This is usually triggered when client attempts
            # to pull from a source that has no common base_commit.
            # See: test_server.MultiAckDetailedGraphWalkerImplTestCase.\
            #          test_multi_ack_stateless_nodone
            return False

        # don't nak unless no common commits were found, even if not
        # everything is satisfied
        if self._common:
            self.walker.send_ack(self._common[-1])
        else:
            self.walker.send_nak()
        return True

<<class ReceivePackHandler>>

class UploadArchiveHandler(Handler):

    def __init__(self, backend, proto, http_req=None):
        super(UploadArchiveHandler, self).__init__(backend, proto, http_req)

    def handle(self):
        # TODO(jelmer)
        raise NotImplementedError(self.handle)


<<constant DEFAULT_HANDLERS>>


<<class TCPGitRequestHandler>>

<<class TCPGitServer>>


def main(argv=sys.argv):
    """Entry point for starting a TCP git server."""
    import optparse
    parser = optparse.OptionParser()
    parser.add_option("-l", "--listen_address", dest="listen_address",
                      default="localhost",
                      help="Binding IP address.")
    parser.add_option("-p", "--port", dest="port", type=int,
                      default=TCP_GIT_PORT,
                      help="Binding TCP port.")
    options, args = parser.parse_args(argv)

    log_utils.default_logging_config()
    if len(args) > 1:
        gitdir = args[1]
    else:
        gitdir = '.'

    from dulwich import porcelain
    porcelain.daemon(gitdir, address=options.listen_address,
                     port=options.port)


def serve_command(handler_cls, argv=sys.argv, backend=None, inf=sys.stdin,
                  outf=sys.stdout):
    """Serve a single command.

    This is mostly useful for the implementation of commands used by e.g. git+ssh.

    :param handler_cls: `Handler` class to use for the request
    :param argv: execv-style command-line arguments. Defaults to sys.argv.
    :param backend: `Backend` to use
    :param inf: File-like object to read from, defaults to standard input.
    :param outf: File-like object to write to, defaults to standard output.
    :return: Exit code for use with sys.exit. 0 on success, 1 on failure.
    """
    if backend is None:
        backend = FileSystemBackend()
    def send_fn(data):
        outf.write(data)
        outf.flush()
    proto = Protocol(inf.read, send_fn)
    handler = handler_cls(backend, argv[1:], proto)
    # FIXME: Catch exceptions and write a single-line summary to outf.
    handler.handle()
    return 0


def generate_info_refs(repo):
    """Generate an info refs file."""
    refs = repo.get_refs()
    return write_info_refs(refs, repo.object_store)


def generate_objects_info_packs(repo):
    """Generate an index for for packs."""
    for pack in repo.object_store.packs:
        yield b'P ' + pack.data.filename.encode(sys.getfilesystemencoding()) + b'\n'


def update_server_info(repo):
    """Generate server info for dumb file access.

    This generates info/refs and objects/info/packs,
    similar to "git update-server-info".
    """
    repo._put_named_file(os.path.join('info', 'refs'),
        b"".join(generate_info_refs(repo)))

    repo._put_named_file(os.path.join('objects', 'info', 'packs'),
        b"".join(generate_objects_info_packs(repo)))


if __name__ == '__main__':
    main()
@

\subsection{[[walk.py]]}

<<[[Tree]] methods>>=
def lookup_path(self, lookup_obj, path):
    """Look up an object in a Git tree.

    :param lookup_obj: Callback for retrieving object by SHA1
    :param path: Path to lookup
    :return: A tuple of (mode, SHA) of the resulting path.
    """
    parts = path.split(b'/')
    sha = self.id
    mode = None
    for p in parts:
        if not p:
            continue
        obj = lookup_obj(sha)
        if not isinstance(obj, Tree):
            raise NotTreeError(sha)
        mode, sha = obj[p]
    return mode, sha
@
%dead?

%-------------------------------------------------------------------------

<<dulwich/walk.py>>=
# walk.py -- General implementation of walking commits and their contents.
# Copyright (C) 2010 Google, Inc.
#
<<dulwich license>>
"""General implementation of walking commits and their contents."""


from collections import defaultdict

import collections
import heapq
from itertools import chain

from dulwich.diff_tree import (
    RENAME_CHANGE_TYPES,
    tree_changes,
    tree_changes_for_merge,
    RenameDetector,
    )
from dulwich.errors import (
    MissingCommitError,
    )
from dulwich.objects import (
    Commit,
    Tag,
    )

<<type walk.ORDER>>

<<constant walk.ALL_ORDERS>>

<<constant walk._MAX_EXTRA_COMMITS>>

<<class WalkEntry>>

<<class _CommitTimeQueue>>

<<class Walker>>

<<function walk._topo_reorder>>
@

\subsection{[[web.py]]}

% Looks much simpler than server.py

<<dulwich/web.py>>=
# web.py -- WSGI smart-http server
# Copyright (C) 2010 Google, Inc.
# Copyright (C) 2012 Jelmer Vernooij <jelmer@samba.org>
#
<<dulwich license>>
"""HTTP server for dulwich that implements the git smart HTTP protocol."""

from io import BytesIO
import shutil
import tempfile
import gzip
import os
import re
import sys
import time
from wsgiref.simple_server import (
    WSGIRequestHandler,
    ServerHandler,
    WSGIServer,
    make_server,
    )

try:
    from urlparse import parse_qs
except ImportError:
    from urllib.parse import parse_qs


from dulwich import log_utils
from dulwich.protocol import (
    ReceivableProtocol,
    )
from dulwich.repo import (
    Repo,
    )
from dulwich.server import (
    DictBackend,
    DEFAULT_HANDLERS,
    generate_info_refs,
    generate_objects_info_packs,
    )


logger = log_utils.getLogger(__name__)


# HTTP error strings
HTTP_OK = '200 OK'
HTTP_NOT_FOUND = '404 Not Found'
HTTP_FORBIDDEN = '403 Forbidden'
HTTP_ERROR = '500 Internal Server Error'


def date_time_string(timestamp=None):
    # From BaseHTTPRequestHandler.date_time_string in BaseHTTPServer.py in the
    # Python 2.6.5 standard library, following modifications:
    #  - Made a global rather than an instance method.
    #  - weekdayname and monthname are renamed and locals rather than class
    #    variables.
    # Copyright (c) 2001-2010 Python Software Foundation; All Rights Reserved
    weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    months = [None,
              'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
              'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    if timestamp is None:
        timestamp = time.time()
    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(timestamp)
    return '%s, %02d %3s %4d %02d:%02d:%02d GMD' % (
            weekdays[wd], day, months[month], year, hh, mm, ss)


def url_prefix(mat):
    """Extract the URL prefix from a regex match.

    :param mat: A regex match object.
    :returns: The URL prefix, defined as the text before the match in the
        original string. Normalized to start with one leading slash and end
        with zero.
    """
    return '/' + mat.string[:mat.start()].strip('/')


def get_repo(backend, mat):
    """Get a Repo instance for the given backend and URL regex match."""
    return backend.open_repository(url_prefix(mat))


def send_file(req, f, content_type):
    """Send a file-like object to the request output.

    :param req: The HTTPGitRequest object to send output to.
    :param f: An open file-like object to send; will be closed.
    :param content_type: The MIME type for the file.
    :return: Iterator over the contents of the file, as chunks.
    """
    if f is None:
        yield req.not_found('File not found')
        return
    try:
        req.respond(HTTP_OK, content_type)
        while True:
            data = f.read(10240)
            if not data:
                break
            yield data
        f.close()
    except IOError:
        f.close()
        yield req.error('Error reading file')
    except:
        f.close()
        raise


def _url_to_path(url):
    return url.replace('/', os.path.sep)


def get_text_file(req, backend, mat):
    req.nocache()
    path = _url_to_path(mat.group())
    logger.info('Sending plain text file %s', path)
    return send_file(req, get_repo(backend, mat).get_named_file(path),
                     'text/plain')


def get_loose_object(req, backend, mat):
    sha = (mat.group(1) + mat.group(2)).encode('ascii')
    logger.info('Sending loose object %s', sha)
    object_store = get_repo(backend, mat).object_store
    if not object_store.contains_loose(sha):
        yield req.not_found('Object not found')
        return
    try:
        data = object_store[sha].as_legacy_object()
    except IOError:
        yield req.error('Error reading object')
        return
    req.cache_forever()
    req.respond(HTTP_OK, 'application/x-git-loose-object')
    yield data


def get_pack_file(req, backend, mat):
    req.cache_forever()
    path = _url_to_path(mat.group())
    logger.info('Sending pack file %s', path)
    return send_file(req, get_repo(backend, mat).get_named_file(path),
                     'application/x-git-packed-objects')


def get_idx_file(req, backend, mat):
    req.cache_forever()
    path = _url_to_path(mat.group())
    logger.info('Sending pack file %s', path)
    return send_file(req, get_repo(backend, mat).get_named_file(path),
                     'application/x-git-packed-objects-toc')


def get_info_refs(req, backend, mat):
    params = parse_qs(req.environ['QUERY_STRING'])
    service = params.get('service', [None])[0]
    if service and not req.dumb:
        handler_cls = req.handlers.get(service.encode('ascii'), None)
        if handler_cls is None:
            yield req.forbidden('Unsupported service')
            return
        req.nocache()
        write = req.respond(
            HTTP_OK, 'application/x-%s-advertisement' % service)
        proto = ReceivableProtocol(BytesIO().read, write)
        handler = handler_cls(backend, [url_prefix(mat)], proto,
                              http_req=req, advertise_refs=True)
        handler.proto.write_pkt_line(
            b'# service=' + service.encode('ascii') + b'\n')
        handler.proto.write_pkt_line(None)
        handler.handle()
    else:
        # non-smart fallback
        # TODO: select_getanyfile() (see http-backend.c)
        req.nocache()
        req.respond(HTTP_OK, 'text/plain')
        logger.info('Emulating dumb info/refs')
        repo = get_repo(backend, mat)
        for text in generate_info_refs(repo):
            yield text


def get_info_packs(req, backend, mat):
    req.nocache()
    req.respond(HTTP_OK, 'text/plain')
    logger.info('Emulating dumb info/packs')
    return generate_objects_info_packs(get_repo(backend, mat))


class _LengthLimitedFile(object):
    """Wrapper class to limit the length of reads from a file-like object.

    This is used to ensure EOF is read from the wsgi.input object once
    Content-Length bytes are read. This behavior is required by the WSGI spec
    but not implemented in wsgiref as of 2.5.
    """

    def __init__(self, input, max_bytes):
        self._input = input
        self._bytes_avail = max_bytes

    def read(self, size=-1):
        if self._bytes_avail <= 0:
            return b''
        if size == -1 or size > self._bytes_avail:
            size = self._bytes_avail
        self._bytes_avail -= size
        return self._input.read(size)

    # TODO: support more methods as necessary


def handle_service_request(req, backend, mat):
    service = mat.group().lstrip('/')
    logger.info('Handling service request for %s', service)
    handler_cls = req.handlers.get(service.encode('ascii'), None)
    if handler_cls is None:
        yield req.forbidden('Unsupported service')
        return
    req.nocache()
    write = req.respond(HTTP_OK, 'application/x-%s-result' % service)
    proto = ReceivableProtocol(req.environ['wsgi.input'].read, write)
    handler = handler_cls(backend, [url_prefix(mat)], proto, http_req=req)
    handler.handle()


class HTTPGitRequest(object):
    """Class encapsulating the state of a single git HTTP request.

    :ivar environ: the WSGI environment for the request.
    """

    def __init__(self, environ, start_response, dumb=False, handlers=None):
        self.environ = environ
        self.dumb = dumb
        self.handlers = handlers
        self._start_response = start_response
        self._cache_headers = []
        self._headers = []

    def add_header(self, name, value):
        """Add a header to the response."""
        self._headers.append((name, value))

    def respond(self, status=HTTP_OK, content_type=None, headers=None):
        """Begin a response with the given status and other headers."""
        if headers:
            self._headers.extend(headers)
        if content_type:
            self._headers.append(('Content-Type', content_type))
        self._headers.extend(self._cache_headers)

        return self._start_response(status, self._headers)

    def not_found(self, message):
        """Begin a HTTP 404 response and return the text of a message."""
        self._cache_headers = []
        logger.info('Not found: %s', message)
        self.respond(HTTP_NOT_FOUND, 'text/plain')
        return message.encode('ascii')

    def forbidden(self, message):
        """Begin a HTTP 403 response and return the text of a message."""
        self._cache_headers = []
        logger.info('Forbidden: %s', message)
        self.respond(HTTP_FORBIDDEN, 'text/plain')
        return message.encode('ascii')

    def error(self, message):
        """Begin a HTTP 500 response and return the text of a message."""
        self._cache_headers = []
        logger.error('Error: %s', message)
        self.respond(HTTP_ERROR, 'text/plain')
        return message.encode('ascii')

    def nocache(self):
        """Set the response to never be cached by the client."""
        self._cache_headers = [
          ('Expires', 'Fri, 01 Jan 1980 00:00:00 GMT'),
          ('Pragma', 'no-cache'),
          ('Cache-Control', 'no-cache, max-age=0, must-revalidate'),
          ]

    def cache_forever(self):
        """Set the response to be cached forever by the client."""
        now = time.time()
        self._cache_headers = [
          ('Date', date_time_string(now)),
          ('Expires', date_time_string(now + 31536000)),
          ('Cache-Control', 'public, max-age=31536000'),
          ]


class HTTPGitApplication(object):
    """Class encapsulating the state of a git WSGI application.

    :ivar backend: the Backend object backing this application
    """

    services = {
      ('GET', re.compile('/HEAD$')): get_text_file,
      ('GET', re.compile('/info/refs$')): get_info_refs,
      ('GET', re.compile('/objects/info/alternates$')): get_text_file,
      ('GET', re.compile('/objects/info/http-alternates$')): get_text_file,
      ('GET', re.compile('/objects/info/packs$')): get_info_packs,
      ('GET', re.compile('/objects/([0-9a-f]{2})/([0-9a-f]{38})$')): get_loose_object,
      ('GET', re.compile('/objects/pack/pack-([0-9a-f]{40})\\.pack$')): get_pack_file,
      ('GET', re.compile('/objects/pack/pack-([0-9a-f]{40})\\.idx$')): get_idx_file,

      ('POST', re.compile('/git-upload-pack$')): handle_service_request,
      ('POST', re.compile('/git-receive-pack$')): handle_service_request,
    }

    def __init__(self, backend, dumb=False, handlers=None, fallback_app=None):
        self.backend = backend
        self.dumb = dumb
        self.handlers = dict(DEFAULT_HANDLERS)
        self.fallback_app = fallback_app
        if handlers is not None:
            self.handlers.update(handlers)

    def __call__(self, environ, start_response):
        path = environ['PATH_INFO']
        method = environ['REQUEST_METHOD']
        req = HTTPGitRequest(environ, start_response, dumb=self.dumb,
                             handlers=self.handlers)
        # environ['QUERY_STRING'] has qs args
        handler = None
        for smethod, spath in self.services.keys():
            if smethod != method:
                continue
            mat = spath.search(path)
            if mat:
                handler = self.services[smethod, spath]
                break

        if handler is None:
            if self.fallback_app is not None:
                return self.fallback_app(environ, start_response)
            else:
                return [req.not_found('Sorry, that method is not supported')]

        return handler(req, self.backend, mat)


class GunzipFilter(object):
    """WSGI middleware that unzips gzip-encoded requests before
    passing on to the underlying application.
    """

    def __init__(self, application):
        self.app = application

    def __call__(self, environ, start_response):
        if environ.get('HTTP_CONTENT_ENCODING', '') == 'gzip':
            try:
                environ['wsgi.input'].tell()
                wsgi_input = environ['wsgi.input']
            except (AttributeError, IOError, NotImplementedError):
                # The gzip implementation in the standard library of Python 2.x
                # requires working '.seek()' and '.tell()' methods on the input
                # stream.  Read the data into a temporary file to work around
                # this limitation.
                wsgi_input = tempfile.SpooledTemporaryFile(16 * 1024 * 1024)
                shutil.copyfileobj(environ['wsgi.input'], wsgi_input)
                wsgi_input.seek(0)

            environ['wsgi.input'] = gzip.GzipFile(
                filename=None, fileobj=wsgi_input, mode='r')
            del environ['HTTP_CONTENT_ENCODING']
            if 'CONTENT_LENGTH' in environ:
                del environ['CONTENT_LENGTH']

        return self.app(environ, start_response)


class LimitedInputFilter(object):
    """WSGI middleware that limits the input length of a request to that
    specified in Content-Length.
    """

    def __init__(self, application):
        self.app = application

    def __call__(self, environ, start_response):
        # This is not necessary if this app is run from a conforming WSGI
        # server. Unfortunately, there's no way to tell that at this point.
        # TODO: git may used HTTP/1.1 chunked encoding instead of specifying
        # content-length
        content_length = environ.get('CONTENT_LENGTH', '')
        if content_length:
            environ['wsgi.input'] = _LengthLimitedFile(
                environ['wsgi.input'], int(content_length))
        return self.app(environ, start_response)


def make_wsgi_chain(*args, **kwargs):
    """Factory function to create an instance of HTTPGitApplication,
    correctly wrapped with needed middleware.
    """
    app = HTTPGitApplication(*args, **kwargs)
    wrapped_app = LimitedInputFilter(GunzipFilter(app))
    return wrapped_app


class ServerHandlerLogger(ServerHandler):
    """ServerHandler that uses dulwich's logger for logging exceptions."""

    def log_exception(self, exc_info):
        if sys.version_info < (2, 7):
            logger.exception('Exception happened during processing of request')
        else:
            logger.exception('Exception happened during processing of request',
                             exc_info=exc_info)

    def log_message(self, format, *args):
        logger.info(format, *args)

    def log_error(self, *args):
        logger.error(*args)


class WSGIRequestHandlerLogger(WSGIRequestHandler):
    """WSGIRequestHandler that uses dulwich's logger for logging exceptions."""

    def log_exception(self, exc_info):
        logger.exception('Exception happened during processing of request',
                         exc_info=exc_info)

    def log_message(self, format, *args):
        logger.info(format, *args)

    def log_error(self, *args):
        logger.error(*args)

    def handle(self):
        """Handle a single HTTP request"""

        self.raw_requestline = self.rfile.readline()
        if not self.parse_request():  # An error code has been sent, just exit
            return

        handler = ServerHandlerLogger(
            self.rfile, self.wfile, self.get_stderr(), self.get_environ()
        )
        handler.request_handler = self      # backpointer for logging
        handler.run(self.server.get_app())


class WSGIServerLogger(WSGIServer):

    def handle_error(self, request, client_address):
        """Handle an error. """
        logger.exception(
            'Exception happened during processing of request from %s' %
            str(client_address))


def main(argv=sys.argv):
    """Entry point for starting an HTTP git server."""
    import optparse
    parser = optparse.OptionParser()
    parser.add_option("-l", "--listen_address", dest="listen_address",
                      default="localhost",
                      help="Binding IP address.")
    parser.add_option("-p", "--port", dest="port", type=int,
                      default=8000,
                      help="Port to listen on.")
    options, args = parser.parse_args(argv)

    if len(args) > 1:
        gitdir = args[1]
    else:
        gitdir = os.getcwd()

    log_utils.default_logging_config()
    backend = DictBackend({'/': Repo(gitdir)})
    app = make_wsgi_chain(backend)
    server = make_server(options.listen_address, options.port, app,
                         handler_class=WSGIRequestHandlerLogger,
                         server_class=WSGIServerLogger)
    logger.info('Listening for HTTP connections on %s:%d',
                options.listen_address, options.port)
    server.serve_forever()


if __name__ == '__main__':
    main()
@
