\documentclass[12pt]{report}
%alt: [12pt, twocolumn, landscape]
%coupling: see Config.tex

\input{latex/Packages}
\input{latex/Config}
\input{latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - TODO removed cur_tok in lexerfunc, move it outside

%thx to codemap/codegraph/scheck:

%thx to this manual, I better understand sh:
% - how rc -e works for error strictness (and its interaction with mk)

%history LP-ization:
% - skeleton, mostly copy paste of Shell.nw skeleton
% - put all content of files in the Extra section, via 'lpizer'
%   which also now split in chunks!
%    * function, type, exception, constant, signature
% - read Extra section, identify concepts, first TOC (copy also Shell.nw)
% - distribute parts of the file before
% - aspecify advanced features!
% - TODO add figures
% - TODO add explanations

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Shell [[rc]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Tom Duff and Yoann Padioleau
}

\maketitle 
%\onecolumn
\hrule
%\input{latex/Copyright}
%\input{latex/CopyrightPlan9}
\begin{quote}
Copyright \copyright{} 2025 Yoann Padioleau \\
Permission is granted to copy, distribute and/or modify this document,
except all the source code it contains, under the terms of the GNU Free
Documentation License, Version 1.3.
\end{quote}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
\chapter{Introduction}
%******************************************************************************

#include "Intro.nw"

%\chapter{Overview}
% now in Intro.nw too

% essence of shell = fork, exec, wait + rediction and pipe (and fd adjust in fork
% before exec)
% show code for minimalist shell first? just Simple command (and maybe Pipe or redir)

\section{Code organization}

\section{Software architecture}

\section{Book structure}



%******************************************************************************
\chapter{Core Data Structures}
%******************************************************************************
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}


% follow mostly data flow order diagram of section X
% token -> AST -> opcodes -> runq

\section{Tokens}

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Word *)*/
/*(*-----------------------------------------*)*/
%token<string * bool(* quoted *)> TWord

/*(*-----------------------------------------*)*/
/*(*2 Operators *)*/
/*(*-----------------------------------------*)*/
%token TPipe
%token<Ast.redirection_kind> TRedir
%token TAndAnd TOrOr TBang
%token TTwiddle  
%token TSemicolon 
%token TAnd
<<Parser tokens, operators other cases>>

/*(*-----------------------------------------*)*/
/*(*2 Variables *)*/
/*(*-----------------------------------------*)*/
%token TEq
%token TDollar
<<Parser tokens, variables other cases>>

/*(*-----------------------------------------*)*/
/*(*2 Punctuation *)*/
/*(*-----------------------------------------*)*/
%token TOPar TCPar
%token TOBrace TCBrace
<<Parser tokens, punctuation other cases>>

/*(*-----------------------------------------*)*/
/*(*2 Keywords *)*/
/*(*-----------------------------------------*)*/
%token TIf TNot TWhile TSwitch TFor TIn TFn

/*(*-----------------------------------------*)*/
/*(*2 Misc *)*/
/*(*-----------------------------------------*)*/
%token TNewline

%token EOF
@

% classic, except TNewline, usually skipped in trad lang but
% here newline has special semantic and trigger special behavior
% like terminating a command and displaying a prompt in interactive mode


\section{Abstract syntax tree (AST)}

%trans: see TNewline, in fact in AST line concept! will see how
% can have multi line command later, especially for statements if/while/...

<<type [[Ast.line]]>>=
(* None when reads EOF *)
type line = cmd_sequence option
@
% parse_line() later

<<type [[Ast.cmd_sequence]]>>=
  and cmd_sequence = cmd list
@
% separated by ';'


<<type [[Ast.cmd]]>>=
and cmd =
  | EmptyCommand

  (* Base *)
  | Simple of value * values
  | Pipe of cmd * cmd (* less: lfd, rfd option *)
  | Async of cmd

  (* Redirections *)
  | Redir of cmd * redirection
  <<[[Ast.cmd]] other redirection cases>>

  (* expressions *)
  | And of cmd * cmd
  | Or of cmd * cmd
  | Not of cmd
  (* can also run the program 'test' for other comparisons ('[' in bash) *)
  | Match of value * values

  (* stmts *)
  | If of cmd_sequence * cmd
  (* Note that you can not put a 'cmd option' in If instead of IfNot below. 
   * rc has to process 'if(...) cmd\n' now! It can not wait for an else.
   *)
  | IfNot of cmd
  | While of cmd_sequence * cmd
  <<[[Ast.cmd]] other statement cases>>

  (* definitions *)
  (* can do x=a; but also $x=b ! 
   * less: could have AssignGlobal and AssignLocal of ... cmd
   *)
  | Assign of value * value * cmd (* can be EmptyCommand *)
  | Fn of value * cmd_sequence
  <<[[Ast.cmd]] other definition cases>>
@
% Assign because actually often do CFLAGS=xxx make

% Simple is important one.
% If Ifnot a bit weird but explained later.
% Fn has no params part but because via $* and $1, $2, ...


%trans: Simple of value * values =~ command call

<<type [[Ast.values]]>>=
(* separated by spaces *)
and values = value list
@


<<type [[Ast.value]]>>=
(* rc does not use types; there is no integer, no boolean, no float.
 * The only value in rc is the list of strings. Even a single
 * string is really a list with one element.
 *)
type value = 
  (* The string can contain the * ? [ special characters.
   * So, even a single word can expand to a list of strings.
   * less: they should be preceded by \001
   * less: W of word_elt list and word_elt = Star | Question | ...Str of string
   *)
  | Word of string * bool (* quoted *)
  | Dollar of value
  | List of values
  <<[[Ast.value]] other cases>>
@

<<type [[Ast.redirection]]>>=
  and redirection = redirection_kind * value (* the filename *)
@

<<type [[Ast.redirection_kind]]>>=
    and redirection_kind = 
      | RWrite (* > *)
      | RRead  (* < *)
      | RAppend (* > > *)
      <<[[Ast.redirection_kind]] other cases>>
@



%TODO: dump AST for ls /etc > /tmp/list.txt, and ref to -dump_ast in appendix



\section{Opcodes}

<<signature [[Compile.compile]]>>=
val compile : Ast.cmd_sequence -> Opcode.codevec
@

<<type [[Opcode.codevec]]>>=
type codevec = opcode array
@

<<type [[Opcode.opcode]]>>=
type opcode =
  | F of operation
  | I of int
  | S of string
@
% 'I' useful for Jump pc
% S will be Words mostly

% a bit like assembly, opcodes, operands, but very simple.
% why opcode? why not interpret AST instead?

% Stack machine, Word, Pop, use either inline or on Stack
<<type [[Opcode.operation]]>>=
(* Operations generated by the compiler. 
 * 
 * Semantic of comments below:
 *  - Arguments on stack (...)
 *  - Arguments in line [...]
 *  - Code in line with jump around {...}
 * 
 * alt: type operation = ((unit -> unit) * string)
 *)
type operation =

  (* Stack (argv) *)
  | Mark
  | Word (* [string] *)
  | Popm (* (value) *)
  <<[[Opcode.operation]] other stack cases>>

  (* Variable *)
  | Assign (* (name)(val) *)
  | Dollar (* (name) *)
  <<[[Opcode.operation]] other variable cases>>

  (* Process! *)
  | Simple (* (args) *)
  | Async  (* {... Xreturn} *)

  (* Control flow *)
  | If 
  | IfNot
  (* While are compiled in jumps *)
  | Jump  (* [addr] *)
  | Exit 
  <<[[Opcode.operation]] other control cases>>

  (* Boolean return status  *)
  | Wastrue
  | Not
  | False (* {...} *)
  | True  (* {...} *)
  | Match (* (pat, str) *)

  (* Redirections *)
  | Read (* (file)[fd] *)
  | Write (* (file)[fd] *)
  | Append (* (file)[fd] *)
  <<[[Opcode.operation]] other redirection cases>>

  (* Pipes *)
  | Pipe (* [i j]{... Xreturn}{... Xreturn} *)
  <<[[Opcode.operation]] other pipe cases>>

  (* Functions *)
  | Fn (* (name){... Xreturn } *)

  <<[[Opcode.operation]] other cases>>

  | REPL (* *)
@

% REPL! (was Xrdcmds?)
% Simple again

% will become clearer as we progress

%TODO: show example of opcode for ls /etc > /tmp/list.txt, via -dump ?? with ref to appendix?



\section{Words}
%alt: and lists of words
%alt: TODO: merge with next section?

% runtime value, what will be in the variables bindings
% Not like Ast.value!

<<type [[Runtime.value]]>>=
(* In rc the basic (and only) value is the list of strings.
 * A single word is considered as a list with one element.
 *)
type value = string list
@
% TODO? confusing to use value here with Ast.value?
% or done on purpose to relate?


\section{Variables}

<<type [[Runtime.varname]]>>=
(* can be anything: "foo", but also "*", "1", "2", etc *)
type varname = string
@
% $* $1 will be used (not like in mk where must be ident)

<<type [[Runtime.var]]>>=
type var = { 
  (* can be None when lookup for a value that was never set before,
   * which is different from Some [] (when do A=()), which is also
   * different from Some [""] (when do A='').
   *)
  mutable v: value option;
  (* less: opti: changed: bool *)
}
@
% remember value is string list!

<<signature [[Runtime.globals]]>>=
val globals : (varname, var) Hashtbl.t
@

<<global [[Runtime.globals]]>>=
let globals: (varname, var) Hashtbl.t = 
  Hashtbl.create 101
@

<<signature [[Var.gvlook]]>>=
(* This will only look for globals (in Runtime.globals) *)
val gvlook : Runtime.varname -> Runtime.var
@

<<function [[Var.gvlook]]>>=
let gvlook (name : R.varname) : R.var =
  try 
    Hashtbl.find R.globals name
  with Not_found ->
    let var = { R.v = None } in
    Hashtbl.add R.globals name var;
    var
@





<<signature [[Var.vinit]]>>=
(* Populate Runtime.globals from the current environment *)
val vinit : < Cap.env ; .. > -> unit
@

%alt: move later? maybe ok here
<<function [[Var.vinit]]>>=
let vinit (_caps : < Cap.env; .. >) =
  Logs.err (fun m -> m "TODO: load from environment")
@



\section{Functions}

<<signature [[Runtime.fns]]>>=
val fns : (string, fn) Hashtbl.t
@
<<global [[Runtime.fns]]>>=
let fns: (string, fn) Hashtbl.t = 
  Hashtbl.create 101
@

<<type [[Runtime.fn]]>>=
type fn = {
  code: Opcode.codevec;
  pc: int;
  (* less: fnchanged *)
}
@
% why pc? can't simply start at 0 by convention?



\section{Threads and run queue}

<<type [[Runtime.thread]]>>=
type thread = {
  code: Opcode.codevec;
  pc: int ref;

  mutable argv: string list;
  locals: (varname, var) Hashtbl.t;

  <<[[Runtime.thread]] other fields>>
}
@
% pc = program counter (a classic in assembly)
% argv =~ sp = stack (also classic in assembly)
% called argv cos ultimately what will be passed to simple commands
%  executed

%less: use Stack.t for argv?

% called "thread" because kinda like thread? But in practice
% will trigger fork/exec of separate process but the
% parent will juggle with those threads structures (Tied possibly
% to external process)


<<signature [[Runtime.runq]]>>=
val runq : thread list ref
@
% when will handle pipe command, will execute in parallel 2 process
% that will be attached to a thread data-structure to synchronize

<<constant [[Runtime.runq]]>>=
(* less: could have also  'let cur = { code = boostrap; pc = 1; chan = stdin }'
 * in addition to runq. Then there will be no need for cur ().
 *)
let runq = ref []
@

<<signature [[Runtime.cur]]>>=
val cur : unit -> thread
@
<<function [[Runtime.cur]]>>=
let cur () =
  match !runq with
  | [] -> failwith "empty runq"
  | x::_xs -> x
@



<<signature [[Runtime.mk_thread]]>>=
val mk_thread :
  Opcode.codevec -> int -> (varname, var) Hashtbl.t -> thread
@

<<function [[Runtime.mk_thread]]>>=
(* This function was called start(), but it does not really start right
 * away the new thread. So better to call it mk_thread.
 * It starts with pc <> 0 when handle async, traps, pipes, etc.
 *)
let mk_thread code pc locals =
  let t = {
    code = code;
    pc = ref pc;
    argv = [];
    locals = locals;

    <<[[Runtime.mk_thread()]] set other fields>>
  } in
  t
@


%TODO? dump a thread for simple command?


\subsection{The stack}

% argv

<<signature [[Runtime.push_word]]>>=
val push_word : string -> unit
@
<<function [[Runtime.push_word]]>>=
let push_word s =
  let t = cur () in
  t.argv <- s::t.argv
@


<<signature [[Runtime.pop_word]]>>=
val pop_word : unit -> unit
@
<<function [[Runtime.pop_word]]>>=
let pop_word () =
  let t = cur () in
  match t.argv with
  | [] -> failwith "pop_word but no word!"
  | _x::xs ->
      t.argv <- xs
@



\subsection{Local variables}


<<signature [[Var.vlook]]>>=
(* This will look first in the locals (in Runtime.cur().locals) and then
 * in globals (in Runtime.globals)
 *)
val vlook : Runtime.varname -> Runtime.var
@

<<function [[Var.vlook]]>>=
let vlook name =
  if !Runtime.runq <> []
  then 
    let t = Runtime.cur () in
    try 
      Hashtbl.find t.R.locals name
    with Not_found ->
      gvlook name
  else gvlook name
@

<<signature [[Var.setvar]]>>=
(* Override the content of a (local or global) variable *)
val setvar : Runtime.varname -> Runtime.value -> unit
@

<<function [[Var.setvar]]>>=
let setvar (name : Runtime.varname) (v : Runtime.value) : unit =
  let var = vlook name in
  var.R.v <- Some v
@



\subsection{Redirections}
%alt: move later? easier to explain later?

<<[[Runtime.thread]] other fields>>=
(* things to do before exec'ing the simple command *)
mutable redirections: (redir list) list;
@
%TODO: list list?? (redir list) stack ?

<<type [[Runtime.redir]]>>=
  and redir =
    (* the file descriptor From becomes To, e.g., /tmp/foo becomes stdout,
     * which means your process output will now go in /tmp/foo.
     *)
    | FromTo of Unix.file_descr (* from *) * Unix.file_descr (* to *)
    | Close of Unix.file_descr
@
%TODO: ???

<<[[Runtime.mk_thread()]] set other fields>>=
redirections = 
  (match !runq with
  | t::_ts -> []::t.redirections
  | [] -> []::[]
  );
@
%TODO: ???

\subsection{Wait status}

<<[[Runtime.thread]] other fields>>=
(* things to wait for after a thread forked a process *)
mutable waitstatus: waitstatus;
@
% threads are attached to external process and pid we need
% to wait for

<<type [[Runtime.waitstatus]]>>=
  and waitstatus =
    | NothingToWaitfor
    (* process pid to wait for in Xpipewait (set from Xpipe) *)
    | WaitFor of int 
    (* exit status from child process returned from a wait() *)
    | ChildStatus of string
@


<<[[Runtime.mk_thread()]] set other fields>>=
waitstatus = NothingToWaitfor;
@


%******************************************************************************
\chapter{[[main()]]}
%******************************************************************************


\section{Overview}

<<type [[CLI.caps]]>>=
(* Need:
 *  - fork/exec: obviously as we are a shell
 *  - chdir: for the builtin 'cd'
 *  - env: to ??
 *  - exit: as many commands can abruptely exit 'rc' itself or children
 *    created by 'rc'
 *  - open_in: ??
 *
 * alt: could remove Cap.exit and use Exit.ExitCode exn in Process.ml instead
*)
type caps = < Cap.fork; Cap.exec; Cap.chdir; Cap.env; Cap.exit; Cap.open_in >
@

<<signature [[CLI.main]]>>=
(* entry point (can also raise Exit.ExitCode) *)
val main: <caps; ..> -> string array -> Exit.t
@

<<toplevel [[Main._1]]>>=
let _ =
  Cap.main (fun (caps : Cap.all_caps) ->
     let argv = CapSys.argv caps in
     Exit.exit caps 
        (Exit.catch (fun () -> 
            CLI.main caps argv))
   )
@



%TODO: ex of use of rc, rc, rc -I, rc ls /foo?


<<function [[CLI.main]]>>=
let main (caps : <caps; .. >) (argv : string array) : Exit.t =
  let args = ref [] in
  <<[[CLI.main()]] debugging initializations>>

  let options = [
    <<[[CLI.main()]] [[options]] elements>>
  ]
  in
  (* old: was Arg.parse but we want explicit argv control *)
  (try 
    Arg.parse_argv argv (Arg.align options) (fun t -> args := t::!args) usage;
  with
  | Arg.Bad msg -> UConsole.eprint msg; raise (Exit.ExitCode 2)
  | Arg.Help msg -> UConsole.print msg; raise (Exit.ExitCode 0)
  );
  <<[[CLI.main()]] logging initializations>>
  <<[[CLI.main()]] CLI action processing>>
  Var.vinit caps;
  (* todo: trap_init () *)
  <<[[CLI.main()]] other initializations>>
  try 
    interpret_bootstrap (caps :> < caps >) (List.rev !args);
    Exit.OK
  with exn ->
    <<[[CLI.main()]] when [[exn]] thrown in [[interpret()]]>>
@
%$

%meta: argv :) hence argv in thread, cos rc itself is a CLI command

<<[[CLI.main()]] when [[Failure]] [[exn]] thrown in [[interpret()]]>>=
| Failure s -> 
    (* useful to indicate that error comes from rc, not subprocess *)
    Logs.err (fun m -> m  "rc: %s" s);
    Exit.Code 1
@


<<signature [[CLI.interpret_bootstrap]]>>=
val interpret_bootstrap : < caps > -> string list -> unit
@


\section{Command-line arguments processing}
%ocaml: section not that needed

<<constant [[CLI.usage]]>>=
let usage =
  "usage: rc [-SsriIlxevV] [-c arg] [-m command] [file [arg ...]]"
@

% will show gradually

\subsection{Interactive mode: [[rc -i]]}
% and prompt part1

<<constant [[Flags.interactive]]>>=
(* -i (on by default when detects that stdin is /dev/cons *)
let interactive = ref false
@

<<[[CLI.main()]] other initializations>>=
(* todo: 
 * if argc=1 and Isatty then Flags.interactive := true 
 *)
@

<<[[CLI.main()]] [[options]] elements>>=
"-i", Arg.Set Flags.interactive,
" interactive mode (display prompt)";
"-I", Arg.Clear Flags.interactive,
" non-interactive mode (no prompt)";
@

% prompt display when interactive!

% and error management different when interactive
% lots of little things different when interactive.

<<[[Runtime.thread]] other fields>>=
(* to display a prompt or not *)
mutable iflag: bool;
@
<<[[Runtime.mk_thread()]] set other fields>>=
iflag = false;
@

%TODO: why per thread? why not use globals everywhere?


\subsection{Login mode: [[rc -l]]}

<<constant [[Flags.login]]>>=
(* -l (on by default if argv0 starts with a -) *)
let login = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-l", Arg.Set Flags.login,
" login mode (execute ~/lib/profile)";
@

%TODO? implemented?

%trans: many more flags, shown gradually, especially Chapter X
% advanced features and Y for debugging


%\section{Initialization}
%Var.vinit before
% trapinit?

%\section{Setting [[runq]]}
%\section{Setting [[runq->argv]]}

\section{Bytecode interpreter loop}


<<function [[CLI.interpret_bootstrap]]>>=
let interpret_bootstrap (caps : < caps >) (args : string list) : unit =
  let t = R.mk_thread (bootstrap ()) 0 (Hashtbl.create 11) in
  R.runq := t::!R.runq;

  <<[[CLI.interpret_bootstrap()]] other initializations for [[t]]>>

  while true do
    (* bugfix: need to fetch the current thread each time,
     * as the interpreted code may have modified runq.
     *)
    let t = Runtime.cur () in
    let pc = t.R.pc in
    <<[[CLI.interpret()]] if [[rflag]]>>
    incr pc;
    (match t.R.code.(!pc - 1) with
    (* opcode dispatch ! *)
    | O.F operation ->  Interpreter.interpret_operation caps operation
    | O.S s -> failwith (spf "was expecting a F, not a S: %s" s)
    | O.I i -> failwith (spf "was expecting a F, not a I: %d" i)
    );
    (* todo: handle trap *)
  done
[@@profiling]
@

% will see real one bootstrap() later, but for now
% essentially this one below

<<constant [[CLI._bootstrap_simple]]>>=
let _bootstrap_simple : O.opcode array = 
  [| O.F O.REPL |]
@


% incr pc, so need pc -1 after, and in interpret_operation assume
% pc will be one after and no need to incr, already done, unless
% need extra adjustments


<<signature [[Interpreter.interpret_operation]]>>=
(* Interpret one operation. Called from a loop in main(). *)
val interpret_operation :
  < Cap.fork ; Cap.exec ; Cap.chdir ; Cap.exit ; Cap.open_in; .. > ->
  Opcode.operation ->
  unit
@


<<function [[Interpreter.interpret_operation]]>>=
let interpret_operation (caps: < Cap.fork; Cap.exec; Cap.chdir; Cap.exit; .. >) op : unit =
  match op with
  <<[[Interpreter.interpret_operation()]] match [[operation]] cases>>
  | (O.Concatenate|O.Stringify    |O.Index|
     O.Unlocal|
     O.Fn|
     O.For|
     O.Read|O.Append |O.ReadWrite|
     O.Close|O.Dup|O.PipeFd|
     O.Subshell|O.Backquote|O.Async
    ) ->
    failwith ("TODO: " ^ Dumper_.s_of_opcode (O.F op))
@
%$

%LP: later, when implemented
<<[[Opcode.operation]] other redirection cases>>=
| ReadWrite (* (file)[fd] *)
| Close  (* [fd] *)
| Dup    (* [fd0 fd1] *)
| Popredir (* *)
@
<<[[Opcode.operation]] other pipe cases>>=
| PipeFd (* [type]{... Xreturn} *)
@



<<[[CLI.interpret_bootstrap()]] other initializations for [[t]]>>=
(* less: set argv0 *)
args |> List.rev |> List.iter Runtime.push_word;
@
% in practice empty? rc itself takes arguments?? yes! [file [arg ...]]
% see usage
% but for REPL, empty


<<[[CLI.interpret_bootstrap()]] other initializations for [[t]]>>=
t.R.lexbuf <- Lexing.from_channel stdin;
@

<<[[Runtime.thread]] other fields>>=
(* connected on stdin by default (changed when do '. file') *)
mutable lexbuf: Lexing.lexbuf;
@
% but why need lexbuf? not already compiled and code stored in thread.code?
% yes but this code can be '.' which requires to read more commands
% and evaluate them from a source '. env.sh'
<<[[Runtime.mk_thread()]] set other fields>>=
lexbuf = Lexing.from_function (fun _ _ -> failwith "unconnected lexbuf");
@



<<[[CLI.interpret_bootstrap()]] other initializations for [[t]]>>=
t.R.iflag <- !Flags.interactive;
@
% first thread (the REPL) is interactive if shell was set to be interactive
% some will not?

\section{Reading commands: [[O.REPL]]}
%c: was Xrdcmds()

% see bootstrap_simple, and interpreter loop, so here we go
% interpret_operation first case. Will gradually show in chapter X
% but important understand this one also for lexing/parsing chapter

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* *)
| O.REPL -> Op_repl.op_REPL caps ()
@

<<function [[Op_repl.op_REPL]]>>=
(* was called Xrdcmds *)
let op_REPL (caps : < Cap.exit; ..>) () =
  let t = R.cur () in

  <<[[Op_repl.op_REPL()]] if [[sflag]]>>
  <<[[Op_repl.op_REPL()]] set [[prompt]] if [[iflag]]>>
  (* less: call Noerror before yyparse *)

  let lexbuf = t.R.lexbuf in
  try 
    let cmdseq_opt = Parse.parse_line lexbuf in
    match cmdseq_opt with
    | Some seq ->
        (* should contain an op_return *)
        let codevec = Compile.compile seq in

        let newt = R.mk_thread codevec 0 t.R.locals in
        R.runq := newt::!(R.runq);

        decr t.R.pc;
        (* when codevec does a op_return(), then interpreter loop
         * in main should call us back since the pc was decremented above
         *)
    <<[[Op_repl.op_REPL()]] match [[cmdset_opt]] other cases>>

  with Failure s -> 
    <<[[Op_repl.op_REPL()]] when [[Failure s]] thrown>>
@

% lexbuf, parse_line, compile, runq
% and this is a hidden loop because of the decr t.R.pc!

<<signature [[Parse.parse_line]]>>=
val parse_line : Lexing.lexbuf -> Ast.line
@

% and compile seen before, so overview of next chapter right here!



<<[[Op_repl.op_REPL()]] when [[Failure s]] thrown>>=
(* todo: check signals  *)
(* less: was doing Xreturn originally *)
if t.R.iflag
then begin
  Logs.err (fun m -> m "%s" s);
  (* go back for next command *)
  decr t.R.pc;
end
else failwith s
@




%\chapter{Input}
%\section{Overview}
%\section{Reading a character: [[getnext()]]}
%\subsection{End-of-file management}
%\subsection{Multiple lines commands and escaped newlines}
%\section{Looking ahead: [[nextc()]] and [[advance()]]}
%\subsection{Displaying the prompt}


%******************************************************************************
\chapter{Lexing}
%******************************************************************************

% Seen tokens before in core DS.

% seen mentioned parse_line in REPL

% parse_line() will call Lexer.token() via lexfunc below

\section{[[lexfunc()]] skeleton}

<<[[Parse.parse_line()]] nested function [[lexfunc]]>>=
let lexfunc lexbuf =
  <<[[Parse.lexfunc()]] possibly print the prompt>>
  let tok = ref (Lexer.token lexbuf) in
  <<[[Parse.lexfunc()]] adjustment for skipnl depending on [[tok]] read>>
  <<[[Parse.lexfunc()]] adjust [[curtok]] with [[tok]]>>
  (* todo: 
     - handle lastdol 
     - handle SUB
     - handle free caret insertion
  *)
  !tok 
  <<[[Parse.lexfunc()]] possibly dump tokens>>
in
@

<<signature [[Lexer.token]]>>=
val token: Lexing.lexbuf -> Parser.token
@

%\section{Error reporting}
<<exception [[Lexer.Lexical_error]]>>=
exception Lexical_error of string
@
<<function [[Lexer.error]]>>=
let error s =
  raise (Lexical_error s)
@


\section{[[token()]] skeleton}


<<Lexer.mll>>=
{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Parser

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Limitations compared to rc:
 *  - no unicode support
*)
<<exception [[Lexer.Lexical_error]]>>
<<function [[Lexer.error]]>>
<<function [[Lexer.incr_lineno]]>>
}
(*****************************************************************************)
(* Regexps aliases *)
(*****************************************************************************)
<<lexer regexp aliases>>

(*****************************************************************************)
(* Main rule *)
(*****************************************************************************)
<<rule [[Lexer.token]]>>

(*****************************************************************************)
(* Quote rule *)
(*****************************************************************************)
<<rule [[Lexer.quote]]>>
@



<<rule [[Lexer.token]]>>=
rule token = parse

  (* ----------------------------------------------------------------------- *)
  (* Spacing/comments *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] space cases>>
  <<[[Lexer.token()]] comment cases>>

  (* ----------------------------------------------------------------------- *)
  (* Symbols *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] symbol cases>>

  (* ----------------------------------------------------------------------- *)
  (* Variables *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] variable cases>>

  (* ----------------------------------------------------------------------- *)
  (* Quoted word *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] quoted word cases>>

  (* ----------------------------------------------------------------------- *)
  (* Keywords and unquoted words *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] keywords and unquoted words cases>>

  (* ----------------------------------------------------------------------- *)
  | eof { EOF }
  | _ (*as c*)   { error (spf "unrecognized character: '%s'" (Lexing.lexeme lexbuf)) }
@




<<lexer regexp aliases>>=
(* less: not used yet, special regexp used with lastdol *)
let idchr = ['a'-'z''A'-'Z''0'-'9''_''*']
@




%\section{[[yylex()]]}

\section{Spaces and comments ([['#']])}

<<[[Lexer.token()]] space cases>>=
| [' ''\t']+ { token lexbuf }
@

<<[[Lexer.token()]] comment cases>>=
| '#' [^'\n']* { token lexbuf }
@


\section{Newlines and prompts}
\label{sec:newlines-and-prompts}

<<[[Lexer.token()]] space cases>>=
| '\n'       { incr_lineno(); Prompt.doprompt := true; TNewline }
@
% TNewline will be important in grammar to terminate a command
% and parse_line() will return triggering compilation and execution
% of new thread.

% incr_lineno later

<<signature [[Prompt.doprompt]]>>=
val doprompt : bool ref
@
<<constant [[Prompt.doprompt]]>>=
(* Set to true so the prompt is displayed before the first character is read.
 *
 * Do we need that global? Can we not just call pprompt() explicitely?
 * No because when we get a newline, we know we should display the prompt,
 * but not before finishing executing the command. So the display
 * prompt should be done before the next round of input.
 * less: actually we could do it in the caller of parse_line, in the REPL.
 *)
let doprompt = ref true
@


<<[[Parse.lexfunc()]] possibly print the prompt>>=
(* less: could do that in caller? would remove need for doprompt *)
if !Prompt.doprompt
then Prompt.pprompt ();
@

<<signature [[Prompt.prompt]]>>=
val prompt : string ref
@
<<constant [[Prompt.prompt]]>>=
let prompt = ref "% "
@

% print prompt
<<signature [[Prompt.pprompt]]>>=
(* !will reset doprompt! *)
val pprompt : unit -> unit
@
<<function [[Prompt.pprompt]]>>=
let pprompt () =
  let t = R.cur () in
  if t.R.iflag then begin
    prerr_string !prompt;
    flush stderr;
    <<[[Prompt.pprompt()]] adjust [[prompt]] for next time>>
  end;
  (* alt: incr t.R.line; this is done in the lexer instead *)
  doprompt := false
@


<<[[Op_repl.op_REPL()]] set [[prompt]] if [[iflag]]>>=
(* set prompstr *)
if t.R.iflag then begin
  let promptv = (Var.vlook "prompt").R.v in
  Prompt.prompt := 
    (match promptv with
    | Some (x::_xs) -> x
    (* stricter? display error message if prompt set but no element?*)
    | Some [] | None -> "% "
    );
end;
@

% prompt has 2 parts? when regular and when follow antislash newline?
% this time the first part of the prompt

<<[[Lexer.token()]] space cases>>=
| '\\''\n'  {
    incr_lineno ();
    Prompt.pprompt ();
    token lexbuf
}    
@

<<[[Prompt.pprompt()]] adjust [[prompt]] for next time>>=
(* set promptstr for the next pprompt() *)
let promptv = (Var.vlook "prompt").R.v in
prompt := 
  (match promptv with
  | Some [_x;y] -> y
   (* stricter? display error message if prompt set no 2 elements?*)
  | Some _ | None -> "\t"
  );
@




\section{Operators ([[';']], [['&']], [['|']], [['<']], [['>']], [['$']], [['&&']], [['||']], \ldots)}
%alt: Symbols?

<<[[Lexer.token()]] symbol cases>>=
| ';'  { TSemicolon }
@
<<[[Lexer.token()]] symbol cases>>=
| "&"  { TAnd }
@

<<[[Lexer.token()]] symbol cases>>=
| ">"  { TRedir Ast.RWrite }
| "<"  { TRedir Ast.RRead }
| ">>" { TRedir Ast.RAppend }
@


<<[[Lexer.token()]] variable cases>>=
| "$"   { TDollar }
@

<<[[Lexer.token()]] symbol cases>>=
| '('  { TOPar }   | ')' { TCPar }
| '{'  { TOBrace } | '}' { TCBrace }
@
<<[[Lexer.token()]] symbol cases>>=
| '='  { TEq }
@


<<[[Lexer.token()]] symbol cases>>=
| "|"  { Globals.skipnl := true; TPipe }
@


\label{sec:skipnl}
<<constant [[Globals.skipnl]]>>=
(* This global is used by the lexer and parser to consider certain
 * newlines as regular spaces. Because rc is an interactive
 * interpreter, newline has a special meaning: it terminates a command.
 * However, sometimes we just want to add a newline because the command
 * is too long. Escaping the newline is one way to do it. 
 * But when we start to parse 'cmd1 &&' we know that we are expecting
 * more stuff. So after the && and other binary operators  we consider 
 * the newline not as a command terminator, but as a space.
 * Also we indent the prompt to let the user know he can still enter
 * more characters.
 *)
let skipnl = ref false
@

% reset
<<[[Parse.parse_line()]] locals and inits>>=
Globals.skipnl := false;
@
<<[[Parse.parse_line()]] locals and inits>>=
let got_skipnl_last_round = ref false in
@

<<[[Parse.lexfunc()]] adjustment for skipnl depending on [[tok]] read>>=
if !got_skipnl_last_round then begin
  if !tok = Parser.TNewline 
  then begin
    let rec loop () =
      Prompt.pprompt ();
      tok := Lexer.token lexbuf;
      if !tok = Parser.TNewline
      then loop ()
    in
    loop ()
  end;
  got_skipnl_last_round := false;
end;
if !Globals.skipnl 
then got_skipnl_last_round := true;
Globals.skipnl := false;
@
% subtle, first round when just got |, then got_skipnl_last_round
% is false so big code not executed but then skipnl reseted
% and got_skipnl is set to true
% next time for next token, then big code will be executed, and
% if token was newline then we actually don't return it
% and call tokenized until we have something different.


<<[[Lexer.token()]] symbol cases>>=
| "&&" { Globals.skipnl := true; TAndAnd }
| "||" { Globals.skipnl := true; TOrOr }
@

<<[[Lexer.token()]] symbol cases>>=
| "!" { TBang }
@

<<[[Lexer.token()]] symbol cases>>=
| "~" { TTwiddle } 
@




\section{Quoted strings ([['...']])}

<<[[Lexer.token()]] quoted word cases>>=
| "'" { let s = quote lexbuf in TWord (s, true) }
@
% note that s will contain the string inside the quote, without
% enclosing quote! but allow to use special chars inside
% the quote at least, including newline, including quote itself by using it 2 times,
% a bit like %% in printf

% no double quote in rc, just single quote.
%TODO: double quote meaning? dump its AST/tokens for x="a b c d" vs 'a b c d' ??

<<rule [[Lexer.quote]]>>=
and quote = parse
  | "'" { "" } 
  | "''" { "'" ^ quote lexbuf } 
  | "\n" { 
      incr_lineno ();
      Prompt.pprompt ();
      "\n" ^ quote lexbuf
    }
  | [^'\'' '\n']+ { let s = Lexing.lexeme lexbuf in s ^ quote lexbuf }
  (* stricter: generate error *)
  | eof { error "unterminated quote" }
@

\section{Keywords and words ([[if]], [[for]], [[while]], [[switch]], [[fn]], \ldots )}

<<lexer regexp aliases>>=
(* original: !strchr("\n \t#;&|^$=`'{}()<>", c) && c!=EOF;
 * note that wordchr allows '~', '!', '@', '"', ','
 *)
let wordchr = [^'\n' ' ' '\t' '#'
                ';' '&' '|' '^' '$' '=' 
                '`' '\'' 
               '{''}' '('')' '<''>'
                ]
@
% see why need quote! for all those special characters!

<<[[Lexer.token()]] keywords and unquoted words cases>>=
| wordchr+ { 
  match Lexing.lexeme lexbuf with
  | "if"    -> TIf
  | "while" -> TWhile
  | "for"   -> TFor
  | "in"    -> TIn
  | "not"   -> TNot
  | "switch" -> TSwitch
  | "fn"     -> TFn
  | s -> TWord (s, false)
}
@


%******************************************************************************
\chapter{Parsing}
%******************************************************************************

\section{[[parse_line()]] skeleton}

%trans: finally parse_line!

<<function [[Parse.parse_line]]>>=
let parse_line lexbuf =
  let curtok = ref (Parser.EOF, "EOF") in
  <<[[Parse.parse_line()]] locals and inits>>
  <<[[Parse.parse_line()]] nested function [[lexfunc]]>>
  try 
    Parser.rc lexfunc lexbuf
    <<[[Parse.parse_line()]] possibly dump AST>>
  with 
    | Parsing.Parse_error ->
        error "syntax error" !curtok
    | Lexer.Lexical_error s ->
        error (spf "lexical error, %s" s) !curtok
@
% 'rc' grammar rule!

<<[[Parse.lexfunc()]] adjust [[curtok]] with [[tok]]>>=
let s = Lexing.lexeme lexbuf in
curtok := (!tok, s);
@
% curtok for error management in parse_line only? ugly
%TODO: get rid of?, can still call Lexing.lexeme in exn handler?
% maybe can do 'Parser.rc (fun lexbuf -> let tok = lexfunc lexbuf; curtok := ....) ?


\section{Error location reporting}

<<[[Runtime.thread]] other fields>>=
(* for error reporting (None when reading from stdin) *)
(* less: file has to be mutable? could be a param of start? like chan? *)
mutable file: Common.filename option;
line: int ref;
@
<<[[Runtime.mk_thread()]] set other fields>>=
file = None;
line = ref 1;
@
% we saw set line to 1 also in?
% for file, who is setting it? when do . foo.sh! TODO ref?


<<function [[Lexer.incr_lineno]]>>=
(* we could do that in pprompt() too *)
let incr_lineno () =
  let t = Runtime.cur () in
  incr t.Runtime.line
@  
%TODO: what is using t.line ??



<<function [[Parse.error]]>>=
let error s (curtok, curtokstr) =
  let t = R.cur () in
  let locstr =
    match t.R.file, t.R.iflag with
    | Some f, false -> spf "%s:%d: " f !(t.R.line)
    | Some f, true -> spf "%s: " f
    | None, false -> spf "%d: " !(t.R.line)
    | None, true -> ""
  in
  let tokstr = 
    match curtok with
    | Parser.TNewline -> ""
    | _ -> spf "token %s: " (curtokstr)
  in
  let str = spf "rc: %s%s%s" locstr tokstr s in

  (* todo: reset globals like lastdol, lastword *)
  (* less: error recovery, skip until next newline *)
  Status.setstatus s;

  (* less: nerror++; *)
  failwith str
@
%LP: setstatus later?



\section{Grammar overview}

% classic, lex/yacc

<<Parser.mly>>=
%{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Stdcompat (* for |> *)
open Common
open Ast

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Parser.mk_seq]]>>
%}

/*(*************************************************************************)*/
/*(*1 Tokens *)*/
/*(*************************************************************************)*/
<<Parser tokens>>

/*(*************************************************************************)*/
/*(*1 Priorities *)*/
/*(*************************************************************************)*/
<<Parser token priorities>>

/*(*************************************************************************)*/
/*(*1 Rules type declaration *)*/
/*(*************************************************************************)*/
<<Parser entry points types>>

%%

<<grammar>>
@



% classic yacc too? some special prio?
% lower means higher priority so $ really tight to var
% TODO: example of AST dump of expression and see prio?

<<Parser token priorities>>=
/*(* from low to high *)*/
%left TIf TWhile TFor TSwitch TCPar TNot
%left TAndAnd TOrOr
%left TBang TSubshell
%left TPipe
%left TCaret
/*(* $$A -> ($ ($ A)) not (($ $) A) *)*/
%right TDollar TCount TStringify
%left TSub
@

<<Parser entry points types>>=
%type <Ast.line> rc
<<Parser other rule types>>
%start rc
@



<<grammar>>=
/*(*************************************************************************)*/
/*(*1 line *)*/
/*(*************************************************************************)*/
rc:
  | line TNewline { Some $1 }
  | EOF           { None }

<<rule [[Parser.line]]>>
<<other line related rules>>

/*(*************************************************************************)*/
/*(*1 Command *)*/
/*(*************************************************************************)*/

<<rule [[Parser.cmd]]>>
<<rule [[Parser.simple]]>>
<<other command related rules>>

/*(*************************************************************************)*/
/*(*1 Word *)*/
/*(*************************************************************************)*/

<<rule [[Parser.comword]]>>
<<rule [[Parser.word]]>>
<<other word related rules>>

/*(*************************************************************************)*/
/*(*1 Redirection *)*/
/*(*************************************************************************)*/

<<rule [[Parser.redir]]>>
<<other redirection related rules>>

/*(*************************************************************************)*/
/*(*1 Skipnl hacks *)*/
/*(*************************************************************************)*/

<<skipnl rules>>
@

%EOF case! None
%TNewline!

\section{Simple commands ([[<cmd> <arg1>...<argn>]]) }

% a line can have a single command (stmt)
<<rule [[Parser.line]]>>=
/*(* =~ stmt *)*/
line:
  | cmd { [$1] }
  <<[[Parser.line]] other cases>>
@


<<Parser other rule types>>=
%type <Ast.cmd> cmd
@

% a (single) command can be a simple "expression"
<<rule [[Parser.cmd]]>>=
/*(* =~ expr *)*/
cmd:
  | /*empty*/ { EmptyCommand }
  | simple    { 
      let (cmd, args, redirs) = $1 in
      let args = List.rev args in
      let base = Simple (cmd, args) in
      <<[[Parser.cmd]] adjust [[base]] with [[redis]]>>
    }
  <<[[Parser.cmd]] other cases>>
@
% will see redirs later, but for now empty so return just base
% EmptyCommand also here, useful for Assign

<<Parser other rule types>>=
%type <value * value list * (redirection_kind * value, redirection_kind * int * int) either list> simple
@

<<rule [[Parser.simple]]>>=
/*(* =~ primary expr *)*/
simple:
  | first        { $1, [], [] }
  | simple word  { let (cmd, args, redirs) = $1 in (cmd, $2::args, redirs) }
  <<[[Parser.simple]] other cases>>
@
% List.rev above cos reverted here


<<Parser other rule types>>=
%type <Ast.value> first
@

<<other word related rules>>=
first:
  | comword           { $1 }
  <<[[Parser.first]] other cases>>
@

% command word (the first word)
<<rule [[Parser.comword]]>>=
comword:
  | TWord                         { Word (fst $1, snd $1) }
  <<[[Parser.comword]] other cases>>
@


<<rule [[Parser.word]]>>=
word:
  | comword          { $1 }
  | keyword          { Word ($1, false) }
  <<[[Parser.word]] other cases>>
@
% flexible language, not like regular lang where if forbidden,
% here if could be a filename argument of a command! it's just that
% it can't be the command name

<<other word related rules>>=
keyword:
  | TFor { "for" }  | TIn { "in" }
  | TIf { "if" }  | TNot { "not" }
  | TWhile { "while" }
  | TSwitch { "switch" }
  | TFn { "fn" }
  <<[[Parser.keyword]] other cases>>
@



\section{Operators}

\subsection{Sequence ([[';']], [['&']])}

<<[[Parser.line]] other cases>>=
| cmdsa line { $1 $2  }
@

% cmdsa = command sequence or and

<<other line related rules>>=
cmdsa:
  | cmd TSemicolon { (fun x -> mk_Seq ($1, x)) }
  | cmd TAnd       { (fun x -> mk_Seq (Async $1, x)) }
@
% $1 $2 and fun x -> ... grammar idiom

% so cmd1 & cmd2 is really cmd1& ; cmd2

<<function [[Parser.mk_seq]]>>=
(* This is a useful optimisation as you can get lots of EmptyCommand,
 * for instance, in {\nls\n} you will get 2 EmptyCommand (for each \n)
*)
let mk_Seq (a, b) =
  match a, b with
  | EmptyCommand, _ -> b
  | _, [EmptyCommand] -> [a]
  | _ -> a::b
@


\subsection{Logical operators  ([['&&']], [['||']], [['!']])}

<<[[Parser.cmd]] other cases>>=
| cmd TAndAnd cmd { And ($1, $3) }
| cmd TOrOr cmd   { Or  ($1, $3) }
| TBang cmd       { Not $2 }
@


<<[[Parser.keyword]] other cases>>=
| TBang { "!" }
@
% if not first word, then can be a parameter of a command


\subsection{String matching  (\texttt{'\textasciitilde'})}
%alt: move in advanced section, but nice to have a construct that
% can go inside 'if' otherwise have to talk about 'test' or '[' or bash

<<[[Parser.cmd]] other cases>>=
| TTwiddle word words { Match ($2, $3) }
@
% note that operator appears in first position, not binary operator
% kinda builtin command

% semantic will be if word match one of the other words (List.exists)

<<[[Parser.keyword]] other cases>>=
| TTwiddle { "~" }
@


<<other word related rules>>=
words: words_rev { List.rev $1 }
@
<<other word related rules>>=
words_rev:
  | /*empty*/  { [] }
  | words_rev word { $2::$1 }
@

\subsection{Pipe  ([['|']])}

<<[[Parser.cmd]] other cases>>=
| cmd TPipe cmd  { Pipe ($1, $3) }
@


\subsection{Redirections  ([['>']], [['<']])}

<<[[Parser.simple]] other cases>>=
| simple redir { let (cmd, args, redirs) = $1 in (cmd, args, $2::redirs) }
@
% add to redir, can have multiple redir! ex: cat < foo.txt > out.txt =~ cp :)

<<rule [[Parser.redir]]>>=
redir:
  | TRedir word { Left ($1, $2) }
  <<[[Parser.redir]] other cases>>
@


<<[[Parser.cmd]] adjust [[base]] with [[redis]]>>=
let redirs = List.rev redirs in
redirs |> List.fold_left (fun acc e ->
  match e with
  | Left (kind, word)    -> Redir (acc, (kind, word))
  | Right (kind, fd0, fd1) -> Dup (acc, kind, fd0, fd1)
) base
@

%TODO? dump AST and see tree or Redir enclosing each other

\section{Control flow statements ([[if]], [[if not]], [[while]], [[switch]], [[for]])}

<<[[Parser.cmd]] other cases>>=
| TIf paren_skipnl cmd { If ($2, $3) }
| TIf tnot_skipnl  cmd { IfNot $3 }
@

<<[[Parser.cmd]] other cases>>=
| TWhile paren_skipnl cmd   { While ($2, $3) }
@

<<skipnl rules>>=
paren_skipnl: paren { Globals.skipnl := true; $1 }
tnot_skipnl: TNot   { Globals.skipnl := true; }
@
% see \ref{sec:skipnl} before

<<other command related rules>>=
paren: TOPar body TCPar { $2 }
@
% body later but =~ cmd
% need paren to separate condition from cmd
% not that condition is a command too! exit code will determine
% (or can also be '~' )


<<[[Parser.cmd]] other cases>>=
| TSwitch word_skipnl brace { Switch ($2, $3) }
@
<<[[Ast.cmd]] other statement cases>>=
| Switch of value * cmd_sequence
@


<<[[Parser.cmd]] other cases>>=
/*(* I added the %prec TFor. *)*/
| TFor TOPar word TIn words tcpar_skipnl cmd %prec TFor { ForIn ($3, $5, $7) }
| TFor TOPar word tcpar_skipnl cmd           %prec TFor { For ($3, $5) }
@
<<[[Ast.cmd]] other statement cases>>=
| ForIn of value * values * cmd
(* less: could desugar as ForIn value $* *)
| For of value * cmd
@



<<skipnl rules>>=
word_skipnl: word   { Globals.skipnl := true; $1 }
tcpar_skipnl: TCPar { Globals.skipnl := true; }
@


\section{Grouping (\texttt{'\{...\}'})} 

% used in Switch above

% but can also be part of cmd

<<[[Parser.cmd]] other cases>>=
| brace epilog   { 
    let cmd = (Compound $1) in
    <<[[Parser.cmd]] in [[brace]] case, adjust [[cmd]] with [[epilog]]>>
}
@

<<[[Ast.cmd]] other statement cases>>=
| Compound of cmd_sequence
@
%$

<<other command related rules>>=
brace: TOBrace body TCBrace { $2 }
@
% so no diff with paren? brace can have epilog after

<<other command related rules>>=
body: 
  | cmd         { [$1] }
  | cmdsan body { $1 $2 }
@
<<other command related rules>>=
cmdsan:
  | cmdsa        { $1 }
  | cmd TNewline { (fun x -> mk_Seq ($1, x)) }
@
% so can have newline now! newline act as semicolon now when in body context!





<<other redirection related rules>>=
epilog:
  | /*empty*/    { [] }
  | redir epilog { $1::$2 }
@

<<[[Parser.cmd]] in [[brace]] case, adjust [[cmd]] with [[epilog]]>>=
$2 |> List.fold_left (fun acc e -> 
  match e with
  | Left (kind, word) -> Redir (acc, (kind, word))
  | Right (kind, fd0, fd1) -> Dup (acc, kind, fd0, fd1)
)  cmd
@


\section{Functions ([[fn <f> { ... }]])}

<<[[Parser.cmd]] other cases>>=
/*(* stricter: allow only word, not words *)*/
| TFn word brace { Fn ($2, $3) }
@

% function use =   [[f ( )]] so parsed as a simple command

\section{Variables ([[<x> = ...]], [[$x]])}

<<[[Parser.cmd]] other cases>>=
| assign cmd %prec TBang { $1 $2 }
@
% again $1 $2 idiom

% need %prec because?

<<other command related rules>>=
assign: first TEq word { (fun x -> Assign ($1, $3, x))  }
@
% x can be EmptyCommand when TNewline

<<[[Parser.comword]] other cases>>=
| TDollar word                  { Dollar $2 }
@

\section{Lists ([[(...)]])}

% note that have seen parens in if/while context but
% here different

<<[[Parser.comword]] other cases>>=
| TOPar words TCPar             { List $2 }
@


%\chapter{Checking}


%******************************************************************************
\chapter{Bytecode Generation and Interpretation}
%******************************************************************************


\section{Overview}

%\subsection{[[emitxxx()]]}
\subsection{[[compile()]]}

<<function [[Compile.compile]]>>=
let compile (seq : Ast.cmd_sequence) : Opcode.codevec =

  (* a growing array *)
  let codebuf = ref [| |] in
  let len_codebuf = ref 0 in
  (* pointer in codebuf *)
  let idx = ref 0 in

  <<[[Compile.compile()]] nested function [[emit]]>>
  <<[[Compile.compile()]] nested function [[set]]>>

  outcode_seq seq !Flags.eflag (emit, set, idx);
  emit (O.F O.Return);
  (* less: O.F O.End *)
  (* less: heredoc, readhere() *)

  (* return the trimmed array *)
  Array.sub !codebuf 0 !idx
  <<[[Compile.compile()]] possibly dump returned opcodes>>
@

<<[[Opcode.operation]] other control cases>>=
| Return
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Return -> Process.return caps ()
@

<<[[Op_repl.op_REPL()]] match [[cmdset_opt]] other cases>>=
| None -> Process.return caps ()
@
% when return op_REPL, and interpret_operation, will go gack to
% while loop of interpret_bootstrap and newt at the top of cur!
% so will execute that!

% called when REPL gets EOF too and cmdseq_opt is None (see section X
% with EOF rc case rule)
<<signature [[Process.return]]>>=
val return : < Cap.exit ; .. > -> unit -> unit
@

<<function [[Process.return]]>>=
(* Was called Xreturn but called not only from the opcode interpreter.
 * It is an helper function really.
 *)
let return (caps : < Cap.exit; .. >) () =
  <<[[Process.return()]] initializations>>
  match !R.runq with
  | [] -> failwith "empty runq"
  (* last thread in runq, we exit then *)
  | [_x] -> exit caps (Status.getstatus ())
  | _x::xs -> 
      R.runq := xs
@
% will see exit and getstatus later





<<[[Compile.compile()]] nested function [[emit]]>>=
let emit x =
  <<[[Compile.compile()]] nested function [[emit]] possibly grow [[codebuf]]>>
  !codebuf.(!idx) <- x;
  incr idx
in
@

<<[[Compile.compile()]] nested function [[emit]] possibly grow [[codebuf]]>>=
(* grow the array if needed *)
if !idx = !len_codebuf then begin
  len_codebuf := !len_codebuf + 100;
  codebuf := Array.append !codebuf (Array.make 100 (O.I 0));
end;
@


<<[[Compile.compile()]] nested function [[set]]>>=
let set idx2 x =
  <<[[Compile.compile()]] nested function [[set]] array bound checking>>
  !codebuf.(idx2) <- x;
in
@

<<[[Compile.compile()]] nested function [[set]] array bound checking>>=
if idx2 < 0 || idx2 >= !len_codebuf
then failwith (spf "Bad address %d in set()" idx2);
@

\subsection{[[outcode_seq()]] skeleton}

% return unit cos side effect on enclosing codebuf in compile()
% via emit or set or idx

<<function [[Compile.outcode_seq]]>>=
let outcode_seq (seq : Ast.cmd_sequence) eflag (emit,set,idx) : unit =

  let rec xseq (seq : Ast.cmd_sequence) eflag : unit =
   <<[[Compile.outcode_seq]] in nested [[xseq()]]>>
  
  and xcmd (cmd : Ast.cmd) eflag : unit =
    match cmd with
    <<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>
    | (A.Async _|
       A.Dup (_, _, _, _)|
       A.While (_, _)|
       A.ForIn (_, _, _)|
       A.For (_, _)
       )
       -> failwith ("TODO compile: " ^ Dumper_.s_of_cmd cmd)

 (* Do we need to pass eflag here too?
  * Even though types are mutually recursive because of Backquote, the
  * compilation of backquote does not use eflag!
  *)
  and xword (w : Ast.value) : unit =
    match w with
    <<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>
    | (A.CommandOutput _|
       A.Index (_, _)|
       A.Concat (_, _)|
       A.Stringify _
      )
       -> failwith ("TODO compile: " ^ Dumper_.s_of_value w)

  and xwords (ws : Ast.value list) : unit =
    <<[[Compile.outcode_seq]] in nested [[xwords()]]>>
  in
  xseq seq eflag
@




\section{Simple commands}

% reminder: ls /etc => Simple (Word "ls", [Word "/etc"])

\subsection{Bytecode generation}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Simple (w, ws) -> 
    emit (O.F O.Mark);
    xwords ws;
    xword w;
    emit (O.F O.Simple);
    <<[[Compile.outcode_seq]] in [[A.Simple]] case after emit [[O.Simple]]>>
@
% need Mark so know when finish args

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Word (s, _quoted) ->
    emit (O.F O.Word);
    emit (O.S s);
@


\subsection{Stack management}

<<[[Compile.outcode_seq]] in nested [[xwords()]]>>=
ws |> List.rev |> List.iter (fun w -> xword w);
@
% List.rev! stack!

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.List ws ->
    xwords ws
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [string] *)
| O.Word ->
    let t = R.cur () in
    let pc = t.R.pc in
    let x = t.R.code.(!pc) in
    incr pc;
    (match x with
    | O.S s -> R.push_word s
    (* stricter: but should never happen *)
    | op -> failwith (spf "was expecting a S, not %s" (Dumper_.s_of_opcode op))
    )
@
% remember pc already incremented in caller, so incr pc here to increment
% it even more to pass the inline string


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Mark -> R.push_list ()
@

<<signature [[Runtime.push_list]]>>=
val push_list : unit -> unit
@
<<function [[Runtime.push_list]]>>=
let push_list () =
  let t = cur () in
  t.argv_stack <- t.argv :: t.argv_stack;
  t.argv <- []
@

<<[[Runtime.thread]] other fields>>=
(* Used for switch but also assignments. *)
mutable argv_stack: (string list) list;
@

<<[[Runtime.mk_thread()]] set other fields>>=
argv_stack = [];
@
% how can have enclosing argv_stack we need to save?

\subsection{[[O.Simple]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (args) *)
| O.Simple -> Op_process.op_Simple caps ()
@


<<function [[Op_process.op_Simple]]>>=
let op_Simple (caps : < Cap.fork; Cap.exec; Cap.chdir; Cap.exit; ..>) () =
  let t = R.cur () in
  let argv = t.R.argv in
  <<[[Op_process.op_Simple()]] possibly dump command>>
  match argv with
  <<[[Op_process.op_Simple()]] match [[argv]] empty case>>
  | argv0::args ->
      match argv0 with
      <<[[Op_process.op_Simple()]] match [[argv0]] builtin cases>>
      | _ ->
        <<[[Op_process.op_Simple()]] when default case, before the fork>>
        (try 
          let pid = forkexec caps () in
          R.pop_list ();
          <<[[Op_process.op_Simple()]] when default case, after the fork>>
        with
          | Failure s ->
              E.error caps ("try again: " ^ s)
          | Unix.Unix_error (err, s1, s2) -> 
              E.error caps (Process.s_of_unix_error err s1 s2)
)
@
%$


<<signature [[Runtime.pop_list]]>>=
val pop_list : unit -> unit
@
<<function [[Runtime.pop_list]]>>=
let pop_list () =
  let t = cur () in
  match t.argv_stack with
  (* At the very beginning we do *=(argv) in bootstrap.
   * In that case, Assign will generate two pop_list, but for
   * the second one argv_stack becomes empty. The only thing
   * we must do is to empty argv then.
   *)
  | [] ->
     t.argv <- []
  | x::xs -> 
      t.argv_stack <- xs;
      t.argv <- x
@
% we need push_list with Mark before, so once done we need to restore

<<[[Op_process.op_Simple()]] when default case, before the fork>>=
(* if exitnext opti *)
flush stderr;
(* less: Updenv *)
@


\subsection{Builtin dispatch}

% before seeing main case and forkexec, see builtin special case
% when first word is a builtin

<<[[Op_process.op_Simple()]] match [[argv0]] builtin cases>>=
| s when Builtin.is_builtin s -> Builtin.dispatch caps argv0
@

<<signature [[Builtin.is_builtin]]>>=
val is_builtin : string -> bool
@
<<signature [[Builtin.dispatch]]>>=
(* execute the builtin *)
val dispatch : < Cap.chdir ; Cap.exit ; Cap.open_in; .. > -> string -> unit
@


<<[[Op_process.op_Simple()]] match [[argv0]] builtin cases>>=
(* todo: if argv0 is a function *)
| "builtin" -> 
    (match args with
    | [] ->
        Logs.err (fun m -> m "builtin: empty argument list");
        Status.setstatus "empty arg list";
        R.pop_list ()
    | argv0::_args ->
        R.pop_word ();
        Builtin.dispatch caps argv0
    )
@
%LP: split setstatus and move later


\subsection{Fork}

% Essence of a shell! Fork/exec/wait)! a 50LOC mini shell will be that

<<function [[Op_process.forkexec]]>>=
let forkexec (caps : < Cap.fork; Cap.exec; Cap.exit; .. >) () : int =
  let pid = CapUnix.fork caps () in
  (* child *)
  if pid = 0
  then begin
    (* less: clearwaitpids *)
    (* less: could simplify and remove this word if exec was not a builtin *)
    R.push_word "exec";
    exec caps ();
    (* should not be reached, unless prog could not be executed *)
    Process.exit caps ("can't exec: " ^ !Globals.errstr);
    0
  end
  else 
    (* parent *)
    (* less: addwaitpid *)
    pid
@
%LP: could aspectize the push_word "exec" here and in exec() below

\subsection{Exec}

<<function [[Op_process.exec]]>>=
let exec (caps : < Cap.exec; Cap.exit; .. >) () : unit =
  R.pop_word (); (* "exec" *)

  let t = R.cur () in
  let argv = t.R.argv in
  match argv with
  | [] -> E.error caps "empty argument list" 
  | prog::_xs -> 
      <<[[Op_process.exec()]] before [[execute]]>>
      execute caps argv (PATH.search_path_for_cmd prog);
      (* should not be reached, unless prog could not be executed *)
      R.pop_list ()
@
% intermediate exec because also builtin so factorize code
%TODO: rename search_path_for_cmd? it's not actually trying to find prog!
% actually why need prog as a param?

<<function [[Op_process.execute]]>>=
let execute (caps : <Cap.exec; ..>) args path =

  let argv = Array.of_list args in
  let errstr = ref "" in

  (* less: Updenv () *)
  path |> List.iter (fun root ->
    let path = (if root = "" then "" else root ^ "/") ^ argv.(0) in
    try 
      CapUnix.execv caps path argv |> ignore
    with Unix.Unix_error (err, s1, s2) ->
     errstr := Process.s_of_unix_error err s1 s2;
     Globals.errstr := s2
  );
  (* reached only when could not find a path *)
  Logs.err (fun m -> m "%s: %s" argv.(0) !errstr)
@
% List.iter ??
% path adjustment??


\subsection{Error management}

<<[[Op_process.op_Simple()]] match [[argv]] empty case>>=
(* How can you get an empty list as Simple has at least one word?
 * If you do A=()\n and then $A\n then Simple has a word, but after
 * expansion the list becomes empty.
 * stricter: I give extra explanations
 *)
| [] -> E.error caps "empty argument list (after variable expansion)" 
@


<<signature [[Error.error]]>>=
(* Will behave like a 'raise'. Will Return until you reach
 * the interactive thread and set the status to the error argument.
 * Mostly used by the builtins.
 *)
val error : < Cap.exit ; .. > -> string -> unit
@



<<function [[Error.error]]>>=
(* less: error1 similar to error but without %r *)
let error (caps: < Cap.exit; ..>) (s : string) =
  (* less: use argv0 *)
  (* less: use %r *)
  Logs.err (fun m -> m "rc: %s" s);

  Status.setstatus "error";

  while (R.cur ()).R.iflag do
    (* goes up the call stack, like when we have an exception *)
    Process.return caps ();
  done
@

<<constant [[Globals.errstr]]>>=
(* to mimic Plan 9 errstr() *)
let errstr = ref ""
@







<<signature [[Process.s_of_unix_error]]>>=
val s_of_unix_error : Unix.error -> string -> string -> string
@
<<function [[Process.s_of_unix_error]]>>=
let s_of_unix_error err _s1 _s2 = 
  spf "%s" (Unix.error_message err)
@

\subsection{[[$status]] management}

% in bash $$?

<<signature [[Status.setstatus]]>>=
val setstatus : string -> unit
@
<<function [[Status.setstatus]]>>=
let setstatus s =
  Var.setvar "status" [s]
@


<<signature [[Status.getstatus]]>>=
val getstatus : unit -> string
@
<<function [[Status.getstatus]]>>=
let getstatus () =
  let v = (Var.vlook "status").R.v in
  match v with
  | None -> ""
  | Some [x] -> x
  (* stricter: should never happen *)
  | Some _ -> failwith "getstatus: $status is a list with more than one element"
@
%$


<<signature [[Status.truestatus]]>>=
val truestatus : unit -> bool
@
<<function [[Status.truestatus]]>>=
let truestatus () : bool =
  let s = getstatus () in
  s = ""
  || s =~ "0+\\(|0+\\)*"
@
% | for pipe


\subsection{Wait}
% fork, exec, wait, the trinity

<<[[Op_process.op_Simple()]] when default case, after the fork>>=
(* do again even if was interrupted *)
while Process.waitfor pid = Process.WaitforInterrupted do
  ()
done
@

<<signature [[Process.waitfor]]>>=
val waitfor : int -> waitfor_result
@


<<type [[Process.waitfor_result]]>>=
type waitfor_result =
  | WaitforInterrupted
  | WaitforFound
  | WaitforNotfound
@

% Capa waitfor!
<<function [[Process.waitfor]]>>=
let waitfor pid =
  (* less: check for havewaitpid *)

  try 
    let rec loop () =
      let (pid2, status) = Unix.wait () in
      let status_str = 
        match status with
        | Unix.WEXITED i -> spf "%d" i
        | Unix.WSIGNALED i -> spf "signaled %d" i
        | Unix.WSTOPPED i -> spf "stopped %d" i
      in
      if pid = pid2
      then begin
        Status.setstatus status_str;
        WaitforFound
      end else begin
        !R.runq |> List.iter (fun t ->
          match t.R.waitstatus with
          | R.WaitFor pid ->
              if pid = pid2
              then t.R.waitstatus <- R.ChildStatus status_str;
          | R.ChildStatus _ | R.NothingToWaitfor -> ()
        );
        loop ()
      end
    in
    loop ()
  with Unix.Unix_error (err, s1, s2) ->
    Globals.errstr := s_of_unix_error err s1 s2;
    if err = Unix.EINTR
    then WaitforInterrupted
    else WaitforNotfound
@


\subsection{[[$path]] management}

<<signature [[PATH.find_in_path]]>>=
val find_in_path :
  string (* cmd *) -> string list (* $path *) -> Common.filename
@
%$

<<signature [[PATH.search_path_for_cmd]]>>=
val search_path_for_cmd : string (* cmd *) -> string list (* $path *)
@
%$

<<function [[PATH.search_path_for_cmd]]>>=
let search_path_for_cmd s =
  let nullpath = [""] in

  if s =~ "^/" ||
     (* Plan 9 device paths *)
     s =~ "^#" || 
     s =~ "\\./" ||
     s =~ "\\.\\./"
  then nullpath
  else
    let v = (Var.vlook "path").R.v in
    (match v with
    | None -> nullpath
    | Some xs -> xs
    )
@

<<function [[PATH.find_in_path]]>>=
let find_in_path _s _paths =
  raise Todo
@
%TODO


%\subsection{Fork optimization}


\section{Operators}


\subsection{Basic sequence}

<<[[Compile.outcode_seq]] in nested [[xseq()]]>>=
(* less set iflast, for if not syntax error checking *)
seq |> List.iter (fun x -> xcmd x eflag)
@

% sequence is simply generating bytecode for each cmd!

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.EmptyCommand -> ()
@


\subsection{Logical operators}


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.And (cmd1, cmd2) ->
    xcmd cmd1 false;
    emit (O.F O.True);
    let p = !idx in
    xcmd cmd2 eflag;

    set p (O.I !idx)
@
% True then execute pc+1 otherwise jump

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.True ->
    let t = R.cur () in
    let pc = t.R.pc in
    if Status.truestatus ()
    then incr pc
    else pc := int_at_address t (!pc)
@

<<function [[Interpreter.int_at_address]]>>=
let int_at_address t pc =
  match t.R.code.(pc) with
  | O.I i -> i
  (* stricter: generate error, but should never happen *)
  | op -> failwith (spf "was expecting I, not %s at %d" 
                      (Dumper_.s_of_opcode op) pc)
@


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Or (cmd1, cmd2) ->
    xcmd cmd1 false;
    emit (O.F O.False);
    let p = !idx in
    xcmd cmd2 eflag;

    set p (O.I !idx)
@

% similar but False

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.False ->
    let t = R.cur () in
    let pc = t.R.pc in
    if Status.truestatus ()
    then pc := int_at_address t (!pc)
    else incr pc
@



<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Not cmd ->
    xcmd cmd eflag;
    emit (O.F O.Not);
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Not ->
    Status.setstatus (if Status.truestatus() then "false" else "");
@
% "" means true (exit code 0), anything else is error (falsy)

\subsection{String matching}


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Match (w, ws) ->
    emit (O.F O.Mark);
    xwords ws;
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Match);
    <<[[Compile.outcode_seq]] in [[A.Match]] case after emit [[O.Match]]>>
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (pat, str) *)
| O.Match ->
    let t = R.cur () in
    let argv = t.R.argv in
    let subject = String.concat " " argv in
    Status.setstatus "no match";
    R.pop_list ();
    let argv = t.R.argv in
    argv |> List.exists (fun w -> 
      if Pattern.match_str subject w
      then begin
        Status.setstatus "";
        true
      end else false
    ) |> ignore;
    R.pop_list ();
@

\subsection{Redirection}

%\subsection{Trace of a redirection}
%\subsubsection{[[Redir]]}
%\subsubsection{[[doredir()]]}

\subsubsection{Bytecode generation}


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Redir (cmd, (redir_kind, word)) ->
    (* resolve the filename *)
    emit (O.F O.Mark);
    xword word;
    emit (O.F O.Glob);

    (match redir_kind with
    | A.RWrite ->
        emit (O.F O.Write);
        emit (O.I 1);
    (* less: and A.RHere *)
    | A.RRead -> 
        emit (O.F O.Read);
        emit (O.I 0);
    | A.RAppend -> 
        emit (O.F O.Append);
        emit (O.I 1);
    | _ -> failwith ("TODO compile: " ^ Dumper_.s_of_cmd cmd)
    );
    
    (* perform the command *)
    xcmd cmd eflag;
    emit (O.F O.Popredir);
@

% Glob!

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Popredir ->
    R.pop_redir ()
@

\subsubsection{[[O.Write]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (file)[fd] *)
| O.Write ->
    let t = R.cur () in
    let argv = t.R.argv in
    let pc = t.R.pc in
    (match argv with
    | [file] ->
        (try 
          let fd_from = 
            Unix.openfile file [Unix.O_CREAT;Unix.O_WRONLY] 0o666 in
          (* should be stdout *)
          let fd_to =
            let i = int_at_address t !pc in
            file_descr_of_int i
          in
          R.push_redir (R.FromTo (fd_from, fd_to));
          incr pc;
          R.pop_list();
        with Unix.Unix_error (_err, _s1, _s2) ->
          prerr_string (spf "%s: " file);
          E.error caps "can't open"
        )
    | []       -> E.error caps "> requires file"
    | _x::_y::_xs -> E.error caps "> requires singleton"
    )
@


<<function [[Interpreter.file_descr_of_int]]>>=
(* could be in runtime.ml *)
let file_descr_of_int i =
  match i with
  | 0 -> Unix.stdin
  | 1 -> Unix.stdout
  | 2 -> Unix.stderr
  (* todo: how do that? if do >[1=4] ?? *)
  | n -> failwith (spf "file_descr_of_int: unsupported int %d" n)
@


<<signature [[Runtime.push_redir]]>>=
val push_redir : redir -> unit
@

<<function [[Runtime.push_redir]]>>=
let push_redir (x : redir) : unit =
  let t = cur () in
  match t.redirections with
  | [] -> failwith "push_redir: no starting redir"
  | xs::xxs -> t.redirections <- (x::xs)::xxs
@


\subsubsection{[[O.Read]]}
%TODO: O.Read not implemented yet 

\subsubsection{[[O.Append]]}
%TODO: O.Append

\subsubsection{Closing redirection opened files}




<<signature [[Runtime.pop_redir]]>>=
val pop_redir : unit -> unit
@
<<function [[Runtime.pop_redir]]>>=
let pop_redir () =
  let t= cur () in
  match t.redirections with
  | [] -> failwith "pop_redir: no starting redir"
  | []::_xxs -> failwith "popredir null!"
  | (x::xs)::xxs ->
      t.redirections <- xs::xxs;
      (match x with
      | FromTo (fd_from, _fd_to) ->
          Unix.close fd_from
      | Close _ ->
          ()
      )
@


<<[[Process.return()]] initializations>>=
R.turf_redir ();
@
%???

<<signature [[Runtime.turf_redir]]>>=
val turf_redir : unit -> unit
@

<<function [[Runtime.turf_redir]]>>=
let turf_redir () =
  let t = cur () in
  while List.hd t.redirections <> [] do
    pop_redir ()
  done
@

<<[[Op_process.exec()]] before [[execute]]>>=
R.doredir t.R.redirections;
@

<<signature [[Runtime.doredir]]>>=
val doredir : redir list list -> unit
@
<<function [[Runtime.doredir]]>>=
let doredir xxs =
  xxs |> List.flatten |> List.rev |> List.iter (fun redir ->
    match redir with
    | FromTo (xfrom, xto) ->
        Unix.dup2 xfrom xto;
        Unix.close xfrom
    | Close from ->
        Unix.close from
  )
@



\subsection{Pipe}

%\subsubsection{Trace of a pipe}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Pipe (cmd1, cmd2) ->
    emit (O.F O.Pipe);
    emit (O.I 1); (* left fd *)
    emit (O.I 0); (* right fd *)

    let p = !idx in
    emit (O.I 0);
    let q = !idx in
    emit (O.I 0);

    (* will be executed in a forked child, hence Exit *)
    xcmd cmd1 eflag;
    emit (O.F O.Exit);

    (* will be executed in a children thread, hence Return *)
    set p (O.I !idx);
    xcmd cmd2 eflag;
    emit (O.F O.Return);

    (* will be executed by parent once the children thread finished *)
    set q (O.I !idx);
    emit (O.F O.PipeWait);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [i j]{... Xreturn}{... Xreturn} *)
| O.Pipe -> 
    let t = R.cur () in
    let pc = t.R.pc in
    (* left file descriptor, should be stdout *)
    let lfd =
      let i = int_at_address t !pc in
      file_descr_of_int i
    in
    incr pc;
    (* right file descriptor, should be stdin *)
    let rfd =
      let i = int_at_address t !pc in
      file_descr_of_int i
    in
    incr pc;

    let (pipe_read, pipe_write) = Unix.pipe () in
    let forkid = CapUnix.fork caps () in

    (* child *)
    if forkid = 0 then begin
      (* less: clearwaitpids () *)
      (* pc + 2 to jump over the jump addresses *)
      let newt = R.mk_thread t.R.code (!pc + 2) t.R.locals in
      R.runq := [newt];
      Unix.close pipe_read;
      R.push_redir (R.FromTo (pipe_write, lfd));
    (* parent *)
    end else begin
      (* less: addwaitpid () *)
      let newt = 
        R.mk_thread t.R.code (int_at_address t (!pc+0)) t.R.locals in
      R.runq := newt::!R.runq;
      Unix.close pipe_write;
      R.push_redir (R.FromTo (pipe_read, rfd));
    
     (* once newt finished, jump to Xpipewait *)
      pc := int_at_address t (!pc+1);
      t.R.waitstatus <- R.WaitFor forkid;
    end
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Exit -> 
    (* todo: trapreq *)
    Process.exit caps (Status.getstatus())
@
<<signature [[Process.exit]]>>=
val exit : < Cap.exit ; .. > -> string -> unit
@
<<function [[Process.exit]]>>=
let exit (caps: < Cap.exit; ..>) s =
  (* todo: Updenv *)
  Status.setstatus s;
  (* todo: how communicate error to parent process under Unix? 
   * alt: raise Exit.ExitCode which removes the need for Cap.exit
   *)
  CapStdlib.exit caps (if Status.truestatus () then 0 else 1)
@


<<[[Opcode.operation]] other pipe cases>>=
| PipeWait (* argument passed through Thread.pid *)
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* argument passed through Thread.pid *)
| O.PipeWait -> 
    let t = R.cur () in
    (match t.R.waitstatus with
    (* stricter: *)
    | R.NothingToWaitfor -> 
        failwith "Impossible: NothingToWaitfor for PipeWait"
    (* a previous waitfor() already got it *)
    | R.ChildStatus status -> 
        Status.setstatus (Status.concstatus status (Status.getstatus()));
    | R.WaitFor pid ->
        let status = Status.getstatus () in
        (* will internally call setstatus() when it found the right child *)
        Process.waitfor pid |> ignore;
        t.R.waitstatus <- R.NothingToWaitfor;
        Status.setstatus (Status.concstatus (Status.getstatus()) status);
    )
@

<<signature [[Status.concstatus]]>>=
val concstatus : string -> string -> string
@
<<function [[Status.concstatus]]>>=
let concstatus s1 s2 =
  s1 ^ "|" ^ s2
@


\subsection{Asynchronous execution}

%TODO: not implemented yet



\section{Control flow statements}

\subsection{[[if]]}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.If (cmds, cmd) ->
    xseq cmds false;
    emit (O.F O.If);
    let p = !idx in
    emit (O.I 0);
    xcmd cmd eflag;
    emit (O.F O.Wastrue);
    set p (O.I !idx);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.If ->
    let t = R.cur () in
    let pc = t.R.pc in

    Globals.ifnot := true;
    if Status.truestatus()
    then incr pc
    else pc := int_at_address t (!pc);
@

\subsection{[[if not]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.IfNot ->
    let t = R.cur () in
    let pc = t.R.pc in
    if !Globals.ifnot
    then incr pc
    else pc := int_at_address t (!pc);
@


<<constant [[Globals.ifnot]]>>=
(* Set to true at the beginning of an if and back to false
 * if rc executes the then branch. Kept to true otherwise
 * so next IfNot will run.
 *)
let ifnot = ref false
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Wastrue ->
    Globals.ifnot := false
@



<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.IfNot cmd ->
    emit (O.F O.IfNot);
    let p = !idx in
    emit (O.I 0);
    xcmd cmd eflag;
    set p (O.I !idx);
@


\subsection{[[while]]}

%TODO: not implemented

\subsection{[[for]]}

%TODO: not implemented

<<[[Opcode.operation]] other control cases>>=
| For   (* (var, list){... Xreturn} *)
@

\subsection{[[switch]]}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Switch (w, cmds) ->

    (match cmds with
    | (A.Simple (A.Word ("case", false), _))::_ -> ()
    | _ -> failwith "case missing in switch"
    );

    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Jump);

    let nextcase = !idx in
    emit (O.I 0);
    let out = !idx in
    emit (O.F O.Jump);
    let leave = !idx in
    emit (O.I 0);
    
    set nextcase (O.I !idx);

    let aux cmds =
      match cmds with
      | [] -> ()
      | (A.Simple (A.Word ("case", false), ws))::cmds ->
          emit (O.F O.Mark);
          xwords ws;
          emit (O.F O.Case);
          let nextcase = !idx in
          emit (O.I 0);

          let cmds_for_this_case, _other_cases = split_when_case cmds in
          cmds_for_this_case |> List.iter (fun cmd ->
            xcmd cmd eflag
          );
          emit (O.F O.Jump);
          emit (O.I out);
          set nextcase (O.I !idx);
      | _ -> failwith "case missing in switch"
    in
    aux cmds;
    set leave (O.I !idx);
    (* can not call pop_list(), here, otherwise circular deps *)
    emit (O.F O.Popm);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [addr] *)
| O.Jump ->
    let t = R.cur () in
    let pc = t.R.pc in
    pc := int_at_address t (!pc);
@


<<[[Opcode.operation]] other control cases>>=
| Case  (* (pat, value){...} *)
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (pat, value){...} *)
| O.Case ->
    let t = R.cur () in
    let pc = t.R.pc in
    let s = List.hd t.R.argv_stack |> String.concat " " in
    let argv = t.R.argv in
    let match_found = argv |> List.exists (fun w -> Pattern.match_str s w) in
    (if match_found
    then incr pc
    else pc := int_at_address t (!pc)
    );
    R.pop_list ();
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (value) *)
| O.Popm ->
    R.pop_list ()
@



<<function [[Compile.split_when_case]]>>=
let split_when_case cmds =
  cmds |> Common2.span (function
    | (A.Simple (A.Word ("case", false), _)) -> false
    | _ -> true
  )
@


\subsection{Blocks: \texttt{'\{...\}'}}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Compound seq -> xseq seq eflag
@
% simple :)

\section{Functions}

\subsection{Function definitions ([[fn <foo> { ... }]])}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Fn (w, cmds) ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Fn);
    let p = !idx in
    (* less: emit str of fn *)
    emit (O.S "Fn String Todo?");
    xseq cmds eflag;
    emit (O.F O.Unlocal);
    emit (O.F O.Return);
    set p (O.I !idx);
@

%O.Fn TODO

\subsection{Function uses ([[<foo>(...)]])}


\section{Variables}

\subsection{Variable definitions ([[<x>=...]])}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Assign (val1, val2, cmd) ->
    let all_assigns, cmd = 
      split_at_non_assign (A.Assign (val1, val2, cmd)) in
    (match cmd with
    (* A=b; *)
    | A.EmptyCommand -> 
        all_assigns |> List.iter (fun (val1, val2) ->
          emit (O.F O.Mark);
          xword val2;
          emit (O.F O.Mark);
          xword val1;
          emit (O.F O.Assign);
        )

    (* A=b cmd; *)
    | _ -> 
        all_assigns |> List.iter (fun (val1, val2) ->
          emit (O.F O.Mark);
          xword val2;
          emit (O.F O.Mark);
          xword val1;
          emit (O.F O.Local);
        );
        xcmd cmd eflag;
        all_assigns |> List.iter (fun (_, _) ->
          emit (O.F O.Unlocal);
        )
    )
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) (val) *)
| O.Assign ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] ->
        (* no call to globlist for varname as it can be "*" for $* *)
        (* less: deglob varname *)
        let v = Var.vlook varname in
        R.pop_list ();

        (* less: globlist for the arguments *)
        let argv = t.R.argv in
        v.R.v <- Some argv;
        R.pop_list ();

    | _ -> E.error caps "variable name not singleton!"
    )
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) (val) *)
| O.Local ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] ->
      (* less: deglob varname *)
      R.pop_list ();
      (* less: globlist *)
      let argv = t.R.argv in
      Hashtbl.add t.R.locals varname { R.v = Some argv };
      R.pop_list ();
    | _ -> E.error caps "variable name not singleton!"
    )
@


<<function [[Compile.split_at_non_assign]]>>=
let rec split_at_non_assign = function
  | A.Assign (val1, val2, cmd) ->
      let (a,b) = split_at_non_assign cmd in
      (val1, val2)::a, b
  | b -> [], b
@


\subsection{Variable uses ([[$<x>]])} %$

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Dollar w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Dollar);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.Dollar ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] -> 
       (* less: deglob varname *)
       (try 
          let value = vlook_varname_or_index varname in
          R.pop_list ();
          let argv = t.R.argv in
          let newargv = 
            (match value with None -> [] | Some xs -> xs) @ argv in
          t.R.argv <- newargv
        with Failure s -> E.error caps s
       )             
    | _ -> E.error caps "variable name not singleton!"
    )
@

\subsection{Special variables} %$

<<function [[Interpreter.vlook_varname_or_index]]>>=
let vlook_varname_or_index varname =
  if varname =~ "^[0-9]+$"
  then
    let i = int_of_string varname in
    let v = (Var.vlook "*").R.v in
    (match v with
    (* stricter: array out of bound checking *)
    | None -> failwith "undefined $*"
    | Some xs -> 
        (* list indexes in rc starts at 1, not 0 *)
        if i >= 1 && i <= List.length xs
        then Some ([List.nth xs (i-1)])
        else failwith (spf "out of bound, $%d too big for $*" i)
    )
  else (Var.vlook varname).R.v
@

%\subsection{Interpolation}


%******************************************************************************
\chapter{Builtins}
%******************************************************************************

\section{Overview}

<<function [[Builtin.is_builtin]]>>=
let is_builtin s =
  List.mem s [
    "cd"; 
    "."; "eval"; 
    "exit";
    "flag";
    "finit"
  ]
@
%TODO: "exec" ?

% op_SIMPLE -> <>
<<function [[Builtin.dispatch]]>>=
let dispatch (caps : < Cap.chdir; Cap.exit; Cap.open_in; ..>) s =
  match s with
  <<[[Builtin.dispatch()]] match [[s]] cases>>
  | _ -> failwith (spf "unsupported builtin %s" s)
@
%$

\section{[[$ cd]]}

<<[[Builtin.dispatch()]] match [[s]] cases>>=
| "cd" -> 
    let t = R.cur () in
    let argv = t.R.argv in
    (* default value in case something goes wrong below *)
    Status.setstatus "can't cd";

    (* less: cdpath vlook *)
    (match argv with
    | [_cd] -> 
        let v = (Var.vlook "home").R.v in
        (match v with
        | Some (dir::_) ->
          if dochdir caps dir
          then Status.setstatus ""
          (* less: %r *)
          else Logs.err (fun m -> m "Can't cd %s" dir)
        | _ -> Logs.err (fun m -> m "Can't cd -- $home empty")
        )
    | [_cd;dir] ->
        (* less: cdpath iteration *)
        if dochdir caps dir
        then Status.setstatus ""
        else Logs.err (fun m -> m "Can't cd %s" dir)
    | _ ->
        Logs.err (fun m -> m "Usage: cd [directory]");
    );
    R.pop_list()
@

<<function [[Builtin.dochdir]]>>=
let dochdir (caps : < Cap.chdir; .. >) s =
  try 
    Logs.info (fun m -> m "about to chdir to %s" s);
    CapUnix.chdir caps s;
    true
  with Unix.Unix_error _ ->
    false
@

\section{[[$ exit]]}

\section{[[$ .]]}

<<[[Builtin.dispatch()]] match [[s]] cases>>=
| "." ->
    let t = R.cur () in
    R.pop_word (); (* "." *)

    if !ndots > 0
    then Globals.eflagok := true;
    incr ndots;

    let iflag =
      match t.R.argv with
      | "-i"::_xs -> R.pop_word (); true
      | _ -> false
    in
    (match t.R.argv with
    | [] -> E.error caps "Usage: . [-i] file [arg ...]"
    | zero::args ->
        R.pop_word ();
        (* less: searchpath, also for dot? seems wrong *)
        (try 
          let file = zero in
          Logs.info (fun m -> m "evaluating %s" file);
          let chan = CapStdlib.open_in caps file in
          let newt = R.mk_thread dotcmds 0 (Hashtbl.create 10) in
          R.runq := [newt];
          R.push_redir (R.Close (Unix.descr_of_in_channel chan));
          newt.R.file <- Some file;
          newt.R.lexbuf <- Lexing.from_channel chan;
          newt.R.iflag <- iflag;
          (* push for $* *)
          R.push_list ();
          newt.R.argv <- args;
          (* push for $0 *)
          R.push_list ();
          newt.R.argv <- [zero];

        with Failure _ ->
          prerr_string (spf "%s: " zero);
          E.error caps ".: can't open"
        )
    ) 
@


<<constant [[Builtin.ndots]]>>=
let ndots = ref 0
@


<<constant [[Builtin.dotcmds]]>>=
(* for the builtin '.' (called 'source' in bash) *)
let dotcmds = 
  [|
    O.F O.Mark;
      O.F O.Word;
      O.S "0";
    O.F O.Local;

    O.F O.Mark;
      O.F O.Word;
      O.S "*";
    O.F O.Local;

    O.F O.REPL;

    O.F O.Unlocal;
    O.F O.Unlocal;
    O.F O.Return;
  |]         
@


\section{[[$ eval]]}

\subsection{[[$ flag]]}
% put earlier? used heavily in rcmain

<<global [[Flags.hflags]]>>=
let hflags: (char, bool) Hashtbl.t = Hashtbl.create 10
@

<<[[CLI.main()]] other initializations>>=
(* for 'flags' builtin (see builtin.ml) *)
argv |> Array.iter (fun s ->
  if s =~ "^-\\([a-zA-Z]\\)"
  then begin
    let letter = Regexp_.matched1 s in
    let char = String.get letter 0 in
    Hashtbl.add Flags.hflags char true
  end
);
@

<<[[Builtin.dispatch()]] match [[s]] cases>>=
| "flag" -> 
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [_flag;letter] ->
        (* stricter: *)
        if String.length letter <> 1
        then E.error caps "flag argument must be a single letter"
        else begin
          let char = String.get letter 0 in
          let is_set =
            try Hashtbl.find Flags.hflags char
            with Not_found -> false
          in
          Status.setstatus (if is_set then "" else "flag not set");
        end

    | [_flag;_letter;_set] ->
        failwith "TODO: flag letter +- not handled yet"

    | _ -> E.error caps ("Usage: flag [letter] [+-]")
    );
    R.pop_list()

@

\subsection{[[$ finit]]}

<<[[Builtin.dispatch()]] match [[s]] cases>>=
| "finit" -> 
   (* less: Xrdfn *)
   R.pop_list ()
@

\section{[[$ wait]]}



%******************************************************************************
\chapter{Environment}
%******************************************************************************
% worth a chapter?

\section{[[Updenv()]]}

\section{[[Vinit()]]}

%\section{Functions in the environment}


%******************************************************************************
\chapter{Signals}
%******************************************************************************




%******************************************************************************
\chapter{Initialization}
%******************************************************************************



\section{Actual bootstrapping code}

<<function [[CLI.bootstrap]]>>=
(* The real one is more complex:
 *  *=(argv);. /usr/lib/rcmain $*
 * Boostrap is now a function because it uses a flag that can be
 * modified after startup.
 *)
let bootstrap () : O.opcode array = 
  [| 
      O.F O.Mark;
        O.F O.Word;
        O.S "*";
      O.F O.Assign; (* will pop_list twice *)

      O.F O.Mark;
        O.F O.Mark;
          O.F O.Word;
          O.S "*";
        O.F O.Dollar; (* will pop_list once *)
        O.F O.Word;
        O.S !Flags.rcmain; (* can be changed -m *)
        O.F O.Word;
        O.S ".";
      O.F O.Simple; (* will pop_list once *)

      O.F O.Exit;
  |]
@
%$

\section{Intitialization script and [[rc -m /path/to/rcmain]]}

<<constant [[Flags.rcmain]]>>=
(* can be changed with -m *)
let rcmain = ref "/rc/lib/rcmain"
@

<<[[CLI.main()]] [[options]] elements>>=
"-m", Arg.Set_string Flags.rcmain,
" <file> read commands to initialize rc from file, not /rc/lib/rcmain";
@


\section{Actual environment}




%******************************************************************************
\chapter{Globbing}
%******************************************************************************

<<[[Opcode.operation]] other cases>>=
(* Globbing *)
| Glob (* (value?) *)
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (value?) *)
| O.Glob ->
    Logs.err (fun m -> m "TODO: interpret Glob");
    ()
@
%TODO: but should be emitted far more no? Even in Simple
% we should emit no?

\section{Lexing globbing characters}

\section{Expanding globbing characters}

\section{[[glob()]]}

\section{[[match()]]}






%******************************************************************************
\chapter{Debugging for the [[rc]] User}
%******************************************************************************

\section{Printing commands: [[rc -x]]}

<<constant [[Flags.xflag]]>>=
(* -x, to print simple commands before executing them *)
let xflag = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-x", Arg.Set Flags.xflag,
" print each simple command before executing it";
@

<<[[Op_process.op_Simple()]] possibly dump command>>=
(* less: globlist () *)
if !Flags.xflag 
then Logs.app (fun m -> m "%s" (String.concat " " argv));
@

\section{Printing subprocesses status: [[rc -s]]}

<<constant [[Flags.sflag]]>>=
(* -s, to print status when error in command just ran *)
let sflag = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-s", Arg.Set Flags.sflag,
" print exit status after any command where the status is non-null";
@
<<[[Op_repl.op_REPL()]] if [[sflag]]>>=
(* todo: flush error and reset error count *)
if !Flags.sflag && not (Status.truestatus()) 
then Logs.app (fun m -> m "status=%s" (Status.getstatus ()));
@

\section{Logging: [[rc -v]]}
%ocaml: NEW

<<[[CLI.main()]] debugging initializations>>=
let level = ref (Some Logs.Warning) in
@

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
(* TODO: move in a CLI_common.ml *)
"-v", Arg.Unit (fun () -> level := Some Logs.Info),
 " verbose mode";
"-verbose", Arg.Unit (fun () -> level := Some Logs.Info),
" verbose mode";
"-quiet", Arg.Unit (fun () -> level := None),
" ";
"-debug", Arg.Unit (fun () -> level := Some Logs.Debug),
" trace the main functions";
@

<<[[CLI.main()]] logging initializations>>=
Logs.set_level !level;
Logs.info (fun m -> m "ran as %s from %s" argv.(0) (Sys.getcwd ()));
@

\section{Failing fast: [[rc -e]]}
% very important, especially when using rc with mk!

<<constant [[Flags.eflag]]>>=
(* -e, for strict error checking. Abort the script when an error happens.*)
let eflag = ref false
@
% passed down a lot in outcode (why not use Flags.eflag instead
% of passing it down?)

<<[[CLI.main()]] [[options]] elements>>=
"-e", Arg.Set Flags.eflag,
" exit if $status is non-null after a simple command";
@



<<[[Opcode.operation]] other cases>>=
(* Error management *)
| Eflag
@

<<[[Compile.outcode_seq]] in [[A.Simple]] case after emit [[O.Simple]]>>=
if eflag 
then emit (O.F O.Eflag);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Eflag ->
    if !Globals.eflagok && not (Status.truestatus())
    then Process.exit caps (Status.getstatus())
@

<<[[Compile.outcode_seq]] in [[A.Match]] case after emit [[O.Match]]>>=
if eflag 
then emit (O.F O.Eflag);
@
% why eflag also for Match?

\section{Strict mode: [[rc -strict]]}
%ocaml: NEW

<<constant [[Flags.strict_mode]]>>=
let strict_mode = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-strict", Arg.Set Flags.strict_mode,
" strict mode";
@

%******************************************************************************
\chapter{Advanced Features}
%******************************************************************************
%alt: Advanced Topics

%\section{Shell-like features implemented outside [[rc]]}
% completion, history (readline?), ...
% done in rio!


\section{Reading commands from a string: [[rc -c]]}

\section{Unicode}



\section{Advanced constructs}



<<[[Ast.cmd]] other definition cases>>=
| DelFn of value
@
<<[[Opcode.operation]] other cases>>=
| DelFn (* (name) *)
(* less: RdFn *)
@
<<[[Parser.cmd]] other cases>>=
| TFn word       { DelFn $2 }
@
<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.DelFn w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.DelFn);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.DelFn ->
    let t = R.cur () in
    let argv = t.R.argv in
    argv |> List.iter (fun s ->
      let x = Fn.flook s in
      match x with
      | Some _ -> Hashtbl.remove R.fns s
      | None -> 
          (* stricter: *)
          if !Flags.strict_mode
          then E.error caps (spf "deleting undefined function %s" s)
    );
@

\subsection{Subshell: [[@ <cmd>]]}

<<Parser tokens, operators other cases>>=
%token TSubshell
@

<<[[Opcode.operation]] other cases>>=
(* ?? *)
| Subshell (* {... Xexit} *)
@

<<[[Lexer.token()]] symbol cases>>=
| "@" { TSubshell }
@

<<[[Parser.keyword]] other cases>>=
| TSubshell { "@" }
@

\subsection{Count and indexing of variables: [[$#<foo>]], [[$<foo>(...)]]} %$

<<Parser tokens, variables other cases>>=
%token TCount
@

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Count w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Count);
@


<<[[Ast.value]] other cases>>=
| Count of value (* $#foo *)
| Index of value * values (* $foo(...) *)
@
%$

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.Count ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] -> 
        (* less: deglob *)
        let value = vlook_varname_or_index varname in
        let num = 
          match value with
          | None -> 0
          | Some xs -> List.length xs
        in
        R.pop_list ();
        R.push_word (spf "%d" num)
    | _ -> E.error caps "variable name not singleton!"
    )
@


<<[[Lexer.token()]] variable cases>>=
| "$#"  { TCount }
@

<<[[Opcode.operation]] other stack cases>>=
| Count (* (name) *)
| Concatenate (* (left)(right) *)
| Stringify (* (name) *)
@

<<[[Opcode.operation]] other variable cases>>=
| Index  (* ??? *)
| Local (* (name)(val) *)
| Unlocal (* *)
@

\subsection{Command output as a file: \texttt{'<\{<cmd>\}'}}

<<Parser tokens, punctuation other cases>>=
%token TBackquote
@

<<[[Ast.value]] other cases>>=
(* this causes the value and cmd types to be mutually recursive. Uses $IFS *)
| CommandOutput of cmd_sequence
@
%$

<<[[Opcode.operation]] other cases>>=
| Backquote (* {... Xreturn} *)
@

<<[[Lexer.token()]] symbol cases>>=
| "`" { TBackquote } 
@

<<[[Parser.comword]] other cases>>=
| TBackquote brace              { CommandOutput $2 }
@

\subsection{Command substitution: \texttt{`\{<cmd>\}}}

\subsection{Read-write redirections: [[<> <file>]]}

\subsection{General redirections: [[>[2] <file>]]}

<<[[Lexer.token()]] symbol cases>>=
| ">[" (['0'-'9']+ (*as fd0*)) "=" (['0'-'9']+ (*as fd1*)) "]" 
       {  let fd0 = failwith "TODO: fd0" in
   let fd1 = failwith "TODO: fd1" in
   TDup (Ast.RWrite, int_of_string fd0, int_of_string fd1)
}
| ">>[" (['0'-'9']+ (*as fd0*)) "=" (['0'-'9']+ (*as fd1*)) "]" 
       {
           let fd0 = failwith "TODO: fd0" in
    let fd1 = failwith "TODO: fd1" in
    TDup (Ast.RAppend, int_of_string fd0, int_of_string fd1)
}
(* less: advanced pipe and redirection *)
@

\subsection{Advanced dup: [[>[<fd0>=<fd1>]] ], [[<>[<fd0>=<fd1>] ]], [[<[<fd0>=<fd1>] ]]}

%LP: distribute to advanced or later
<<Parser tokens, operators other cases>>=
%token<Ast.redirection_kind * int * int> TDup
@

<<[[Parser.redir]] other cases>>=
| TDup        { Right $1 }
@


<<[[Ast.redirection_kind]] other cases>>=
(* less: RHere *) (* < < *)
| RDup of int * int (* >[x=y] *)
@

<<[[Ast.cmd]] other redirection cases>>=
| Dup of cmd * redirection_kind * int * int (* >[1=2] *)
@

\subsection{Advanced pipes: [[|[<fd>] ]], [[|[<fd0>=<fd1>] ]]}

\subsection{Here documents: [[<< <HERE>]]}

\subsection{Stringification of variables: [[$"<foo>]]} %$

<<Parser tokens, variables other cases>>=
%token TStringify
@
<<[[Lexer.token()]] variable cases>>=
| "$\"" { TStringify }
@
%$


<<[[Ast.value]] other cases>>=
| Stringify of value (* $"foo " *)
@
%$

<<[[Parser.comword]] other cases>>=
| TCount word                   { Count $2 }
| TDollar word TSub words TCPar { Index ($2, $4) }
| TStringify word               { Stringify $2 }
@

<<Parser tokens, punctuation other cases>>=
%token TSub
@



\subsection{String concatenation}

<<Parser tokens, punctuation other cases>>=
%token TCaret
@

<<[[Parser.word]] other cases>>=
| word TCaret word { Concat ($1, $3) }
@
<<[[Parser.first]] other cases>>=
| first TCaret word { Concat ($1, $3) }
@

<<[[Lexer.token()]] symbol cases>>=
| "^" { TCaret }
@

<<[[Ast.value]] other cases>>=
(* ^ distributes over lists *)
| Concat of value * value
@

\section{Advanced builtins}

\subsection{[[$ exec]]}

\subsection{[[$ whatis]]}

\subsection{[[$ rfork]]}

\subsection{[[$ shift]]}


%******************************************************************************
\chapter{Conclusion}
%******************************************************************************
\label{chap:conclusion}


%******************************************************************************
\appendix
%******************************************************************************


%******************************************************************************
\chapter{Debugging for the [[mk]] Developer}
%******************************************************************************

\section{Exception backtraces}
%TODO: disable by default!
%alt: move in Error management appendix later?

<<constant [[Flags.debugger]]>>=
let debugger = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
"-debugger", Arg.Set Flags.debugger,
" ";
@

<<[[CLI.main()]] when [[exn]] thrown in [[interpret()]]>>=
if !Flags.debugger
then raise exn
else 
  (match exn with
  <<[[CLI.main()]] when [[Failure]] [[exn]] thrown in [[interpret()]]>>
  (* alt: could catch Exit.ExitCode here but this is done in Main.ml *)
  | _ -> raise exn
  )
@

\section{Dumpers}

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-dump_tokens", Arg.Set Flags.dump_tokens,
" dump the tokens as they are generated";
"-dump_ast", Arg.Set Flags.dump_ast,
" dump the parsed AST";
"-dump_opcodes", Arg.Set Flags.dump_opcodes,
" dump the generated opcodes ";
@

\subsection{Dumping tokens}

<<[[Parse.lexfunc()]] possibly dump tokens>>=
|> (fun tok -> 
    if !Flags.dump_tokens 
    then Logs.app (fun m -> m "%s" (Dumper.dump (tok,s)));
    tok)
@

\subsection{Dumping the AST}

<<[[Parse.parse_line()]] possibly dump AST>>=
|> (fun ast -> if !Flags.dump_ast then Logs.app (fun m -> m "%s" (Dumper_.s_of_line ast)); ast)
@

\subsection{Dumping the opcodes}

\subsection{XXX}

<<signature [[Dumper_.s_of_cmd]]>>=
val s_of_cmd : Ast.cmd -> string
@

<<signature [[Dumper_.s_of_opcode]]>>=
val s_of_opcode : Opcode.opcode -> string
@

<<signature [[Dumper_.s_of_line]]>>=
val s_of_line : Ast.line -> string
@

<<signature [[Dumper_.s_of_cmd_sequence]]>>=
val s_of_cmd_sequence : Ast.cmd_sequence -> string
@

<<signature [[Dumper_.s_of_value]]>>=
val s_of_value : Ast.value -> string
@

<<signature [[Dumper_.s_of_codevec]]>>=
val s_of_codevec : Opcode.codevec -> string
@

<<signature [[Dumper_.s_of_operation]]>>=
val s_of_operation : Opcode.operation -> string
@



<<constant [[Flags.dump_tokens]]>>=
let dump_tokens = ref false
@

<<constant [[Flags.dump_ast]]>>=
let dump_ast = ref false
@

<<constant [[Flags.dump_opcodes]]>>=
let dump_opcodes = ref false
@

<<[[Compile.compile()]] possibly dump returned opcodes>>=
|> (fun x -> if !Flags.dump_opcodes then Logs.app (fun m -> m "%s" (Dumper_.s_of_codevec x)); x)
@
<<function [[Dumper_.s_of_line]]>>=
let s_of_line x =
  let v = Meta_ast.vof_line x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_cmd_sequence]]>>=
let s_of_cmd_sequence x =
  let v = Meta_ast.vof_cmd_sequence x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_cmd]]>>=
let s_of_cmd x =
  let v = Meta_ast.vof_cmd x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_value]]>>=
let s_of_value x =
  let v = Meta_ast.vof_value x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_opcode]]>>=
let s_of_opcode x =
  let v = Meta_opcode.vof_opcode x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_operation]]>>=
let s_of_operation x =
  let v = Meta_opcode.vof_operation x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_codevec]]>>=
let s_of_codevec x =
  let xs = Array.to_list x in
  let v = Ocaml.vof_list Meta_opcode.vof_opcode xs in
  Ocaml.string_of_v v
@


\section{Bytecode generator trace: [[rc -r]]}

<<constant [[Flags.rflag]]>>=
(* -r, similar to dump_opcodes, but at each step *)
let rflag = ref false
@


<<[[CLI.main()]] [[options]] elements>>=
"-r", Arg.Set Flags.rflag,
" print internal form of commands (opcodes)";
@

<<[[CLI.interpret()]] if [[rflag]]>>=
(* less: cycle =~ codevec pointer *)
if !Flags.rflag
then Logs.app (fun m -> m "pid %d %d %s %s"
            (Unix.getpid ())
            !pc
            (Dumper_.s_of_opcode t.R.code.(!pc))
            ( (t.R.argv::t.R.argv_stack) |> List.map (fun xs ->
                spf "(%s)" (String.concat " " xs)
               ) |> String.concat " "));
@


\section{Printing characters: [[rc -v]]}
% hmm I've used it for verbose now

\section{Printing all characters: [[rc -V]]}





\section{CLI actions}

<<[[CLI.main()]] debugging initializations>>=
let action = ref "" in
@

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-test_parser", Arg.Unit (fun () -> action := "-test_parser"), " ";
@

<<[[CLI.main()]] CLI action processing>>=
(* to test and debug components of mk *)
if !action <> "" then begin 
  do_action caps !action (List.rev !args); 
  raise (Exit.ExitCode 0)
end;
@


<<function [[CLI.do_action]]>>=
let do_action caps s xs =
  match s with
  | "-test_parser" ->
      xs |> List.iter (fun file ->
        let file = Fpath.v file in
        Logs.info (fun m -> m "processing %s" !!file);
        file |> FS.with_open_in caps (fun (chan : Chan.i) ->
          let lexbuf = Lexing.from_channel chan.Chan.ic in

          (* for error reporting I need a runq *)
          let t = Runtime.mk_thread [||] 0 (Hashtbl.create 0) in
          R.runq := t::!R.runq;
          t.R.file <- Some !!file;

          let rec loop () =
            let line = Parse.parse_line lexbuf in
            match line with
            | Some seq -> 
              Logs.app (fun m -> m "%s" (Dumper_.s_of_cmd_sequence seq));
              loop ();
            | None -> ()
          in
          loop ()
       )
      )

  | _ -> failwith ("action not supported: " ^ s)
  (* old: do that in caller now, so more explicit 
  runq := t::!runq
  *)
@


%\chapter{Error Management}


%******************************************************************************
\chapter{Examples of [[rc]] scripts}
%******************************************************************************

\section{[[/rc/lib/rcmain]]}


\section{[[/home/pad/lib/profile]]}



%\chapter{Changelog}
% code via make loc = ?? LOC, after full lpized  ? LOC
% orig Rc.nw = ?? LOC, after full lpized and comments in sections ??
% now: =~ ?? LOC so added ?? LOE (Lines of explanations)
% rc in C: ? LOC (but more features)

\ifallcode
#include "Rc_extra.nw"
\fi

%******************************************************************************
\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
LOC = Lines Of Code
CLI = Command-Line Interface
\end{verbatim}


\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
