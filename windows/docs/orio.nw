\documentclass[12pt]{report}

\input{latex/Packages}
\input{latex/Noweb}
\input{latex/Config}
\input{latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:

%thx to this manual, better understand rio/windowing-system:

%history LP-ization:

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Windowing System [[rio]]
}\\
OCaml edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike and Yoann Padioleau
}

\maketitle 

%\onecolumn
\hrule
\begin{quote}
Copyright \copyright{} 2025-2026 Yoann Padioleau \\
Permission is granted to copy, distribute and/or modify this document,
except all the source code it contains, under the terms of the GNU Free
Documentation License, Version 1.3.
\end{quote}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup


%******************************************************************************
\chapter{Introduction}
%******************************************************************************

#include "Intro.nw"

%\chapter{Overview}
% now in Intro.nw too

\section{[[hellorio.ml]]}

<<constant [[Hellorio._]]>>=
let _ =
  Cap.main (fun caps -> thread_main caps)
@

<<function [[Hellorio.thread_main]]>>=
(* the Keyboard.init() and Mouse.init() below create other threads *)
let thread_main (caps : < Cap.draw; Cap.open_in; Cap.keyboard; Cap.mouse; .. >) =
  let display : Display.t = Draw.init caps "Hello Rio" in
  let view : Display.image = Draw_rio.get_view caps display in

  let kbd : Keyboard.ctl = Keyboard.init caps in
  let mouse : Mouse.ctl = Mouse.init caps in

  let bgcolor : Image.t  = 
    Image.alloc display Rectangle.r_1x1 Channel.rgba32 true Color.magenta
  in
  (* if does not use originwindow, then need to add view.r.min *)
  let mousepos = ref (Point.add view.r.Rectangle.min (Point.p 10 10)) in

  redraw display view !mousepos bgcolor;

  while true do
    <<[[Hellorio.thread_main()]] in event loop>>
    redraw display view !mousepos bgcolor;
  done
@

<<function [[Hellorio.redraw]]>>=
let redraw (display : Display.t) (view : Display.image) (pos : Point.t)
     (bgcolor : Image.t) : unit =
  Draw.draw view view.r bgcolor None Point.zero;
  (* todo: Text.string *)
  Line.line view pos (Point.add pos (Point.p 100 100))
    Line.EndSquare Line.EndSquare 2 display.black Point.zero;
  Display.flush display
@
%ocaml: less globals, pass down view and display

<<type [[Hellorio.event]]>>=
type event =
  | Mouse of Mouse.state
  | Key of Keyboard.key
  (* less: Resize *)
@

<<[[Hellorio.thread_main()]] in event loop>>=
let ev : event = 
  [
    Keyboard.receive kbd |> (fun ev -> Event.wrap ev (fun x -> Key x));
    Mouse.receive mouse |> (fun ev -> Event.wrap ev (fun x -> Mouse x));
  ] |> Event.select
in
(match ev with
| Mouse m -> 
  mousepos := m.pos
| Key c ->
  if c = 'q'
  then exit 0
  else Logs.app (fun m -> m "%c" c)
(* less: 
 * | Resize -> view := getwindow display
 *)
);
@



\section{Code organization}
\label{tab:code-orga}

\section{Software architecture}

\subsection{Processes,  procs, and threads relationships}
\label{sec:thread-archi}
\label{fig:soft-archi-threads}
\label{fig:hellorio-and-shell}

\subsection{Trace of a new window creation}
\label{sec:trace-new-window}
\label{sec:new-namespace}
\label{sec:new-thread}
\label{sec:new-layer}

\subsection{Trace of a mouse click}
\label{sec:trace-mouse-click}

\subsection{Trace of a key press}
\label{sec:trace-key-press}

\subsection{Trace of a drawing operation}
\label{sec:trace-draw}

\section{Book structure}

%###############################################################################


%******************************************************************************
\chapter{Core Data Structures}
%******************************************************************************
\label{chap:core-ds}

\section{Device handles}

\subsection{Output device: [[display]] and [[view]]}
%ocaml: not globals anymore, passed down functions

\subsection{Input devices: [[mouse]] and [[kbd]]}%%[[mousectl]] and [[keyboardctl]]}
%ocaml: also not globals anymore! threads can be passed arguments!

\section{Desktop}%%, [[desktop]]}
%ocaml: also not a global anymore

<<constant [[Globals.red]]>>=
let red               = ref Display.fake_image
@

\section{Windows}
\label{sec:core-ds-Windows}

\subsection{[[Window.t]]}

<<type [[Window.t]]>>=
(* The window type! *)
type t = {
  (* ---------------------------------------------------------------- *)
  (* ID *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] id fields>>

  (* ---------------------------------------------------------------- *)
  (* Graphics *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] graphics fields>>

  (* ---------------------------------------------------------------- *)
  (* Mouse *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] mouse fields>>

  (* ---------------------------------------------------------------- *)
  (* Keyboard *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] keyboard fields>>

  (* ---------------------------------------------------------------- *)
  (* Commands *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] command fields>>

  (* ---------------------------------------------------------------- *)
  (* Process *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] process fields>>

  (* ---------------------------------------------------------------- *)
  (* Config *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] config fields>>

  (* ---------------------------------------------------------------- *)
  (* Wm *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] wm fields>>

  (* ---------------------------------------------------------------- *)
  (* Textual Window *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] textual window fields>>

  (* ---------------------------------------------------------------- *)
  (* Graphical Window *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] graphical window fields>>

  (* ---------------------------------------------------------------- *)
  (* Concurrency *)
  (* ---------------------------------------------------------------- *)
  (* less: 
   * - a Ref (Mutex.t? atomic anyway in ocaml), ref counting
   *   or simply a counter as there is no race issue for rio-ocaml.
   * - Qlock (Condition.t?), needed for?
   *)

  (* ---------------------------------------------------------------- *)
  (* Misc *)
  (* ---------------------------------------------------------------- *)
  <<[[Window.t]] other fields>>
}
@

<<type [[Window.wid]]>>=
(* window id *)
type wid = int
@


<<[[Window.t]] id fields>>=
(* visible in /mnt/wsys/winid (and used for /mnt/wsys/<id>/devs) *)
id: wid;
(* public named image, visible in /mnt/wsys/winname; change when resize *)
mutable winname: string;
@

<<global [[Window.wid_counter]]>>=
let wid_counter = 
  ref 0
@


<<[[Window.t]] id fields>>=
(* writable through /mnt/wsys/label *)
mutable label: string;
@





<<[[Window.t]] graphics fields>>=
(* This is most of the time a layer, but it can also be a plain Image.t
 * when the window is hidden.
 * less: option? when delete the window structure and thread is still
 * out there because we wait for the process to terminate?
 *)
mutable img: Image.t;
@

<<[[Window.t]] graphics fields>>=
(* todo: for originwindow and really virtual screen? vs img.r? *)
mutable screenr: Rectangle.t;
@


%XXX
<<[[Window.t]] graphics fields>>=
(* writable through /mnt/wsys/cursor *)
mutable mouse_cursor: Cursor.t option;
@


<<[[Window.t]] mouse fields>>=
(* Threads_window.thread --> Thread_fileserver.dispatch(Read).
 * The channel inside the channel will be used to write a mouse state
 * to thread_fileserver.
*)
chan_devmouse_read: Mouse.state Event.channel Event.channel;

(* Note that we do not queue all mouse states; just the clicks/releases,
 * otherwise the queue would be too big when you move around the mouse.
 * less: max size = ? mutex around? recent queue.mli says not thread-safe 
 *)
mouseclicks_queue: (Mouse.state * mouse_counter) Queue.t;
(* less: could have simpler mouse_new_event: bool? *)
mutable mouse_counter: mouse_counter;
mutable last_count_sent: mouse_counter;

(* we do not queue all mouse states (we queue just the clicks/releases);
 * for the rest (moving the mouse) we just keep the last state.
 *)
mutable last_mouse: Mouse.state;
(* ?? how differ from last_mouse.buttons? *)
mutable last_buttons: Mouse.buttons;
@


<<[[Window.t]] keyboard fields>>=
(* Threads_window.thread --> Thread_fileserver.dispatch(Read).
 * The first channel will be used by thread_fileserver to indicate the
 * number of bytes the process wants to read from its /dev/cons. The second
 * channel will be used to send the bytes to thread_fileserver.
 * Note that we send bytes, even though we read keys.
*)
chan_devcons_read: (int Event.channel * string Event.channel) Event.channel;

(* Threads_window.thread --> Thread_fileserver.dispatch(Write).
 * Note that we send full runes, not bytes.
 * The channel inside will be used to read from thread_fileserver(Write)
 * the data the process wrote to its /dev/cons.
 *)
chan_devcons_write: (Rune.t list Event.channel) Event.channel;

(* see also Window.terminal below for keys when in non-raw (buffered) mode *)
raw_keys: Keyboard.key Queue.t;
@


<<[[Window.t]] process fields>>=
(* not really mutable, but set after Window.alloc() *)
mutable pid: int;
(* can be changed through /mnt/wsys/wdir *)
mutable pwd: Fpath.t;
(* todo? notefd *)
@

<<[[Window.t]] config fields>>=
mutable auto_scroll: bool;
@

<<[[Window.t]] graphical window fields>>=
(* can also be used in textual windows, but more rare *)
mutable consctl_opened: bool;
mutable raw_mode: bool;
@


\subsection{[[windows]]}

<<global [[Globals.windows]]>>=
let windows: (Window.wid, Window.t) Hashtbl.t = Hashtbl_.create ()
@

<<type [[Window.topped_counter]]>>=
type topped_counter = int
@

<<global [[Window.topped_counter]]>>=
let topped_counter =
  ref 0
@

<<[[Window.t]] wm fields>>=
mutable topped: topped_counter;
@


%XXX
<<global [[Globals.hidden]]>>=
(* a subset of 'windows' *)
let hidden: (Window.wid, Window.t) Hashtbl.t = Hashtbl_.create ()
@

\subsection{[[current]]}
\label{sec:current}

<<global [[Globals.current]]>>=
(* the man page of rio (rio(1)) uses the term 'current' 
 * old: was called 'input' in rio
 *)
let current: Window.t option ref  = ref None
@

<<function [[Globals.win]]>>=
(* a bit like cpu(), up() in the kernel, a convenient global *)
let win () =
  !current
@

\subsection{Graphical windows}

<<[[Window.t]] graphical window fields>>=
mutable mouse_opened: bool;
@

\subsection{Textual windows}

<<[[Window.t]] textual window fields>>=
terminal: Terminal.t;
@

\section{Filesystem server}


\subsection{[[Fileserver.t]]}%% and [[filsys]]}
%ocaml: no filsys global

<<type [[Fileserver.t]]>>=
type t = {
  (* the pipe *)

  (* clients_fd will be shared by all the winshell processes *)
  clients_fd: Unix.file_descr;
  server_fd: Unix.file_descr;

  (* for security *)
  user: string;

  (* the files managed by the server currently-in-use by the client *)
  fids: (File.fid, File.t) Hashtbl.t;

  <<[[Fileserver.t]] other fields>>
}
@

%XXX
<<[[Fileserver.t]] other fields>>=
(* refined after Tversion first message *)
mutable message_size: int;
@

\subsection{File state and file ids}

<<type [[File.fid]]>>=
(* This is maintained by the "client" (the kernel on behalf of a winshell) *)
type fid = Protocol_9P.fid
@

<<type [[File.t]]>>=
(* fid server-side state (a file) *)
type t = {
  (* The fid is maintained by the "client" (the kernel on behalf of winshell).
   * It is the key used to access information about a file used by
   * the client (it's redundant in File.t because it is also the key in
   * Fileserver.t.fids)
   *)
  fid: fid;

  (* the state *)
  mutable opened: Plan9.open_flags option;

  <<[[File.t]] other fields>>
}
@

%XXX
<<[[File.t]] other fields>>=
(* The qid is what is returned by the "server" to identify a file (or dir).
 * It is mutable because a fid can be 'walked' to point to another file
 * on the server.
 *)
mutable qid: Plan9.qid;
(* for stat (mutable for the same reason than qid above) *)
mutable entry: dir_entry_short;

(* less: we could also use a wid *)
win: Window.t;

(* less: nrpart for runes *)
@

%XXX
<<type [[File.filecode]]>>=
(* This is returned by the server (rio) to identify a file of the server *)
type filecode = 
  | Dir of dir
  | File of devid
@

%%\subsection{Workers and jobs: [[Xfid]]}

%%\subsection{9P callbacks: [[fcall]]}

\section{Devices}
%ocaml: new section, new type

<<type [[Device.t]]>>=
type t = {
  (* ex: "winname", "cons" *)
  name: string;
  perm: Plan9.perm_property;

  (* called when a process is opening/closing the device *)
  open_: Window.t -> unit;
  close: Window.t -> unit;
  
  (* called when a process is reading/writing on the device.
   *
   * we need to thread 'read' (and 'write') because this operation may spend
   * some time waiting while receiving and sending information on channels.
   * 
   * Note that 'read' takes an offset (and count) because each device 
   * can honor or not the offset requirements. For instance,
   * /dev/winname does honor offset but /dev/mouse does not.
   *)
  read_threaded: int64 -> int -> Window.t -> string (* bytes *);
  write_threaded: int64 -> string (* bytes *) -> Window.t -> unit;
}
@

<<constant [[Device.default]]>>=
let default = {
  name = "<default>";
  perm = Plan9.rw;
  open_ = (fun _ -> ());
  close = (fun _ -> ());
  read_threaded = (fun _ _ _ -> "");
  write_threaded = (fun _ _ _ -> ());
}
@


%******************************************************************************
\chapter{[[main()]]}
%******************************************************************************
\label{chap:main}

<<toplevel [[Main._1]]>>=
let _ = 
  Cap.main (fun (caps : Cap.all_caps) ->
     Exit.exit caps (Exit.catch (fun () -> CLI.main caps (CapSys.argv caps)))
  )
@


<<type [[CLI.caps]]>>=
(* Need:
 * - draw/mouse/keyboard because rio multiplexes access to those devices
 * - fork/exec/chdir when creating new windows which trigger new rc
 *   processes run possibly from different directories.
 * - open_in: for /dev/winname access
 * - mount/bind: for the window to mount the rio fileserver to /mnt/wsys
 *   and then bind it to /dev for virtual /dev/{cons,mouse,...}
 *)
type caps = < 
    Cap.draw; Cap.mouse; Cap.keyboard;
    Cap.fork; Cap.exec; Cap.chdir;
    Cap.open_in;
    Cap.mount; Cap.bind
  >
@

<<signature [[CLI.main]]>>=
(* entry point (can also raise Exit.ExitCode) *)
val main: <caps; Cap.stdout; Cap.stderr; ..> ->
  string array -> Exit.t
@

<<constant [[CLI.usage]]>>=
let usage = 
  "usage: rio [options]"
@


%XXX
<<[[CLI.main()]] [[options]] elements>>=
"-s", Arg.Unit (fun () -> raise Todo),
" ";
@
<<[[CLI.main()]] [[options]] elements>>=
"-font", Arg.String (fun _s -> raise Todo),
" <fontname>";
@
<<[[CLI.main()]] [[options]] elements>>=
"-i", Arg.String (fun _s -> raise Todo),
" <initcmd>";
@
<<[[CLI.main()]] [[options]] elements>>=
"-k", Arg.String (fun _s -> raise Todo),
" <kbdcmd>";
@
<<[[CLI.main()]] [[options]] elements>>=
"-test", Arg.Unit (fun () -> Test.test ()),
" ";
@

<<function [[CLI.main]]>>=
let main (caps : < caps; Cap.stdout; Cap.stderr; ..>) (argv : string array) :
    Exit.t =
  <<[[CLI.main()]] locals>>
  let options = [
    <<[[CLI.main()]] [[options]] elements>>
  ] |> Arg.align
  in
  (* This may raise ExitCode *)
  Arg_.parse_argv caps argv options (fun _f -> Arg.usage options usage) usage;
  <<[[CLI.main()]] logging setup>>
  try 
    (* the main call *)
    thread_main caps
  with exn ->
      <<[[CLI.main()]] handle [[exn]]>>
@


<<signature [[CLI.thread_main]]>>=
(* main thread which will itself create mouse/keyboard/fs/... threads *)
val thread_main: < caps; ..> -> Exit.t
@

<<function [[CLI.thread_main]]>>=
let thread_main (caps: < caps; .. >) : Exit.t =

  (* Rio, a graphical application *)
  <<[[CLI.thread_main()]] graphics initializations>>

  (* Rio, a filesystem server *)
  let fs = Fileserver.init () in

  (* Rio, a concurrent application *)
  let (exit_chan: Exit.t Event.channel) = Event.new_channel () in
  <<[[CLI.thread_main()]] threads creation>>

  (* Wait *)
  let exit_code = Event.receive exit_chan |> Event.sync in
  (* todo: kill all procs? all the winshell processes? *)
  (* todo: kill all threads? done when do exit no? *)
  exit_code
@

\section{Graphics initialization}

<<[[CLI.thread_main()]] graphics initializations>>=
let display : Display.t = Draw.init caps "orio" in
(* alt: simpler (but does not allow rio under rio in): 
 * let view = display.image in
 * less: let viewr save?
 *)
let view : Display.image = Draw_rio.get_view caps display in
let font : Font.t = Font_default.load_default_font display in

<<[[CLI.thread_main()]] graphics initializations, debug>>

let background = Image.alloc_color display (Color.mk2 0x77 0x77 0x77) in
Globals.red   := Image.alloc_color display (Color.mk2 0xDD 0x00 0x00);
Globals.title_color       := Image.alloc_color display Color.greygreen;
Globals.title_color_light := Image.alloc_color display Color.palegreygreen;

let desktop : Baselayer.t = Baselayer.alloc view background in

Draw.draw_color view view.r background;
  (* to test: alternative to -test that leverages work done above
  Test.test_display_default_font display view;
  Test.test_display_text display view font;
  *)

Display.flush display;
@

<<constant [[Globals.title_color]]>>=
let title_color       = ref Display.fake_image
@
<<constant [[Globals.title_color_light]]>>=
let title_color_light = ref Display.fake_image
@

%%\section{Mouse initialization}
%%\section{Keyboard initialization}
%%\section{Channels creation}

\section{Threads creation}

<<[[CLI.thread_main()]] threads creation>>=
(* To break some mutual dependencies.
 * The mouse right-click and menu will trigger the creation
 * of new windows and new window threads and call this function.
 *)
Wm.threads_window_thread_func := Threads_window.thread;
@
% must be done before we create thhe mouse thread?

<<[[CLI.thread_main()]] threads creation>>=
let mouse : Mouse.ctl = Mouse.init caps in
let kbd : Keyboard.ctl = Keyboard.init caps in

let _kbd_thread   = 
  Thread.create Thread_keyboard.thread kbd in

let _mouse_thread = 
  Thread.create (Thread_mouse.thread caps)
     (exit_chan, 
      mouse, (display, desktop, view, font),
      fs) in

let _fileserver_master_thread =
  Thread.create Threads_fileserver.thread fs in
@

\section{Filesystem server initialization}

\subsection{[[Fileserver.init()]]}%%[[filsysinit()]]}

<<signature [[Fileserver.init]]>>=
(* internally creates a pipe between clients_fd/server_fd above *)
val init: unit -> t
@

<<function [[Fileserver.init]]>>=
let init () =
  let (fd1, fd2) = Unix2.pipe () in
  (* the default threadUnix implementation just set non_block for fd2
   * (the 'in_fd'), but in plan9 pipes are bidirectional so we need 
   * to set non_block for fd1 too.
   *)
  Unix.set_nonblock fd1;
  (* todo? record fd2 as close_on exec? 
   * Unix.set_close_on_exec? but when it's useful really? just cleaner/safer?
   *)
 
  { clients_fd = fd1;
    server_fd = fd2;

    (* todo: let user = Common.cat "/dev/user" |> String.concat "" in *)
    user = "pad";
    message_size = 8192 + Protocol_9P.io_header_size;

    fids = Hashtbl_.create ();
  }
@

%%\subsection{Worker allocator: [[xfidinit()]]}

%******************************************************************************
\chapter{Threads} %% Procs and Threads
%******************************************************************************
\label{chap:processes-threads}
%ocaml: no Procs and Threads, just threads as Thread do not block
% on unix calls (thx to ThreadUnix) so no need intermediate proc
% to do the read and thread for the channel.

\section{Keyboard thread}

<<signature [[Thread_keyboard.thread]]>>=
(* Reads from the keyboard and sends the key to the "current" window *)
val thread: Keyboard.ctl -> unit
@

<<function [[Thread_keyboard.thread]]>>=
let thread (kbd : Keyboard.ctl) : unit =
  (* less: threadsetname *)

  while true do
    let key = Keyboard.receive kbd |> Event.sync in
    (* less: 
     *  - do that in other thread? so can start reading more keys? 
     *  - have sendp?
     *  - receive array of keys? nbrecv?
     *  - use double array of keys so can send and then receive without
     *    losing anything?
    *)
    Globals.win () |> Option.iter (fun (win : Window.t) ->
      Event.send win.chan_keyboard key |> Event.sync
    )
  done
@


<<[[Window.t]] keyboard fields>>=
(* Threads_window.thread <-- Thread_keyboard.thread (<-- keyboard.thread) *)
(* todo: need list of keys? [20]?not reactif enough if buffer one key only? *)
chan_keyboard: Keyboard.key Event.channel;
@


\section{Mouse thread}

<<signature [[Thread_mouse.thread]]>>=
(* Reads from the mouse and sends the mouse state to the "current" window
 * if the cursor is in the windows rect. Otherwise might call the 
 * window manager to change the current window or also display a menu depending
 * on the mouse state. With this menu one can select "New" which will create
 * a new window and process (hence the need for Cap.fork below).
 *)
val thread: 
  < Cap.fork; Cap.exec; Cap.chdir; Cap.mount; Cap.bind; .. > ->
  Exit.t Event.channel * Mouse.ctl * 
  (Display.t * Baselayer.t * Image.t * Font.t) * Fileserver.t -> 
  unit
@

<<type [[Thread_mouse.event]]>>=
type event =
  | Mouse of Mouse.state
@

<<function [[Thread_mouse.thread]]>>=
let thread (caps : < Cap.fork; .. >) 
           (exitchan, mouse, (display, desktop, view, font), fs) =
  (* less: threadsetname *)

  while true do
    let ev = 
      [
        Mouse.receive mouse |> (fun ev -> Event.wrap ev (fun x -> Mouse x));
      ] |> Event.select
    in
    (match ev with
    | Mouse m ->
      (* less: wkeyboard and button 6 *)
      (* less: loop again *)
      (* less: wkeyboard and ptinrect *)
      (* todo? race on Globals.win? can change between? need store in local?*)

      <<[[Thread_mouse.thread()]] let [[sending_to_win]]>>
      (match sending_to_win with
      | true ->
        <<[[Thread_mouse.thread()]] when [[sending_to_win]]>>
      | false ->
        <<[[Thread_mouse.thread()]] when not [[sending_to_win]]>>
    )
  )
  done
@

\subsection{Application mouse events}

<<[[Thread_mouse.thread()]] let [[sending_to_win]]>>=
let sending_to_win =
  match Globals.win () with
  | Some (w : Window.t) ->
    (* less: logical coordinates with winput.img.r and winput.screenr *)
    let xy = m.pos in
    (* less: goto scrolling if scroll buttons *)
    let inside = Window.pt_inside_border xy w in
    (* todo: set scrolling *)
    (* todo: set moving *)
    (* less: || scrolling *)
    inside && (w.mouse_opened || m.buttons.left)
  | None -> false
in
@

<<[[Thread_mouse.thread()]] when [[sending_to_win]]>>=
(* could assert that Globals.win() <> None *)
Globals.win () |> Option.iter (fun (w : Window.t) ->
  (if not (Mouse.has_click m)
  then Wm.corner_cursor_or_window_cursor w m.pos mouse
  (* todo: why if click then not corner cursor? *)
  else Wm.window_cursor w m.pos  mouse
  );
  (* less: send logical coordinates *)
  Event.send w.chan_mouse m |> Event.sync
)
@

<<[[Window.t]] mouse fields>>=
(* Threads_window.thread <-- Thread_mouse.thread (<-- Mouse.thread) *)
chan_mouse: Mouse.state Event.channel;
@

\subsection{Windowing system mouse events}


%XXX
<<[[Thread_mouse.thread()]] when not [[sending_to_win]]>>=
let wopt = Globals.window_at_point m.pos in
(match wopt with
| Some w -> Wm.corner_cursor_or_window_cursor w m.pos mouse
| None -> Mouse.reset_cursor mouse
);
(* todo: if moving and buttons *)
(* todo: set corner cursor again part2 *)

if Mouse.has_click m
then 
  let under_mouse =
    match wopt, Globals.win () with
    | None, _ -> Nothing
    (* less: look if w2.topped > 0? seems useless *)
    | Some w1, Some w2 when w1 == w2 -> CurrentWin w1
    | Some w, _ -> OtherWin w
  in
  (match under_mouse with
  (* TODO: remove; just because hard to right click on QEMU and laptop*)
  | Nothing when m.buttons.left ->
    wm_menu caps m.pos Mouse.Left exitchan 
      mouse (display, desktop, view, font) fs


  | ((*Nothing |*) CurrentWin _) when m.buttons.left ->
    ()

  | Nothing when m.buttons.middle ->
     middle_click_system m mouse
  | CurrentWin (w : Window.t) when m.buttons.middle ->
    if not w.mouse_opened
    then middle_click_system m mouse

  | (Nothing | CurrentWin _) when m.buttons.right ->
    wm_menu caps m.pos Mouse.Right exitchan 
      mouse (display, desktop, view, font) fs

  | OtherWin w when m.buttons.left ->
    Wm.top_win w
    (* less: should drain and wait that release up, unless winborder *)
  | OtherWin w when m.buttons.middle || m.buttons.right ->
    Wm.top_win w
    (* todo: should goto again, may need to send event *)
    
  | _ -> raise (Impossible "Mouse.has_click so one field is true")
  );
(* todo: reset moving *)
(* less: drain *)
@


<<function [[Globals.window_at_point]]>>=
(* old: was called wpointto in rio *)
let window_at_point pt =
  let res = ref None in
  windows |> Hashtbl.iter (fun _k w ->
    if Rectangle.pt_in_rect pt w.W.screenr && not w.W.deleted
    then
      match !res with
      | None -> res := Some w
      | Some w2 when w.W.topped > w2.W.topped -> res := Some w
      | _ -> ()
  );
  !res
@

\section{Window threads}

<<signature [[Threads_window.thread]]>>=
(* Thread listening to keyboard/mouse/wm events for a particular window
 * and dispatching to the right channel.
 *)
val thread: Window.t -> unit
@

<<type [[Threads_window.event]]>>=
type event = 
  (* reading from keyboard thread *)
  | Key   of Keyboard.key
  (* reading from mouse thread *)
  | Mouse of Mouse.state
  (* reading from many places *)
  | Cmd   of Window.cmd

  <<[[Threads_window.event]] other cases>>
@

<<function [[Threads_window.thread]]>>=
let thread (w : Window.t) =
  (* less: threadsetname *)
  <<[[Threads_window.thread()]] channels creation>>

  while true do
    let ev = (
    (* receive *)
    [ 
      Event.receive w.chan_keyboard |> wrap (fun x -> Key x);
      Event.receive w.chan_mouse    |> wrap (fun x -> Mouse x);
      Event.receive w.chan_cmd      |> wrap (fun x -> Cmd x);
    ] @
      <<[[Threads_window.thread()]] other [[select]] elements>>
    ) |> Event.select
    in
    (match ev with
    | Key key -> 
      key_in w key
    | Mouse m -> 
      mouse_in w m
    | Cmd cmd -> 
      (* todo: if return Exited then threadsexit and free channels.
       * When answer Exited? when Cmd is Exited?
       *)
      cmd_in w cmd
    <<[[Threads_window.thread()]] match [[ev]] other cases>>
    );
    if not w.deleted
    then Image.flush w.img;
  done
@


<<[[Window.t]] command fields>>=
(* Threads_window.thread <-- Thread_mouse.thread? | ?? *)
(* less: also list of cmds? [20]? *)
chan_cmd: cmd Event.channel;
@

<<type [[Window.cmd]]>>=
type cmd =
  | Delete
  (* for resize event but also for hide/show *)
  | Reshape of 
      Image.t (* can be Layer.t or an off-screen Image.t when hidden *)
      (*Mouse.ctl*) (* needed for window_cursor() when repaint border *)
(*
  | Move of Image.t * Rectangle.t
  | Refresh
  | Wakeup
  (* less: RawOff | RawOn? HoldOn | HoldOff *)
*)
@


<<[[Window.t]] other fields>>=
(* todo: why need this? *)
mutable deleted: bool;
@


%XXX
<<[[Threads_window.thread()]] channels creation>>=
let chan_devmouse = Event.new_channel () in
let chan_devcons_read_count = Event.new_channel () in
let chan_devcons_read_bytes = Event.new_channel () in
let chan_devcons_write_runes = Event.new_channel () in
@
%XXX
<<[[Threads_window.event]] other cases>>=
(* producing for thread_fileserver(Read Qmouse) *)
| SentChannelForMouseRead
(* producing for thread_fileserver(Read Qcons) *)
| SentChannelsForConsRead
(* producing and then consuming for thread_fileserver(Write Qcons) *)
| SentChannelForConsWrite
@

%XXX
<<[[Threads_window.thread()]] other [[select]] elements>>=
(* sending *)
(if w.mouse_counter <> w.last_count_sent 
 then [Event.send w.chan_devmouse_read chan_devmouse 
        |> wrap (fun () -> SentChannelForMouseRead)]
 else []
) @
(* less: npart *)
(if (w.raw_mode && Queue.length w.raw_keys > 0) ||
    (not w.raw_mode && Terminal.newline_after_output_point w.terminal)
 then [Event.send w.chan_devcons_read 
          (chan_devcons_read_count, chan_devcons_read_bytes)
        |> wrap (fun () -> SentChannelsForConsRead)]
 else []
) @
(* less: auto_scroll, mouseopen?? 
 * todo: qh vs org and nchars *)
(if true
 then [Event.send w.chan_devcons_write chan_devcons_write_runes
      |> wrap (fun () -> SentChannelForConsWrite);]
 else []
)
@
%XXX
<<[[Threads_window.thread()]] match [[ev]] other cases>>=
| SentChannelForMouseRead -> 
  mouse_out w chan_devmouse
| SentChannelsForConsRead -> 
  bytes_out w (chan_devcons_read_count, chan_devcons_read_bytes)
| SentChannelForConsWrite ->
  runes_in w chan_devcons_write_runes
@
<<function [[Threads_window.runes_in]]>>=
(* output from application *)
let runes_in (w: Window.t) (chan : Rune.t list Event.channel) =
  let runes = Event.receive chan |> Event.sync in
  Terminal.runes_in w.terminal runes
@
<<signature [[Terminal.runes_in]]>>=
val runes_in: t -> Rune.t list -> unit
@

\subsection{Keyboard events listening}

<<function [[Threads_window.key_in]]>>=
(* input from user *)
let key_in (w : Window.t) (key : Keyboard.key) =
  (* less: if key = 0? when can happen? EOF? Ctrl-D? *)
  if not w.deleted then begin
    match w.raw_mode, w.mouse_opened with
    (* todo: if holding *)
    | false, false -> 
      (* less: snarf *)
      Terminal.key_in w.terminal key

    | true, true (* less: || q0 == nr *) ->
      Queue.add key w.raw_keys 

    (* less: in theory we should allow also special navigation keys here *)
    | true, false  ->
      failwith "key_in: TODO: raw mode in textual window"

    | false, true  ->
      failwith "key_in: TODO: buffered mode in graphical window"
  end
@

<<signature [[Terminal.key_in]]>>=
val key_in: t -> Keyboard.key -> unit
@


\subsection{Mouse events listening}

<<function [[Threads_window.mouse_in]]>>=
let mouse_in (w : Window.t) (m : Mouse.state) =
  w.last_mouse <- m;
  match w.mouse_opened with
  | true -> 
    w.mouse_counter <- w.mouse_counter + 1;
    (* less: limit queue length? *)
    if m.buttons <> w.last_buttons 
    then begin 
      Queue.add (m, w.mouse_counter) w.mouseclicks_queue;
      w.last_buttons <- m.buttons
    end;
  | false -> failwith "mouse_in: mouse not opened todo"
@

\subsection{Control events listening}

<<function [[Threads_window.cmd_in]]>>=
let cmd_in (w : Window.t) (cmd : cmd) =
  match cmd with
  <<[[Threads_window.cmd_in()]] match [[cmd]] cases>>
@

%XXX
<<[[Threads_window.cmd_in()]] match [[cmd]] cases>>=
| Delete -> 
  (* less: break if window already deleted *)
  (* todo: delete timeout process *)
  Wm.close_win w
@
%XXX
<<[[Threads_window.cmd_in()]] match [[cmd]] cases>>=
| Reshape (new_img : Display.image) ->
  (* less: put all of that in Wm.resize_win ? *)
  if w.deleted
  (* less: free new_img if deleted, but when can happen? *)
  then failwith "window already deleted";
  let r = new_img.r in
  w.screenr <- r;
  Wm.resize_win w new_img;
  (* less: set wctlready to true *)
  (* todo: delete timeout proc for old name of window *)
  (match Rectangle.dx r, Globals.win () with
  | 0, Some w2 when w2 == w ->
    Wm.set_current_and_repaint None
  | _n, Some w2 when (w2 == w) -> 
    (* less: could Wm.set_current_and_repaint_borders (Some w) mouse,
     * useless opti I think to special case here w2 == w
     *)
    ()
  | _n, (Some _ | None) ->
    Wm.set_current_and_repaint (Some w)
  );
  (* less: Image.flush new_img, but useless cos done in thread () *)
  ()
@

\section{Filesystem server thread} %% proc}

%%\subsection{[[filsysproc()]]}

<<signature [[Threads_fileserver.thread]]>>=
(* 
  will serve all the virtual devices for new windows/processes created by rio.
 *)
val thread: Fileserver.t -> unit
@

<<function [[Threads_fileserver.thread]]>>=
(* the master *)
let thread (fs : Fileserver.t) =
  (* less: threadsetname *)
  
  while true do
    let req : P9.message = P9.read_9P_msg fs.server_fd in

    <<[[Threads_fileserver.thread]] in loop, debug>>

    (match req.typ with
    | P9.T x -> dispatch fs req x
    | P9.R _x ->
      (* less: Ebadfcall *)
      raise (Impossible (spf "got a response request: %s" (P9.str_of_msg req)))
    );
    (* for Version first-message check *)
    first_message := false
  done
@

<<constant [[Threads_fileserver.first_message]]>>=
(* for Version *)
let first_message = ref true
@

<<function [[Threads_fileserver.dispatch]]>>=
let dispatch (fs : Fileserver.t) (req : P9.message) (request_typ : P9.Request.t) =
  match request_typ with
  <<[[Threads_fileserver.dispatch()]] match [[request_typ]] cases>>
@


%XXX
<<[[Threads_fileserver.dispatch()]] match [[request_typ]] cases>>=
(* Attach *)
| T.Attach (rootfid, _auth_fid_opt, uname, aname) ->
  (* stricter: *)
  if Hashtbl.mem fs.fids rootfid
  then failwith (spf "Attach: fid already used: %d" rootfid);

  (match () with
  | _ when uname <> fs.user ->
    error fs req (spf "permission denied, %s <> %s" uname fs.user)
  | _ ->
  (* less: could do that in a worker thread (if use qlock) *)
  (* less: newlymade, qlock all *)
  (try
     let wid = int_of_string aname in
     let w = Hashtbl.find Globals.windows wid in

     let entry = File.root_entry in
     let file_id = entry.code, wid in
     let qid = File.qid_of_fileid file_id entry.type_ in

     let file = File.{
       fid = rootfid; 
       qid = qid; 
       entry = entry;
       opened = None;
       win = w;
     } in
     Hashtbl.add fs.fids rootfid file;
     answer fs {req with P9.typ = P9.R (R.Attach qid) }
   with _exn ->
      error fs req (spf "unknown id in attach: %s" aname)
  (* less: incref, qunlock *)
  ))

(* Walk *)
| T.Walk (fid, newfid_opt, xs) ->
  check_fid "walk" fid fs;
  let file : File.t = Hashtbl.find fs.fids fid in
  let wid = file.win.id in
  (match file.opened, newfid_opt with
  | Some _, _ ->
    error fs req "walk of open file"
  (* stricter? failwith or error? *)
  | _, Some newfid when Hashtbl.mem fs.fids newfid ->
    error fs req (spf "clone to busy fid: %d" newfid)
  | _ when List.length xs > P9.max_welem ->
    error fs req (spf "name too long: [%s]" (String.concat ";" xs))
  | _ ->
    let file =
      match newfid_opt with
      | None -> file
      | Some newfid ->
        (* clone *)
        (* less: incref on file.w *)
        let newfile = { file with
          File.fid = newfid; 
          File.opened = None 
          (* todo: nrpart? *)
        } in
        Hashtbl.add fs.fids newfid newfile;
        newfile
    in
    let rec walk qid (entry : File.dir_entry_short) acc xs =
      match xs with
      | [] -> qid, entry, List.rev acc
      | x::xs ->
        if qid.N.typ <> N.QTDir
        (* will be catched below and transformed in an 9P Rerror message *)
        then failwith "not a directory";
        (match entry.code, x with
        | _Qwsys, ".." -> failwith "walk: Todo '..'"
        | File.Dir File.Root, x ->
          let entry = 
            toplevel_entries |> List.find (fun (entry : File.dir_entry_short)->
                     entry.name = x)
          in
          let file_id = entry.code, wid in
          let qid = File.qid_of_fileid file_id entry.type_ in
          (* continue with other path elements *)
          walk qid entry (qid::acc) xs
        (* todo: Wsys, snarf *)
        | _ -> 
          raise (Impossible "should be catched by 'not a directory' above")
        )
    in
    (try 
      let final_qid, final_entry, qids = 
        walk file.qid file.entry [] xs
      in
      file.qid <- final_qid;
      file.entry <- final_entry;
      answer fs { req with P9.typ = P9.R (R.Walk qids) }
    with exn ->
      newfid_opt |> Option.iter (fun newfid ->
        Hashtbl.remove fs.fids newfid
      );
      (match exn with
      (* this can happen many times because /dev is a union-mount so
       * we get walk requests also for /dev/draw/... and other devices
       *)
      | Not_found -> 
        error fs req "file does not exist"
      | Failure s when s = "not a directory" ->
        error fs req "not a directory"
      (* internal error then *)
      | _ -> raise exn
      )
    )
  )

(* Open *)
| T.Open (fid, flags) ->
  check_fid "open" fid fs;
  let file = Hashtbl.find fs.fids fid in
  let w = file.win in
  (* less: OTRUNC | OCEXEC | ORCLOSE, and remove DMDIR| DMAPPEND from perm *)
  let perm = file.entry.perm in
  if flags.x || (flags.r && not perm.r)
             || (flags.w && not perm.w)
  then error fs req "permission denied"
  else
    if w.deleted
    then error fs req "window deleted"
    else 
    (* less: could do that in a worker thread *)
    (try 
       (match file.entry.code with
       | File.File devid ->
         let dev = device_of_devid devid in
         dev.D.open_ w
       | File.Dir _dir ->
         (* todo: nothing to do for dir? ok to open a dir? *)
         ()
       );
       file.opened <- Some flags;
       let iounit = fs.message_size - P9.io_header_size in
       answer fs { req with P9.typ = P9.R (R.Open (file.qid, iounit)) }
     with Device.Error str ->
       error fs req str
    )


(* Clunk *)
| T.Clunk (fid) ->
  check_fid "clunk" fid fs;
  let file = Hashtbl.find fs.fids fid in
  (match file.opened with
  | Some _flags ->
    (match file.entry.code with
    | File.File devid ->
      let dev = device_of_devid devid in
      dev.D.close file.win
      (* todo: wclose? *)
    | File.Dir _ ->
      ()
    )
  (* stricter? can clunk a file not opened? *)
  | None ->
    (* todo: winclosechan *)
    ()
  );
  Hashtbl.remove fs.fids fid;
  answer fs { req with P9.typ = P9.R (R.Clunk) }

(* Read *)
| T.Read (fid, offset, count) ->
  check_fid "read" fid fs;
  let file = Hashtbl.find fs.fids fid in
  let w = file.win in

  (match file.entry.code with
  | _ when w.deleted ->
    error fs req "window deleted"
  | File.File devid ->
    (* a worker thread (less: opti: arena of workers? *)
    Thread.create (fun () ->
     (* less: getclock? *)
     (try 
       let dev = device_of_devid devid in
       let data = dev.D.read_threaded offset count w in
       answer fs { req with P9.typ = P9.R (R.Read data) }
     with Device.Error str ->
       error fs req str
    )) () |> ignore
  | File.Dir _ ->
    failwith "TODO: readdir"
  )

(* Write *)
| T.Write (fid, offset, data) ->
  check_fid "write" fid fs;
  let file = Hashtbl.find fs.fids fid in
  let w = file.win in

  (match file.entry.code with
  | _ when w.deleted ->
    error fs req "window deleted"
  | File.File devid ->
    (* a worker thread (less: opti: arena of workers? *)
    Thread.create (fun () ->
     (try 
       let dev = device_of_devid devid in
       (* less: case where want to let device return different count? *)
       let count = String.length data in
       dev.D.write_threaded offset data w;
       answer fs { req with P9.typ = P9.R (R.Write count) }
     with Device.Error str ->
       error fs req str
    )) () |> ignore
  | File.Dir _ ->
    raise (Impossible "kernel should not call write on fid of a directory")
  )
(* Stat *)
| T.Stat (fid) ->
  check_fid "stat" fid fs;
  let file = Hashtbl.find fs.fids fid in
  let short = file.entry in
  (* less: getclock *)
  let clock = 0 in
  let dir_entry = {
    N.name = short.name;
    (* less: adjust version for snarf *)
    N.qid = file.qid;
    N.mode = (N.int_of_perm_property short.perm, 
      match file.qid.N.typ with
      | N.QTDir -> N.DMDir
      | N.QTFile -> N.DMFile
    );
    N.length = 0; (*/* would be nice to do better */*)

    N.atime = clock;
    N.mtime = clock;

    N.uid = fs.user;
    N.gid = fs.user;
    N.muid = fs.user;

    N._typ = 0;
    N._dev = 0;
  }
  in
  answer fs { req with P9.typ = P9.R (R.Stat dir_entry) }

(* Other *)
| T.Create _ 
| T.Remove _
| T.Wstat _
    -> error fs req "permission denied"

(* todo: handle those one? *)
| T.Flush _
| T.Auth _
  -> 
  failwith (spf "TODO: req = %s" (P9.str_of_msg req))
@



\subsection{[[Version]] request}%%[[filsysversion()]]}

<<[[Threads_fileserver.dispatch()]] match [[request_typ]] cases>>=
(* Version *)
| T.Version (msize, str) -> 
  (match () with
  | _ when not !first_message ->
    error fs req "version: request not first message"
  | _ when msize < 256 ->
    error fs req "version: message size too small";
  | _ when str <> "9P2000" ->
    error fs req "version: unrecognized 9P version";
  | _ ->
    fs.message_size <- msize;
    answer fs {req with P9.typ = P9.R (R.Version (msize, str)) }
  )
@

%%\section{[[Xfid]] allocator thread}

%%\section{[[Xfid]] threads}

%******************************************************************************
\chapter{Cursors}
%******************************************************************************
\label{chap:cursor}

\section{Cursor graphics}

\subsection{Classic cursors}

<<signature [[Cursors.crosscursor]]>>=
val crosscursor : Cursor.t
@
<<signature [[Cursors.boxcursor]]>>=
val boxcursor   : Cursor.t
@
<<signature [[Cursors.sightcursor]]>>=
val sightcursor : Cursor.t
@

<<constant [[Cursors.crosscursor]]>>=
(* when create a new window (sweep()) *)
let crosscursor = {
  offset = { x = -7; y = -7; };
  clr = Cursor.ints_to_bytes
    [| 0x03; 0xC0; 0x03; 0xC0; 0x03; 0xC0; 0x03; 0xC0;
       0x03; 0xC0; 0x03; 0xC0; 0xFF; 0xFF; 0xFF; 0xFF;
       0xFF; 0xFF; 0xFF; 0xFF; 0x03; 0xC0; 0x03; 0xC0;
       0x03; 0xC0; 0x03; 0xC0; 0x03; 0xC0; 0x03; 0xC0; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x01; 0x80; 0x01; 0x80; 0x01; 0x80;
       0x01; 0x80; 0x01; 0x80; 0x01; 0x80; 0x7F; 0xFE;
       0x7F; 0xFE; 0x01; 0x80; 0x01; 0x80; 0x01; 0x80;
       0x01; 0x80; 0x01; 0x80; 0x01; 0x80; 0x00; 0x00;
    |];
}
@

<<constant [[Cursors.boxcursor]]>>=
(* when move a window (drag()) *)
let boxcursor = {
  offset =  {x = -7; y = -7; };
  clr = Cursor.ints_to_bytes
    [| 0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF;
       0xFF; 0xFF; 0xF8; 0x1F; 0xF8; 0x1F; 0xF8; 0x1F;
       0xF8; 0x1F; 0xF8; 0x1F; 0xF8; 0x1F; 0xFF; 0xFF;
       0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x7F; 0xFE; 0x7F; 0xFE; 0x7F; 0xFE;
       0x70; 0x0E; 0x70; 0x0E; 0x70; 0x0E; 0x70; 0x0E;
       0x70; 0x0E; 0x70; 0x0E; 0x70; 0x0E; 0x70; 0x0E;
       0x7F; 0xFE; 0x7F; 0xFE; 0x7F; 0xFE; 0x00; 0x00; 
    |];
}
@

<<constant [[Cursors.sightcursor]]>>=
(* when select a window (point_to()) *)
let sightcursor = {
  offset =  {x = -7; y = -7; };
  clr = Cursor.ints_to_bytes
    [| 0x1F; 0xF8; 0x3F; 0xFC; 0x7F; 0xFE; 0xFB; 0xDF;
       0xF3; 0xCF; 0xE3; 0xC7; 0xFF; 0xFF; 0xFF; 0xFF;
       0xFF; 0xFF; 0xFF; 0xFF; 0xE3; 0xC7; 0xF3; 0xCF;
       0x7B; 0xDF; 0x7F; 0xFE; 0x3F; 0xFC; 0x1F; 0xF8; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x0F; 0xF0; 0x31; 0x8C; 0x21; 0x84;
       0x41; 0x82; 0x41; 0x82; 0x41; 0x82; 0x7F; 0xFE;
       0x7F; 0xFE; 0x41; 0x82; 0x41; 0x82; 0x41; 0x82;
       0x21; 0x84; 0x31; 0x8C; 0x0F; 0xF0; 0x00; 0x00; 
    |];
}
@


<<constant [[Cursors._whitearrow]]>>=
let _whitearrow = {
  offset =  {x = 0; y = 0; };
  clr = Cursor.ints_to_bytes
    [| 0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFE; 0xFF; 0xFC; 
       0xFF; 0xF0; 0xFF; 0xF0; 0xFF; 0xF8; 0xFF; 0xFC; 
       0xFF; 0xFE; 0xFF; 0xFF; 0xFF; 0xFE; 0xFF; 0xFC; 
       0xF3; 0xF8; 0xF1; 0xF0; 0xE0; 0xE0; 0xC0; 0x40; 
    |];
  set = Cursor.ints_to_bytes
    [| 0xFF; 0xFF; 0xFF; 0xFF; 0xC0; 0x06; 0xC0; 0x1C; 
       0xC0; 0x30; 0xC0; 0x30; 0xC0; 0x38; 0xC0; 0x1C; 
       0xC0; 0x0E; 0xC0; 0x07; 0xCE; 0x0E; 0xDF; 0x1C; 
       0xD3; 0xB8; 0xF1; 0xF0; 0xE0; 0xE0; 0xC0; 0x40; 
    |];
}
@

<<constant [[Cursors._query]]>>=
let _query = {
  offset =  {x = -7;y = -7; };
  clr = Cursor.ints_to_bytes
    [| 0x0f; 0xf0; 0x1f; 0xf8; 0x3f; 0xfc; 0x7f; 0xfe; 
       0x7c; 0x7e; 0x78; 0x7e; 0x00; 0xfc; 0x01; 0xf8; 
       0x03; 0xf0; 0x07; 0xe0; 0x07; 0xc0; 0x07; 0xc0; 
       0x07; 0xc0; 0x07; 0xc0; 0x07; 0xc0; 0x07; 0xc0; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x0f; 0xf0; 0x1f; 0xf8; 0x3c; 0x3c; 
       0x38; 0x1c; 0x00; 0x3c; 0x00; 0x78; 0x00; 0xf0; 
       0x01; 0xe0; 0x03; 0xc0; 0x03; 0x80; 0x03; 0x80; 
       0x00; 0x00; 0x03; 0x80; 0x03; 0x80; 0x00; 0x00; 
    |];
}
@

\subsection{Border and corner cursors}

<<type [[Cursors.corner]]>>=
type corner = 
  | TopLeft    | Top    | TopRight
  | Left                | Right
  | BottomLeft | Bottom | BottomRight
@

<<constant [[Cursors.tl]]>>=
let tl = {
  offset =  {x = -4; y = -4; };
  clr = Cursor.ints_to_bytes
    [| 0xfe; 0x00; 0x82; 0x00; 0x8c; 0x00; 0x87; 0xff; 
       0xa0; 0x01; 0xb0; 0x01; 0xd0; 0x01; 0x11; 0xff; 
       0x11; 0x00; 0x11; 0x00; 0x11; 0x00; 0x11; 0x00; 
       0x11; 0x00; 0x11; 0x00; 0x11; 0x00; 0x1f; 0x00; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x7c; 0x00; 0x70; 0x00; 0x78; 0x00; 
       0x5f; 0xfe; 0x4f; 0xfe; 0x0f; 0xfe; 0x0e; 0x00; 
       0x0e; 0x00; 0x0e; 0x00; 0x0e; 0x00; 0x0e; 0x00; 
       0x0e; 0x00; 0x0e; 0x00; 0x0e; 0x00; 0x00; 0x00; 
    |];
}
@

<<constant [[Cursors.t]]>>=
let t = {
  offset =  {x = -7; y = -8; };
  clr = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x00; 0x00; 0x03; 0x80; 0x06; 0xc0; 
       0x1c; 0x70; 0x10; 0x10; 0x0c; 0x60; 0xfc; 0x7f; 
       0x80; 0x01; 0x80; 0x01; 0x80; 0x01; 0xff; 0xff; 
       0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x01; 0x00; 
       0x03; 0x80; 0x0f; 0xe0; 0x03; 0x80; 0x03; 0x80; 
       0x7f; 0xfe; 0x7f; 0xfe; 0x7f; 0xfe; 0x00; 0x00; 
       0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 
    |];
}
@

<<constant [[Cursors.tr]]>>=
let tr = {
  offset =  {x = -11; y = -4; };
  clr = Cursor.ints_to_bytes
    [| 0x00; 0x7f; 0x00; 0x41; 0x00; 0x31; 0xff; 0xe1; 
       0x80; 0x05; 0x80; 0x0d; 0x80; 0x0b; 0xff; 0x88; 
       0x00; 0x88; 0x0; 0x88; 0x00; 0x88; 0x00; 0x88; 
       0x00; 0x88; 0x00; 0x88; 0x00; 0x88; 0x00; 0xf8; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x00; 0x3e; 0x00; 0x0e; 0x00; 0x1e; 
       0x7f; 0xfa; 0x7f; 0xf2; 0x7f; 0xf0; 0x00; 0x70; 
       0x00; 0x70; 0x00; 0x70; 0x00; 0x70; 0x00; 0x70; 
       0x00; 0x70; 0x00; 0x70; 0x00; 0x70; 0x00; 0x00; 
    |];
}
@

<<constant [[Cursors.r]]>>=
let r = {
  offset =  {x = -8; y = -7; };
  clr = Cursor.ints_to_bytes
    [| 0x07; 0xc0; 0x04; 0x40; 0x04; 0x40; 0x04; 0x58; 
       0x04; 0x68; 0x04; 0x6c; 0x04; 0x06; 0x04; 0x02; 
       0x04; 0x06; 0x04; 0x6c; 0x04; 0x68; 0x04; 0x58; 
       0x04; 0x40; 0x04; 0x40; 0x04; 0x40; 0x07; 0xc0; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x03; 0x80; 0x03; 0x80; 0x03; 0x80; 
       0x03; 0x90; 0x03; 0x90; 0x03; 0xf8; 0x03; 0xfc; 
       0x03; 0xf8; 0x03; 0x90; 0x03; 0x90; 0x03; 0x80; 
       0x03; 0x80; 0x03; 0x80; 0x03; 0x80; 0x00; 0x00; 
    |];
}
@

<<constant [[Cursors.br]]>>=
let br = {
  offset =  {x = -11; y = -11; };
  clr = Cursor.ints_to_bytes
    [| 0x00; 0xf8; 0x00; 0x88; 0x00; 0x88; 0x00; 0x88; 
       0x00; 0x88; 0x00; 0x88; 0x00; 0x88; 0x00; 0x88; 
       0xff; 0x88; 0x80; 0x0b; 0x80; 0x0d; 0x80; 0x05; 
       0xff; 0xe1; 0x00; 0x31; 0x00; 0x41; 0x00; 0x7f; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x00; 0x70; 0x00; 0x70; 0x00; 0x70; 
       0x0; 0x70; 0x00; 0x70; 0x00; 0x70; 0x00; 0x70; 
       0x00; 0x70; 0x7f; 0xf0; 0x7f; 0xf2; 0x7f; 0xfa; 
       0x00; 0x1e; 0x00; 0x0e; 0x00; 0x3e; 0x00; 0x00; 
    |];
}
@

<<constant [[Cursors.b]]>>=
let b = {
  offset =  {x = -7; y = -7; };
  clr = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 
       0xff; 0xff; 0x80; 0x01; 0x80; 0x01; 0x80; 0x01; 
       0xfc; 0x7f; 0x0c; 0x60; 0x10; 0x10; 0x1c; 0x70; 
       0x06; 0xc0; 0x03; 0x80; 0x00; 0x00; 0x00; 0x00; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 
       0x00; 0x00; 0x7f; 0xfe; 0x7f; 0xfe; 0x7f; 0xfe; 
       0x03; 0x80; 0x03; 0x80; 0x0f; 0xe0; 0x03; 0x80; 
       0x01; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 
    |];
}
@

<<constant [[Cursors.bl]]>>=
let bl = {
  offset =  {x = -4; y = -11; };
  clr = Cursor.ints_to_bytes
    [| 0x1f; 0x00; 0x11; 0x00; 0x11; 0x00; 0x11; 0x00; 
       0x11; 0x00; 0x11; 0x00; 0x11; 0x00; 0x11; 0x00; 
       0x11; 0xff; 0xd0; 0x01; 0xb0; 0x01; 0xa0; 0x01; 
       0x87; 0xff; 0x8c; 0x00; 0x82; 0x00; 0xfe; 0x00; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x0e; 0x00; 0x0e; 0x00; 0x0e; 0x00; 
       0x0e; 0x00; 0x0e; 0x00; 0x0e; 0x00; 0x0e; 0x00; 
       0x0e; 0x00; 0x0f; 0xfe; 0x4f; 0xfe; 0x5f; 0xfe; 
       0x78; 0x00; 0x70; 0x00; 0x7c; 0x00; 0x00; 0x0; 
    |];
}
@

<<constant [[Cursors.l]]>>=
let l = {
  offset =  {x = -7; y = -7; };
  clr = Cursor.ints_to_bytes
    [| 0x03; 0xe0; 0x02; 0x20; 0x02; 0x20; 0x1a; 0x20; 
       0x16; 0x20; 0x36; 0x20; 0x60; 0x20; 0x40; 0x20; 
       0x60; 0x20; 0x36; 0x20; 0x16; 0x20; 0x1a; 0x20; 
       0x02; 0x20; 0x02; 0x20; 0x02; 0x20; 0x03; 0xe0; 
    |];
  set = Cursor.ints_to_bytes
    [| 0x00; 0x00; 0x01; 0xc0; 0x01; 0xc0; 0x01; 0xc0; 
       0x09; 0xc0; 0x09; 0xc0; 0x1f; 0xc0; 0x3f; 0xc0; 
       0x1f; 0xc0; 0x09; 0xc0; 0x09; 0xc0; 0x01; 0xc0; 
       0x01; 0xc0; 0x01; 0xc0; 0x01; 0xc0; 0x00; 0x00; 
    |];
}
@

\section{Setting the cursor}

\subsection{[[riosetcursor()]]}

\subsection{[[cornercursor()]]}

<<function [[Wm._corner_cursor]]>>=
let _corner_cursor (w : Window.t) (pt : Point.t) (mouse : Mouse.ctl) =
  if Window.pt_on_border pt w
  then Mouse.set_cursor mouse (Cursors.which_corner_cursor w.screenr pt)
@


<<function [[Wm.corner_cursor_or_window_cursor]]>>=
let corner_cursor_or_window_cursor (w : Window.t) (pt : Point.t) (mouse : Mouse.ctl) =
  if Window.pt_on_border pt w
  then Mouse.set_cursor mouse (Cursors.which_corner_cursor w.screenr pt)
  else window_cursor w pt mouse
@

<<function [[Window.pt_on_border]]>>=
(* old: was called winborder in rio *)
let pt_on_border pt w =
  Rectangle.pt_in_rect pt w.screenr && not (pt_inside_border pt w)
@

<<function [[Window.pt_inside_border]]>>=
(* old: was not an helper in rio, but should to be consistent with winborder.
 * alt: pt_on_content (window border vs window content in Windows.nw)
 *)
let pt_inside_border pt w =
  Rectangle.pt_in_rect pt (Rectangle.insetrect window_border_size w.screenr)
@




<<signature [[Cursors.which_corner_cursor]]>>=
val which_corner_cursor: Rectangle.t -> Point.t -> Cursor.t
@


<<function [[Cursors.which_corner_cursor]]>>=
let which_corner_cursor rect p =
  let corner = which_corner rect p in
  match corner with
  | TopLeft -> tl
  | Top -> t
  | TopRight -> tr
  | Left -> l
  | Right -> r
  | BottomLeft -> bl
  | Bottom -> b
  | BottomRight -> br
@

<<type [[Cursors.portion]]>>=
type portion = Inf | Middle | Sup
@

<<function [[Cursors.which_corner]]>>=
let which_corner r p =
  let left_right = portion p.x r.min.x r.max.x in
  let bottom_top = portion p.y r.min.y r.max.y in
  match left_right, bottom_top with
  | Inf, Inf -> TopLeft
  | Inf, Middle -> Left
  | Inf, Sup -> BottomLeft
  | Middle, Inf -> Top
  | Middle, Middle -> 
    raise (Impossible "which_corner: pt_on_frame should not generate this")
  | Middle, Sup -> Bottom
  | Sup, Inf -> TopRight
  | Sup, Middle -> Right
  | Sup, Sup -> BottomRight
@

<<function [[Cursors.portion]]>>=
let portion x low high =
  (* normalize to low *)
  let x = x - low in
  let high = high - low in
  (* TODO: unused low? *)
  let _low = 0 in

  match () with
  | _ when x < 20 -> Inf
  | _ when x > high - 20 -> Sup
  | _ -> Middle
@


\subsection{[[wsetcursor()]]}

%******************************************************************************
\chapter{Window Manager}
%******************************************************************************
\label{chap:wm}

\section{Overview}

\section{Right-click system menu}



\section{Window borders click}

\section{[[Wctlmesg]]}


\section{Window creation}

\subsection{Window thread creation: [[new()]]}

\subsection{[[Window]] allocation: [[wmk()]]}

\subsection{Window process creation: [[winshell()]]}

\subsection{Namespace adjustments: [[filsysmount()]]}

\subsection{Public layer: [[wsetname()]]}

\subsection{Mouse action [[sweep()]]}

<<signature [[Mouse_action.sweep]]>>=
(* allows to specify a window area *)
val sweep: 
  Mouse.ctl -> (Display.t * Baselayer.t * Font.t) -> Image.t option
@

<<type [[Mouse_action.sweep_state]]>>=
type sweep_state = 
  (* start, no buttons *)
  | SweepInit
  (* right click *)
  | SweepRightClicked of Point.t
  (* move while holding right click *)
  | SweepMove of Point.t * Point.t * Image.t option
  (* release right click *)
  | SweepUnclicked of Image.t option
  (* to factorize cornercursor *)
  | SweepReturn of Image.t option

  (* error management when left or middle click or too small rectangle *)
  | SweepRescue of bool (* clicked state *) * Image.t option
  (* wait until no buttons *)
  | SweepDrain
@

<<function [[Mouse_action.sweep]]>>=
let sweep (mouse : Mouse.ctl) (display, desktop, font) : Image.t option =
  (* todo: menuing? but not sweeping? *)
  Mouse.set_cursor mouse Cursors.crosscursor;

  let rec transit = function
    | SweepInit ->
      let m = Mouse.read mouse in
      if not (Mouse.has_click m)
      then transit SweepInit
      else 
        (* less: force exactly right click? *)
        (* todo: Mouse.Right at some point *)
        if Mouse.has_button m Mouse.Left
        then transit (SweepRightClicked m.Mouse.pos)
        else transit (SweepRescue (true, None))
    | SweepRightClicked p0 ->
      (* less: onsceen (using clipr) *)
      transit (SweepMove (p0, p0, None))
    | SweepMove (p0, p1, old_img_opt) ->
      let m = Mouse.flush_and_read display mouse in
      (match () with
      (* less: force exactly right click? *)
      (* todo: Mouse.Right at some point *)
      | _ when Mouse.has_button m Mouse.Left ->
        if m.Mouse.pos = p1
        then transit (SweepMove (p0, p1, old_img_opt))
        else
          (* less: onscreen *)
          let p1 = m.Mouse.pos in
          let r = Rectangle.canonical p0 p1 in
          if Rectangle.dx r > 5 && Rectangle.dy r > 5 then begin
            (* need that? should be transparent anyway no? *)
            let grey = Color.mk2 0xEE 0xEE 0xEE in
            (* todo? RefreshNothing? *)
            let img = Layer.alloc desktop r grey in
            old_img_opt |> Option.iter Layer.free;
            Polygon.border img r Window.window_border_size 
              !Globals.red Point.zero;
            Display.flush display;
            transit (SweepMove (p0, p1, Some img))
          end
          else transit (SweepMove (p0, p1, old_img_opt))
      | _ when not (Mouse.has_click m) -> 
        transit (SweepUnclicked (old_img_opt))
      | _ -> 
        assert(Mouse.has_click m);
        transit (SweepRescue (true, old_img_opt))
      )
    | SweepUnclicked (old_img_opt) ->
      (match old_img_opt with
      | None -> transit (SweepReturn None)
      | Some (old_img : Display.image) ->
        let r = old_img.r in
        if Rectangle.dx r < 100 || Rectangle.dy r < 3 * font.Font.height
        then transit (SweepRescue (false, old_img_opt))
        else begin
          (* todo? RefreshBackup? *)
          let img = Layer.alloc desktop r Color.white in
          Layer.free old_img;
          Polygon.border img r Window.window_border_size 
            !Globals.red Point.zero;
          (* done in caller but more logical here I think *)
          Display.flush display;
          (* finally!! got an image *)
          transit (SweepReturn (Some img))
        end
      )
    | SweepReturn img_opt ->
      (* todo: cornercursor? pos! *)
      (* less: moveto to force cursor update? ugly ... *)
      (* less: menuing = false *)
      img_opt

    | SweepRescue (clicked_state, old_img_opt) ->
      old_img_opt |> Option.iter Layer.free;
      if clicked_state
      then transit SweepDrain
      else transit (SweepReturn None)
    | SweepDrain ->
      let m = Mouse.read mouse in
      if not (Mouse.has_click m)
      then transit (SweepReturn None)
      else transit SweepDrain
  in
  transit SweepInit
@

\section{Window focus}

\section{Window deletion}

\subsection{[[delete()]]}

\subsection{[[deletetimeoutproc()]] and [[deletethread()]]}

\subsection{[[Deleted]] and [[Exited]]}

\subsection{Mouse action [[pointto()]]}

<<signature [[Mouse_action.point_to]]>>=
val point_to: 
  Mouse.ctl -> Window.t option
@

<<function [[Mouse_action.point_to]]>>=
let point_to (mouse : Mouse.ctl) : Window.t option =
  (* todo: menuing? but not sweeping? *)
  Mouse.set_cursor mouse Cursors.sightcursor;

  let m = ref (Mouse.read mouse) in
  while not (Mouse.has_click !m) do
    m := Mouse.read mouse;
  done;
  let wopt =
    if Mouse.has_button !m Mouse.Right
    then Globals.window_at_point !m.Mouse.pos
    else None
  in
  (* less: wait and cancel option? *)
  while (Mouse.has_click !m) do
    m := Mouse.read mouse;
  done;
  (* restore cursor state *)
  Globals.win () |> Option.iter (fun w ->
    Wm.corner_cursor_or_window_cursor w !m.Mouse.pos mouse
  );
  wopt
@



\section{Window move}

\subsection{[[move()]]}

\subsection{Mouse action [[drag()]]}


\section{Window resize}

\subsection{[[resize()]]}

\subsection{Mouse action [[bandsize()]]}

\section{Window visibility}
\label{sec:window-hide}

\subsection{[[hide()]]}

\subsection{[[hiddden]]}

\subsection{[[unhide()]]}

%******************************************************************************
\chapter{Filesystem Server}
%******************************************************************************
\label{chap:filesystem-server}

\section{Additional data structures}

\subsection{[[Qxxx]]}

\subsection{[[dirtab]]}

\section{[[filsysrespond()]]}

\section{Attach}

\subsection{[[filsysattach()]]}

\subsection{[[xfidattach()]]}

\section{Walk}

\subsection{[[filsyswalk()]]}

\subsection{Cloning [[fid]]}

\subsection{[[..]]}

\subsection{Error management}

\section{Open}

\subsection{[[filsysopen()]]}

\subsection{[[xfidopen()]]}

\section{Clunk/Close}

\subsection{[[filsysclunk()]]}

\subsection{[[xfidclose()]]}

\section{Read}

\subsection{[[filsysread()]]}

\subsection{Reading a directory}

\subsection{[[xfidread()]]}

\section{Write}

\subsection{[[filsyswrite()]]}

\subsection{[[xfidwrite()]]}

\section{Stats}

\subsection{[[filsysstat()]]}

\section{Forbidden operations}

%******************************************************************************
\chapter{Virtual Devices}
%******************************************************************************
\label{chap:virtual-devices}

\section{[[/mnt/wsys/mouse]]}

<<signature [[Virtual_mouse.dev_mouse]]>>=
(* a virtual "/dev/mouse" *)
val dev_mouse: Device.t
@

<<constant [[Virtual_mouse.dev_mouse]]>>=
let dev_mouse = { (*Device.default with*)
  name = "mouse";
  perm = Plan9.rw;

  open_ = (fun (w : Window.t) ->
    if w.mouse_opened
    then raise (Error "file in use");
    w.mouse_opened <- true;
    (* less: resized <- false? and race comment? *)
    ()
  );
  close = (fun (w : Window.t) ->
    (* stricter? check that was opened indeed? *)
    w.mouse_opened <- false;
    (* todo: resized? Refresh message?*)
    ()
  );
  (* a process is reading on its /dev/mouse; we must read from mouse
   * events coming to the window, events sent from the mouse thread.
   *)
  read_threaded = (fun _offset count (w : Window.t) ->
    (* less: flushtag *)
    (* less: qlock active *)
    (* less: qlock unactive after answer? so need reorg this func? *)
    let chan = Event.receive w.chan_devmouse_read |> Event.sync in
    let m : Mouse.state    = Event.receive chan |> Event.sync in
    (* less: resize message *)
    let str = 
      spf "%c%11d %11d %11d %11d " 
        'm' m.pos.x m.pos.y (Mouse.int_of_buttons m.buttons) m.msec
    in
    (* bugfix: note that we do not honor_offset. /dev/mouse is a dynamic file *)
    Device.honor_count count str
  );
  write_threaded = (fun _offset _str _w ->
    failwith "TODO: virtual_mouse.write_threaded"
  );
}
@

\subsection{Reading part1}

\subsection{Writing}



\section{[[/mnt/wsys/cons]]}

<<signature [[Virtual_cons.dev_cons]]>>=
(* virtual "/dev/cons" *)
val dev_cons    : Device.t
@

<<constant [[Virtual_cons.dev_cons]]>>=
let dev_cons = { Device.default with
  name = "cons";
  perm = Plan9.rw;

  (* a process is reading on its /dev/cons; we must read from key
   * events coming to the window (events sent from the keyboard thread).
   *)
  read_threaded = (fun _offset count (w : Window.t) ->
    (* less: flushtag *)
    (* less: handle unicode partial runes *)
    let (chan_count_out, chan_bytes_in) = 
      Event.receive w.chan_devcons_read |> Event.sync in
    Event.send chan_count_out count |> Event.sync;
    (* less: handle if flushing *)
    (* less: qlock active *)
    let bytes = Event.receive chan_bytes_in |> Event.sync in
    (* we asked for count so honor_count is redundant below (but defensive) *)
    Device.honor_count count bytes
  );
  (* a process is writing on its /dev/cons; it wants to output strings
   * on the terminal
   *)
  write_threaded = (fun _offset str (w : Window.t) ->
    (* todo: partial runes *)
    let runes = Rune.bytes_to_runes str in
    (* less: flushtag *)
    let chan_runes_out = Event.receive w.chan_devcons_write |> Event.sync in
    (* less: handle if flushing *)
    (* less: qlock active *)
    Event.send chan_runes_out runes |> Event.sync;
  );
}
@

\subsection{Reading part1}

\subsection{Writing part1}

\subsection{Bytes versus runes, partial runes}

\section{[[/mnt/wsys/consctl]]}

<<signature [[Virtual_cons.dev_consctl]]>>=
(* virtual "/dev/consctl" *)
val dev_consctl : Device.t
@

<<constant [[Virtual_cons.dev_consctl]]>>=
let dev_consctl = { Device.default with
  name = "consctl";
  perm = Plan9.w;
  
  open_ = (fun (w : Window.t) ->
    if w.consctl_opened
    then raise (Error "file in use");
    w.consctl_opened <- true;
  );
  close = (fun (w : Window.t) ->
    (* less: if holding *)
    if w.raw_mode
    then begin
      w.raw_mode <- false;
      (* less: send RawOff? but nop in Threads_window anyway *)
    end;
    w.consctl_opened <- false;
  );
    
  write_threaded = (fun _offset str (w : Window.t) ->
    match str with
    | "rawon" -> 
      (* less: holding *)
      (* stricter: set to bool, not increment, so no support 
       *  for multiple rawon *)
      (* stricter? exn if already on? *)
      w.raw_mode <- true;
      (* less: send RawOn? *)
    | "rawoff" ->
      (* todo: send RawOff so terminal can process remaining queued raw keys *)
      w.raw_mode <- false;
    | "holdon" ->
      failwith ("TODO: holdon")
    | "holdoff" ->
      failwith ("TODO: holdoff")
    | _ -> 
      raise (Error (spf "unknown control message: %s" str));
  );
}
@

\section{[[/mnt/wsys/cursor]]}

<<signature [[Virtual_mouse.dev_cursor]]>>=
(* a virtual "/dev/cursor" *)
(* val dev_cursor: Device.t *)
@

<<constant [[Virtual_mouse._dev_cursor]]>>=
let _dev_cursor = { (*Device.default with*)
  name = "cursor";
  perm = Plan9.rw;

  open_ = (fun _w ->
    raise Todo
  );
  close = (fun _w ->
    raise Todo
  );
  read_threaded = (fun _offset _count _w  ->
    raise Todo
  );
  write_threaded = (fun _offset _str _w ->
    raise Todo
  );
}
@



\section{[[/dev/draw/]] and [[/mnt/wsys/winname]]}

<<signature [[Virtual_draw.dev_winname]]>>=
(* virtual "/dev/winname" *)
val dev_winname: Device.t
@

<<constant [[Virtual_draw.dev_winname]]>>=
let dev_winname = { Device.default with
  name = "winname";
  perm = Plan9.r;
  
  read_threaded = (fun offset count (w : Window.t) ->
    let str = w.winname in
    if str = ""
    then raise (Error "window has no name");
    Device.honor_offset_and_count offset count str
  );
}
@

%******************************************************************************
\chapter{Graphical Windows}
%******************************************************************************
\label{chap:graphical-windows}

\section{Graphical window setup}

\subsection{[[initdraw()]]}

\subsection{[[initmouse()]], mouse-open mode}

\subsection{[[initkeyboard()]], raw-access mode}

\section{Mouse events}

\subsection{Mouse state queue}

\subsection{[[/mnt/wsys/mouse]]  reading part2}

\section{Keyboard events}

\subsection{Raw keys queue}

\subsection{[[/mnt/wsys/cons]] reading part2}

\section{Resize events}

\section{[[/mnt/wsys/window]]}

%******************************************************************************
\chapter{Textual Windows}
%******************************************************************************
\label{chap:textual-windows}

\section{Textual window creation}

\subsection{Scrollbar}

\subsection{Frame}

\section{Frame widget}
\label{sec:frame-widget}

\subsection{[[Frame]]}

\subsection{[[frinit()]]}

\subsection{Frame colors}
\subsection{Frame tick}
\subsection{Frame boxes}
\subsection{Frame strings}
\subsection{Frame rune position, point, and box number}
\subsection{Frame selection}

\section{Content modification}

\subsection{[[winsert()]]}
\subsection{Growing array}

\section{Content rendering}

\subsection{[[frinsert()]]}

\subsection{[[frdelete()]]}

\subsection{[[wshow()]]}
\subsection{Drawing the scrollbar: [[wscrdraw()]]}
\subsection{Drawing the tick: [[frtick()]]}
\subsection{Drawing the text and the selection: [[frdrawsel()]]}
\subsection{Moving the frame origin}
\subsection{Selecting}
\subsection{Repainting}

\section{Keyboard events}
\subsection{Text input queue}
\subsection{[[/mnt/wsys/cons]] reading part3}
\subsection{Navigation keys}
\subsection{Special keys}

\section{Application output events}
\subsection{[[/mnt/wsys/cons]] writing part2}

\section{Mouse events}
\subsection{Middle click menu}
\subsection{Other clicks}

\section{Automatic scrolling mode}

\section{Scroll bar interaction}

\section{Resize}

\section{[[/mnt/wsys/text]]}

%******************************************************************************
\chapter{Windowing System Files}
%******************************************************************************
\label{chap:window-files}

\section{[[/mnt/wsys/winid]]}

<<signature [[Dev_wm.dev_winid]]>>=
val dev_winid: Device.t
@

<<constant [[Dev_wm.dev_winid]]>>=
let dev_winid = { Device.default with
  name = "winid";
  perm = Plan9.r;
  read_threaded = (fun offset count (w : Window.t) ->
    let str = spf "%11d" w.id in
    Device.honor_offset_and_count offset count str
  );
}
@


\section{[[/mnt/wsys/label]]}

\section{[[/mnt/wsys/screen]]}

\section{[[/mnt/wsys/wsys/]]}

\section{[[/mnt/wsys/wctl]]}
\label{sec:mnt-wsys-wctl}

\subsection{Reading}

\subsection{Writing (controlling windows)}

%******************************************************************************
\chapter{Advanced Topics TODO}
%******************************************************************************
\label{chap:advanced}

\section{External mount: [[/srv/rio.user.pid]]}

\section{Command-line control: [[/srv/riowctl.user.pid]]}

\section{Recursive [[rio]]}
\label{sec:recursive-rio}

\section{Advanced terminal editing}

\subsection{Snarf}
\label{sec:snarf}

\subsection{Plumb}
\label{sec:plumb}

\subsection{Auto complete}
\label{sec:completion}
\label{sec:wdir}

\subsection{Word selection}

\section{Automatic scrolling: [[rio -s]]}

\section{Initial command: [[rio -i]]}

\section{Fake keyboard input: [[rio -k]]}

\subsection{[[rio -k]]}

\subsection{[[wkeyboard]]}

\subsection{[[/mnt/wsys/kdbin]]}

\subsection{Keyboard hide}

\section{Font selection: [[rio -f]]}

\section{Holding mode}

\section{Signals, notes}

\section{Timer}

\section{Flushing}

\section{Security}

\section{TODO [[Wakeup]]}

\section{TODO [[Refresh]]}

%******************************************************************************
\chapter{Conclusion}
%******************************************************************************
\label{chap:conclusion}

%###############################################################################

\appendix

%******************************************************************************
\chapter{Debugging}
%******************************************************************************
\label{chap:debugging-appendix}


<<[[CLI.main()]] locals>>=
let level = ref (Some Logs.Warning) in
@

<<[[CLI.main()]] logging setup>>=
Logs_.setup !level ();
Logs.info (fun m -> m "rio ran from %s" (Sys.getcwd()));
@


<<constant [[Globals.debug_9P]]>>=
let debug_9P = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
(* pad: not in original *)
"-debug_9P", Arg.Set Globals.debug_9P,
" ";
@

<<[[Threads_fileserver.thread]] in loop, debug>>=
(* todo: should exit the whole proc if error *)
if !Globals.debug_9P
then Logs.debug (fun m -> m "%s" (P9.str_of_msg req));
@

<<constant [[Globals.debug_draw]]>>=
let debug_draw = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
"-debug_draw", Arg.Set Globals.debug_draw,
" ";
@

<<[[CLI.thread_main()]] graphics initializations, debug>>=
if !Globals.debug_draw
then Display.debug display;
@

%******************************************************************************
\chapter{Error Management}
%******************************************************************************
\label{chap:error}

<<[[CLI.main()]] locals>>=
let backtrace = ref false in
@

<<[[CLI.main()]] handle [[exn]]>>=
if !backtrace
then raise exn
else 
  (match exn with
  | Failure s ->
        Logs.err (fun m -> m "%s" s);
        Exit.Code 1
  | _ -> raise exn
  )
@

<<function [[Threads_fileserver.error]]>>=
let error fs req str =
  let res = { req with P9.typ = P9.R (R.Error str) } in
  answer fs res
@


<<exception [[Device.Error]]>>=
(* This will be catched up by thread_fileserver to transform the
 * exception in an Rerror 9P response.
 *)
exception Error of string
@



\section{Error codes}

\section{[[error()]], [[derror()]]}

%******************************************************************************
%%\chapter{Utilities}
%******************************************************************************
%%\label{chap:utilities}

%******************************************************************************
\chapter{Examples of Windowing System Applications TODO}
%******************************************************************************
\label{chap:examples}

%******************************************************************************
\chapter{Extra Code}
%******************************************************************************

#include "orio_extra.nw"


\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
API = Application Programming Interface
GUI = Graphical User Interface
IDE = Integrated Development Environment
IPC = Inter Process Communication
RPC = Remote Procedure Call
LOC = Lines Of Code
PTY = Pseudo TTY
TTY = Teletype
WIMP = Window Icon Menu Pointer
MIME = Multipurpose Internet Mail Extensions
PDA = Personal Digital Assistant
\end{verbatim}


\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
