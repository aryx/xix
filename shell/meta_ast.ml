(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Ast

module Ocaml = OCaml

let rec vof_value =
  function
  | Word ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_bool v2
      in Ocaml.VSum (("Word", [ v1; v2 ]))
  | List v1 -> let v1 = vof_values v1 in Ocaml.VSum (("List", [ v1 ]))
  | CommandOutput v1 ->
      let v1 = vof_cmd_sequence v1 in Ocaml.VSum (("CommandOutput", [ v1 ]))
  | Dollar v1 -> let v1 = vof_value v1 in Ocaml.VSum (("Dollar", [ v1 ]))
  | Count v1 -> let v1 = vof_value v1 in Ocaml.VSum (("Count", [ v1 ]))
  | Index ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Index", [ v1; v2 ]))
  | Concat ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_value v2
      in Ocaml.VSum (("Concat", [ v1; v2 ]))
  | Stringify v1 ->
      let v1 = vof_value v1 in Ocaml.VSum (("Stringify", [ v1 ]))
and vof_values v = Ocaml.vof_list vof_value v
and vof_cmd =
  function
  | EmptyCommand -> Ocaml.VSum (("EmptyCommand", []))
  | Simple ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Simple", [ v1; v2 ]))
  | Pipe ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("Pipe", [ v1; v2 ]))
  | Async v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("Async", [ v1 ]))
  | Redir ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_redirection v2
      in Ocaml.VSum (("Redir", [ v1; v2 ]))
  | Dup ((v1, v2, v3, v4)) ->
      let v1 = vof_cmd v1
      and v2 = vof_redirection_kind v2
      and v3 = Ocaml.vof_int v3
      and v4 = Ocaml.vof_int v4
      in Ocaml.VSum (("Dup", [ v1; v2; v3; v4 ]))
  | And ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("And", [ v1; v2 ]))
  | Or ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("Or", [ v1; v2 ]))
  | Not v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("Not", [ v1 ]))
  | Match ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Match", [ v1; v2 ]))
  | If ((v1, v2)) ->
      let v1 = vof_cmd_sequence v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("If", [ v1; v2 ]))
  | IfNot v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("IfNot", [ v1 ]))
  | While ((v1, v2)) ->
      let v1 = vof_cmd_sequence v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("While", [ v1; v2 ]))
  | Switch ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd_sequence v2
      in Ocaml.VSum (("Switch", [ v1; v2 ]))
  | ForIn ((v1, v2, v3)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      and v3 = vof_cmd v3
      in Ocaml.VSum (("ForIn", [ v1; v2; v3 ]))
  | For ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("For", [ v1; v2 ]))
  | Compound v1 ->
      let v1 = vof_cmd_sequence v1 in Ocaml.VSum (("Compound", [ v1 ]))
  | Fn ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd_sequence v2
      in Ocaml.VSum (("Fn", [ v1; v2 ]))
  | DelFn v1 -> let v1 = vof_value v1 in Ocaml.VSum (("DelFn", [ v1 ]))
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_value v1
      and v2 = vof_value v2
      and v3 = vof_cmd v3
      in Ocaml.VSum (("Assign", [ v1; v2; v3 ]))
and vof_cmd_sequence v = Ocaml.vof_list vof_cmd v
and vof_redirection (v1, v2) =
  let v1 = vof_redirection_kind v1
  and v2 = vof_value v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_redirection_kind =
  function
  | RWrite -> Ocaml.VSum (("RWrite", []))
  | RRead -> Ocaml.VSum (("RRead", []))
  | RAppend -> Ocaml.VSum (("RAppend", []))
  | RDup ((v1, v2)) ->
      let v1 = Ocaml.vof_int v1
      and v2 = Ocaml.vof_int v2
      in Ocaml.VSum (("RDup", [ v1; v2 ]))
  
let vof_line v = Ocaml.vof_option vof_cmd_sequence v
  

