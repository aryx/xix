\section{[[Arch_linker.ml]]}

<<type [[Arch_linker.t]]>>=
type 'instr t = {
  branch_opd_of_instr: 'instr -> A.branch_operand option;
  visit_globals_instr: (A.global -> unit) -> 'instr -> unit;
}
@

%-------------------------------------------------------------

<<Arch_linker.ml>>=
module A = Ast_asm

(* Arch-specific methods allowing to factorize code in the linker
 * (e.g., in Load.ml)
 * alt: use a functor, but can't with ocaml-light and records are fine! 
 *)
<<type [[Arch_linker.t]]>>
@

\section{[[Check.mli]]}

%-------------------------------------------------------------

<<Check.mli>>=

<<signature [[Check.check]]>>
@

\section{[[Check.ml]]}

%-------------------------------------------------------------

<<Check.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

open Types
module T = Types

<<function [[Check.check]]>>

(* todo: could also check validity of object file:
 *  - no duplicate DATA for same global.
 *    for instance with int foo = 1; int foo = 2;  5c does not say anything,
 *    but we should warn at least in linker because generated assembly
 *    contains DATA concerning same global!
 * less:
 *  - registers are in range, 
 *  - integers are in range,
 *    ex with immediate in shifting operation:
 *    if i >= 0 && i <= 31
 *    then ...
 *    else failwith "shift value out of range"
 *  - that cond is AL for B and Bxx,
 *  - that use Local or Param only when inside a Text (and for Local
 *    that if fits the size specified),
 *    | None -> error loc "use of parameter outside of procedure"
 *    | None -> error loc "use of local outside of procedure"
 *  - ...
 * 
 *  See use of error() in codegen5.ml, or notes about 5l in ocaml in
 *  Linker.nw for more invariants to check.
 *)
@


\section{[[CLI.mli]]}

%-------------------------------------------------------------

<<CLI.mli>>=
<<type [[CLI.caps]]>>

<<signature [[CLI.main]]>>

<<signature [[CLI.link]]>>
@


\section{[[CLI.ml]]}

%-------------------------------------------------------------

<<CLI.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

module T = Types

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of 5l/vl, the Plan 9 ARM/MIPS linkers.
 *
 * Main limitations compared to 5l/vl/...:
 * - no -E digit 
 *   (What was it anyway?)
 * - no optimisation about small data, strings in text section
 *   (really gain?)
 * - no extensions not yet understood (import/export, dynamic linking)
 *   (not sure it was used by any Plan 9 programs)
 * - address of parameter or local is not supported
 *   (Why would you want that? Does 5c generate that?)
 *   update: actually I support it now no?
 *
 * Main limitations compared to 5l:
 * - no half-word specialized instructions and immhalf()
 *   (rare instructions anyway?)
 * Main limitations compared to vl:
 *  - no sched/nosched support (no scheduling)
 *    (but better not to be too smart? in fact vl was only linker doing that)
 *
 * Better than 5l/vl/...:
 * - greater code reuse across all linkers thanks to:
 *    * use of marshalling for objects and libraries
 *    * factorized analysis such as Resolve.build_graph, Datagen.gen,
 *      Load.load, Layout.layout_data
 * 
 * todo?:
 *  - -v is quite useful to debug "redefinition" linking errors
 *    (see pb I had when linking bcm/ kernel)
 *  - when get undefined symbol, print function you are currently in!
 *    very useful to diagnose issue to give context and where to look for
 *  - arith LCON less: NCON
 *  - half word and byte load/store basic version
 *  - endianess and datagen
 *  - advanced instructions: floats, MULL, coprocessor, psr, etc
 *  - library ranlib/symdef indexing
 *  - profiling -p
 *  - symbol table
 *  - program counter line table
 *  - nice error reporting for signature conflict, conflicting objects
 *
 * later:
 *  - look at the 5l Go sources in the Golang source, maybe ideas to steal?
 *)

(*****************************************************************************)
(* Types, constants, and globals *)
(*****************************************************************************)
<<type [[CLI.caps]]>>

<<constant [[CLI.init_text]]>>
<<constant [[CLI.init_round]]>>
<<constant [[CLI.init_data]]>>

<<constant [[CLI.init_entry]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[CLI.config_of_header_type]]>>

(*****************************************************************************)
(* Main algorithm *)
(*****************************************************************************)
<<function [[CLI.link5]]>>

(* similar to link5 *)
let linkv (caps : < Cap.open_in; ..> ) (config : Exec_file.linker_config) (files : Fpath.t list) (chan : Chan.o) : unit =
  let arch : Ast_asmv.instr Arch_linker.t = {
    Arch_linker.branch_opd_of_instr = Ast_asmv.branch_opd_of_instr;
    Arch_linker.visit_globals_instr = Ast_asmv.visit_globals_instr;
  }
  in
  let (code, data, symbols) = Load.load caps files arch in
  T.lookup (config.entry_point, T.Public) None symbols |> ignore;
  let graph = Resolve.build_graph arch.branch_opd_of_instr symbols code in
  let graph = Rewritev.rewrite graph in
  let symbols2, (data_size, bss_size) = 
    Layout.layout_data symbols data in
  Layout.xdefine symbols2 symbols ("setR30" , T.Public) (T.SData2 (0, T.Data));
  Check.check symbols;
  let symbols2, graph, text_size = 
    Layoutv.layout_text symbols2 config.init_text graph in
  let sizes : Exec_file.sections_size = 
    Exec_file.{ text_size; data_size; bss_size } 
  in
  let init_data =  
    match config.init_data with
    | None -> Int_.rnd (text_size + config.init_text) config.init_round
    | Some x -> x
  in
  let config = { config with Exec_file.init_data = Some init_data } in
  Logs.info (fun m -> m "final config is %s" 
        (Exec_file.show_linker_config config));
  let instrs = Codegenv.gen symbols2 config graph in
  let datas  = Datagen.gen symbols2 init_data sizes data in
  Execgen.gen config sizes instrs datas symbols2 chan


<<function [[CLI.link]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[CLI.main]]>>
@


\section{[[Codegen5.mli]]}

<<type [[Codegen5.pool (Codegen5.mli)]]>>=
@

%-------------------------------------------------------------

<<Codegen5.mli>>=

<<type [[Codegen5.pool (Codegen5.mli)]]>>

<<signature [[Codegen5.size_of_instruction]]>>

<<signature [[Codegen5.gen]]>>

(* internals *)
val rules: Codegen.env -> Types.addr option -> Types5.node -> Codegen.action

@


\section{[[Codegen5.ml]]}

<<type [[Codegen5.pool]]>>=
@




<<function [[Codegen5.int_of_bits]]>>=
let int_of_bits (n : node) (x : Bits.int32) : int =
  try
    Bits.int_of_bits32 x
  with Failure s -> error n s
@

<<function [[Codegen5.offset_to_R12]]>>=
let offset_to_R12 x =
  (* less: x - BIG at some point if want some optimisation *)
  x
@

<<function [[Codegen5.base_and_offset_of_indirect]]>>=
let base_and_offset_of_indirect node symbols2 autosize x =
  match x with
  | Indirect (r, off) -> r, off 
  | Entity (Param (_s, off)) ->
      (* remember that the +4 below is because we access the frame of the
       * caller which for sure is not a leaf. Note that autosize
       * here had possibly a +4 done if the current function
       * was a leaf, but still we need another +4 because what matters
       * now is the adjustment in the frame of the caller!
       *)
      rSP, autosize + 4 + off
  | Entity (Local (_s, off)) -> 
      rSP, autosize + off
  | Entity (Global (global, off)) ->
      let v = Hashtbl.find symbols2 (T.symbol_of_global global) in
      (match v with
        | T.SData2 (offset, _kind) ->
          rSB, offset_to_R12 (offset + off)
      (* stricter: allowed in 5l but I think with wrong codegen *)
      | T.SText2 _ -> 
          error node (spf "use of procedure %s in indirect with offset"
                       (A.s_of_global global))
      )
  | Imsr _ | Ximm _ -> raise (Impossible "should be called only for indirects")
@

<<function [[Codegen5.immrot]]>>=
let immrot x =
  if x >= 0 && x <= 0xff
  then Some (0, x)
  else raise Todo
@

<<function [[Codegen5.immoffset]]>>=
let immoffset x =
  (x >= 0 && x <= 0xfff) || (x < 0 && x >= -0xfff)
@

<<function [[Codegen5.gcond]]>>=
(* gxxx below means gen_binary_code of xxx *)

let gcond cond =
  match cond with
  | EQ            -> (0x0, 28)
  | NE            -> (0x1, 28)
  | GE (U) -> (0x2, 28)
  | LT (U) -> (0x3, 28)
  | MI            -> (0x4, 28)
  | PL            -> (0x5, 28)
  | VS            -> (0x6, 28)
  | VC            -> (0x7, 28)
  | GT (U) -> (0x8, 28)
  | LE (U) -> (0x9, 28) 
  | GE (S)   -> (0xa, 28) 
  | LT (S)   -> (0xb, 28)
  | GT (S)   -> (0xc, 28)
  | LE (S)   -> (0xd, 28)
  | AL            -> (0xe, 28)
  | NV            -> (0xf, 28)
@

<<function [[Codegen5.gop_arith]]>>=
let gop_arith op =
  match op with
  | AND -> (0x0, 21)
  | EOR -> (0x1, 21)
  | SUB -> (0x2, 21)
  | RSB -> (0x3, 21)
  | ADD -> (0x4, 21)
  | ADC -> (0x5, 21)
  | SBC -> (0x6, 21)
  | RSC -> (0x7, 21)
  (* TST 0x8, TEQ 0x9, CMP 0xa, CMN 0xb via gop_cmp below *)
  | ORR -> (0xc, 21)
  | MOV -> (0xd, 21) (* no reading syntax in 5a, but can be generated by 5l *)
  | BIC -> (0xe, 21)
  | MVN -> (0xf, 21)

  | MUL | DIV | MOD -> raise (Impossible "should match those cases separately")
  | SLL | SRL | SRA -> raise (Impossible "should match those cases separately")
@

<<function [[Codegen5.gsetbit]]>>=
let gsetbit opt =
  match opt with
  | None -> []
  | Some Set_condition -> [(1, 20)]
@

<<function [[Codegen5.gop_shift]]>>=
let gop_shift op =
  match op with
  | SLL -> (0, 5)
  | SRL -> (1, 5)
  | SRA -> (2, 5)
  | _ -> raise (Impossible "should match those cases separately")
@

<<function [[Codegen5.gop_cmp]]>>=
let gop_cmp op =
  match op with
  (* Set_condition set by default for comparison opcodes *)
  | TST -> [(0x8, 21); (1, 20)]
  | TEQ -> [(0x9, 21); (1, 20)]
  | CMP -> [(0xa, 21); (1, 20)]
  | CMN -> [(0xb, 21); (1, 20)]
@

<<function [[Codegen5.gop_bitshift_register]]>>=
let gop_bitshift_register op =
  match op with
  | Sh_logic_left   -> (0x0, 5)
  | Sh_logic_right  -> (0x1, 5)
  | Sh_arith_right  -> (0x2, 5)
  | Sh_rotate_right -> (0x3, 5)
@

<<function [[Codegen5.gop_rcon]]>>=
let gop_rcon x =
  match x with
  | Left (R r) -> [(r,8); (1, 4)]
  | Right i    -> [(i, 7); (0, 4)]
@

<<function [[Codegen5.gshift]]>>=
let gshift (R rf) op2 rcon = 
  gop_rcon rcon @ [gop_bitshift_register op2; (rf, 0)]
@

<<function [[Codegen5.gbranch_static]]>>=
let gbranch_static (nsrc : T5.node) cond is_bl =
  match nsrc.branch with
  | None -> raise (Impossible "resolving should have set the branch field")
  | Some ndst -> 
      let dst_pc = ndst.real_pc in
      let v = (dst_pc - nsrc.real_pc) - 8 in
      if v mod 4 <> 0
      then raise (Impossible "layout text wrong, not word aligned node");
      let v = (v asr 2) land 0xffffff in
      (* less: stricter: warn if too big, but should never happens *)
      [gcond cond; (0x5, 25);
       (if is_bl then (0x1, 24) else (0x0, 24)); 
       (v, 0) 
       ]
@

<<function [[Codegen5.gmem]]>>=
let gmem cond op move_size opt offset_or_rm (R rbase) (R rt) =
  [gcond cond; (0x1, 26) ] @
  (match opt with
  | None ->                  [(1, 24)] (* pre offset *)
  | Some PostOffsetWrite ->  [(0, 24)]
  | Some WriteAddressBase -> [(1, 24); (1, 21)]
  ) @
  [(match move_size with 
   | Word -> (0, 22) 
   | Byte _ -> (1, 22) 
   | HalfWord _ -> raise (Impossible "should use different pattern rule")
   );
   (match op with 
    | LDR -> (1, 20) 
    | STR -> (0, 20)
   );
   (rbase, 16); (rt, 12);
  ] @
  (match offset_or_rm with
  | Either.Left offset -> 
      if offset >= 0 
      then [(1, 23); (offset, 0)]
      else [(0, 23); (-offset, 0)]
  | Either.Right (R r) -> [(1, 25); (r, 0)]
  )
@

<<function [[Codegen5.gload_from_pool]]>>=
let gload_from_pool (nsrc : T5.node) cond rt =
  match nsrc.branch with
  | None -> raise (Impossible "literal pool should be attached to node")
  | Some ndst ->
      (* less: could assert the dst node is a WORD *)
      let dst_pc = ndst.real_pc in
      let v = (dst_pc - nsrc.real_pc) - 8 in
      if v mod 4 <> 0
      then raise (Impossible "layout text wrong, not word aligned node");
      (* LDR v(R15), RT (usually R11) *)
      gmem cond LDR Word None (Left v) rPC rt
@


%-------------------------------------------------------------

<<Codegen5.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast_asm
open Ast_asm5

module T = Types
module T5 = Types5
open Types
open Types5
open Codegen

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* ARM code generation.
 *
 * ocaml: No need for optab/oplook/ocmp/cmp as in 5l. Just use pattern matching!
 *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

<<type [[Codegen5.pool]]>>

<<type [[Codegen5.action]]>>

<<type [[Codegen5.mem_opcode]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Codegen5.error]]>>

<<function [[Codegen5.int_of_bits]]>>

<<function [[Codegen5.offset_to_R12]]>>

<<function [[Codegen5.base_and_offset_of_indirect]]>>

(*****************************************************************************)
(* Operand classes *)
(*****************************************************************************)

<<function [[Codegen5.immrot]]>>

<<function [[Codegen5.immoffset]]>>

(*****************************************************************************)
(* Code generation helpers *)
(*****************************************************************************)

<<function [[Codegen5.gcond]]>>


<<function [[Codegen5.gop_arith]]>>
  
<<function [[Codegen5.gsetbit]]>>
  

<<function [[Codegen5.gop_shift]]>>


<<function [[Codegen5.gop_cmp]]>>

<<function [[Codegen5.gop_bitshift_register]]>>

<<function [[Codegen5.gop_rcon]]>>

(*****************************************************************************)
(* More complex code generation helpers *)
(*****************************************************************************)

<<function [[Codegen5.gshift]]>>

<<function [[Codegen5.gbranch_static]]>>


<<function [[Codegen5.gmem]]>>

<<function [[Codegen5.gload_from_pool]]>>
      
(*****************************************************************************)
(* The rules! *)
(*****************************************************************************)
<<function [[Codegen5.rules]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)
(* TODO: could reuse this code and only things changing are the rules to pass?*)
<<function [[Codegen5.size_of_instruction]]>>

(* TODO: could reuse this code and only things changing are the rules to pass?*)
<<function [[Codegen5.gen]]>>
@


\section{[[Datagen.mli]]}

%-------------------------------------------------------------

<<Datagen.mli>>=

<<signature [[Datagen.gen]]>>
@


\section{[[Datagen.ml]]}

%-------------------------------------------------------------

<<Datagen.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module A = Ast_asm
module T = Types

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Datagen.gen]]>>
@


\section{[[Execgen.mli]]}

%-------------------------------------------------------------

<<Execgen.mli>>=

<<signature [[Execgen.gen]]>>
@


\section{[[Execgen.ml]]}

%-------------------------------------------------------------

<<Execgen.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module T = Types

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Execgen.gen]]>>
@


\section{[[Layout5.mli]]}

%-------------------------------------------------------------

<<Layout5.mli>>=

<<signature [[Layout5.layout_data]]>>

<<signature [[Layout5.layout_text]]>>
@


\section{[[Layout5.ml]]}

%-------------------------------------------------------------

<<Layout5.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module T = Types
module T5 = Types5
module A = Ast_asm

<<function [[Layout5.xdefine]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)
<<function [[Layout5.layout_data]]>>

(* TODO: seems reusable if pass Codegen5.size_of_instruction? move
 * to Latout.ml with layout_date?
 *)
<<function [[Layout5.layout_text]]>>
@


\section{[[Load.mli]]}

%-------------------------------------------------------------

<<Load.mli>>=

<<signature [[Load.load]]>>
@


\section{[[Load.ml]]}

<<function [[Load.process_global]]>>=
(* "Names", modifies global, modifies h *)
let process_global (global : A.global) (h : T.symbol_table) (idfile : int) : unit =
  (match global.priv with
  | Some _ -> global.priv <- Some idfile
  | None -> ()
  );
  (* populate symbol table with SXref if new entity *)
  T.lookup_global global h |> ignore
@

%-------------------------------------------------------------

<<Load.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
module A = Ast_asm
module T = Types

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Load.process_global]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Load.load]]>>
@


\section{[[Main.ml]]}

%-------------------------------------------------------------

<<Main.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
(* open Xix_linker *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<toplevel [[Main._1]]>>
@


\section{[[Resolve.mli]]}

%-------------------------------------------------------------

<<Resolve.mli>>=

<<signature [[Resolve.build_graph]]>>
@

\section{[[Resolve.ml]]}

%-------------------------------------------------------------

<<Resolve.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

open Types
module A = Ast_asm
module T = Types

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Resolve.build_graph]]>>
@


\section{[[Rewrite5.mli]]}

%-------------------------------------------------------------

<<Rewrite5.mli>>=

<<signature [[Rewrite5.rewrite]]>>
@


\section{[[Rewrite5.ml]]}

<<function [[Rewrite5.find_first_no_nop_node]]>>=
@

%-------------------------------------------------------------

<<Rewrite5.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module A = Ast_asm
module A5 = Ast_asm5
open Types
module T = Types
module T5 = Types5

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Rewrite5.find_first_no_nop_node]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Rewrite5.rewrite]]>>
@


\section{[[Types.ml]]}


<<function [[Types.lookup]]>>=
(* create new entry with SXRef if not found *)
let lookup (k : symbol) (sigopt : signature option) (h : symbol_table) : value =
  let v =
    try
      Hashtbl.find h k
    with Not_found ->
      let v = { section = SXref; sig_ = sigopt } in
      Hashtbl.add h k v;
      v
  in
  (match sigopt, v.sig_ with
  | None, None -> ()
  | Some i1, Some i2 ->
      (* todo: report also offending object files *)
      if i1 <> i2
      then failwith (spf "incompatible type signatures %d and %d" i1 i2)
  (* less: could report error when one define sig and not other *)
  | _ -> ()
  );
  v
@



<<function [[Types.lookup_global]]>>=
let lookup_global (x : A.global) (h : symbol_table) : value =
  let symbol = symbol_of_global x in
  lookup symbol x.signature h
@

<<function [[Types.s_of_loc]]>>=
(* less: would need Hist mapping for this file to convert to original source *)
let s_of_loc (file, line) =
  spf "%s:%d" !!file line
@

<<function [[Types.iter]]>>=
let rec iter f n =
  f n;
  n.next |> Option.iter (fun n -> iter f n)
@

<<function [[Types.iter_with_env]]>>=
let rec iter_with_env f env n =
  let env = f env n in
  n.next |> Option.iter (fun n -> iter_with_env f env n)
@


%-------------------------------------------------------------

<<Types.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

module A = Ast_asm

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* --------------------------------------- *)
(* basic types *)
(* --------------------------------------- *)

<<type [[Types.loc]]>>
[@@deriving show]

<<type [[Types.byte]]>>
[@@deriving show]
<<type [[Types.word]]>>
[@@deriving show]

<<type [[Types.addr]]>>
[@@deriving show]
<<type [[Types.offset]]>>
[@@deriving show]

<<type [[Types.symbol]]>>
<<type [[Types.scope]]>>
[@@deriving show]

(* --------------------------------------- *)
(* The virtual pc world *)
(* --------------------------------------- *)

<<type [[Types.virt_pc]]>>
[@@deriving show]

<<type [[Types.section]]>>
[@@deriving show]

<<type [[Types.signature]]>>
[@@deriving show]

<<type [[Types.value]]>>
[@@deriving show]

<<type [[Types.symbol_table]]>>
(*[@@deriving show]*)

(* --------------------------------------- *)
(* The real pc world *)
(* --------------------------------------- *)

<<type [[Types.real_pc]]>>
[@@deriving show]

<<type [[Types.section2]]>>
<<type [[Types.data_kind]]>>
[@@deriving show]

<<type [[Types.value2]]>>
[@@deriving show]

<<type [[Types.symbol_table2]]>>
(*[@@deriving show]*)

(* --------------------------------------- *)
(* Code vs Data *)
(* --------------------------------------- *)


(* Split Asm instructions in code vs data.
 *
 * For 'code' below we want to do some naming. We could copy many of 
 * ast_asm.ml and replace 'global' with the fully resolved 'symbol'.
 * But it would be a big copy paste. Instead, we opted for a mutable field 
 * in ast_asm.ml set by the linker (see Ast_asm.entity.priv).
 *)
<<type [[Types.code]]>>
<<type [[Types.code_bis]]>>
[@@deriving show {with_path = false}]

<<type [[Types.data]]>>
[@@deriving show]


(* graph via pointers, like in original 5l *)
<<type [[Types.node]]>>
[@@deriving show]

<<type [[Types.code_graph]]>>
[@@deriving show]

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Types.lookup]]>>

<<function [[Types.s_of_symbol]]>>

<<function [[Types.symbol_of_global]]>>

<<function [[Types.lookup_global]]>>


<<function [[Types.s_of_loc]]>>

<<function [[Types.iter]]>>

<<function [[Types.iter_with_env]]>>
@


\section{[[Types5.ml]]}

<<function [[Types5.show_instr]]>>=
(* for ocaml-light, to work without deriving *)
let show_instr _ = "NO DERIVING"
[@@warning "-32"]
@

%-------------------------------------------------------------

<<Types5.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<function [[Types5.show_instr]]>>

<<type [[Types5.instr]]>>

<<type [[Types5.node]]>>

<<type [[Types5.code_graph]]>>
@


\section{[[executables/A_out.mli]]}

%-------------------------------------------------------------

<<executables/A_out.mli>>=

<<signature [[A_out.header_size]]>>

<<signature [[A_out.write_header]]>>
@


\section{[[executables/A_out.ml]]}

%-------------------------------------------------------------

<<executables/A_out.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<constant [[A_out.header_size]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[A_out.write_header]]>>
@


\section{[[executables/Elf.mli]]}

%-------------------------------------------------------------

<<executables/Elf.mli>>=

<<signature [[Elf.header_size]]>>

<<signature [[Elf.write_headers]]>>
@


\section{[[executables/Elf.ml]]}

%-------------------------------------------------------------

<<executables/Elf.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* ELF executable format types and IO helpers.
 *
 * spec: ???
*)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

<<constant [[Elf.exec_header_32_size]]>>
<<constant [[Elf.program_header_32_size]]>>
<<constant [[Elf.section_header_32_size]]>>

<<constant [[Elf.nb_program_headers]]>>

<<constant [[Elf.header_size]]>>

(* ------------------------------------------------------------------------- *)
(* Exec header *)
(* ------------------------------------------------------------------------- *)

<<type [[Elf.ident_class]]>>

(* alt: ident_data *)
<<type [[Elf.byte_order]]>>

<<type [[Elf.ident_version]]>>

<<type [[Elf.elf_type]]>>

<<type [[Elf.machine]]>>

(* ------------------------------------------------------------------------- *)
(* Program header *)
(* ------------------------------------------------------------------------- *)

<<type [[Elf.program_header_type]]>>

<<type [[Elf.program_header_protection]]>>

(* ------------------------------------------------------------------------- *)
(* Section header *)
(* ------------------------------------------------------------------------- *)

(*****************************************************************************)
(* Conversions *)
(*****************************************************************************)
<<function [[Elf.byte_of_class]]>>

<<function [[Elf.byte_of_byte_order]]>>

<<function [[Elf.int_of_version]]>>

<<function [[Elf.int_of_elf_type]]>>

<<function [[Elf.int_of_machine]]>>

<<function [[Elf.int_of_program_header_type]]>>

<<function [[Elf.int_of_prot]]>>

<<function [[Elf.int_of_prots]]>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)
<<function [[Elf.write_ident]]>>

<<function [[Elf.program_header_32]]>>
  
(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Elf.write_headers]]>>
@


\section{[[executables/Exec_file.ml]]}

<<function [[Exec_file.show_linker_config]]>>=
(* for ocaml-light to work without deriving *)
let show_linker_config _ = "NO DERIVING"
[@@warning "-32"]
@

%-------------------------------------------------------------

<<executables/Exec_file.ml>>=

<<type [[Exec_file.addr]]>>
[@@deriving show]

<<type [[Exec_file.header_type]]>>
[@@deriving show]

<<type [[Exec_file.sections_size]]>>
[@@deriving show]

<<function [[Exec_file.show_linker_config]]>>

<<type [[Exec_file.linker_config]]>>
[@@deriving show]
@


\section{[[libraries/Library_file.mli]]}

%-------------------------------------------------------------

<<libraries/Library_file.mli>>=
<<type [[Library_file.t]]>>

<<signature [[Library_file.load]]>>

<<signature [[Library_file.save]]>>

<<signature [[Library_file.is_lib_filename]]>>
@


\section{[[libraries/Library_file.ml]]}

%-------------------------------------------------------------

<<libraries/Library_file.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Regexp_.Operators
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Simple API to load/save archive library files (e.g., libc.a) *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

(* An archive (.a) is really essentially just a list of objects, which in Plan 9
 * are just a list of serialized assembly ASTs
 *
 * TODO: do SYMDEF/ranlib indexing so can avoid objects that are not
 * needed by the linked program like in 5l/vl/...
 *)
<<type [[Library_file.t]]>>

(*****************************************************************************)
(* API *)
(*****************************************************************************)

<<function [[Library_file.save]]>>

<<function [[Library_file.load]]>>

<<function [[Library_file.is_lib_filename]]>>
@


\section{[[tools/ar.ml]]}

%-------------------------------------------------------------

<<tools/ar.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of ar, the Plan 9 (object) archiver.
 *
 * Main limitations compared to ar:
 *  - no complex CLI flags; just 'oar objfiles [-o libfile]'
 *    no ar vu, ar rcs, ... just archive!
 *
 * todo:
 *  - index the archive a la SYMDEF/ranlib to reduce size of
 *    binaries in the linker for unneeded object files
 *
 * later:
 *)

(*****************************************************************************)
(* Types, constants, and globals *)
(*****************************************************************************)
<<type [[Ar.caps]]>>

<<constant [[Ar.usage]]>>

(*****************************************************************************)
(* Main algorithm *)
(*****************************************************************************)
<<function [[Ar.archive]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Ar.main]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<constant [[Ar._]]>>
@


\section{[[tools/nm.ml]]}

%-------------------------------------------------------------

<<tools/nm.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Ast_asm
module A = Ast_asm

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of nm, the Plan 9 object/executable/library symbol inspector.
 * 'nm' probably stands for "names" or "name map".
 *
 * Main limitations compared to nm:
 *  - 
 *
 * todo:
 *  - handle executable too
 *
 * later:
 *)

(*****************************************************************************)
(* Types, constants, and globals *)
(*****************************************************************************)
<<type [[Nm.caps]]>>

<<constant [[Nm.usage]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Nm.visit_obj]]>>

(*****************************************************************************)
(* Main algorithm *)
(*****************************************************************************)

<<function [[Nm.nm]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Nm.main]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<constant [[Nm._]]>>
@


