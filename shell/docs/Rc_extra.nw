\chapter{Extra Code}

\section{[[shell/]]}

\subsection*{[[Ast.ml]]}

%-------------------------------------------------------------

<<shell/Ast.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

<<type [[Ast.value]]>>
<<type [[Ast.values]]>>

<<type [[Ast.cmd]]>>
<<type [[Ast.cmd_sequence]]>>

(* todo: RDup does not have a filename? so push value inside RWrite of value*)
<<type [[Ast.redirection]]>>
<<type [[Ast.redirection_kind]]>>

<<type [[Ast.line]]>>

(* less: type any = Line of line | ... so easier dumper *)
@

\subsection*{[[Builtin.ml]]}

%-------------------------------------------------------------

<<shell/Builtin.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

open Common

module R = Runtime
module E = Error
module O = Opcode

<<function [[Builtin.is_builtin]]>>
<<constant [[Builtin.ndots]]>>
<<function [[Builtin.dochdir]]>>
<<constant [[Builtin.dotcmds]]>>
<<function [[Builtin.dispatch]]>>
@

\subsection*{[[CLI.ml]]}

%-------------------------------------------------------------

<<shell/CLI.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

open Common
open Fpath_.Operators

module R = Runtime
module O = Opcode

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of rc, the Plan 9 shell.
 *
 * Main limitations compared to rc:
 *  - no unicode support
 *  - not all of the fancy redirections and fancy pipes
 *  - no storing of functions in the environment
 *    (used by rcmain. But can do the same by using '. rcmain')
 * 
 * Improvements (IMHO):
 *  - a strict mode where we report when deleting undefined function
 *  - Logs with errors and warnings and debug
 *  - more?
 * 
 * todo:
 *  - read environment variables and export variables
 *  - globbing
 *  - Isatty rc -i detection
 *  - add ~ shortcut for HOME (from csh?)
 *  - rc -c
 *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

<<type [[CLI.caps]]>>

(* -d and -p are dead according to man page so I removed them *)
<<constant [[CLI.usage]]>>

(*****************************************************************************)
(* Testing *)
(*****************************************************************************)

<<function [[CLI.do_action]]>>

(*****************************************************************************)
(* Main algorithm *)
(*****************************************************************************)

<<constant [[CLI._bootstrap_simple]]>>
<<function [[CLI.bootstrap]]>>

<<function [[CLI.interpret_bootstrap]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[CLI.main]]>>
@

\subsection*{[[Compile.ml]]}

%-------------------------------------------------------------

<<shell/Compile.ml>>=
open Common

module A = Ast
module O = Opcode

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* AST to opcodes.
*)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Compile.split_at_non_assign]]>>
<<function [[Compile.split_when_case]]>>

(*****************************************************************************)
(* Compilation algorithm *)
(*****************************************************************************)

<<function [[Compile.outcode_seq]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Compile.compile]]>>
@


\subsection*{[[Dumper_.ml]]}

%-------------------------------------------------------------

<<shell/Dumper_.ml>>=
module Ocaml = OCaml
(* less: could use Any *)

<<function [[Dumper_.s_of_line]]>>
<<function [[Dumper_.s_of_cmd_sequence]]>>
<<function [[Dumper_.s_of_cmd]]>>
<<function [[Dumper_.s_of_value]]>>

<<function [[Dumper_.s_of_opcode]]>>
<<function [[Dumper_.s_of_operation]]>>
<<function [[Dumper_.s_of_codevec]]>>
@

\subsection*{[[Env.ml]]}

%-------------------------------------------------------------

<<shell/Env.ml>>=
@

\subsection*{[[Error.ml]]}

%-------------------------------------------------------------

<<shell/Error.ml>>=
module R = Runtime

<<function [[Error.error]]>>
@

\subsection*{[[Flags.ml]]}

%-------------------------------------------------------------

<<shell/Flags.ml>>=
open Common

<<constant [[Flags.interactive]]>>
<<constant [[Flags.login]]>>

<<constant [[Flags.eflag]]>>
<<constant [[Flags.rflag]]>>
<<constant [[Flags.sflag]]>>
<<constant [[Flags.xflag]]>>

(* less: let cflag = ref "" *)

<<global [[Flags.hflags]]>>

<<constant [[Flags.rcmain]]>>

(* pad: I added this one *)
<<constant [[Flags.strict_mode]]>>

<<constant [[Flags.dump_tokens]]>>
<<constant [[Flags.dump_ast]]>>
<<constant [[Flags.dump_opcodes]]>>

<<constant [[Flags.debugger]]>>
@


\subsection*{[[Fn.ml]]}

<<signature [[Fn.flook]]>>=
val flook : string -> Runtime.fn option
@

<<function [[Fn.flook]]>>=
let flook s =
  try 
    Some (Hashtbl.find R.fns s)
  with Not_found -> None
@

%-------------------------------------------------------------

<<shell/Fn.ml>>=
module R = Runtime

<<function [[Fn.flook]]>>
@

\subsection*{[[Glob.ml]]}

%-------------------------------------------------------------

<<shell/Glob.ml>>=
@

\subsection*{[[Globals.ml]]}

<<constant [[Globals.eflagok]]>>=
(* this is set after the first . of rcmain *)
let eflagok = ref false
@

%-------------------------------------------------------------

<<shell/Globals.ml>>=

<<constant [[Globals.skipnl]]>>
<<constant [[Globals.errstr]]>>

<<constant [[Globals.ifnot]]>>
<<constant [[Globals.eflagok]]>>
@

\subsection*{[[Heredoc.ml]]}

%-------------------------------------------------------------

<<shell/Heredoc.ml>>=
@


\subsection*{[[Interpreter.ml]]}

%-------------------------------------------------------------

<<shell/Interpreter.ml>>=
open Common

module O = Opcode
module R = Runtime
module E = Error

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Interpreter.file_descr_of_int]]>>
<<function [[Interpreter.int_at_address]]>>

<<function [[Interpreter.vlook_varname_or_index]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Interpreter.interpret_operation]]>>
@

\subsection*{[[Main.ml]]}

%-------------------------------------------------------------

<<shell/Main.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Xix_shell

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<toplevel [[Main._1]]>>
@

\subsection*{[[Meta_ast.ml]]}

<<function [[Meta_ast.vof_line]]>>=
let vof_line v = Ocaml.vof_option vof_cmd_sequence v
@

%-------------------------------------------------------------

<<shell/Meta_ast.ml>>=
(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Ast

module Ocaml = OCaml

let rec vof_value =
  function
  | Word ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_bool v2
      in Ocaml.VSum (("Word", [ v1; v2 ]))
  | List v1 -> let v1 = vof_values v1 in Ocaml.VSum (("List", [ v1 ]))
  | CommandOutput v1 ->
      let v1 = vof_cmd_sequence v1 in Ocaml.VSum (("CommandOutput", [ v1 ]))
  | Dollar v1 -> let v1 = vof_value v1 in Ocaml.VSum (("Dollar", [ v1 ]))
  | Count v1 -> let v1 = vof_value v1 in Ocaml.VSum (("Count", [ v1 ]))
  | Index ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Index", [ v1; v2 ]))
  | Concat ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_value v2
      in Ocaml.VSum (("Concat", [ v1; v2 ]))
  | Stringify v1 ->
      let v1 = vof_value v1 in Ocaml.VSum (("Stringify", [ v1 ]))
and vof_values v = Ocaml.vof_list vof_value v
and vof_cmd =
  function
  | EmptyCommand -> Ocaml.VSum (("EmptyCommand", []))
  | Simple ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Simple", [ v1; v2 ]))
  | Pipe ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("Pipe", [ v1; v2 ]))
  | Async v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("Async", [ v1 ]))
  | Redir ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_redirection v2
      in Ocaml.VSum (("Redir", [ v1; v2 ]))
  | Dup ((v1, v2, v3, v4)) ->
      let v1 = vof_cmd v1
      and v2 = vof_redirection_kind v2
      and v3 = Ocaml.vof_int v3
      and v4 = Ocaml.vof_int v4
      in Ocaml.VSum (("Dup", [ v1; v2; v3; v4 ]))
  | And ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("And", [ v1; v2 ]))
  | Or ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("Or", [ v1; v2 ]))
  | Not v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("Not", [ v1 ]))
  | Match ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Match", [ v1; v2 ]))
  | If ((v1, v2)) ->
      let v1 = vof_cmd_sequence v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("If", [ v1; v2 ]))
  | IfNot v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("IfNot", [ v1 ]))
  | While ((v1, v2)) ->
      let v1 = vof_cmd_sequence v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("While", [ v1; v2 ]))
  | Switch ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd_sequence v2
      in Ocaml.VSum (("Switch", [ v1; v2 ]))
  | ForIn ((v1, v2, v3)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      and v3 = vof_cmd v3
      in Ocaml.VSum (("ForIn", [ v1; v2; v3 ]))
  | For ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("For", [ v1; v2 ]))
  | Compound v1 ->
      let v1 = vof_cmd_sequence v1 in Ocaml.VSum (("Compound", [ v1 ]))
  | Fn ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd_sequence v2
      in Ocaml.VSum (("Fn", [ v1; v2 ]))
  | DelFn v1 -> let v1 = vof_value v1 in Ocaml.VSum (("DelFn", [ v1 ]))
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_value v1
      and v2 = vof_value v2
      and v3 = vof_cmd v3
      in Ocaml.VSum (("Assign", [ v1; v2; v3 ]))
and vof_cmd_sequence v = Ocaml.vof_list vof_cmd v
and vof_redirection (v1, v2) =
  let v1 = vof_redirection_kind v1
  and v2 = vof_value v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_redirection_kind =
  function
  | RWrite -> Ocaml.VSum (("RWrite", []))
  | RRead -> Ocaml.VSum (("RRead", []))
  | RAppend -> Ocaml.VSum (("RAppend", []))
  | RDup ((v1, v2)) ->
      let v1 = Ocaml.vof_int v1
      and v2 = Ocaml.vof_int v2
      in Ocaml.VSum (("RDup", [ v1; v2 ]))
  
<<function [[Meta_ast.vof_line]]>>
@

\subsection*{[[Meta_opcode.ml]]}

<<function [[Meta_opcode.vof_operation]]>>=
let vof_operation =
  function
  | Mark -> Ocaml.VSum (("Mark", []))
  | Word -> Ocaml.VSum (("Word", []))
  | Popm -> Ocaml.VSum (("Popm", []))
  | Count -> Ocaml.VSum (("Count", []))
  | Concatenate -> Ocaml.VSum (("Concatenate", []))
  | Stringify -> Ocaml.VSum (("Stringify", []))
  | Glob -> Ocaml.VSum (("Glob", []))
  | Assign -> Ocaml.VSum (("Assign", []))
  | Dollar -> Ocaml.VSum (("Dollar", []))
  | Index -> Ocaml.VSum (("Index", []))
  | Local -> Ocaml.VSum (("Local", []))
  | Unlocal -> Ocaml.VSum (("Unlocal", []))
  | Fn -> Ocaml.VSum (("Fn", []))
  | DelFn -> Ocaml.VSum (("DelFn", []))
  | Simple -> Ocaml.VSum (("Simple", []))
  | Exit -> Ocaml.VSum (("Exit", []))
  | Return -> Ocaml.VSum (("Return", []))
  | If -> Ocaml.VSum (("If", []))
  | IfNot -> Ocaml.VSum (("IfNot", []))
  | Jump -> Ocaml.VSum (("Jump", []))
  | Match -> Ocaml.VSum (("Match", []))
  | Case -> Ocaml.VSum (("Case", []))
  | For -> Ocaml.VSum (("For", []))
  | Wastrue -> Ocaml.VSum (("Wastrue", []))
  | Not -> Ocaml.VSum (("Not", []))
  | False -> Ocaml.VSum ((" False", []))
  | True -> Ocaml.VSum ((" True", []))
  | Read -> Ocaml.VSum (("Read", []))
  | Write -> Ocaml.VSum (("Write", []))
  | ReadWrite -> Ocaml.VSum (("ReadWrite", []))
  | Append -> Ocaml.VSum (("Append", []))
  | Close -> Ocaml.VSum (("Close", []))
  | Dup -> Ocaml.VSum (("Dup", []))
  | Pipe -> Ocaml.VSum (("Pipe", []))
  | PipeWait -> Ocaml.VSum (("PipeWait", []))
  | PipeFd -> Ocaml.VSum (("PipeFd", []))
  | Eflag -> Ocaml.VSum (("Eflag", []))
  | Subshell -> Ocaml.VSum (("Subshell", []))
  | Backquote -> Ocaml.VSum (("Backquote", []))
  | Async -> Ocaml.VSum (("Async", []))
  | REPL -> Ocaml.VSum (("REPL", []))
  | Popredir -> Ocaml.VSum (("Popredir", []))
@

<<function [[Meta_opcode.vof_opcode]]>>=
let vof_opcode =
  function
  | F v1 -> let v1 = vof_operation v1 in Ocaml.VSum (("F", [ v1 ]))
  | I v1 -> let v1 = Ocaml.vof_int v1 in Ocaml.VSum (("I", [ v1 ]))
  | S v1 -> let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("S", [ v1 ]))
@

%-------------------------------------------------------------

<<shell/Meta_opcode.ml>>=
(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Opcode
module Ocaml = OCaml

<<function [[Meta_opcode.vof_operation]]>>
  
<<function [[Meta_opcode.vof_opcode]]>>
@


\subsection*{[[Op_process.ml]]}

%-------------------------------------------------------------

<<shell/Op_process.ml>>=

module R = Runtime
module E = Error

<<function [[Op_process.execute]]>>

<<function [[Op_process.exec]]>>

<<function [[Op_process.forkexec]]>>

<<function [[Op_process.op_Simple]]>>
@


\subsection*{[[Op_repl.ml]]}

%-------------------------------------------------------------

<<shell/Op_repl.ml>>=

module R = Runtime

<<function [[Op_repl.op_REPL]]>>
@

\subsection*{[[Opcode.ml]]}

%-------------------------------------------------------------

<<shell/Opcode.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

<<type [[Opcode.operation]]>>
<<type [[Opcode.opcode]]>>
<<type [[Opcode.codevec]]>>
@

\subsection*{[[PATH.ml]]}

%-------------------------------------------------------------

<<shell/PATH.ml>>=
open Common

module R = Runtime

<<function [[PATH.search_path_for_cmd]]>>
<<function [[PATH.find_in_path]]>>
@

\subsection*{[[Lexer.mli]]}

%-------------------------------------------------------------

<<Lexer.mli>>=
<<signature [[Lexer.token]]>>

<<exception [[Lexer.Lexical_error]]>>
@

\subsection*{[[Lexer.mll]]}

%-------------------------------------------------------------

\subsection*{[[Parser.mly]]}


\subsection*{[[Parse.ml]]}

%-------------------------------------------------------------

<<shell/Parse.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module R = Runtime

<<function [[Parse.error]]>>

<<function [[Parse.parse_line]]>>
@


\subsection*{[[Pattern.ml]]}

<<type [[Pattern.pattern]]>>=
type pattern = string
@

<<function [[Pattern.match_str]]>>=
(* todo: handle [ * ?  *)
let match_str s1 s2 =
  s1 = s2
@

%-------------------------------------------------------------

<<shell/Pattern.ml>>=

<<type [[Pattern.pattern]]>>

<<function [[Pattern.match_str]]>>
@

\subsection*{[[Process.ml]]}

%-------------------------------------------------------------

<<shell/Process.ml>>=
open Common

module R = Runtime

<<function [[Process.s_of_unix_error]]>>

<<function [[Process.exit]]>>

<<function [[Process.return]]>>


<<type [[Process.waitfor_result]]>>

<<function [[Process.waitfor]]>>
@

\subsection*{[[Prompt.ml]]}

%-------------------------------------------------------------

<<shell/Prompt.ml>>=
module R = Runtime

<<constant [[Prompt.doprompt]]>>
<<constant [[Prompt.prompt]]>>

<<function [[Prompt.pprompt]]>>
@

\subsection*{[[Runtime.ml]]}

%-------------------------------------------------------------

<<shell/Runtime.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types and globals *)
(*****************************************************************************)

<<type [[Runtime.varname]]>>
<<type [[Runtime.value]]>>
<<type [[Runtime.var]]>>
<<type [[Runtime.fn]]>>

<<type [[Runtime.thread]]>>

<<type [[Runtime.redir]]>>

<<type [[Runtime.waitstatus]]>>

<<global [[Runtime.globals]]>>

<<global [[Runtime.fns]]>>

(* less: argv0 *)

<<constant [[Runtime.runq]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Runtime.cur]]>>

<<function [[Runtime.push_list]]>>
<<function [[Runtime.pop_list]]>>

<<function [[Runtime.push_word]]>>
<<function [[Runtime.pop_word]]>>

<<function [[Runtime.push_redir]]>>
<<function [[Runtime.pop_redir]]>>

<<function [[Runtime.turf_redir]]>>

<<function [[Runtime.doredir]]>>

<<function [[Runtime.mk_thread]]>>
@


\subsection*{[[Status.ml]]}

%-------------------------------------------------------------

<<shell/Status.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common

module R = Runtime

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Small helpers to manipulate the "status" special variable (see Var.ml) *)

(*****************************************************************************)
(* API *)
(*****************************************************************************)

<<function [[Status.setstatus]]>>
<<function [[Status.getstatus]]>>
<<function [[Status.concstatus]]>>
<<function [[Status.truestatus]]>>
@

\subsection*{[[Var.ml]]}

%-------------------------------------------------------------

<<shell/Var.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

module R = Runtime

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Helpers to manipulate rc shell variables *)

(*****************************************************************************)
(* API *)
(*****************************************************************************)

<<function [[Var.gvlook]]>>
<<function [[Var.vlook]]>>

<<function [[Var.setvar]]>>

<<function [[Var.vinit]]>>
@


\subsection*{[[Builtin.mli]]}

%-------------------------------------------------------------

<<Builtin.mli>>=
<<signature [[Builtin.is_builtin]]>>

<<signature [[Builtin.dispatch]]>>
@

\subsection*{[[CLI.mli]]}

%-------------------------------------------------------------

<<CLI.mli>>=

<<type [[CLI.caps]]>>

<<signature [[CLI.main]]>>

(* internals *)
<<signature [[CLI.interpret_bootstrap]]>>
@

\subsection*{[[Compile.mli]]}

%-------------------------------------------------------------

<<Compile.mli>>=
<<signature [[Compile.compile]]>>
@

\subsection*{[[Dumper_.mli]]}

%-------------------------------------------------------------

<<Dumper_.mli>>=
<<signature [[Dumper_.s_of_cmd]]>>
<<signature [[Dumper_.s_of_opcode]]>>

(* extra *)

<<signature [[Dumper_.s_of_line]]>>
<<signature [[Dumper_.s_of_cmd_sequence]]>>
<<signature [[Dumper_.s_of_value]]>>
<<signature [[Dumper_.s_of_codevec]]>>
<<signature [[Dumper_.s_of_operation]]>>
@

\subsection*{[[Env.mli]]}

%-------------------------------------------------------------

<<Env.mli>>=
@

\subsection*{[[Error.mli]]}

%-------------------------------------------------------------

<<Error.mli>>=
<<signature [[Error.error]]>>
@

\subsection*{[[Fn.mli]]}

%-------------------------------------------------------------

<<Fn.mli>>=
<<signature [[Fn.flook]]>>
@

\subsection*{[[Glob.mli]]}

%-------------------------------------------------------------

<<Glob.mli>>=
@

\subsection*{[[Heredoc.mli]]}

%-------------------------------------------------------------

<<Heredoc.mli>>=
@

\subsection*{[[Interpreter.mli]]}

%-------------------------------------------------------------

<<Interpreter.mli>>=
<<signature [[Interpreter.interpret_operation]]>>
@

\subsection*{[[PATH.mli]]}

%-------------------------------------------------------------

<<PATH.mli>>=
<<signature [[PATH.find_in_path]]>>

<<signature [[PATH.search_path_for_cmd]]>>
@

\subsection*{[[Parse.mli]]}

%-------------------------------------------------------------

<<Parse.mli>>=
<<signature [[Parse.parse_line]]>>
@

\subsection*{[[Pattern.mli]]}

<<signature [[Pattern.match_str]]>>=
val match_str : string -> pattern -> bool
@

%-------------------------------------------------------------

<<Pattern.mli>>=
(* todo: Glob char *)
<<type [[Pattern.pattern]]>>

<<signature [[Pattern.match_str]]>>
@

\subsection*{[[Process.mli]]}

%-------------------------------------------------------------

<<Process.mli>>=
<<type [[Process.waitfor_result]]>>

<<signature [[Process.return]]>>
<<signature [[Process.exit]]>>
<<signature [[Process.waitfor]]>>
<<signature [[Process.s_of_unix_error]]>>
@

\subsection*{[[Prompt.mli]]}

%-------------------------------------------------------------

<<Prompt.mli>>=
<<signature [[Prompt.doprompt]]>>
<<signature [[Prompt.prompt]]>>

<<signature [[Prompt.pprompt]]>>
@

\subsection*{[[Runtime.mli]]}

%-------------------------------------------------------------

<<Runtime.mli>>=

<<type [[Runtime.varname]]>>
<<type [[Runtime.value]]>>
<<type [[Runtime.var]]>>
<<type [[Runtime.fn]]>>

<<type [[Runtime.thread]]>>
<<type [[Runtime.redir]]>>

<<type [[Runtime.waitstatus]]>>

(* globals *)

<<signature [[Runtime.globals]]>>
<<signature [[Runtime.fns]]>>
<<signature [[Runtime.runq]]>>

(* API *)

<<signature [[Runtime.cur]]>>
<<signature [[Runtime.push_list]]>>
<<signature [[Runtime.pop_list]]>>
<<signature [[Runtime.push_word]]>>
<<signature [[Runtime.pop_word]]>>
<<signature [[Runtime.push_redir]]>>
<<signature [[Runtime.pop_redir]]>>
<<signature [[Runtime.turf_redir]]>>
<<signature [[Runtime.doredir]]>>

<<signature [[Runtime.mk_thread]]>>
@

\subsection*{[[Status.mli]]}

%-------------------------------------------------------------

<<Status.mli>>=
(* helpers to manipulate the "status" special variable (see Var.ml) *)

<<signature [[Status.setstatus]]>>
<<signature [[Status.getstatus]]>>
<<signature [[Status.concstatus]]>>
<<signature [[Status.truestatus]]>>
@

\subsection*{[[Var.mli]]}

%-------------------------------------------------------------

<<Var.mli>>=
(* Helpers to manipulate rc shell variables *)

<<signature [[Var.gvlook]]>>
<<signature [[Var.vlook]]>>
<<signature [[Var.setvar]]>>
<<signature [[Var.vinit]]>>
@
