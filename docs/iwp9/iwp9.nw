\documentclass{article}
%CONFIG:
%\usepackage{fullpage}

\input{../../principia/docs/latex/Packages}

%alt: \input{../latex/Noweb}
\usepackage{../../principia/docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../../principia/docs/latex/syncweb}

\newif\iffinal\newif\ifverbose\newif\ifallcode
\input{../../principia/docs/latex/Macros}

\title{
XiX: \plan in \ocaml
}
\author{
Yoann Padioleau\\
yoann.padioleau@gmail.com
}

\begin{document}
\date{}
\maketitle

\begin{abstract}
XiX is a work-in-progress project to port parts of \plan to \ocaml:
its build system [[mk]], its shell [[rc]], its ARM and Mips toolchain [[[5v][acl]]],
but also its windowing system [[rio]], and more.
%other: ed, lex/yacc, cat/ls/...
\end{abstract}

\section{Introduction}
\xix, which stands for ``\xix is \xix''\footnote{\xix is the first project with a fully recursive acronym.},
is a port of the C source code of major \plan programs to
\ocaml\furl{https://ocaml.org},
an industrial-strength functional programming language.
%with an emphasis on expressiveness and safety.
%alt: a functional programming language.
%
Table~\ref{tab:ports} presents the current state of the project.
The code of \xix is available at \url{https://github.com/aryx/xix}.


The first question about this project that comes to mind is why?
%
The main motivation for \xix comes actually from another project of
mine called {\em \principia}\furl{https://github.com/aryx/principia-softwarica}
(I submitted a separate paper to this workshop describing 
\principia). In short, \principia is a series of books explaining the code
of \plan programs essential to the programmer such as the linker,
assembler, build system, up to the windowing system.
%
One strategy to fully understand a program, in order to explain its
code in a book, is surprisingly to try to port it to another language.
%
Indeed, during the porting of a program, it is tempting, because
good programmers are lazy, to not implement certain features initially judged 
as accessory, and so to focus on the main parts of the program.
%
The process of discovering what are those essential parts already
helps to understand the original code.
%
Moreover, very often the final ported program does not work
at first because those features judged as accessory turned out to be essential,
which again helps to better understand the original code and its hidden
subtelities.


I chose OCaml mainly because it is the programming language I am the
most familiar with, and as it happens it is also my favourite.
%
The port reached a point though where the \xix programs are actually 
useful on their own, independently of \principia.
%
Indeed, first \ocaml programs are usually portable and most \xix
programs are working without any extra effort on Linux, macOS, and Windows
(plan9port\furl{https://9fans.github.io/plan9port/} also helps to
run \plan programs on Linux and macOS).
%
Then

\begin{verbatim}
can experiment more easily, and add more features. Ex??




\end{verbatim}
% then long term easier to explain its code so candidate for \principia II.

\begin{table}[htbp]
\centering
\begin{tabular}{l l r l r}
\hline
\textbf{Category} & \textbf{\plan Program(s)} & \textbf{LOC} & \textbf{\xix Program} & \textbf{LOC} \\
\hline

% I used syncweb -loc to compute those numbers on principia and xix.
% For multi-archs programs, I used syncweb -loc and then manually
% added wc -l *.[chly] or wc -l *.ml* for the other archs code.

Build system      & [[mk]]          & 4350  & [[omk]]            & 2240 \\
Shell             & [[rc]]          & 6500  & [[orc]]            & 2190 \\
Assembler         & [[5a va]]       & 3020  & [[oas]]            & 2190 \\
% also ia, but better hide for now
Linker            & [[5l vl]]       & 12980 & [[olk]]            & 2910 \\
C Compiler        & [[5c vc libcc]]    & 28000 & [[occ]]            & 5310 \\
% lex yacc? but not really plan9 prog in the first place and
% the code does not come from a port really
Editor            & [[ed]]          & 1600  & [[oed]]            & 1220 \\
Graphics          & [[libdraw]]     & 7280  & [[lib_odraw]]      & 2940 \\
Communication     & [[lib9p]]       & 2920     & [[lib_plan9]]   & 1080 \\
Windowing system  & [[rio]]         & 5960  & [[orio]]           & 2820 \\
Utilities         & [[cat pwd wc]]  & 173   & [[ocat opwd owc]]  & 220 \\
\hline
\textbf{Total: } & & 72783 & & 23120 \\
%origin: the total was computed by chatGPT by copy pasting table
% and asking to compute total
\hline

\end{tabular}
\caption{%
\plan and \xix Programs Statistics.\\
{\footnotesize
(\textbf{LOC} = lines of code, including code comments)
}
}
\label{tab:ports}
\end{table}

\section{Current state}

\begin{verbatim}
omk/orc good, can actually use the pair to drive
the build process of xix itself.

toolchain enough for helloprintf.c for arm, mips, riscv
targeting both Plan9 and Linux!

ed is almost complete, just few advanced features missing.

then windowing system rio!
with graphics and comm! it works! see screenshot
this can actually only work under plan9. need plan9 kernel.

actually some rudimentary kernel.
% but also utilities (ed, hoc? grep? sed? awk?), 




\end{verbatim}

\section{C vs \ocaml}

\begin{verbatim}
%LOC, not as big diff as one would claim.
% And not even totally fair.
% adv feature usually adds 10% to the LOC.
% So C with clever trick can be very expressive, see pattern
% matching encoded via table, ocmp, etc.
% constantly suprised by C.
% BUT! LOE will be bigger!

% C is great but old. Rust, Ziglang new contenders.
% Actually some r9 projects for Rust, and ziglang kinda new toolchain,
% but OCaml has pros compared to Rust/Ziglang. For many programs, simpler
% to not handle memory. Actually original code was not doing much memory
% management. Simple mm. But even simpler now. 

% Moreover OCaml has lots
% of nice things like ADTs for more readable compilation in linker,
% no need optab.c, ocmp, ... just direct pattern matching on advanced
% SHOW code diff C vs OCaml.



% plan9 was rethinking and simplifying Unix. Xix is also rethinking
% and simplifying Plan9. Remove more features. Less code!
% even less code than plan9! STEPS project! So even easier 
% to teach. Actually series of books explaining the code, ocaml editions
% of C books in principia softwarica.









\end{verbatim}

%TOC:
% - components:
%   * omk/orc, less features, just essential, so LOC/LOE comparison?
%     can even do mk+rc in same binary? rc as a lib! easy with OCaml!
%     so even better than plan9! perf improv? also if pure
%     program then can reset rc state easily! harder with C. power of FP!
%   * toolchain: assembler/linker/compiler, ar/nm, more reusable code!
%     reuse more in asm, linker, compiler! lots of code dupe in plan9
%     use 'a instr polymorphic type, helpers, arch interfaces, etc.
%     nice use of marshalling to reduce code of IO and special object/ar formats
%     archs: arm, mips, riscv (RISC is simpler)
%     OS: plan9 and Linux ELF
%   * olex, oyacc
%   * oed, and other utilities: ogrep, osed, oawk
%   * orio and threads, and 9p in OCaml for draw device interaction
%     significant! can replace rio by orio on plan9 (more on OCaml for plan9
%     below) screenshot?
%     * libsystem with 9p, mound/bind syscall
%     * libdraw (user side) for orio (below)
%   * ogit! not in plan9
%   * kernel (rudimentary)
% - Plan9 in OCaml, but also OCaml in Plan9 :)
%   ocaml for plan9 (and ocaml-light), especially for orio which requires plan9
%   to work. Port of old ocaml version, simpler,
%   less dependencies, more traditional C and simple use of libc (and stdio? need  APE?)
% - LOC/LOE! compare books on mk vs omk
% - on OCaml
%   also capabilities!
% - git, docker, GHA, testsuite (not much tests in plan9), bootstrap-mk.sh,
%   easy to test on Linux/macOS/Windows (plan9 not so easy by comparison,
%   might have slow down also adoption)
% - Software engineering lessons and improvements after 30 years:
%   abuse int, abuse strings, code dupe, error mangagement OK_0, OK_1,
%   bools, ...
%   we learned stuff in 30 years.
% - Future work

\section{\ocaml in \plan}

\begin{verbatim}
Fork of \ocaml 1.07 available at \url{https://github.com/aryx/ocaml-light}.
Simpler to port, less dependencies.
% so many forks :)
Enough to compile \xix because \xix code does not use
recent features of \ocaml.
%recent, meaning from the last 20 years, hmmm

Just need byterun/, because ocaml compiler in OCaml
and bytecode interpreter in C. Once interpreter ported, done, and
C is easy to port. Just had to remove ifdefs, use plan9 libc, and
add a few functions.
%
Actually I use
\goken\furl{https://github.com/aryx/goken9cc}
(I submitted a separate work-in-progress paper to this workshop
describing the motivations and features of Goken).

% screenshot with orio, ocamlrun, oas, olk, occ, 
% even ocat test.s


\end{verbatim}

\section{Conclusion}

\end{document}
