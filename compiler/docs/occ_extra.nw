\section{[[Arch_compiler.ml]]}

%-------------------------------------------------------------

<<Arch_compiler.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

<<type [[Arch_compiler.env]]>>
<<type [[Arch_compiler.t]]>>

(* TODO? instead of Arch5, ... could also define an of_arch function
 * here, like I did for Arch_linker
 *
 * todo? have a portable asm? ast_asm_common.ml? 
 * with ATEXT, ANOP, ARET, etc.
 *)
@

\section{[[Arch5.mli]]}

%-------------------------------------------------------------

<<Arch5.mli>>=

<<signature [[Arch5.arch]]>>
@


\section{[[Arch5.ml]]}

%-------------------------------------------------------------

<<Arch5.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

open Arch_compiler
module T = Type

<<function [[Arch5.width_of_type]]>>

<<constant [[Arch5.arch]]>>
@

\section{[[Ast.ml]]}

%-------------------------------------------------------------

<<Ast.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An Abstract Syntax Tree (AST) for C.
 * 
 * The AST below does not match exactly the source code; I do a few
 * simplications at parsing time:
 *  - no nested struct definitions; they are lifted to the toplevel and 
 *    a blockid is associated with the tag name to avoid name conflicts
 *  - no anonymous structure; an artificial name is gensym'ed.
 *  - no anonymous structure element; an artificial field name is gensym'ed
 *  - no mix of typedefs with variable declarations;
 *    again typedefs are lifted to the top
 *  - enums are also lifted to the top (and its constants are tagged with
 *    a blockid)
 * 
 * This AST is actually more a named AST (but not a typed AST). 
 * Indeed, in C, you can not separate completely the naming phase from parsing.
 * The grammar of C has an ambiguity with typedefs, so we need to keep track of 
 * typedefs and identifiers and their scope during parsing. It would be
 * redundant to do this work again in a separate naming phase, so I 
 * name and resolve the scope of identifiers at parsing time
 * (however I check for inconsistencies or redefinitions after parsing).
 * Moreover, because I lift up struct definitions, I also keep track
 * and resolve the scope of tags.
 * 
 * See also pfff/lang_c/parsing/ast_c.ml and pfff/lang_cpp/parsing/ast_cpp.ml
 * 
 * todo: 
 *  - have a (large) integer and (large) double for Int and Float?
 *    Int64.t? if unsigned long long constant? enough? overflow in int64_of_str?
 *)

(*****************************************************************************)
(* The AST related types *)
(*****************************************************************************)

<<type [[Ast.loc]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Name *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast.name]]>>
[@@deriving show]

<<type [[Ast.blockid]]>>
[@@deriving show]

<<type [[Ast.fullname]]>>
[@@deriving show]

<<type [[Ast.idkind]]>>

<<type [[Ast.tagkind]]>>

(* ------------------------------------------------------------------------- *)
(* Types *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.typ]]>>
<<type [[Ast.type_bis]]>>

<<type [[Ast.function_type]]>>

<<type [[Ast.parameter]]>>

(* ------------------------------------------------------------------------- *)
(* Expression *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.expr]]>>
<<type [[Ast.expr_bis]]>>

<<type [[Ast.argument]]>>

<<type [[Ast.const_expr]]>>

<<type [[Ast.unaryOp]]>>
<<type [[Ast.assignOp]]>>
<<type [[Ast.fixOp]]>>

<<type [[Ast.binaryOp]]>>
<<type [[Ast.arithOp]]>>
<<type [[Ast.logicalOp]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Statement *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.stmt]]>>
<<type [[Ast.stmt_bis]]>>

<<type [[Ast.case_list]]>>

(* ------------------------------------------------------------------------- *)
(* Variables *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast.var_decl]]>>
<<type [[Ast.initialiser]]>>
[@@deriving show]


(* ------------------------------------------------------------------------- *)
(* Definitions *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.func_def]]>>
[@@deriving show]

<<type [[Ast.struct_def]]>>
<<type [[Ast.field_def]]>>
[@@deriving show]

<<type [[Ast.enum_def]]>>
<<type [[Ast.enum_constant]]>>
[@@deriving show]

<<type [[Ast.type_def]]>>

(* ------------------------------------------------------------------------- *)
(* Program *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.toplevel]]>>
[@@deriving show]

<<type [[Ast.toplevels]]>>
[@@deriving show]

<<type [[Ast.program]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Any *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.any]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Ast.tagkind_of_su]]>>

<<function [[Ast.unwrap]]>>

open Common
open Regexp_.Operators
<<function [[Ast.is_gensymed]]>>
@

\section{[[Check.mli]]}

%-------------------------------------------------------------

<<Check.mli>>=

<<type [[Check.error]]>>

<<signature [[Check.string_of_error]]>>

<<exception [[Check.Error]]>>
<<signature [[Check.failhard]]>>

<<signature [[Check.check_program]]>>
@

\section{[[Check.ml]]}

%-------------------------------------------------------------

<<Check.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
open Either

open Ast

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This module makes sure every entity used is defined. In some cases
 * it also checks if an entity is unused, or if it is incorrectly redeclared.
 * 
 * For typechecking see Typecheck.ml.
 * For naming and scope resolving see Parser.mly.
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Check.usedef]]>>

<<type [[Check.env]]>>

<<type [[Check.error]]>>

<<function [[Check.string_of_error]]>>

<<exception [[Check.Error]]>>

<<constant [[Check.failhard]]>>

<<function [[Check.error]]>>
 
(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Check.inconsistent_tag]]>>

<<function [[Check.check_inconsistent_or_redefined_tag]]>>

<<function [[Check.inconsistent_id]]>>

<<function [[Check.check_inconsistent_or_redefined_id]]>>

<<function [[Check.check_unused_locals]]>>

<<function [[Check.check_labels]]>>

(*****************************************************************************)
(* Use/Def *)
(*****************************************************************************)
<<function [[Check.check_usedef]]>>

(*****************************************************************************)
(* Unreachable code *)
(*****************************************************************************)
(* TODO *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Check.check_program]]>>
@

\section{[[CLI.mli]]}

%-------------------------------------------------------------

<<CLI.mli>>=
<<type [[CLI.caps]]>>

<<signature [[CLI.main]]>>

<<signature [[CLI.compile]]>>
@

\section{[[CLI.ml]]}

%-------------------------------------------------------------

<<CLI.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
open Regexp_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of 5c, the Plan 9 C compiler for ARM.
 *
 * Main limitations compared to 5c/vc/...:
 *  - no unicode support
 *  - can not compile multiple files at the same time
 *    (but you should use mk anyway)
 *  - can not compile from stdin
 *    (but who uses that?)
 *  - no -. to remove auto search for header in current directory
 *    (but who uses that?)
 *  - no error recovery, we stop at the first error (except in check.ml)
 *    (but compiler now fast enough and errors have a domino effect anyway)
 *  - no support for certain kencc extensions: 
 *     * STILL? unnamed structure element
 *       (confusing anyway, and annoying when porting code to gcc/clang)
 *     * typestr
 *       (seems dead)
 *  - no support for certain C features:
 *     * enum float
 *       (who uses that?)
 *
 * stricter:
 *  - stricter for grammar (see parser.mly), for instance force a specific
 *    order between the sign, qualifier, and type.
 *  - disallow implicit declarations of functions
 *  - stricter for typechecking (see typecheck.ml), for instance
 *    we do not support void* conversions (5c -V), and we use name
 *    equality for typechecking structs, not field equality.
 *    we also do not automatically transform 0 in nil; I force to write
 *    nil
 * 
 * improvements:
 *  - we forbid more constructs: 
 *     * typedef and initializers, 
 *     * typedef function definitions, 
 *     * three dots parameter in the middle, 
 *     * far more (see tests/)
 *  - better error location (no use of vague nearln) and
 *    better error messages (a la clang)
 * 
 * todo:
 *  - finish enough to at least handle helloc.c (basic function calls, basic
 *    types)
 *  - safe-linking support
 *  - debugger support
 *  - profiler support
 *)

(*****************************************************************************)
(* Types, constants, and globals *)
(*****************************************************************************)
<<type [[CLI.caps]]>>

(*****************************************************************************)
(* Testing *)
(*****************************************************************************)

<<function [[CLI.do_action]]>>

(*****************************************************************************)
(* Main algorithms *)
(*****************************************************************************)

<<function [[CLI.frontend]]>>

<<function [[CLI.backend5]]>>
<<function [[CLI.compile5]]>>

<<function [[CLI.compile]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[CLI.main]]>>
@

\section{[[Codegen5.mli]]}

%-------------------------------------------------------------

<<Codegen5.mli>>=

<<type [[Codegen5.error]]>>
<<signature [[Codegen5.string_of_error]]>>
<<exception [[Codegen5.Error]]>>

<<signature [[Codegen5.codegen]]>>
@

\section{[[Codegen5.ml]]}


<<constant [[Codegen5.rRET]]>>=
let rRET = R 0
@

<<constant [[Codegen5.rEXT1]]>>=
(* for 'extern register xx;', used in ARM kernel *)
let rEXT1 = R 10
@

<<constant [[Codegen5.rEXT2]]>>=
let rEXT2 = R 9
@

<<constant [[Codegen5.regs_initial]]>>=
let regs_initial = 
  let arr = Array.make A5.nb_registers 0 in
  [A5.rLINK; A5.rPC;       (* hardware reseved *)
   A5.rTMP; A5.rSB; A5.rSP; (* linker reserved *)
   rEXT1; rEXT2;         (* compiler reserved *)
  ] |> List.iter (fun (R x) ->
    arr.(x) <- 1
  );
  arr
@

<<type [[Codegen5.integer]]>>=
type integer = int
@


<<constant [[Codegen5.fake_instr]]>>=
let fake_instr = A.Virtual A.NOP
@

<<constant [[Codegen5.fake_loc]]>>=
let fake_loc = -1
@

<<constant [[Codegen5.fake_pc]]>>=
let fake_pc = -1
@

<<constant [[Codegen5.noattr]]>>=
@

<<function [[Codegen5.add_instr]]>>=
let add_instr env instr loc = 
  (* grow array if necessary *)
  if !(env.pc) >= Array.length !(env.code)
  then begin
    let increment = 100 in
    let newcode = 
      Array.make (Array.length !(env.code) + increment)  (fake_instr, fake_loc)
    in
    Array.blit !(env.code) (Array.length !(env.code)) newcode 0 0;
    env.code := newcode
  end;

  !(env.code).(!(env.pc)) <- (instr, loc);
  incr env.pc;
  ()
@

<<function [[Codegen5.set_instr]]>>=
let set_instr env pc instr loc =
  if pc >= !(env.pc)
  then failwith (spf "set_instr: pc > env.pc (%d >= %d)" pc !(env.pc));
  !(env.code).(pc) <- (instr, loc)
@

<<function [[Codegen5.add_fake_instr]]>>=
let add_fake_instr env str =
  let spc = !(env.pc) in
  add_instr env (A.LabelDef (str ^ "(fake)")) fake_loc;
  spc
@

<<function [[Codegen5.add_fake_goto]]>>=
let add_fake_goto env loc =
  let spc = !(env.pc) in
  add_instr env (A.Instr (A5.B (ref (Absolute fake_pc)), A5.AL)) loc;
  spc
@

<<function [[Codegen5.patch_fake_goto]]>>=
let patch_fake_goto env pcgoto pcdest =
  match !(env.code).(pcgoto) with
  (* TODO? what about BL? time to factorize B | BL | Bxx ? *)
  (* ocaml-light: | A5.Instr (A5.B aref, A5.AL), _loc | A5.Instr (A5.Bxx (_, aref), A5.AL), _loc *)
  | A.Instr (A5.B aref, A5.AL), _loc ->
    if !aref = (Absolute fake_pc)
    then aref := Absolute pcdest
    else raise (Impossible "patching already resolved branch")
  | A.Instr (A5.Bxx (_, aref), A5.AL), _loc ->
    if !aref = (Absolute fake_pc)
    then aref := Absolute pcdest
    else raise (Impossible "patching already resolved branch")
  | _ -> raise (Impossible "patching non jump instruction")
@

<<function [[Codegen5.global_of_id]]>>=
let global_of_id fullname idinfo = 
  { name = Ast.unwrap fullname;
    priv = 
      (match idinfo.TC.sto with
      | S.Static -> Some (-1)
      | S.Global | S.Extern -> None
      | _ -> raise (Impossible "global can be only Static/Global/Extern")
      );
    (* less: analyse idinfo.typ *)
    signature = None;
  }
@

<<function [[Codegen5.symbol]]>>=
let symbol fullname = Ast.unwrap fullname
@

<<function [[Codegen5.entity_of_id]]>>=
let entity_of_id env fullname offset_extra =
  let idinfo = Hashtbl.find env.ids_ fullname in
  match idinfo.TC.sto with
  | S.Param -> 
    let offset = Hashtbl.find env.offsets fullname + offset_extra in
    Param (Some (symbol fullname), offset)
  | S.Local ->
    let offset = Hashtbl.find env.offsets fullname + offset_extra in
    (* - offset for locals *)
    A.Local (Some (symbol fullname), - offset)
  | S.Static | S.Global | S.Extern ->
    let offset = offset_extra in
    A.Global (global_of_id fullname idinfo, offset)
@

<<function [[Codegen5.mov_operand_of_opd]]>>=
(* less: opportunity for bitshifted registers? *)
let mov_operand_of_opd env opd =
  match opd.opd with
  | ConstI i   -> A5.Imsr (A5.Imm i)
  | Register r -> A5.Imsr (A5.Reg r)
  | Name (fullname, offset) -> A5.Entity (entity_of_id env fullname offset)
  | Indirect (r, offset) -> A5.Indirect (r, offset)
  | Addr fullname -> A5.Ximm (A.Address (entity_of_id env fullname 0))
@

<<function [[Codegen5.arith_instr_of_op]]>>=
let arith_instr_of_op op r1 r2 r3 =
  A5.Arith (
    (match op with
    | Arith op ->
      (match op with 
      | Plus -> A5.ADD | Minus -> A5.SUB
      | And -> A5.AND | Or -> A5.ORR | Xor -> A5.EOR
      (* todo: need type info for A.SLR *)
      | ShiftLeft -> A5.SLL | ShiftRight -> A5.SRA
      (* todo: need type info for A.MULU, etc *)
      | Mul -> A5.MUL | Div -> A5.DIV | Mod -> A5.MOD
      )
    | Logical _ -> raise Todo
    ),
    None, 
    A5.Reg r1, Some r2, r3
  )
@



<<function [[Codegen5.reguse]]>>=
let reguse env (A.R x) =
  env.regs.(x) <- env.regs.(x) + 1
@

<<function [[Codegen5.regfree]]>>=
let regfree env (A.R x) = 
  env.regs.(x) <- env.regs.(x) - 1;
  if env.regs.(x) < 0
  then raise (Error (E.Misc ("error in regfree", fake_loc)))
@

<<function [[Codegen5.with_reg]]>>=
let with_reg env r f =
  (* less: care about exn? meh, if exn then no recovery anyway *)
  reguse env r;
  let res = f() in
  regfree env r;
  res
@

<<function [[Codegen5.regalloc]]>>=
let regalloc env loc =
  (* less: lasti trick? *)
  let rec aux i n =
    (* This happens in extreme case when the expression tree has a huge
     * depth everywhere. In that case, we should allocate a new temporary
     * on the stack but this complexifies the algorithm.
     *)
    if i >= n 
    then raise (Error(E.Misc("out of fixed registers; rewrite your code",loc)));

    if env.regs.(i) = 0
    then begin
      env.regs.(i) <- 1;
      i
    end
    else aux (i+1) n
  in
  aux 0 (Array.length env.regs)
@

<<function [[Codegen5.opd_regalloc]]>>=
(* We can reuse a previous register if 'tgtopt' is a register.
 * See for example return.c where we can reuse R0 instead of a new R1.
 *)
let opd_regalloc env typ loc tgtopt =
  match typ with
  | T.I _ | T.Pointer _ ->
    let i = 
      match tgtopt with
      | Some { opd = Register (A.R x); typ=_; loc=_ } -> 
        reguse env (A.R x);
        x
      | _ -> regalloc env loc
    in
    { opd = Register (A.R i); typ; loc }
  | _ -> raise Todo
@

<<function [[Codegen5.opd_regfree]]>>=
(*
let opd_regalloc_opd env opd tgtopt =
  opd_regalloc env opd.typ opd.loc tgtopt
let opd_regalloc_e env e tgtopt =
  opd_regalloc env e.e_type e.e_loc tgtopt
*)

let opd_regfree env opd =
  match opd.opd with
  | Register r -> regfree env r;
  | _ -> raise (Impossible "opd_regfree on non-register operand")
@

<<function [[Codegen5.gmove_opt]]>>=
let gmove_opt env opd1 opd2opt = 
  match opd2opt with
  | Some opd2 -> gmove env opd1 opd2
  | None ->
    (* less: should have warned about unused opd in check.ml *)
    ()
@


<<function [[Codegen5.expr_cond]]>>=
let expr_cond env e0 =
  (* todo: *)
  with_reg env rRET (fun () ->
    let dst = { opd = Register rRET; typ = e0.e_type; loc = e0.e_loc } in
    expr env e0 (Some dst);
    (* less: actually should be last loc of e0 *)
    let loc = e0.e_loc in
    add_instr env (A.Instr (A5.Cmp (A5.CMP, A5.Imm 0, rRET), A5.AL)) loc;
    let pc = !(env.pc) in
    add_instr env (A.Instr (A5.Bxx (A5.EQ,(ref (A.Absolute fake_pc))),A5.AL)) loc;
    pc
  )
@

<<function [[Codegen5.expropt]]>>=
let expropt env eopt =
  match eopt with
  | None -> ()
  | Some e -> expr env e None
@


%-------------------------------------------------------------

<<Codegen5.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast_asm
open Ast
module C = Ast
module A = Ast_asm
module A5 = Ast_asm5

module T = Type
module S = Storage
module TC = Typecheck
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * todo:
 *   - funcalls
 *   - fields, structures
 * todo later:
 *   - firstarg opti
 *   - alignment 
 *     * fields (sualign)
 *     * parameters
 *   - other integer types and cast
 *   - float
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Codegen5.env]]>>

<<constant [[Codegen5.rRET]]>>
(* opti: let rARG = A.R 0 *)

<<constant [[Codegen5.rEXT1]]>>
<<constant [[Codegen5.rEXT2]]>>

<<constant [[Codegen5.regs_initial]]>>
   
  
<<type [[Codegen5.integer]]>>

<<type [[Codegen5.operand_able]]>>
<<type [[Codegen5.operand_able_kind]]>>


<<type [[Codegen5.error]]>>
<<function [[Codegen5.string_of_error]]>>
<<exception [[Codegen5.Error]]>>

(*****************************************************************************)
(* Instructions  *)
(*****************************************************************************)
<<constant [[Codegen5.fake_instr]]>>
<<constant [[Codegen5.fake_loc]]>>
<<constant [[Codegen5.fake_pc]]>>
<<constant [[Codegen5.noattr]]>>

<<function [[Codegen5.add_instr]]>>

<<function [[Codegen5.set_instr]]>>


<<function [[Codegen5.add_fake_instr]]>>

<<function [[Codegen5.add_fake_goto]]>>
 
<<function [[Codegen5.patch_fake_goto]]>>

(*****************************************************************************)
(* C to Asm helpers  *)
(*****************************************************************************)
<<function [[Codegen5.global_of_id]]>>

<<function [[Codegen5.symbol]]>>

<<function [[Codegen5.entity_of_id]]>>


<<function [[Codegen5.mov_operand_of_opd]]>>

<<function [[Codegen5.arith_instr_of_op]]>>

(*****************************************************************************)
(* Operand able, instruction selection  *)
(*****************************************************************************)
<<function [[Codegen5.operand_able]]>>

<<constant [[Codegen5.fn_complexity]]>>

<<function [[Codegen5.complexity]]>>

(*****************************************************************************)
(* Register allocation helpers *)
(*****************************************************************************)
<<function [[Codegen5.reguse]]>>

<<function [[Codegen5.regfree]]>>

<<function [[Codegen5.with_reg]]>>
  
<<function [[Codegen5.regalloc]]>>

<<function [[Codegen5.opd_regalloc]]>>

<<function [[Codegen5.opd_regfree]]>>

(*****************************************************************************)
(* Code generation helpers *)
(*****************************************************************************)

(* Even though two arguments are operand_able, it does not mean
 * we can move one into the other with one instruction. 
 * In theory, 5a supports general MOVW, but 5l restricts those
 * MOVW to only store and load (not both at the same time).
 * This is why we must decompose below the move in 2 instructions
 * sometimes.
 *)
let rec gmove env opd1 opd2 =
  match opd1.opd with
  (* a load *)
  | Name _ | Indirect _ ->
    let move_size = 
      match opd1.typ with
      | T.I (T.Int, _) | T.Pointer _ -> A.Word
      | _ -> raise Todo
    in
    (* less: opti which does opd_regfree env opd2 (Some opd2)? worth it? *)
    let opd1reg = opd_regalloc env opd1.typ opd1.loc (Some opd2) in
    gmove_aux env move_size opd1 opd1reg;
    gmove env opd1reg opd2;
    opd_regfree env opd1reg
  | _ ->
    (match opd2.opd with
    (* a store *)
    | Name _ | Indirect _ ->
      let move_size =
        match opd2.typ with
        | T.I (T.Int, _) | T.Pointer _ -> A.Word
        | _ -> raise Todo
      in
      (* less: opti which does opd_regfree env opd2 (Some opd1)?? *)
      let opd2reg = opd_regalloc env opd2.typ opd2.loc None in
      gmove env opd1 opd2reg;
      gmove_aux env move_size opd2reg opd2;
      opd_regfree env opd2reg

    | _ -> 
      (* the simple cases *)
      let move_size = 
        match opd1.typ, opd2.typ with
        | T.I (T.Int, _), T.I (T.Int, _) -> A.Word
        | T.Pointer _, T.Pointer _ -> A.Word
        (* todo: lots of opti related to float *)
        | _ -> raise Todo
      in
      gmove_aux env move_size opd1 opd2
    )

(* At this point, either opd1 or opd2 references memory (but not both),
 * so we can do the move in one instruction.
 *)
and gmove_aux env move_size opd1 opd2 =
  (* less: should happen only for register? *)
  if opd1.opd = opd2.opd
  then ()
  else 
  add_instr env 
    (A.Instr (A5.MOVE (move_size, None, 
                      mov_operand_of_opd env opd1,
                      mov_operand_of_opd env opd2), A5.AL)) opd1.loc

<<function [[Codegen5.gmove_opt]]>>

(*****************************************************************************)
(* Expression *)
(*****************************************************************************)
<<function [[Codegen5.expr]]>>

<<function [[Codegen5.expr_cond]]>>

<<function [[Codegen5.expropt]]>>

(*****************************************************************************)
(* Statement *)
(*****************************************************************************)
<<function [[Codegen5.stmt]]>>

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)
<<function [[Codegen5.codegen]]>>
@


\section{[[Dumper_.mli]]}

%-------------------------------------------------------------

<<Dumper_.mli>>=

<<signature [[Dumper_.s_of_any]]>>

<<signature [[Dumper_.s_of_any_with_types]]>>
@

\section{[[Dumper_.ml]]}

%-------------------------------------------------------------

<<Dumper_.ml>>=

<<function [[Dumper_.s_of_any]]>>

<<function [[Dumper_.s_of_any_with_types]]>>
@

\section{[[Error.mli]]}

%-------------------------------------------------------------

<<Error.mli>>=

<<signature [[Error.warn]]>>

<<signature [[Error.errorexit]]>>
@

\section{[[Error.ml]]}

%-------------------------------------------------------------

<<Error.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

<<function [[Error.warn]]>>

<<function [[Error.errorexit]]>>
@

\section{[[Eval_const.mli]]}

%-------------------------------------------------------------

<<Eval_const.mli>>=

<<exception [[Eval_const.NotAConstant]]>>

<<type [[Eval_const.error]]>>
<<exception [[Eval_const.Error]]>>

<<type [[Eval_const.integer]]>>
<<type [[Eval_const.env]]>>

<<signature [[Eval_const.eval]]>>
@

\section{[[Eval_const.ml]]}

%-------------------------------------------------------------

<<Eval_const.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common

open Ast
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Eval_const.integer]]>>

<<type [[Eval_const.env]]>>

<<exception [[Eval_const.NotAConstant]]>>

<<type [[Eval_const.error]]>>

<<exception [[Eval_const.Error]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Eval_const.eval]]>>
@

\section{[[Flags.ml]]}

<<constant [[Flags.debugger]]>>=
let debugger = ref false
@
%TODO: delete

%-------------------------------------------------------------

<<Flags.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

<<global [[Flags.warn]]>>
<<global [[Flags.warnerror]]>>

(* see also macroprocessor/flags_cpp.ml *)

<<constant [[Flags.dump_tokens]]>>
<<constant [[Flags.dump_ast]]>>
<<constant [[Flags.dump_typed_ast]]>>
<<constant [[Flags.dump_asm]]>>

<<constant [[Flags.debugger]]>>
<<constant [[Flags.backtrace]]>>
@

\section{[[Globals.ml]]}

%-------------------------------------------------------------

<<Globals.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(* See also globals in ../macroprocessor/location_cpp.ml  *)

<<global [[Globals.hids]]>>
@

\section{[[Lexer.mll]]}

\section{[[Main.ml]]}

%-------------------------------------------------------------

<<Main.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
(* open Xix_compiler *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<toplevel [[Main._1]]>>
@

\section{[[Parse.mli]]}

%-------------------------------------------------------------

<<Parse.mli>>=

<<signature [[Parse.parse]]>>

<<signature [[Parse.parse_no_cpp]]>>
@

\section{[[Parse.ml]]}

%-------------------------------------------------------------

<<Parse.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module L = Location_cpp
module T = Parser  (* T for Tokens *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[Parse.parse]]>>

<<function [[Parse.parse_no_cpp]]>>
@

\section{[[Parser.mly]]}

\section{[[Rewrite.mli]]}

%-------------------------------------------------------------

<<Rewrite.mli>>=
@

\section{[[Rewrite.ml]]}

%-------------------------------------------------------------

<<Rewrite.ml>>=

(* todo mandatory:
 *  - pointer arithmetic
 *  - automatic casts
 * todo for opti?:
 *  - OADDR/OIND simplifications
 *  - put constants on the right for commutative operations
 *)
@

\section{[[Storage.ml]]}

%-------------------------------------------------------------

<<Storage.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

<<type [[Storage.t]]>>
[@@deriving show]
@

\section{[[Type.ml]]}

%-------------------------------------------------------------

<<Type.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(* TODO? rename to Type_.ml because conflict with OCaml5 module name *)

<<type [[Type.blockid]]>>
[@@deriving show]
<<type [[Type.fullname]]>>
[@@deriving show]

<<type [[Type.t]]>>

<<type [[Type.integer_type]]>>
<<type [[Type.integer_kind]]>>
<<type [[Type.sign]]>>

<<type [[Type.float_type]]>>

<<type [[Type.struct_kind]]>>
[@@deriving show]

<<type [[Type.qualifier]]>>
[@@deriving show]


<<type [[Type.structdef]]>>
[@@deriving show]

<<constant [[Type.int]]>>
<<constant [[Type.long]]>>
@

\section{[[Typecheck.mli]]}

%-------------------------------------------------------------

<<Typecheck.mli>>=

<<type [[Typecheck.idinfo]]>>

<<type [[Typecheck.typed_program]]>>

<<type [[Typecheck.error]]>>
<<signature [[Typecheck.string_of_error]]>>
<<exception [[Typecheck.Error]]>>

<<signature [[Typecheck.check_and_annotate_program]]>>
@

\section{[[Typecheck.ml]]}

<<type [[Typecheck.integer]]>>=
type integer = int
@

%-------------------------------------------------------------

<<Typecheck.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast
module T = Type
module S = Storage
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This module does many things:
 *  - it expands typedefs
 *  - it assigns a final (resolved) type to every identifiers
 *  - it assigns a final storage to every identifiers
 *  - it assigns a type to every expressions
 *  - it returns a typed AST and also transforms this AST
 *    (e.g., enum constants are replaced by their value)
 * 
 * Thanks to the naming done in parser.mly and the unambiguous Ast.fullname,
 * we do not have to handle scope here. 
 * Thanks to check.ml we do not have to check for inconsistencies or
 * redefinition of tags. We can assume everything is fine.
 * 
 * limitations compared to 5c:
 *  - no 'void*' conversions 
 *    (clang does not either? but we do accept so void* vs xxx* )
 *  - no struct equality by field equality. I use name equality.
 *    (who uses that anyway?)
 *  - no float enum
 *    (who uses that anyway?)
 *  - no 0 to nil automatic cast inserted
 *    (I prefer stricter typechecking)
 * 
 * todo: 
 *  - const checking (in check_const.ml?) need types!
 *  - format checking (in check_format.ml?) need types!
 *  - misc checks
 *    * stupid shift bits (need constant evaluation) outside width
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* less: vlong? *)
<<type [[Typecheck.integer]]>>

<<type [[Typecheck.idinfo]]>>

(* alt: Frontend.result, Frontend.entities, Frontend.t, Typecheck.result *)
<<type [[Typecheck.typed_program]]>>

<<type [[Typecheck.env]]>>
<<type [[Typecheck.expr_context]]>>

(* less: could factorize things in error.ml? *)
<<type [[Typecheck.error]]>>

<<function [[Typecheck.string_of_error]]>>

<<exception [[Typecheck.Error]]>>

<<function [[Typecheck.type_error]]>>

<<function [[Typecheck.type_error2]]>>

(*****************************************************************************)
(* Types helpers *)
(*****************************************************************************)

<<function [[Typecheck.same_types]]>>
   
<<function [[Typecheck.merge_types]]>>

(* when processing enumeration constants, we want to keep the biggest type *)
(*
let max_types t1 t2 = ...
*)

<<function [[Typecheck.check_compatible_binary]]>>

<<function [[Typecheck.result_type_binary]]>>

<<function [[Typecheck.check_compatible_assign]]>>

<<function [[Typecheck.check_args_vs_params]]>>
    
(*****************************************************************************)
(* Storage helpers *)
(*****************************************************************************)
<<function [[Typecheck.merge_storage_toplevel]]>>

(*****************************************************************************)
(* Other helpers *)
(*****************************************************************************)
<<function [[Typecheck.lvalue]]>>

<<function [[Typecheck.array_to_pointer]]>>

<<function [[Typecheck.unsugar_anon_structure_element]]>>

(*****************************************************************************)
(* AST Types to Types.t *)
(*****************************************************************************)
<<function [[Typecheck.type_]]>>

(*****************************************************************************)
(* Expression typechecking *)
(*****************************************************************************)
<<function [[Typecheck.expr]]>>
<<function [[Typecheck.expropt]]>>

(*****************************************************************************)
(* Statement *)
(*****************************************************************************)
<<function [[Typecheck.stmt]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Typecheck.check_and_annotate_program]]>>
@

\section{[[macroprocessor/Ast_cpp.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Ast_cpp.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An Abstract Syntax Tree (AST) for the C Pre-Processor (CPP) directives. *)

(*****************************************************************************)
(* The AST *)
(*****************************************************************************)

<<type [[Ast_cpp.directive]]>>

<<type [[Ast_cpp.macro]]>>
[@@deriving show]
@

\section{[[macroprocessor/Flags_cpp.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Flags_cpp.ml>>=

<<constant [[Flags_cpp.debug_line]]>>
<<constant [[Flags_cpp.debug_include]]>>
<<constant [[Flags_cpp.debug_macros]]>>
@

\section{[[macroprocessor/Lexer_cpp.mll]]}

\section{[[macroprocessor/Location_cpp.mli]]}

<<signature [[Location_cpp.add_event]]>>=
(* add to history *)
val add_event: 
  location_event -> unit
@

<<signature [[Location_cpp.final_loc_of_loc]]>>=
(* !uses history! you should avoid this function in a multifile processing
 * context (e.g., in the linker) *)
val final_loc_of_loc: 
    loc -> final_loc
@

<<signature [[Location_cpp.dump_event]]>>=
val dump_event:
  location_event -> unit
@

%-------------------------------------------------------------

<<macroprocessor/Location_cpp.mli>>=

<<type [[Location_cpp.loc]]>>
<<type [[Location_cpp.final_loc]]>>

<<type [[Location_cpp.location_history]]>>
<<type [[Location_cpp.location_event]]>>
[@@deriving show]

<<signature [[Location_cpp.history]]>>
<<signature [[Location_cpp.line]]>>

<<exception [[Location_cpp.Error]]>>


<<signature [[Location_cpp.add_event]]>>

<<signature [[Location_cpp.final_loc_of_loc]]>>


<<signature [[Location_cpp.dump_event]]>>
@


\section{[[macroprocessor/Location_cpp.ml]]}

<<exception [[Location_cpp.Error]]>>=
exception Error of string * loc
@

<<function [[Location_cpp.dump_event]]>>=
(* for 5c -f 
 * alt: just rely on deriving show but kept this for compatibility with kencc
 *)
let dump_event (event : location_event) : unit =
  match event with
  | Include file -> 
      Logs.app (fun m -> m "%4d: %s" !line !!file)
  | Line (local_line, file) -> 
      Logs.app (fun m -> m "%4d: %s (#line %d)" !line !!file local_line)
  | Eof -> 
      Logs.app (fun m -> m "%4d: <pop>" !line)
@

<<function [[Location_cpp.add_event]]>>=
let add_event (event : location_event) : unit =
  (* alt: use Logs.debug instead of a flag *)
  if !Flags_cpp.debug_line
  then dump_event event;
  history := {location_event = event; global_line = !line }::!history
@

<<function [[Location_cpp.final_loc_of_loc]]>>=
(* 'history' contains the list of location_events in reverse order
 * since we always add an event to the end, for instance: 
 * [200; 150; 130; 60; 1]. The first step is to reverse this list:
 * [1; 60; 130; 150; 200]. Then, if we look for information about line 135, 
 * we want to stop when we encounter 150,
 * so when lineno < x.global_line below succeed for the first time.
 *)
let final_loc_of_loc (lineno : loc) : final_loc =
  let rec aux (lastfile, lastlineno, lastdelta) stack xs =
    match xs with
    | [] -> lastfile, lineno - lastlineno + lastdelta
    | x::xs ->
      if lineno < x.global_line 
      then lastfile, lineno - lastlineno + lastdelta
      else
        (match x.location_event, stack with
        | Eof, (lastfile, _lastlineno, lastdelta)::ys ->
            (* bugfix: wrong!! TODO *)
            aux (lastfile, x.global_line, lastdelta) ys xs
        | Eof, [] -> 
            failwith ("impossible: wrong location history, unpaired Eof")
        | Include file, ys ->
            aux (file, x.global_line, 1)
              ((lastfile, lastlineno, lastdelta)::ys) xs
        | Line (line, file), _y::ys ->
            aux (file, x.global_line, line) ys xs
        | Line (line, file), [] ->
            (* todo: wrong *)
            aux (file, x.global_line, line) [] xs
        )
  in
  aux (Fpath.v "<nofile>", 0, 0) [] (List.rev !history)
@

<<function [[Location_cpp._final_loc_and_includers_of_loc]]>>=
let _final_loc_and_includers_of_loc _lineno =
  raise Todo
@


%-------------------------------------------------------------

<<macroprocessor/Location_cpp.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * less: normalize filenames? use realpath?
 *)

(*****************************************************************************)
(* Types and globals *)
(*****************************************************************************)

<<type [[Location_cpp.loc]]>>
[@@deriving show]

<<type [[Location_cpp.final_loc]]>>
[@@deriving show]

<<type [[Location_cpp.location_history]]>>
<<type [[Location_cpp.location_event]]>>
[@@deriving show {with_path = false}]

(* TODO? move to local in Parse_cpp.ml? *)
<<constant [[Location_cpp.history]]>>

<<constant [[Location_cpp.line]]>>

<<exception [[Location_cpp.Error]]>>

(*****************************************************************************)
(* Debugging *)
(*****************************************************************************)

<<function [[Location_cpp.dump_event]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)
<<function [[Location_cpp.add_event]]>>


<<function [[Location_cpp.final_loc_of_loc]]>>

<<function [[Location_cpp._final_loc_and_includers_of_loc]]>>
@

\section{[[macroprocessor/Parse_cpp.mli]]}

%-------------------------------------------------------------

<<macroprocessor/Parse_cpp.mli>>=

<<type [[Parse_cpp.token_category]]>>
[@@deriving show]

(* wrapper around a parser/lexer (e.g., 5c) to preprocess first the file *)
<<type [[Parse_cpp.hook]]>>

<<signature [[Parse_cpp.parse]]>>

@

\section{[[macroprocessor/Parse_cpp.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Parse_cpp.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

module D = Ast_cpp (* D for Directives *)
module L = Location_cpp
module Flags = Flags_cpp

(* for record matching for ocaml-light *)
open Ast_cpp

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Cpp as a library. This is used by 5c but also 5a.
 * 
 * Main limitations compared to the cpp embedded in 5c of Plan 9:
 *  - no support for unicode
 *  - see Lexer_cpp.mll
 * Main limitations compared to ANSI cpp:
 *  - no complex boolean expressions for #ifdefs
 *
 * stricter:
 *  - see Lexer_cpp.mll
 * more general:
 *  - allow any number of arguments for macros 
 *    (not limited to 25 because of the use of #a to #z)
 *  - allow any body size 
 *    (no 8196 buffer limit)
 *  - allow any filename length in #include 
 *    (no 200 limit)
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Parse_cpp.token_category]]>>
[@@deriving show]

<<type [[Parse_cpp.hook]]>>

<<type [[Parse_cpp.macro]]>>

(*****************************************************************************)
(* Globals *)
(*****************************************************************************)
<<constant [[Parse_cpp.hmacros]]>>

<<constant [[Parse_cpp._cwd]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Parse_cpp.error]]>>


<<function [[Parse_cpp.define_cmdline_def]]>>

<<function [[Parse_cpp.define]]>>

<<function [[Parse_cpp.find_include]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Parse_cpp.parse]]>>
@


\section{[[macroprocessor/Preprocessor.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Preprocessor.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Data structure containing the command-line data that one can pass to cpp
 * (e.g, -D and -I CLI flags).
 * This is passed then to Parse_cpp.parse() in addition to hooks.
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Preprocessor.conf]]>>
[@@deriving show]
@
