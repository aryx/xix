(* Martin Jambon, Yoann Padioleau
 *
 * Copyright (C) 2024-2025 Semgrep Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * LICENSE for more details.
 *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Centralize and unify the use of the standard output (and error) of a
 * program and automatically handle whether or not to display colors
 * depending on the terminal capabilities and/or CLI flags.
 *
 * There are many different ways a program can output a string on
 * the standard output:
 *  - Stdlib.print_string using Stdlib.stdout
 *  - Printf.printf using Stdlib.stdout
 *  - Unix.write using Unix.stdout
 *  - Format.fmt using Formatter.std_formatter
 *  - Fmt.pr, or Fmt.pf using Fmt.stdout
 *  - ANSITerminal.print_string
 *  - Ocolor_format.printf
 *  - UCommon.pr
 *  - ...
 *  - and now UConsole.print() and CapConsole.print too :)
 *
 * (See also TCB/forbid_console.jsonnet for the list of functions we
 * want to forbid to enforce instead the use of this module and CapConsole.ml)
 *
 * One of the goal of this module is to provide another way that can be
 * mocked and grepped and redirected more easily. This is useful
 * for command-line programs that want to clearly separate
 * the normal output of the program from other output.
 *
 * alt:
 *  - Logs.app(), but Logs.app actually print on stderr by default
 *    (without any leading tag), and using a Logs.xxx function for
 *    a regular output feels a bit weird
 *  - use Common.pr(), but we can't easily redirect or mock the output
 *    and we use Common.pr in too many contexts. The use of a separate
 *    UConsole.print() makes it clear this is intended to be the real output
 *    of the program.
 *  - use directly ANSITerminal.ml but again can't be mocked, does not
 *    play well with capabilities so we need to wrap it anyway (CapConsole.ml),
 *    and does not automatically disable colors depending on a highlight config.
 *  - use Fmt but Format pretty printing is too complex for most use cases
 *    and not really needed.
 *
 * TODO:
 *  - move in lib_system/ ?
 *  - use this module for printing all user-facing messages.
 *  - allow to mock the output, with_mock_output () ?
 *    update: or use Testo recent capture_stdout which uses
 *    some Unix.dupe internally so no need to mock?
 *  - allow to redirect the output via a --output flag
 *    with_redirect_output () ?
 *
 * The 'Logs' module depends on this module because logging
 * is done on stderr by default.
 *
 * This module contains the shared part between UConsole.ml and
 * CapConsole.ml
 *
 * Some notes on Windows:
 * The default terminal of Windows does not handle ANSI sequences and so
 * what is generated by ANSITerminal.sprintf(). There are ways to print
 * colors on such Windows terminal but the API is annoying (one can't
 * use ANSITerminal.sprintf but have to use ANSITerminal.printf which is less
 * composable) and anyway if one really wants colors on Windows, one can
 * install fancier and more compatible terminal (or use VSCode which integrates
 * a builtin ANSI-compliant terminal).
 *)

(*****************************************************************************)
(* Types and globals *)
(*****************************************************************************)

(* Usually derived from CLI flags (e.g., --force-color=true) *)
type highlight = On | Off [@@deriving show]

(* set by UConsole.setup() *)
let highlight : highlight ref = ref (On : highlight)

(* accessors *)
let get_highlight () = !highlight

(*****************************************************************************)
(* Partial copy of ANSITerminal.ml *)
(*****************************************************************************)

type color =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
  | Default  (** Default color of the terminal *)
[@@deriving show]

(* for boostrap-mk.sh, will be implemented for real by deriving below *)
let show_style _ = "NOTDERIVED"
[@@warning "-32"]

type style =
  | Reset
  | Bold
  | Underlined
  | Blink
  | Inverse
  | Hidden
  | Foreground of color
  | Background of color
[@@deriving show]

let black = Foreground Black
let red = Foreground Red
let green = Foreground Green
let yellow = Foreground Yellow
let blue = Foreground Blue
let magenta = Foreground Magenta
let cyan = Foreground Cyan
let white = Foreground White
let default = Foreground Default

(*****************************************************************************)
(* Poor's man ANSITerminal *)
(*****************************************************************************)

(* ANSI escape sequences for colored output, depending on log level
 * alt: use ANSIterminal.ml, but not worth it
 * LATER: make portable on plan9
 * see https://en.wikipedia.org/wiki/ANSI_escape_code for the color codes
 *)
let color_code (x : color) : string =
  match x with
  | Black -> "30"
  | Red -> "31"
  | Green -> "32"
  | Yellow -> "33"
  | Blue -> "34"
  | Magenta -> "35"
  | Cyan -> "36"
  | White -> "37"
  | Default -> "37"

(* pre/post escape sequence around the string we want colored *)
let color_pre x =
  Printf.sprintf "\027[%sm" (color_code x)

let color_post () =
  "\027[0m"

(* reimplementation of ANSITerminal.sprintf styles *)
let sprintf styles fmt =
  match get_highlight () with
  | Off -> Printf.sprintf fmt
  | On ->
      (match styles with
      | Foreground x ->
            Printf.ksprintf (fun s -> (color_pre x) ^ s ^ (color_post ())) fmt
      | Reset
      | Bold
      | Underlined
      | Blink | Inverse | Hidden | Background _ -> 
          failwith (Printf.sprintf "TODO: style not handled %s" (show_style styles)))


(* shortcuts *)
let bold s = sprintf Bold "%s" s
let underline s = sprintf Underlined "%s" s
let color c s = sprintf c "%s" s

(*****************************************************************************)
(* Error/Warning/Success messages *)
(*****************************************************************************)

type log_style = Error | Warning | Success

let color_of_style = function
  | Error -> red
  | Warning -> yellow
  | Success -> green

let style_string style str =
  match get_highlight () with
  | On -> sprintf (color_of_style style) "%s" str
  | Off -> str

(* exported in Console.mli *)
let error str = style_string Error str
let warning str = style_string Warning str
let success str = style_string Success str

(*****************************************************************************)
(* Actual printing and caps *)
(*****************************************************************************)

(* %! is to flush *)

let print caps str = 
  let _ = caps#stdout in
  Printf.printf "%s\n%!" str
let print_no_nl caps str = 
  let _ = caps#stdout in
  Printf.printf "%s%!" str
let eprint caps str = 
  let _ = caps#stderr in
  Printf.eprintf "%s\n%!" str

let stdin caps = 
  let _ = caps#stdin in
  stdin
let stdout caps = 
  let _ = caps#stdout in
  stdout
let stderr caps = 
  let _ = caps#stderr in
  stderr
