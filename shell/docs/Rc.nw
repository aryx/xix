\documentclass[12pt]{report}
%alt: [12pt, twocolumn, landscape]
%coupling: see Config.tex

\input{latex/Packages}
\input{latex/Config}
\input{latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:

%thx to codemap/codegraph/scheck:

%thx to this manual, I better understand sh:

%history LP-ization:
% - skeleton, mostly copy paste of Shell.nw skeleton
% - put all content of files in the Extra section, via 'lpizer'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - SEMI aspecify advanced features!
% - TODO add figures
% - TODO add explanations


\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Shell [[rc]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Tom Duff and Yoann Padioleau
}

\maketitle 
%\onecolumn
\hrule
%\input{latex/Copyright}
%\input{latex/CopyrightPlan9}
\begin{quote}
Copyright \copyright{} 2025 Yoann Padioleau \\
Permission is granted to copy, distribute and/or modify this document,
except all the source code it contains, under the terms of the GNU Free
Documentation License, Version 1.3.
\end{quote}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\cite{make}






\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}

\section{Tokens}

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Keywords *)*/
/*(*-----------------------------------------*)*/
%token TFor TIn  TIf TNot TWhile  TSwitch  
%token TFn

/*(*-----------------------------------------*)*/
/*(*2 Word *)*/
/*(*-----------------------------------------*)*/
%token<string * bool(* quoted *)> TWord

/*(*-----------------------------------------*)*/
/*(*2 Operators *)*/
/*(*-----------------------------------------*)*/
%token TPipe
%token TAndAnd TOrOr TBang
%token<Ast.redirection_kind> TRedir
%token<Ast.redirection_kind * int * int> TDup
%token TAnd TSubshell
%token TTwiddle  

/*(*-----------------------------------------*)*/
/*(*2 Punctuation *)*/
/*(*-----------------------------------------*)*/

%token TOPar TCPar TOBrace TCBrace
%token TSemicolon TEq
%token TDollar TCount TStringify 
%token TSub
%token TCaret
%token TBackquote

/*(*-----------------------------------------*)*/
/*(*2 Misc *)*/
/*(*-----------------------------------------*)*/
%token TNewline

%token EOF
@

\section{Abstract syntax tree (AST)}

<<type [[Ast.line]]>>=
(* None when reads EOF *)
type line = cmd_sequence option
@

<<type [[Ast.cmd_sequence]]>>=
  and cmd_sequence = cmd list
@
% separated by ';' ?


<<type [[Ast.cmd]]>>=
and cmd =
  | EmptyCommand

  (* Base *)
  | Simple of value * values
  | Pipe of cmd * cmd (* less: lfd, rfd option *)
  <<[[Ast.cmd]] other base cases>>

  (* Redirections *)
  | Redir of cmd * redirection
  <<[[Ast.cmd]] other redirection cases>>

  (* expressions *)
  <<[[Ast.cmd]] expression cases>>

  (* stmts *)
  | If of cmd_sequence * cmd
  (* Note that you can not put a 'cmd option' in If instead of IfNot below. 
   * rc has to process 'if(...) cmd\n' now! It can not wait for an else.
   *)
  | IfNot of cmd
  | While of cmd_sequence * cmd
  <<[[Ast.cmd]] other statement cases>>

  (* definitions *)
  (* can do x=a; but also $x=b ! 
   * less: could have AssignGlobal and AssignLocal of ... cmd
   *)
  | Assign of value * value * cmd (* can be EmptyCommand *)
  | Fn of value * cmd_sequence
  <<[[Ast.cmd]] other definition cases>>
@



<<type [[Ast.values]]>>=
(* separated by spaces *)
and values = value list
@


<<type [[Ast.value]]>>=
(* rc does not use types; there is no integer, no boolean, no float.
 * The only value in rc is the list of strings. Even a single
 * string is really a list with one element.
 *)
type value = 
  (* The string can contain the * ? [ special characters.
   * So, even a single word can expand to a list of strings.
   * less: they should be preceded by \001
   * less: W of word_elt list and word_elt = Star | Question | ...Str of string
   *)
  | Word of string * bool (* quoted *)
  | Dollar of value
  | List of values
  <<[[Ast.value]] other cases>>
@

<<type [[Ast.redirection]]>>=
  and redirection = redirection_kind * value (* the filename *)
@

<<type [[Ast.redirection_kind]]>>=
    and redirection_kind = 
      | RWrite (* > *)
      | RRead  (* < *)
      | RAppend (* > > *)
      <<[[Ast.redirection_kind]] other cases>>
@



%TODO: dump AST for ls /etc > /tmp/list.txt, and ref to -dump_ast in appendix








%LP: distribute to advanced or later
<<[[Ast.redirection_kind]] other cases>>=
(* less: RHere *) (* < < *)
| RDup of int * int (* >[x=y] *)
@

<<[[Ast.value]] other cases>>=
(* this causes the value and cmd types to be mutually recursive. Uses $IFS *)
| CommandOutput of cmd_sequence
@
%$
<<[[Ast.value]] other cases>>=
| Count of value (* $#foo *)
| Index of value * values (* $foo(...) *)
@
%$
<<[[Ast.value]] other cases>>=
(* ^ distributes over lists *)
| Concat of value * value
@
<<[[Ast.value]] other cases>>=
| Stringify of value (* $"foo " *)
@
%$


<<[[Ast.cmd]] other base cases>>=
| Async of cmd
@

<<[[Ast.cmd]] other redirection cases>>=
| Dup of cmd * redirection_kind * int * int (* >[1=2] *)
@

<<[[Ast.cmd]] expression cases>>=
| And of cmd * cmd
| Or of cmd * cmd
| Not of cmd
@
<<[[Ast.cmd]] expression cases>>=
| Match of value * values
(* can also run the program 'test' for other comparisons *)
@


<<[[Ast.cmd]] other statement cases>>=
| Switch of value * cmd_sequence
@
<<[[Ast.cmd]] other statement cases>>=
| ForIn of value * values * cmd
(* less: could desugar as ForIn value $* *)
| For of value * cmd
@
<<[[Ast.cmd]] other statement cases>>=
| Compound of cmd_sequence
@
%$

<<[[Ast.cmd]] other definition cases>>=
| DelFn of value
@



\section{Opcodes}

<<signature [[Compile.compile]]>>=
val compile : Ast.cmd_sequence -> Opcode.codevec
@

<<type [[Opcode.codevec]]>>=
type codevec = opcode array
@

<<type [[Opcode.opcode]]>>=
type opcode =
  | F of operation
  | I of int
  | S of string
@

% a bit like assembly, opcodes, operands, but very simple.
% why opcode? why not interpret AST instead?

% Stack machine, Word, Pop, use either inline or on Stack
<<type [[Opcode.operation]]>>=
(* Operations generated by the compiler. 
 * 
 * Semantic of comments below:
 *  - Arguments on stack (...)
 *  - Arguments in line [...]
 *  - Code in line with jump around {...}
 * 
 * alt: type operation = ((unit -> unit) * string)
 *)
type operation =

  (* Stack (argv) *)
  | Mark
  | Word (* [string] *)
  | Popm (* (value) *)
  <<[[Opcode.operation]] other stack cases>>

  (* Variable *)
  | Assign (* (name)(val) *)
  | Dollar (* (name) *)
  <<[[Opcode.operation]] other variable cases>>

  (* Process! *)
  | Simple (* (args) *)

  (* Control flow *)
  | If 
  | IfNot
  | Jump  (* [addr] *)
  | Exit 
  <<[[Opcode.operation]] other control cases>>

  (* Boolean return status  *)
  | Wastrue
  | Not
  | False (* {...} *)
  | True  (* {...} *)

  (* Redirections *)
  | Read (* (file)[fd] *)
  | Write (* (file)[fd] *)
  | Append (* (file)[fd] *)
  <<[[Opcode.operation]] other redirection cases>>

  (* Pipes *)
  | Pipe (* [i j]{... Xreturn}{... Xreturn} *)
  <<[[Opcode.operation]] other pipe cases>>

  (* Functions *)
  | Fn (* (name){... Xreturn } *)

  <<[[Opcode.operation]] other cases>>

  | REPL (* *)
@

% REPL! (was Xrdcmds?)


%TODO: show example of opcode for ls /etc > /tmp/list.txt, via -dump ?? with ref to appendix?






%LP: distribute to advanced
<<[[Opcode.operation]] other stack cases>>=
| Count (* (name) *)
| Concatenate (* (left)(right) *)
| Stringify (* (name) *)
@

<<[[Opcode.operation]] other variable cases>>=
| Index  (* ??? *)
| Local (* (name)(val) *)
| Unlocal (* *)
@

<<[[Opcode.operation]] other control cases>>=
(* While are compiled in jumps *)  
| Match (* (pat, str) *)
| Case  (* (pat, value){...} *)
| For   (* (var, list){... Xreturn} *)
@

<<[[Opcode.operation]] other redirection cases>>=
| ReadWrite (* (file)[fd] *)
| Close  (* [fd] *)
| Dup    (* [fd0 fd1] *)
| Popredir (* *)
@

<<[[Opcode.operation]] other pipe cases>>=
| PipeWait (* argument passed through Thread.pid *)
| PipeFd (* [type]{... Xreturn} *)
@


<<[[Opcode.operation]] other cases>>=
| DelFn (* (name) *)
(* less: RdFn *)
@

<<[[Opcode.operation]] other cases>>=
(* ?? *)
| Subshell (* {... Xexit} *)
| Backquote (* {... Xreturn} *)
| Async     (* {... Xreturn} *)
@

<<[[Opcode.operation]] other cases>>=
(* Globbing *)
| Glob (* (value?) *)
@


\section{Words}
%alt: and lists of words

% runtime value, what will be in the stack
% Not like Ast.value!

<<type [[Runtime.value]]>>=
(* In rc the basic (and only) value is the list of strings.
 * A single word is considered as a list with one element.
 *)
type value = string list
@



\section{Variables}

<<type [[Runtime.varname]]>>=
(* can be anything: "foo", but also "*", "1", "2", etc *)
type varname = string
@


<<type [[Runtime.var]]>>=
type var = { 
  (* can be None when lookup for a value that was never set before,
   * which is different from Some [] (when do A=()), which is also
   * different from Some [""] (when do A='').
   *)
  mutable v: value option;
  (* less: opti: changed: bool *)
}
@

<<signature [[Runtime.globals]]>>=
val globals : (varname, var) Hashtbl.t
@

<<global [[Runtime.globals]]>>=
let globals: (varname, var) Hashtbl.t = 
  Hashtbl.create 101
@

<<signature [[Var.gvlook]]>>=
(* This will only look for globals (in Runtime.globals) *)
val gvlook : Runtime.varname -> Runtime.var
@

<<function [[Var.gvlook]]>>=
let gvlook name =
  try 
    Hashtbl.find R.globals name
  with Not_found ->
    let var = { R.v = None } in
    Hashtbl.add R.globals name var;
    var
@





<<signature [[Var.vinit]]>>=
(* Populate Runtime.globals from the current environment *)
val vinit : < Cap.env ; .. > -> unit
@

<<function [[Var.vinit]]>>=
let vinit (_caps : < Cap.env; .. >) =
  Logs.err (fun m -> m "TODO: load from environment")
@



\section{Functions}

<<signature [[Runtime.fns]]>>=
val fns : (string, fn) Hashtbl.t
@

<<global [[Runtime.fns]]>>=
let fns: (string, fn) Hashtbl.t = 
  Hashtbl.create 101
@

<<type [[Runtime.fn]]>>=
type fn = {
  code: Opcode.codevec;
  pc: int;
  (* less: fnchanged *)
}
@




\section{Threads and run queue}

<<type [[Runtime.thread]]>>=
type thread = {
  code: Opcode.codevec;
  pc: int ref;

  mutable argv: string list;
  locals: (varname, var) Hashtbl.t;

  <<[[Runtime.thread]] other fields>>
}
@

%Where is the stack ?? what is argv?



<<signature [[Runtime.runq]]>>=
val runq : thread list ref
@

<<constant [[Runtime.runq]]>>=
(* less: could have also  'let cur = { code = boostrap; pc = 1; chan = stdin }'
 * in addition to runq. Then there will be no need for cur ().
 *)
let runq = ref []
@

<<signature [[Runtime.cur]]>>=
val cur : unit -> thread
@
<<function [[Runtime.cur]]>>=
let cur () =
  match !runq with
  | [] -> failwith "empty runq"
  | x::_xs -> x
@



<<signature [[Runtime.mk_thread]]>>=
val mk_thread :
  Opcode.codevec -> int -> (varname, var) Hashtbl.t -> thread
@

<<function [[Runtime.mk_thread]]>>=
(* This function was called start(), but it does not really start right
 * away the new thread. So better to call it mk_thread.
 * It starts with pc <> 0 when handle async, traps, pipes, etc.
 *)
let mk_thread code pc locals =
  let t = {
    code = code;
    pc = ref pc;
    argv = [];
    locals = locals;

    <<[[Runtime.mk_thread()]] set other fields>>
  } in
  t
@





\subsection{Local variables}


<<signature [[Var.vlook]]>>=
(* This will look first in the locals (in Runtime.cur().locals) and then
 * in globals (in Runtime.globals)
 *)
val vlook : Runtime.varname -> Runtime.var
@

<<function [[Var.vlook]]>>=
let vlook name =
  if !Runtime.runq <> []
  then 
    let t = Runtime.cur () in
    try 
      Hashtbl.find t.R.locals name
    with Not_found ->
      gvlook name
  else gvlook name
@

<<signature [[Var.setvar]]>>=
(* Override the content of a (local or global) variable *)
val setvar : Runtime.varname -> Runtime.value -> unit
@

<<function [[Var.setvar]]>>=
let setvar name v =
  let var = vlook name in
  var.R.v <- Some v
@



\subsection{Redirections}

<<[[Runtime.thread]] other fields>>=
(* things to do before exec'ing the simple command *)
mutable redirections: (redir list) list;
@

<<[[Runtime.mk_thread()]] set other fields>>=
redirections = 
  (match !runq with
  | [] -> []::[]
  | t::_ts -> []::t.redirections
  );
@


\subsection{Wait status}

<<[[Runtime.thread]] other fields>>=
(* things to wait for after a thread forked a process *)
mutable waitstatus: waitstatus;
@
<<[[Runtime.mk_thread()]] set other fields>>=
waitstatus = NothingToWaitfor;
@









<<[[Runtime.thread]] other fields>>=
(* Used for switch but also assignments. *)
mutable argv_stack: (string list) list;
@
%TODO? use value list here?? diff with argv?

<<[[Runtime.mk_thread()]] set other fields>>=
argv_stack = [];
@


<<[[Runtime.thread]] other fields>>=
(* for error reporting (None when reading from stdin) *)
(* less: file has to be mutable? could be a param of start? like chan? *)
mutable file: Common.filename option;
line: int ref;
@

<<[[Runtime.thread]] other fields>>=
(* connected on stdin by default (changed when do '. file') *)
mutable lexbuf: Lexing.lexbuf;
@



<<[[Runtime.mk_thread()]] set other fields>>=
lexbuf = Lexing.from_function (fun _ _ -> failwith "unconnected lexbuf");
iflag = false;
file = None;
line = ref 1;
@





<<[[Runtime.thread]] other fields>>=
(* to display a prompt or not *)
mutable iflag: bool;
@










%\subsection{Stack helpers}

<<signature [[Runtime.push_list]]>>=
val push_list : unit -> unit
@

<<signature [[Runtime.pop_list]]>>=
val pop_list : unit -> unit
@


<<signature [[Runtime.pop_word]]>>=
val pop_word : unit -> unit
@


<<function [[Runtime.push_list]]>>=
let push_list () =
  let t = cur () in
  t.argv_stack <- t.argv :: t.argv_stack;
  t.argv <- []
@

<<function [[Runtime.pop_list]]>>=
let pop_list () =
  let t = cur () in
  match t.argv_stack with
  (* At the very beginning we do *=(argv) in bootstrap.
   * In that case, Assign will generate two pop_list, but for
   * the second one argv_stack becomes empty. The only thing
   * we must do is to empty argv then.
   *)
  | [] ->
     t.argv <- []
  | x::xs -> 
      t.argv_stack <- xs;
      t.argv <- x
@


<<function [[Runtime.pop_word]]>>=
let pop_word () =
  let t = cur () in
  match t.argv with
  | [] -> failwith "pop_word but no word!"
  | _x::xs ->
      t.argv <- xs
@



\chapter{[[main()]]}





\section{Overview}

<<type [[CLI.caps]]>>=
(* Need:
 *  - fork/exec: obviously as we are a shell
 *  - chdir: for the builtin 'cd'
 *  - env: to ??
 *  - exit: as many commands can abruptely exit 'rc' itself or children
 *    created by 'rc'
 *  - open_in: ??
 *
 * alt: could remove Cap.exit and use Exit.ExitCode exn in Process.ml instead
*)
type caps = < Cap.fork; Cap.exec; Cap.chdir; Cap.env; Cap.exit; Cap.open_in >
@

<<signature [[CLI.main]]>>=
(* entry point (can also raise Exit.ExitCode) *)
val main: <caps; ..> -> string array -> Exit.t
@

<<toplevel [[Main._1]]>>=
let _ =
  Cap.main (fun (caps : Cap.all_caps) ->
     let argv = CapSys.argv caps in
     Exit.exit caps 
        (Exit.catch (fun () -> 
            CLI.main caps argv))
   )
@





<<function [[CLI.main]]>>=
let main (caps : <caps; .. >) (argv : string array) : Exit.t =
  let args = ref [] in
  <<[[CLI.main()]] debugging initializations>>

  let options = [
    <<[[CLI.main()]] [[options]] elements>>
  ]
  in
  (* old: was Arg.parse but we want explicit argv control *)
  (try 
    Arg.parse_argv argv (Arg.align options) (fun t -> args := t::!args) usage;
  with
  | Arg.Bad msg -> UConsole.eprint msg; raise (Exit.ExitCode 2)
  | Arg.Help msg -> UConsole.print msg; raise (Exit.ExitCode 0)
  );
  <<[[CLI.main()]] logging initializations>>
  <<[[CLI.main()]] CLI action processing>>
  (* todo: 
   * if argc=1 and Isatty then Flags.interactive := true 
   *)
  Var.vinit caps;
  (* todo: trap_init () *)
  <<[[CLI.main()]] other initializations>>
  try 
    interpret_bootstrap (caps :> < caps >) (List.rev !args);
    Exit.OK
  with exn ->
    <<[[CLI.main()]] when [[exn]] thrown in [[interpret()]]>>
@
%$


<<[[CLI.main()]] when [[Failure]] [[exn]] thrown in [[interpret()]]>>=
| Failure s -> 
    (* useful to indicate that error comes from rc, not subprocess *)
    Logs.err (fun m -> m  "rc: %s" s);
    Exit.Code 1
@


<<signature [[CLI.interpret_bootstrap]]>>=
val interpret_bootstrap : < caps > -> string list -> unit
@


\section{Command-line arguments processing}
%ocaml: section not needed

<<constant [[CLI.usage]]>>=
let usage =
  "usage: rc [-SsriIlxevV] [-c arg] [-m command] [file [arg ...]]"
@

% will show gradually

\subsection{Login mode: [[rc -l]]}

<<constant [[Flags.login]]>>=
(* -l (on by default if argv0 starts with a -) *)
let login = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-l", Arg.Set Flags.login,
" login mode (execute ~/lib/profile)";
@

\subsection{Interactive mode: [[rc -i]]}

<<constant [[Flags.interactive]]>>=
(* -i (on by default when detects that stdin is /dev/cons *)
let interactive = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-i", Arg.Set Flags.interactive,
" interactive mode (display prompt)";
"-I", Arg.Clear Flags.interactive,
" non-interactive mode (no prompt)";
@

\section{Initialization}

%Var.vinit

\section{Bootstrapping bytecodes (simplified)}

<<constant [[CLI._bootstrap_simple]]>>=
let _bootstrap_simple : O.opcode array = 
  [| O.F O.REPL |]
@

%\section{Setting [[runq]]}

%\section{Setting [[runq->argv]]}

\section{Bytecode interpreter loop}


<<function [[CLI.interpret_bootstrap]]>>=
let interpret_bootstrap (caps : < caps >) (args : string list) : unit =
  let t = R.mk_thread (bootstrap ()) 0 (Hashtbl.create 11) in
  R.runq := t::!R.runq;

  t.R.lexbuf <- Lexing.from_channel stdin;
  t.R.iflag <- !Flags.interactive;

  (* less: set argv0 *)
  args |> List.rev |> List.iter Runtime.push_word;

  while true do
    (* bugfix: need to fetch the current thread each time,
     * as the interpreted code may have modified runq.
     *)
    let t = Runtime.cur () in
    let pc = t.R.pc in
    <<[[CLI.interpret()]] if [[rflag]]>>
    incr pc;
    (match t.R.code.(!pc - 1) with
    (* opcode dispatch ! *)
    | O.F operation ->  Interpreter.interpret_operation caps operation
    | O.S s -> failwith (spf "was expecting a F, not a S: %s" s)
    | O.I i -> failwith (spf "was expecting a F, not a I: %d" i)
    );
    (* todo: handle trap *)
  done
[@@profiling]
@


<<signature [[Runtime.push_word]]>>=
val push_word : string -> unit
@
<<function [[Runtime.push_word]]>>=
let push_word s =
  let t = cur () in
  t.argv <- s::t.argv
@

<<signature [[Interpreter.interpret_operation]]>>=
(* Interpret one operation. Called from a loop in main(). *)
val interpret_operation :
  < Cap.fork ; Cap.exec ; Cap.chdir ; Cap.exit ; Cap.open_in; .. > ->
  Opcode.operation ->
  unit
@


<<function [[Interpreter.interpret_operation]]>>=
let interpret (caps: < Cap.fork; Cap.exec; Cap.chdir; Cap.exit; .. >) operation =
  match operation with
  <<[[Interpreter.interpret_operation()]] match [[operation]] cases>>
  | (O.Concatenate|O.Stringify    |O.Index|
     O.Unlocal|
     O.Fn|
     O.For|
     O.Read|O.Append |O.ReadWrite|
     O.Close|O.Dup|O.PipeFd|
     O.Subshell|O.Backquote|O.Async
    ) ->
    failwith ("TODO: " ^ Dumper_.s_of_opcode (O.F operation))
@
%$

\section{Reading commands: [[O.REPL]]}
%c: was Xrdcmds()

<<[[Op_repl.op_REPL()]] set [[prompt]] if [[iflag]]>>=
(* set prompstr *)
if t.R.iflag then begin
  let promptv = (Var.vlook "prompt").R.v in
  Prompt.prompt := 
    (match promptv with
    | Some (x::_xs) -> x
    (* stricter? display error message if prompt set but no element?*)
    | Some [] | None -> "% "
    );
end;
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* *)
| O.REPL -> Op_repl.op_REPL caps ()
@

<<function [[Op_repl.op_REPL]]>>=
(* was called Xrdcmds *)
let op_REPL (caps : < Cap.exit; ..>) () =
  let t = R.cur () in

  <<[[Op_repl.op_REPL()]] if [[sflag]]>>
  <<[[Op_repl.op_REPL()]] set [[prompt]] if [[iflag]]>>

  (* less: call Noerror before yyparse *)

  let lexbuf = t.R.lexbuf in
  try 
    let cmdseq_opt = Parse.parse_line lexbuf in
    match cmdseq_opt with
    | Some seq ->
        (* should contain an op_return *)
        let codevec = Compile.compile seq in
        let newt = R.mk_thread codevec 0 t.R.locals in
        R.runq := newt::!(R.runq);

        decr t.R.pc;
        (* when codevec does a op_return(), then interpreter loop
         * in main should call us back since the pc was decremented above
         *)
    | None -> Process.return caps ()

  with Failure s -> 
    <<[[Op_repl.op_REPL()]] when [[Failure s]] thrown>>
@
% parse_line, compile, runq

<<signature [[Parse.parse_line]]>>=
val parse_line : Lexing.lexbuf -> Ast.line
@
% compile seen before

% when return op_REPL, and interpret_operation, will go gack to
% while loop of interpret_bootstrap and newt at the top of cur!
% so will execute that!

<<[[Op_repl.op_REPL()]] when [[Failure s]] thrown>>=
(* todo: check signals  *)

if not t.R.iflag
(* less: was doing Xreturn originally *)
then failwith s
else begin
  Logs.err (fun m -> m "%s" s);
  (* go back for next command *)
  decr t.R.pc;
end
@


<<signature [[Process.return]]>>=
val return : < Cap.exit ; .. > -> unit -> unit
@

<<function [[Process.return]]>>=
(* Was called Xreturn but called not only from the opcode interpreter.
 * It is an helper function really.
 *)
let return (caps : < Cap.exit; .. >) () =
  R.turf_redir ();
  match !R.runq with
  | [] -> failwith "empty runq"
  (* last thread in runq, we exit then *)
  | [_x] -> exit caps (Status.getstatus ())
  | _x::xs -> 
      R.runq := xs
@





%\chapter{Input}
%\section{Overview}
%\section{Reading a character: [[getnext()]]}
%\subsection{End-of-file management}
%\subsection{Multiple lines commands and escaped newlines}
%\section{Looking ahead: [[nextc()]] and [[advance()]]}
\subsection{Displaying the prompt}

<<signature [[Prompt.doprompt]]>>=
val doprompt : bool ref
@

<<signature [[Prompt.prompt]]>>=
val prompt : string ref
@

<<signature [[Prompt.pprompt]]>>=
(* !will reset doprompt! *)
val pprompt : unit -> unit
@


<<constant [[Prompt.doprompt]]>>=
(* Set to true so the prompt is displayed before the first character is read.
 *
 * Do we need that global? Can we not just call pprompt() explicitely?
 * No because when we get a newline, we know we should display the prompt,
 * but not before finishing executing the command. So the display
 * prompt should be done before the next round of input.
 * less: actually we could do it in the caller of parse_line, in the REPL.
 *)
let doprompt = ref true
@

<<constant [[Prompt.prompt]]>>=
let prompt = ref "% "
@

<<function [[Prompt.pprompt]]>>=
let pprompt () =
  let t = R.cur () in
  if t.R.iflag then begin
    prerr_string !prompt;
    flush stderr;

    (* set promptstr for the next pprompt() *)
    let promptv = (Var.vlook "prompt").R.v in
    prompt := 
      (match promptv with
      | Some [_x;y] -> y
       (* stricter? display error message if prompt set no 2 elements?*)
      | Some _ | None -> "\t"
      );
  end;
  (* alt: incr t.R.line; this is done in the lexer instead *)
  doprompt := false
@








\chapter{Lexing}

% parse_line() will call Lexer.token()

<<signature [[Lexer.token]]>>=
val token: Lexing.lexbuf -> Parser.token
@

<<exception [[Lexer.Lexical_error]]>>=
exception Lexical_error of string
@
<<function [[Lexer.error]]>>=
let error s =
  raise (Lexical_error s)
@


\section{[[token()]] skeleton}


<<Lexer.mll>>=
{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Parser

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Limitations compared to rc:
 *  - no unicode support
*)
<<exception [[Lexer.Lexical_error]]>>
<<function [[Lexer.error]]>>
<<function [[Lexer.incr_lineno]]>>
}
(*****************************************************************************)
(* Regexps aliases *)
(*****************************************************************************)
<<lexer regexp aliases>>

(*****************************************************************************)
(* Main rule *)
(*****************************************************************************)
<<rule [[Lexer.token]]>>

(*****************************************************************************)
(* Quote rule *)
(*****************************************************************************)
<<rule [[Lexer.quote]]>>
@



<<rule [[Lexer.token]]>>=
rule token = parse

  (* ----------------------------------------------------------------------- *)
  (* Spacing/comments *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] space cases>>
  <<[[Lexer.token()]] comment cases>>

  (* ----------------------------------------------------------------------- *)
  (* Symbols *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] symbol cases>>

  (* ----------------------------------------------------------------------- *)
  (* Variables *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] variable cases>>

  (* ----------------------------------------------------------------------- *)
  (* Quoted word *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] quoted word cases>>

  (* ----------------------------------------------------------------------- *)
  (* Keywords and unquoted words *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] keywords and unquoted words cases>>

  (* ----------------------------------------------------------------------- *)
  | eof { EOF }
  | _ (*as c*)   { error (spf "unrecognized character: '%s'" (Lexing.lexeme lexbuf)) }
@




<<lexer regexp aliases>>=
(* less: not used yet, special regexp used with lastdol *)
let idchr = ['a'-'z''A'-'Z''0'-'9''_''*']
@




%\section{[[yylex()]]}

\section{Spaces and comments ([['#']])}

<<[[Lexer.token()]] space cases>>=
| [' ''\t']+ { token lexbuf }
@

<<[[Lexer.token()]] comment cases>>=
| '#' [^'\n']* { token lexbuf }
@


\section{Newlines and prompts}

<<[[Lexer.token()]] space cases>>=
| '\n'       { incr_lineno(); Prompt.doprompt := true; TNewline }
@

<<[[Lexer.token()]] space cases>>=
| '\\''\n'  {
    incr_lineno ();
    Prompt.pprompt ();
    token lexbuf
}    
@


<<function [[Lexer.incr_lineno]]>>=
(* we could do that in pprompt() too *)
let incr_lineno () =
  let t = Runtime.cur () in
  incr t.Runtime.line
@  


\section{Operators ([['&']], [['&&']], [['|']], [['||']], [['<']], [['>']], [['$']], \ldots)}

<<[[Lexer.token()]] symbol cases>>=
| "&&" { Globals.skipnl := true; TAndAnd }
| "||" { Globals.skipnl := true; TOrOr }
@

<<[[Lexer.token()]] symbol cases>>=
| ';'  { TSemicolon }
| "&"  { TAnd }
@

<<[[Lexer.token()]] symbol cases>>=
| "|"  { Globals.skipnl := true; TPipe }
@

<<[[Lexer.token()]] symbol cases>>=
| ">"  { TRedir Ast.RWrite }
| "<"  { TRedir Ast.RRead }
| ">>" { TRedir Ast.RAppend }
@
<<[[Lexer.token()]] symbol cases>>=
| ">[" (['0'-'9']+ (*as fd0*)) "=" (['0'-'9']+ (*as fd1*)) "]" 
       {  let fd0 = failwith "TODO: fd0" in
   let fd1 = failwith "TODO: fd1" in
   TDup (Ast.RWrite, int_of_string fd0, int_of_string fd1)
}
| ">>[" (['0'-'9']+ (*as fd0*)) "=" (['0'-'9']+ (*as fd1*)) "]" 
       {
           let fd0 = failwith "TODO: fd0" in
    let fd1 = failwith "TODO: fd1" in
    TDup (Ast.RAppend, int_of_string fd0, int_of_string fd1)
}
(* less: advanced pipe and redirection *)
@

<<[[Lexer.token()]] symbol cases>>=
| '('  { TOPar }   | ')' { TCPar }
| '{'  { TOBrace } | '}' { TCBrace }
@
<<[[Lexer.token()]] symbol cases>>=
| '='  { TEq }
@

<<[[Lexer.token()]] symbol cases>>=
| "`" { TBackquote } 
@
<<[[Lexer.token()]] symbol cases>>=
| "~" { TTwiddle } 
| "!" { TBang }
@

<<[[Lexer.token()]] symbol cases>>=
| "@" { TSubshell }
@
<<[[Lexer.token()]] symbol cases>>=
| "^" { TCaret }
@


<<constant [[Globals.skipnl]]>>=
(* This global is used by the lexer and parser to consider certain
 * newlines as regular spaces. Because rc is an interactive
 * interpreter, newline has a special meaning: it terminates a command.
 * However, sometimes we just want to add a newline because the command
 * is too long. Escaping the newline is one way to do it. 
 * But when we start to parse 'cmd1 &&' we know that we are expecting
 * more stuff. So after the && and other binary operators  we consider 
 * the newline not as a command terminator, but as a space.
 * Also we indent the prompt to let the user know he can still enter
 * more characters.
 *)
let skipnl = ref false
@


<<[[Lexer.token()]] variable cases>>=
| "$"   { TDollar }
@
<<[[Lexer.token()]] variable cases>>=
| "$#"  { TCount }
@
<<[[Lexer.token()]] variable cases>>=
| "$\"" { TStringify }
@
%$

\section{Quoted strings ([['...']])}

<<[[Lexer.token()]] quoted word cases>>=
| "'" { let s = quote lexbuf in TWord (s, true) }
@

<<rule [[Lexer.quote]]>>=
and quote = parse
  | "''" { "'" ^ quote lexbuf } 
  | "'" { "" } 
  | "\n" { 
      incr_lineno ();
      Prompt.pprompt ();
      "\n" ^ quote lexbuf
    }
  | [^'\'' '\n']+ { let s = Lexing.lexeme lexbuf in s ^ quote lexbuf }
  (* stricter: generate error *)
  | eof { error "unterminated quote" }
@

\section{Keywords and identifiers ([[if]], [[for]], [[while]], [[switch]], [[fn]], \ldots )}

<<lexer regexp aliases>>=
(* original: !strchr("\n \t#;&|^$=`'{}()<>", c) && c!=EOF;
 * note that wordchr allows '~', '!', '@', '"', ','
 *)
let wordchr = [^'\n' ' ' '\t' '#'
                ';' '&''|''^' '$' '=' 
                '`' '\'' 
               '{''}' '('')' '<''>'
                ]
@

<<[[Lexer.token()]] keywords and unquoted words cases>>=
| wordchr+ { 

  let s = Lexing.lexeme lexbuf in
  (match s with
  | "if"    -> TIf
  | "while" -> TWhile
  | "for"   -> TFor
  | "in"    -> TIn
  | "not"   -> TNot
  | "switch" -> TSwitch
  | "fn"     -> TFn

  | _ -> TWord (s, false)
  )
}
@

%\section{Array subscript ([[<arr>(<n>)]])}



\chapter{Parsing}

\section{[[parse_line()]] skeleton}


<<function [[Parse.parse_line]]>>=
let parse_line lexbuf =
  let curtok = ref (Parser.EOF, "EOF") in

  Globals.skipnl := false;
  let got_skipnl_last_round = ref false in

  let lexfunc lexbuf =
    (* less: could do that in caller? would remove need for doprompt *)
    if !Prompt.doprompt
    then Prompt.pprompt ();

    let tok = ref (Lexer.token lexbuf) in

    if !got_skipnl_last_round then begin
      if !tok = Parser.TNewline 
      then begin
        let rec loop () =
          Prompt.pprompt ();
          tok := Lexer.token lexbuf;
          if !tok = Parser.TNewline
          then loop ()
        in
        loop ()
      end;
      got_skipnl_last_round := false;
    end;
    if !Globals.skipnl 
    then got_skipnl_last_round := true;
    Globals.skipnl := false;

    let s = Lexing.lexeme lexbuf in
    curtok := (!tok, s);
    (* todo: 
       - handle lastdol 
       - handle SUB
       - handle free caret insertion
    *)
    !tok 
    |> (fun tok -> 
        if !Flags.dump_tokens 
        then Logs.app (fun m -> m "%s" (Dumper.dump (tok,s)));
        tok)
  in
  try 
    Parser.rc lexfunc lexbuf
    |> (fun ast -> if !Flags.dump_ast then Logs.app (fun m -> m "%s" (Dumper_.s_of_line ast)); ast)
  with 
    | Parsing.Parse_error ->
        error "syntax error" !curtok
    | Lexer.Lexical_error s ->
        error (spf "lexical error, %s" s) !curtok
@



<<function [[Parse.error]]>>=
let error s (curtok, curtokstr) =
  let t = R.cur () in
  let locstr =
    match t.R.file, t.R.iflag with
    | Some f, false -> spf "%s:%d: " f !(t.R.line)
    | Some f, true -> spf "%s: " f
    | None, false -> spf "%d: " !(t.R.line)
    | None, true -> ""
  in
  let tokstr = 
    match curtok with
    | Parser.TNewline -> ""
    | _ -> spf "token %s: " (curtokstr)
  in
  let str = spf "rc: %s%s%s" locstr tokstr s in

  (* todo: reset globals like lastdol, lastword *)
  (* less: error recovery, skip until next newline *)
  Status.setstatus s;

  (* less: nerror++; *)
  failwith str
@



<<function [[Parser.mk_seq]]>>=
(* This is a useful optimisation as you can get lots of EmptyCommand,
 * for instance, in {\nls\n} you will get 2 EmptyCommand (for each \n)
*)
let mk_Seq (a, b) =
  match a, b with
  | EmptyCommand, _ -> b
  | _, [EmptyCommand] -> [a]
  | _ -> a::b
@

<<Parser token priorities>>=
/*(* from low to high *)*/
%left TIf TWhile TFor TSwitch TCPar TNot
%left TAndAnd TOrOr
%left TBang TSubshell
%left TPipe
%left TCaret
/*(* $$A -> ($ ($ A)) not (($ $) A) *)*/
%right TDollar TCount TStringify
%left TSub
@

<<Parser entry points types>>=
%type <Ast.line> rc
%start rc
@

<<Parser.mly>>=
%{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Stdcompat (* for |> *)
open Common
open Ast

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Parser.mk_seq]]>>
%}

/*(*************************************************************************)*/
/*(*1 Tokens *)*/
/*(*************************************************************************)*/
<<Parser tokens>>

/*(*************************************************************************)*/
/*(*1 Priorities *)*/
/*(*************************************************************************)*/
<<Parser token priorities>>

/*(*************************************************************************)*/
/*(*1 Rules type declaration *)*/
/*(*************************************************************************)*/
<<Parser entry points types>>

%%

<<grammar>>
@

<<grammar>>=
/*(*************************************************************************)*/
/*(*1 line *)*/
/*(*************************************************************************)*/
rc:
  | EOF           { None }
  | line TNewline { Some $1 }

/*(* =~ stmt *)*/
line:
  | cmd { [$1] }
  | cmdsa line { $1 $2  }

cmdsa:
  | cmd TSemicolon { (fun x -> mk_Seq ($1, x)) }
  | cmd TAnd       { (fun x -> mk_Seq (Async $1, x)) }

/*(*************************************************************************)*/
/*(*1 Command *)*/
/*(*************************************************************************)*/

/*(* =~ expr *)*/
cmd:
  | /*empty*/ { EmptyCommand }
  | simple    { 
      let (cmd, args, redirs) = $1 in
      let args = List.rev args in
      let redirs = List.rev redirs in
      let base = Simple (cmd, args) in
      redirs |> List.fold_left (fun acc e ->
        match e with
        | Left (kind, word)    -> Redir (acc, (kind, word))
        | Right (kind, fd0, fd1) -> Dup (acc, kind, fd0, fd1)
      ) base
    }
  | brace epilog   { 
      $2 |> List.fold_left (fun acc e -> 
        match e with
        | Left (kind, word) -> Redir (acc, (kind, word))
        | Right (kind, fd0, fd1) -> Dup (acc, kind, fd0, fd1)
      ) (Compound $1) 
  }

  | cmd TAndAnd cmd { And ($1, $3) }
  | cmd TOrOr cmd   { Or  ($1, $3) }
  | TBang cmd       { Not $2 }

  | TTwiddle word words { Match ($2, $3) }

  | cmd TPipe cmd  { Pipe ($1, $3) }

  | TIf paren_skipnl cmd { If ($2, $3) }
  | TIf tnot_skipnl  cmd { IfNot $3 }

  | TWhile paren_skipnl cmd   { While ($2, $3) }
  | TSwitch word_skipnl brace { Switch ($2, $3) }

  /*(* I added the %prec TFor. *)*/
  | TFor TOPar word TIn words tcpar_skipnl cmd %prec TFor { ForIn ($3, $5, $7) }
  | TFor TOPar word tcpar_skipnl cmd           %prec TFor { For ($3, $5) }

  /*(* stricter: allow only word, not words *)*/
  | TFn word brace { Fn ($2, $3) }
  | TFn word       { DelFn $2 }

  | assign cmd %prec TBang { $1 $2 }


/*(* =~ primary expr *)*/
simple:
  | first        { $1, [], [] }
  | simple word  { let (a,b,c) = $1 in (a, $2::b, c) }
  | simple redir { let (a,b,c) = $1 in (a, b, $2::c) }


paren: TOPar body TCPar { $2 }

brace: TOBrace body TCBrace { $2 }

body: 
  | cmd         { [$1] }
  | cmdsan body { $1 $2 }

cmdsan:
  | cmdsa        { $1 }
  | cmd TNewline { (fun x -> mk_Seq ($1, x)) }

assign: first TEq word { (fun x -> Assign ($1, $3, x))  }


/*(*************************************************************************)*/
/*(*1 Word *)*/
/*(*************************************************************************)*/

first:
  | comword           { $1 }
  | first TCaret word { Concat ($1, $3) }


comword:
  | TWord                         { Word (fst $1, snd $1) }
  | TDollar word                  { Dollar $2 }
  | TCount word                   { Count $2 }
  | TDollar word TSub words TCPar { Index ($2, $4) }
  | TOPar words TCPar             { List $2 }
  | TBackquote brace              { CommandOutput $2 }
  | TStringify word               { Stringify $2 }

word:
  | comword          { $1 }
  | keyword          { Word ($1, false) }
  | word TCaret word { Concat ($1, $3) }

keyword:
  | TFor { "for" }  | TIn { "in" }
  | TIf { "if" }  | TNot { "not" }
  | TWhile { "while" }
  | TSwitch { "switch" }
  | TFn { "fn" }

  | TTwiddle { "~" }
  | TBang { "!" }
  | TSubshell { "@" }


words: words_rev { List.rev $1 }

words_rev:
  | /*empty*/  { [] }
  | words_rev word { $2::$1 }

/*(*************************************************************************)*/
/*(*1 Redirection *)*/
/*(*************************************************************************)*/

redir:
  | TRedir word { Left ($1, $2) }
  | TDup        { Right $1 }

epilog:
  | /*empty*/    { [] }
  | redir epilog { $1::$2 }

/*(*************************************************************************)*/
/*(*1 Skipnl hacks *)*/
/*(*************************************************************************)*/

paren_skipnl: paren { Globals.skipnl := true; $1 }

tnot_skipnl: TNot   { Globals.skipnl := true; }

word_skipnl: word   { Globals.skipnl := true; $1 }

tcpar_skipnl: TCPar { Globals.skipnl := true; }

@


\section{Simple commands ([[<cmd> <arg1>...<argn>]]) }

\section{Operators}

\subsection{Sequences ([[';']], [['&']])}

\subsection{Logical operators  ([['&&']], [['||']], [['!']])}

\subsection{String matching  (\texttt{'\textasciitilde'})}

\subsection{Pipe  ([['|']])}

\subsection{Redirections  ([['>']], [['<']])}

\section{Control flow statements ([[if]], [[if not]], [[while]], [[switch]], [[for]])} 
\section{Functions ([[fn]])}

\section{Variables ([[<x> = ...]])}

\section{Lists ([[(...)]])}


%\chapter{Checking}






\chapter{Bytecode Generation and Interpretation}

<<function [[Compile.split_at_non_assign]]>>=
let rec split_at_non_assign = function
  | A.Assign (val1, val2, cmd) ->
      let (a,b) = split_at_non_assign cmd in
      (val1, val2)::a, b
  | b -> [], b
@

<<function [[Compile.split_when_case]]>>=
let split_when_case cmds =
  cmds |> Common2.span (function
    | (A.Simple (A.Word ("case", false), _)) -> false
    | _ -> true
  )
@



<<function [[Interpreter.vlook_varname_or_index]]>>=
let vlook_varname_or_index varname =
  if varname =~ "^[0-9]+$"
  then
    let i = int_of_string varname in
    let v = (Var.vlook "*").R.v in
    (match v with
    (* stricter: array out of bound checking *)
    | None -> failwith "undefined $*"
    | Some xs -> 
        (* list indexes in rc starts at 1, not 0 *)
        if i >= 1 && i <= List.length xs
        then Some ([List.nth xs (i-1)])
        else failwith (spf "out of bound, $%d too big for $*" i)
    )
  else (Var.vlook varname).R.v
@

<<function [[Interpreter.file_descr_of_int]]>>=
(* could be in runtime.ml *)
let file_descr_of_int i =
  match i with
  | 0 -> Unix.stdin
  | 1 -> Unix.stdout
  | 2 -> Unix.stderr
  (* todo: how do that? if do >[1=4] ?? *)
  | n -> failwith (spf "file_descr_of_int: unsupported int %d" n)
@

<<function [[Interpreter.int_at_address]]>>=
let int_at_address t pc =
  match t.R.code.(pc) with
  | O.I i -> i
  (* stricter: generate error, but should never happen *)
  | op -> failwith (spf "was expecting I, not %s at %d" 
                      (Dumper_.s_of_opcode op) pc)
@


\section{Overview}

%\subsection{[[emitxxx()]]}
\subsection{[[compile()]]}

<<function [[Compile.compile]]>>=
let compile (seq : Ast.cmd_sequence) : Opcode.codevec =

  (* a growing array *)
  let codebuf = ref [| |] in
  let len_codebuf = ref 0 in
  (* pointer in codebuf *)
  let idx = ref 0 in

  <<[[Compile.compile()]] nested function [[emit]]>>
  <<[[Compile.compile()]] nested function [[set]]>>

  outcode_seq seq !Flags.eflag (emit, set, idx);
  emit (O.F O.Return);
  (* less: O.F O.End *)
  (* less: heredoc, readhere() *)

  (* return the trimmed array *)
  Array.sub !codebuf 0 !idx
  <<[[Compile.compile()]] possibly dump returned opcodes>>
@

<<[[Opcode.operation]] other control cases>>=
| Return
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Return -> Process.return caps ()
@


<<[[Compile.compile()]] nested function [[emit]]>>=
let emit x =
  <<[[Compile.compile()]] nested function [[emit]] possibly grow [[codebuf]]>>
  !codebuf.(!idx) <- x;
  incr idx
in
@

<<[[Compile.compile()]] nested function [[emit]] possibly grow [[codebuf]]>>=
(* grow the array if needed *)
if !idx = !len_codebuf then begin
  len_codebuf := !len_codebuf + 100;
  codebuf := Array.append !codebuf (Array.make 100 (O.I 0));
end;
@


<<[[Compile.compile()]] nested function [[set]]>>=
let set idx2 x =
  <<[[Compile.compile()]] nested function [[set]] array bound checking>>
  !codebuf.(idx2) <- x;
in
@

<<[[Compile.compile()]] nested function [[set]] array bound checking>>=
if idx2 < 0 || idx2 >= !len_codebuf
then failwith (spf "Bad address %d in set()" idx2);
@

\subsection{[[outcode_seq()]] skeleton}

% return unit cos side effect on enclosing codebuf in compile()
% via emit or set or idx

<<function [[Compile.outcode_seq]]>>=
let outcode_seq (seq : Ast.cmd_sequence) eflag (emit,set,idx) : unit =

  let rec xseq (seq : Ast.cmd_sequence) eflag : unit =
   (* less set iflast, for if not syntax error checking *)
    seq |> List.iter (fun x -> xcmd x eflag)
  
  and xcmd (cmd : Ast.cmd) eflag : unit =
    match cmd with
    <<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>
    | (A.Async _|
       A.Dup (_, _, _, _)|
       A.While (_, _)|
       A.ForIn (_, _, _)|
       A.For (_, _)
       )
       -> failwith ("TODO compile: " ^ Dumper_.s_of_cmd cmd)

 (* Do we need to pass eflag here too?
  * Even though types are mutually recursive because of Backquote, the
  * compilation of backquote does not use eflag!
  *)
  and xword (w : Ast.word) : unit =
    match w with
    <<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>
    | (A.CommandOutput _|
       A.Index (_, _)|
       A.Concat (_, _)|
       A.Stringify _
      )
       -> failwith ("TODO compile: " ^ Dumper_.s_of_value w)

  and xwords (ws : Ast.word list) : unit =
    ws |> List.rev |> List.iter (fun w -> xword w);
    
  in
  xseq seq eflag
@

\subsection{XXX1}


<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Word (s, _quoted) ->
    emit (O.F O.Word);
    emit (O.S s);
@

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.List ws ->
    xwords ws
@

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Dollar w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Dollar);
@

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Count w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Count);
@


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.EmptyCommand -> ()
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Compound seq -> xseq seq eflag
@


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Assign (val1, val2, cmd) ->
    let all_assigns, cmd = 
      split_at_non_assign (A.Assign (val1, val2, cmd)) in
    (match cmd with
    (* A=b; *)
    | A.EmptyCommand -> 
        all_assigns |> List.iter (fun (val1, val2) ->
          emit (O.F O.Mark);
          xword val2;
          emit (O.F O.Mark);
          xword val1;
          emit (O.F O.Assign);
        )

    (* A=b cmd; *)
    | _ -> 
        all_assigns |> List.iter (fun (val1, val2) ->
          emit (O.F O.Mark);
          xword val2;
          emit (O.F O.Mark);
          xword val1;
          emit (O.F O.Local);
        );
        xcmd cmd eflag;
        all_assigns |> List.iter (fun (_, _) ->
          emit (O.F O.Unlocal);
        )
    )
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Pipe (cmd1, cmd2) ->
    emit (O.F O.Pipe);
    emit (O.I 1); (* left fd *)
    emit (O.I 0); (* right fd *)

    let p = !idx in
    emit (O.I 0);
    let q = !idx in
    emit (O.I 0);

    (* will be executed in a forked child, hence Exit *)
    xcmd cmd1 eflag;
    emit (O.F O.Exit);

    (* will be executed in a children thread, hence Return *)
    set p (O.I !idx);
    xcmd cmd2 eflag;
    emit (O.F O.Return);

    (* will be executed by parent once the children thread finished *)
    set q (O.I !idx);
    emit (O.F O.PipeWait);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Redir (cmd, (redir_kind, word)) ->
    (* resolve the filename *)
    emit (O.F O.Mark);
    xword word;
    emit (O.F O.Glob);

    (match redir_kind with
    | A.RWrite ->
        emit (O.F O.Write);
        emit (O.I 1);
    (* less: and A.RHere *)
    | A.RRead -> 
        emit (O.F O.Read);
        emit (O.I 0);
    | A.RAppend -> 
        emit (O.F O.Append);
        emit (O.I 1);
    | _ -> failwith ("TODO compile: " ^ Dumper_.s_of_cmd cmd)
    );
    
    (* perform the command *)
    xcmd cmd eflag;
    emit (O.F O.Popredir);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.If (cmds, cmd) ->
    xseq cmds false;
    emit (O.F O.If);
    let p = !idx in
    emit (O.I 0);
    xcmd cmd eflag;
    emit (O.F O.Wastrue);
    set p (O.I !idx);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.IfNot cmd ->
    emit (O.F O.IfNot);
    let p = !idx in
    emit (O.I 0);
    xcmd cmd eflag;
    set p (O.I !idx);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Match (w, ws) ->
    emit (O.F O.Mark);
    xwords ws;
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Match);
    if eflag 
    then emit (O.F O.Eflag);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Switch (w, cmds) ->

    (match cmds with
    | (A.Simple (A.Word ("case", false), _))::_ -> ()
    | _ -> failwith "case missing in switch"
    );

    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Jump);

    let nextcase = !idx in
    emit (O.I 0);
    let out = !idx in
    emit (O.F O.Jump);
    let leave = !idx in
    emit (O.I 0);
    
    set nextcase (O.I !idx);

    let aux cmds =
      match cmds with
      | [] -> ()
      | (A.Simple (A.Word ("case", false), ws))::cmds ->
          emit (O.F O.Mark);
          xwords ws;
          emit (O.F O.Case);
          let nextcase = !idx in
          emit (O.I 0);

          let cmds_for_this_case, _other_cases = split_when_case cmds in
          cmds_for_this_case |> List.iter (fun cmd ->
            xcmd cmd eflag
          );
          emit (O.F O.Jump);
          emit (O.I out);
          set nextcase (O.I !idx);
      | _ -> failwith "case missing in switch"
    in
    aux cmds;
    set leave (O.I !idx);
    (* can not call pop_list(), here, otherwise circular deps *)
    emit (O.F O.Popm);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Fn (w, cmds) ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Fn);
    let p = !idx in
    (* less: emit str of fn *)
    emit (O.S "Fn String Todo?");
    xseq cmds eflag;
    emit (O.F O.Unlocal);
    emit (O.F O.Return);
    set p (O.I !idx);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.DelFn w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.DelFn);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Not cmd ->
    xcmd cmd eflag;
    emit (O.F O.Not);
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.And (cmd1, cmd2) ->
    xcmd cmd1 false;
    emit (O.F O.True);
    let p = !idx in
    xcmd cmd2 eflag;
    set p (O.I !idx)
@

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Or (cmd1, cmd2) ->
    xcmd cmd1 false;
    emit (O.F O.False);
    let p = !idx in
    xcmd cmd2 eflag;
    set p (O.I !idx)
@

\subsection{XXX2}



<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Exit -> 
    (* todo: trapreq *)
    Process.exit caps (Status.getstatus())
@
<<function [[Process.exit]]>>=
let exit (caps: < Cap.exit; ..>) s =
  (* todo: Updenv *)
  Status.setstatus s;
  (* todo: how communicate error to parent process under Unix? 
   * alt: raise Exit.ExitCode which removes the need for Cap.exit
   *)
  CapStdlib.exit caps (if Status.truestatus () then 0 else 1)
@


<<signature [[Process.exit]]>>=
val exit : < Cap.exit ; .. > -> string -> unit
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Mark -> R.push_list ()
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [string] *)
| O.Word ->
    let t = R.cur () in
    let pc = t.R.pc in
    let x = t.R.code.(!pc) in
    incr pc;
    (match x with
    | O.S s -> R.push_word s
    (* stricter: but should never happen *)
    | op -> failwith (spf "was expecting a S, not %s" (Dumper_.s_of_opcode op))
    )
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) (val) *)
| O.Assign ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] ->
        (* no call to globlist for varname as it can be "*" for $* *)
        (* less: deglob varname *)
        let v = Var.vlook varname in
        R.pop_list ();

        (* less: globlist for the arguments *)
        let argv = t.R.argv in
        v.R.v <- Some argv;
        R.pop_list ();

    | _ -> E.error caps "variable name not singleton!"
    )
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) (val) *)
| O.Local ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] ->
      (* less: deglob varname *)
      R.pop_list ();
      (* less: globlist *)
      let argv = t.R.argv in
      Hashtbl.add t.R.locals varname { R.v = Some argv };
      R.pop_list ();
    | _ -> E.error caps "variable name not singleton!"
    )
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [i j]{... Xreturn}{... Xreturn} *)
| O.Pipe -> 
    let t = R.cur () in
    let pc = t.R.pc in
    (* left file descriptor, should be stdout *)
    let lfd =
      let i = int_at_address t !pc in
      file_descr_of_int i
    in
    incr pc;
    (* right file descriptor, should be stdin *)
    let rfd =
      let i = int_at_address t !pc in
      file_descr_of_int i
    in
    incr pc;

    let (pipe_read, pipe_write) = Unix.pipe () in
    let forkid = CapUnix.fork caps () in

    (* child *)
    if forkid = 0 then begin
      (* less: clearwaitpids () *)
      (* pc + 2 to jump over the jump addresses *)
      let newt = R.mk_thread t.R.code (!pc + 2) t.R.locals in
      R.runq := [newt];
      Unix.close pipe_read;
      R.push_redir (R.FromTo (pipe_write, lfd));
    (* parent *)
    end else begin
      (* less: addwaitpid () *)
      let newt = 
        R.mk_thread t.R.code (int_at_address t (!pc+0)) t.R.locals in
      R.runq := newt::!R.runq;
      Unix.close pipe_write;
      R.push_redir (R.FromTo (pipe_read, rfd));
    
     (* once newt finished, jump to Xpipewait *)
      pc := int_at_address t (!pc+1);
      t.R.waitstatus <- R.WaitFor forkid;
    end
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* argument passed through Thread.pid *)
| O.PipeWait -> 
    let t = R.cur () in
    (match t.R.waitstatus with
    (* stricter: *)
    | R.NothingToWaitfor -> 
        failwith "Impossible: NothingToWaitfor for PipeWait"
    (* a previous waitfor() already got it *)
    | R.ChildStatus status -> 
        Status.setstatus (Status.concstatus status (Status.getstatus()));
    | R.WaitFor pid ->
        let status = Status.getstatus () in
        (* will internally call setstatus() when it found the right child *)
        Process.waitfor pid |> ignore;
        t.R.waitstatus <- R.NothingToWaitfor;
        Status.setstatus (Status.concstatus (Status.getstatus()) status);
    )
@


<<signature [[Process.waitfor]]>>=
val waitfor : int -> waitfor_result
@




<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (value?) *)
| O.Glob ->
    Logs.err (fun m -> m "TODO: interpret Glob");
    ()
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (file)[fd] *)
| O.Write ->
    let t = R.cur () in
    let argv = t.R.argv in
    let pc = t.R.pc in
    (match argv with
    | []       -> E.error caps "> requires file"
    | _x::_y::_xs -> E.error caps "> requires singleton"
    | [file] ->
        (try 
          let fd_from = 
            Unix.openfile file [Unix.O_CREAT;Unix.O_WRONLY] 0o666 in
          (* should be stdout *)
          let fd_to =
            let i = int_at_address t !pc in
            file_descr_of_int i
          in
          R.push_redir (R.FromTo (fd_from, fd_to));
          incr pc;
          R.pop_list();
        with Unix.Unix_error (_err, _s1, _s2) ->
          prerr_string (spf "%s: " file);
          E.error caps "can't open"
        )
            
    )
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Popredir ->
    R.pop_redir ()
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.Dollar ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] -> 
       (* less: deglob varname *)
       (try 
          let value = vlook_varname_or_index varname in
          R.pop_list ();
          let argv = t.R.argv in
          let newargv = 
            (match value with None -> [] | Some xs -> xs) @ argv in
          t.R.argv <- newargv
        with Failure s -> E.error caps s
       )             
    | _ -> E.error caps "variable name not singleton!"
    )
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.Count ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] -> 
        (* less: deglob *)
        let value = vlook_varname_or_index varname in
        let num = 
          match value with
          | None -> 0
          | Some xs -> List.length xs
        in
        R.pop_list ();
        R.push_word (spf "%d" num)
    | _ -> E.error caps "variable name not singleton!"
    )
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (pat, str) *)
| O.Match ->
    let t = R.cur () in
    let argv = t.R.argv in
    let subject = String.concat " " argv in
    Status.setstatus "no match";
    R.pop_list ();
    let argv = t.R.argv in
    argv |> List.exists (fun w -> 
      if Pattern.match_str subject w
      then begin
        Status.setstatus "";
        true
      end else false
    ) |> ignore;
    R.pop_list ();
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.If ->
    let t = R.cur () in
    let pc = t.R.pc in

    Globals.ifnot := true;
    if Status.truestatus()
    then incr pc
    else pc := int_at_address t (!pc);
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Wastrue ->
    Globals.ifnot := false
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.IfNot ->
    let t = R.cur () in
    let pc = t.R.pc in
    if !Globals.ifnot
    then incr pc
    else pc := int_at_address t (!pc);
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [addr] *)
| O.Jump ->
    let t = R.cur () in
    let pc = t.R.pc in
    pc := int_at_address t (!pc);
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (pat, value){...} *)
| O.Case ->
    let t = R.cur () in
    let pc = t.R.pc in
    let s = List.hd t.R.argv_stack |> String.concat " " in
    let argv = t.R.argv in
    let match_found = argv |> List.exists (fun w -> Pattern.match_str s w) in
    (if match_found
    then incr pc
    else pc := int_at_address t (!pc)
    );
    R.pop_list ();
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (value) *)
| O.Popm ->
    R.pop_list ()
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.DelFn ->
    let t = R.cur () in
    let argv = t.R.argv in
    argv |> List.iter (fun s ->
      let x = Fn.flook s in
      match x with
      | Some _ -> Hashtbl.remove R.fns s
      | None -> 
          (* stricter: *)
          if !Flags.strict_mode
          then E.error caps (spf "deleting undefined function %s" s)
    );
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Not ->
    Status.setstatus (if Status.truestatus() then "false" else "");
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.True ->
    let t = R.cur () in
    let pc = t.R.pc in
    if Status.truestatus ()
    then incr pc
    else pc := int_at_address t (!pc)
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.False ->
    let t = R.cur () in
    let pc = t.R.pc in
    if Status.truestatus ()
    then pc := int_at_address t (!pc)
    else incr pc
@


\subsection{[[argv]] management}

\subsection{Process status management}

<<signature [[Status.setstatus]]>>=
val setstatus : string -> unit
@

<<signature [[Status.getstatus]]>>=
val getstatus : unit -> string
@

<<signature [[Status.concstatus]]>>=
val concstatus : string -> string -> string
@

<<signature [[Status.truestatus]]>>=
val truestatus : unit -> bool
@




<<function [[Status.setstatus]]>>=
let setstatus s =
  Var.setvar "status" [s]
@

<<function [[Status.getstatus]]>>=
let getstatus () =
  let v = (Var.vlook "status").R.v in
  match v with
  | None -> ""
  | Some [x] -> x
  (* stricter: should never happen *)
  | Some _ -> failwith "getstatus: $status is a list with more than one element"
@
%$

<<function [[Status.concstatus]]>>=
let concstatus s1 s2 =
  s1 ^ "|" ^ s2
@

<<function [[Status.truestatus]]>>=
let truestatus () =
  let s = getstatus () in
  s = "" || s =~ "0+\\(|0+\\)*"
@




\subsection{Subprocesses management}




\section{Simple commands}


\subsection{Bytecode generation}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Simple (w, ws) -> 
    emit (O.F O.Mark);
    xwords ws;
    xword w;
    emit (O.F O.Simple);
    <<[[Compile.outcode_seq]] in [[A.Simple]] case after emit [[O.Simple]]>>
@
% need Mark so know when finish args

\subsection{[[O.Simple]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (args) *)
| O.Simple -> Op_process.op_Simple caps ()
@


<<function [[Op_process.op_Simple]]>>=
let op_Simple (caps : < Cap.fork; Cap.exec; Cap.chdir; Cap.exit; ..>) () =
  let t = R.cur () in
  let argv = t.R.argv in

  (* less: globlist () *)
  if !Flags.xflag 
  then Logs.app (fun m -> m "%s" (String.concat " " argv));

  match argv with
  (* How can you get an empty list as Simple has at least one word?
   * If you do A=()\n and then $A\n then Simple has a word, but after
   * expansion the list becomes empty.
   * stricter: I give extra explanations
   *)
  | [] -> E.error caps "empty argument list (after variable expansion)" 

  | argv0::args ->
      match argv0 with
      (* todo: if argv0 is a function *)
      | "builtin" -> 
          (match args with
          | [] ->
              Logs.err (fun m -> m "builtin: empty argument list");
              Status.setstatus "empty arg list";
              R.pop_list ()
          | argv0::_args ->
              R.pop_word ();
              Builtin.dispatch caps argv0
          )
      | s when Builtin.is_builtin s -> Builtin.dispatch caps argv0
      | _ ->
        (* if exitnext opti *)
        flush stderr;
        (* less: Updenv *)
        (try 
          let pid = forkexec caps () in
          R.pop_list ();
          (* do again even if was interrupted *)
          while Process.waitfor pid = Process.WaitforInterrupted do
            ()
          done
        with
          | Failure s ->
              E.error caps ("try again: " ^ s)
          | Unix.Unix_error (err, s1, s2) -> 
              E.error caps (Process.s_of_unix_error err s1 s2)
)
@
%$

<<signature [[Process.s_of_unix_error]]>>=
val s_of_unix_error : Unix.error -> string -> string -> string
@
<<function [[Process.s_of_unix_error]]>>=
let s_of_unix_error err _s1 _s2 = 
  spf "%s" (Unix.error_message err)
@



<<signature [[Builtin.is_builtin]]>>=
val is_builtin : string -> bool
@

<<signature [[Builtin.dispatch]]>>=
(* execute the builtin *)
val dispatch : < Cap.chdir ; Cap.exit ; Cap.open_in; .. > -> string -> unit
@

\subsection{Fork}

<<function [[Op_process.forkexec]]>>=
let forkexec (caps : < Cap.fork; Cap.exec; Cap.exit; .. >) () =
  let pid = CapUnix.fork caps () in
  (* child *)
  if pid = 0
  then begin
    (* less: clearwaitpids *)
    (* less: could simplify and remove this word if exec was not a builtin *)
    R.push_word "exec";
    exec caps ();
    (* should not be reached, unless prog could not be executed *)
    Process.exit caps ("can't exec: " ^ !Globals.errstr);
    0
  end
  else 
    (* less: addwaitpid *)
    pid
@

\subsection{Exec}

<<function [[Op_process.execute]]>>=
let execute (caps : <Cap.exec; ..>) args path =

  let argv = Array.of_list args in
  let errstr = ref "" in

  (* less: Updenv () *)
  path |> List.iter (fun root ->
    let path = (if root = "" then "" else root ^ "/") ^ argv.(0) in
    try 
      CapUnix.execv caps path argv |> ignore
    with Unix.Unix_error (err, s1, s2) ->
     errstr := Process.s_of_unix_error err s1 s2;
     Globals.errstr := s2
  );
  (* reached only when could not find a path *)
  Logs.err (fun m -> m "%s: %s" argv.(0) !errstr)
@

<<function [[Op_process.exec]]>>=
let exec (caps : < Cap.exec; Cap.exit; .. >) () =
  R.pop_word (); (* "exec" *)

  let t = R.cur () in
  let argv = t.R.argv in

  match argv with
  | [] -> E.error caps "empty argument list" 
  | prog::_xs -> 
      R.doredir t.R.redirections;
      execute caps argv (PATH.search_path_for_cmd prog);
      (* should not be reached, unless prog could not be executed *)
      R.pop_list ()
@


\subsection{[[$path]] management}

<<signature [[PATH.find_in_path]]>>=
val find_in_path :
  string (* cmd *) -> string list (* $path *) -> Common.filename
@
%$

<<signature [[PATH.search_path_for_cmd]]>>=
val search_path_for_cmd : string (* cmd *) -> string list (* $path *)
@
%$

<<function [[PATH.search_path_for_cmd]]>>=
let search_path_for_cmd s =
  let nullpath = [""] in

  if s =~ "^/" ||
     (* Plan 9 device paths *)
     s =~ "^#" || 
     s =~ "\\./" ||
     s =~ "\\.\\./"
  then nullpath
  else
    let v = (Var.vlook "path").R.v in
    (match v with
    | None -> nullpath
    | Some xs -> xs
    )
@

<<function [[PATH.find_in_path]]>>=
let find_in_path _s _paths =
  raise Todo
@



\subsection{Wait}

<<signature [[Process.waitfor]]>>=
val waitfor : int -> waitfor_result
@


<<type [[Runtime.waitstatus]]>>=
  and waitstatus =
    | NothingToWaitfor
    (* process pid to wait for in Xpipewait (set from Xpipe) *)
    | WaitFor of int 
    (* exit status from child process returned from a wait() *)
    | ChildStatus of string
@

<<type [[Process.waitfor_result]]>>=
type waitfor_result =
  | WaitforInterrupted
  | WaitforFound
  | WaitforNotfound
@

<<function [[Process.waitfor]]>>=
let waitfor pid =
  (* less: check for havewaitpid *)

  try 
    let rec loop () =
      let (pid2, status) = Unix.wait () in
      let status_str = 
        match status with
        | Unix.WEXITED i -> spf "%d" i
        | Unix.WSIGNALED i -> spf "signaled %d" i
        | Unix.WSTOPPED i -> spf "stopped %d" i
      in
      if pid = pid2
      then begin
        Status.setstatus status_str;
        WaitforFound
      end else begin
        !R.runq |> List.iter (fun t ->
          match t.R.waitstatus with
          | R.WaitFor pid ->
              if pid = pid2
              then t.R.waitstatus <- R.ChildStatus status_str;
          | R.ChildStatus _ | R.NothingToWaitfor -> ()
        );
        loop ()
      end
    in
    loop ()
  with Unix.Unix_error (err, s1, s2) ->
    Globals.errstr := s_of_unix_error err s1 s2;
    if err = Unix.EINTR
    then WaitforInterrupted
    else WaitforNotfound
@



\subsection{Fork optimization}



\section{Operators}


\subsection{Basic sequence}


\subsection{Logical operators}


\subsection{String matching}


\subsection{Redirection}

<<signature [[Runtime.push_redir]]>>=
val push_redir : redir -> unit
@

<<signature [[Runtime.pop_redir]]>>=
val pop_redir : unit -> unit
@

<<signature [[Runtime.turf_redir]]>>=
val turf_redir : unit -> unit
@

<<signature [[Runtime.doredir]]>>=
val doredir : redir list list -> unit
@




<<type [[Runtime.redir]]>>=
  and redir =
    (* the file descriptor From becomes To, e.g., /tmp/foo becomes stdout,
     * which means your process output will now go in /tmp/foo.
     *)
    | FromTo of Unix.file_descr (* from *) * Unix.file_descr (* to *)
    | Close of Unix.file_descr
@




<<function [[Runtime.push_redir]]>>=
let push_redir x =
  let t = cur () in
  match t.redirections with
  | [] -> failwith "push_redir: no starting redir"
  | xs::xxs -> t.redirections <- (x::xs)::xxs
@

<<function [[Runtime.pop_redir]]>>=
let pop_redir () =
  let t= cur () in
  match t.redirections with
  | [] -> failwith "pop_redir: no starting redir"
  | []::_xxs -> failwith "popredir null!"
  | (x::xs)::xxs ->
      t.redirections <- xs::xxs;
      (match x with
      | FromTo (fd_from, _fd_to) ->
          Unix.close fd_from
      | Close _ ->
          ()
      )
@

<<function [[Runtime.turf_redir]]>>=
let turf_redir () =
  let t = cur () in
  while List.hd t.redirections <> [] do
    pop_redir ()
  done
@

<<function [[Runtime.doredir]]>>=
let doredir xxs =
  xxs |> List.flatten |> List.rev |> List.iter (fun redir ->
    match redir with
    | FromTo (xfrom, xto) ->
        Unix.dup2 xfrom xto;
        Unix.close xfrom
    | Close from ->
        Unix.close from
  )
@


%\subsection{Trace of a redirection}

\subsubsection{[[Redir]]}

\subsubsection{[[doredir()]]}

\subsubsection{Bytecode generation}

\subsubsection{[[Xwrite()]]}

\subsubsection{[[Xread()]]}

\subsubsection{[[Xappend()]]}

\subsubsection{Closing redirection opened files}



\subsection{Pipe}

%\subsubsection{Trace of a pipe}

\subsection{Asynchronous execution}




\section{Control flow statements}

\subsection{[[if]]}

\subsection{[[while]]}

\subsection{[[for]]}

\subsection{[[switch]]}

\subsection{Blocks: \texttt{'\{...\}'}}



\section{Functions}

\subsection{Function definitions ([[fn <foo> { ... }]])}

\subsection{Function uses ([[<foo>(...)]])}




\section{Variables}

\subsection{Variable definitions ([[<x>=...]])}

\subsection{Variable uses ([[$<x>]])} %$

%\subsection{Interpolation}

\subsection{Special variables}






\chapter{Builtins}

\section{Overview}

<<function [[Builtin.is_builtin]]>>=
let is_builtin s =
  List.mem s [
    "cd"; 
    "."; "eval"; 
    "exit";
    "flag";
    "finit"
  ]
@

% ??? -> <>
<<function [[Builtin.dispatch]]>>=
let dispatch (caps : < Cap.chdir; Cap.exit; Cap.open_in; ..>) s =
  match s with
  | "cd" -> 
      let t = R.cur () in
      let argv = t.R.argv in
      (* default value in case something goes wrong below *)
      Status.setstatus "can't cd";

      (* less: cdpath vlook *)
      (match argv with
      | [_cd] -> 
          let v = (Var.vlook "home").R.v in
          (match v with
          | Some (dir::_) ->
            if dochdir caps dir
            then Status.setstatus ""
            (* less: %r *)
            else Logs.err (fun m -> m "Can't cd %s" dir)
          | _ -> Logs.err (fun m -> m "Can't cd -- $home empty")
          )
      | [_cd;dir] ->
          (* less: cdpath iteration *)
          if dochdir caps dir
          then Status.setstatus ""
          else Logs.err (fun m -> m "Can't cd %s" dir)
      | _ ->
          Logs.err (fun m -> m "Usage: cd [directory]");
      );
      R.pop_list()

  | "." ->
      let t = R.cur () in
      R.pop_word (); (* "." *)

      if !ndots > 0
      then Globals.eflagok := true;
      incr ndots;

      let iflag =
        match t.R.argv with
        | "-i"::_xs -> R.pop_word (); true
        | _ -> false
      in
      (match t.R.argv with
      | [] -> E.error caps "Usage: . [-i] file [arg ...]"
      | zero::args ->
          R.pop_word ();
          (* less: searchpath, also for dot? seems wrong *)
          (try 
            let file = zero in
            Logs.info (fun m -> m "evaluating %s" file);
            let chan = CapStdlib.open_in caps file in
            let newt = R.mk_thread dotcmds 0 (Hashtbl.create 10) in
            R.runq := [newt];
            R.push_redir (R.Close (Unix.descr_of_in_channel chan));
            newt.R.file <- Some file;
            newt.R.lexbuf <- Lexing.from_channel chan;
            newt.R.iflag <- iflag;
            (* push for $* *)
            R.push_list ();
            newt.R.argv <- args;
            (* push for $0 *)
            R.push_list ();
            newt.R.argv <- [zero];

          with Failure _ ->
            prerr_string (spf "%s: " zero);
            E.error caps ".: can't open"
          )
      ) 

  | "flag" -> 
      let t = R.cur () in
      let argv = t.R.argv in
      (match argv with
      | [_flag;letter] ->
          (* stricter: *)
          if String.length letter <> 1
          then E.error caps "flag argument must be a single letter"
          else begin
            let char = String.get letter 0 in
            let is_set =
              try Hashtbl.find Flags.hflags char
              with Not_found -> false
            in
            Status.setstatus (if is_set then "" else "flag not set");
          end

      | [_flag;_letter;_set] ->
          failwith "TODO: flag letter +- not handled yet"

      | _ -> E.error caps ("Usage: flag [letter] [+-]")
      );
      R.pop_list()

  | "finit" -> 
     (* less: Xrdfn *)
     R.pop_list ()

  | _ -> failwith (spf "unsupported builtin %s" s)
@
%$


\section{[[$ cd]]}

<<function [[Builtin.dochdir]]>>=
let dochdir (caps : < Cap.chdir; .. >) s =
  try 
    Logs.info (fun m -> m "about to chdir to %s" s);
    CapUnix.chdir caps s;
    true
  with Unix.Unix_error _ ->
    false
@

\section{[[$ exit]]}

\section{[[$ .]]}

<<constant [[Builtin.ndots]]>>=
let ndots = ref 0
@


<<constant [[Builtin.dotcmds]]>>=
(* for the builtin '.' (called 'source' in bash) *)
let dotcmds = 
  [|
    O.F O.Mark;
      O.F O.Word;
      O.S "0";
    O.F O.Local;

    O.F O.Mark;
      O.F O.Word;
      O.S "*";
    O.F O.Local;

    O.F O.REPL;

    O.F O.Unlocal;
    O.F O.Unlocal;
    O.F O.Return;
  |]         
@


\section{[[$ eval]]}

\section{[[$ wait]]}



\chapter{Environment}


\section{[[Updenv()]]}

\section{[[Vinit()]]}

%\section{Functions in the environment}



\chapter{Signals}









\chapter{Initialization}



\section{Actual bootstrapping code}

<<function [[CLI.bootstrap]]>>=
(* The real one is more complex:
 *  *=(argv);. /usr/lib/rcmain $*
 * Boostrap is now a function because it uses a flag that can be
 * modified after startup.
 *)
let bootstrap () : O.opcode array = 
  [| 
      O.F O.Mark;
        O.F O.Word;
        O.S "*";
      O.F O.Assign; (* will pop_list twice *)

      O.F O.Mark;
        O.F O.Mark;
          O.F O.Word;
          O.S "*";
        O.F O.Dollar; (* will pop_list once *)
        O.F O.Word;
        O.S !Flags.rcmain; (* can be changed -m *)
        O.F O.Word;
        O.S ".";
      O.F O.Simple; (* will pop_list once *)

      O.F O.Exit;
  |]
@
%$

\section{Intitialization script and [[rc -m /path/to/rcmain]]}

<<constant [[Flags.rcmain]]>>=
(* can be changed with -m *)
let rcmain = ref "/rc/lib/rcmain"
@

<<[[CLI.main()]] [[options]] elements>>=
"-m", Arg.Set_string Flags.rcmain,
" <file> read commands to initialize rc from file, not /rc/lib/rcmain";
@


\section{Actual environment}




\chapter{Globbing}

\section{Lexing globbing characters}

\section{Expanding globbing characters}

\section{[[glob()]]}

\section{[[match()]]}







\chapter{Advanced Topics TODO}
%\section{Shell-like features implemented outside [[rc]]}


\section{Reading commands from a string: [[rc -c]]}



\section{Failing fast: [[rc -e]]}
% very important, especially when using rc with mk!

<<constant [[Flags.eflag]]>>=
(* -e, for strict error checking. Abort the script when an error happens.*)
let eflag = ref false
@
% passed down a lot in outcode (why not use Flags.eflag instead
% of passing it down?)

<<[[CLI.main()]] [[options]] elements>>=
"-e", Arg.Set Flags.eflag,
" exit if $status is non-null after a simple command";
@



<<[[Opcode.operation]] other cases>>=
(* Error management *)
| Eflag
@

<<[[Compile.outcode_seq]] in [[A.Simple]] case after emit [[O.Simple]]>>=
if eflag 
then emit (O.F O.Eflag);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Eflag ->
    if !Globals.eflagok && not (Status.truestatus())
    then Process.exit caps (Status.getstatus())
@



\section{Strict mode: [[rc -strict]]}

<<constant [[Flags.strict_mode]]>>=
let strict_mode = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-strict", Arg.Set Flags.strict_mode,
" strict mode";
@


\section{Unicode}




\section{Advanced constructs}

\subsection{Subshell: [[@ <cmd>]]}

\subsection{Here documents: [[<< <HERE>]]}

\subsection{Read-write redirections: [[<> <file>]]}

\subsection{General redirections: [[>[2] <file>]]}

\subsection{Advanced dup: [[>[<fd0>=<fd1>]] ], [[<>[<fd0>=<fd1>] ]], [[<[<fd0>=<fd1>] ]]}

\subsection{Advanced pipes: [[|[<fd>] ]], [[|[<fd0>=<fd1>] ]]}

\subsection{Command output as a file: \texttt{'<\{<cmd>\}'}}

\subsection{Command substitution: \texttt{`\{<cmd>\}}}

\subsection{Stringification of variables: [[$"<foo>]]} %$


\section{Advanced builtins}

\subsection{[[$ exec]]}

\subsection{[[$ whatis]]}

\subsection{[[$ rfork]]}

\subsection{[[$ flag]]}
% put earlier? used heavily in rcmain

<<global [[Flags.hflags]]>>=
let hflags: (char, bool) Hashtbl.t = Hashtbl.create 10
@

<<[[CLI.main()]] other initializations>>=
(* for 'flags' builtin (see builtin.ml) *)
argv |> Array.iter (fun s ->
  if s =~ "^-\\([a-zA-Z]\\)"
  then begin
    let letter = Regexp_.matched1 s in
    let char = String.get letter 0 in
    Hashtbl.add Flags.hflags char true
  end
);
@

\subsection{[[$ shift]]}

\subsection{[[$ finit]]}




\chapter{Conclusion}
\label{chap:conclusion}







\appendix





\chapter{Debugging}

<<constant [[Flags.debugger]]>>=
let debugger = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
"-debugger", Arg.Set Flags.debugger,
" ";
@

<<[[CLI.main()]] when [[exn]] thrown in [[interpret()]]>>=
if !Flags.debugger
then raise exn
else 
  (match exn with
  <<[[CLI.main()]] when [[Failure]] [[exn]] thrown in [[interpret()]]>>
  (* alt: could catch Exit.ExitCode here but this is done in Main.ml *)
  | _ -> raise exn
  )
@

\section{Logging}

<<[[CLI.main()]] debugging initializations>>=
let level = ref (Some Logs.Warning) in
@

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
(* TODO: move in a CLI_common.ml *)
"-v", Arg.Unit (fun () -> level := Some Logs.Info),
 " verbose mode";
"-verbose", Arg.Unit (fun () -> level := Some Logs.Info),
" verbose mode";
"-quiet", Arg.Unit (fun () -> level := None),
" ";
"-debug", Arg.Unit (fun () -> level := Some Logs.Debug),
" trace the main functions";
@

<<[[CLI.main()]] logging initializations>>=
Logs.set_level !level;
Logs.info (fun m -> m "ran as %s from %s" argv.(0) (Sys.getcwd ()));
@

\section{AST dumper}

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-dump_tokens", Arg.Set Flags.dump_tokens,
" dump the tokens as they are generated";
"-dump_ast", Arg.Set Flags.dump_ast,
" dump the parsed AST";
"-dump_opcodes", Arg.Set Flags.dump_opcodes,
" dump the generated opcodes ";
@

<<signature [[Dumper_.s_of_cmd]]>>=
val s_of_cmd : Ast.cmd -> string
@

<<signature [[Dumper_.s_of_opcode]]>>=
val s_of_opcode : Opcode.opcode -> string
@

<<signature [[Dumper_.s_of_line]]>>=
val s_of_line : Ast.line -> string
@

<<signature [[Dumper_.s_of_cmd_sequence]]>>=
val s_of_cmd_sequence : Ast.cmd_sequence -> string
@

<<signature [[Dumper_.s_of_value]]>>=
val s_of_value : Ast.value -> string
@

<<signature [[Dumper_.s_of_codevec]]>>=
val s_of_codevec : Opcode.codevec -> string
@

<<signature [[Dumper_.s_of_operation]]>>=
val s_of_operation : Opcode.operation -> string
@



<<constant [[Flags.dump_tokens]]>>=
let dump_tokens = ref false
@

<<constant [[Flags.dump_ast]]>>=
let dump_ast = ref false
@

<<constant [[Flags.dump_opcodes]]>>=
let dump_opcodes = ref false
@

<<[[Compile.compile()]] possibly dump returned opcodes>>=
|> (fun x -> if !Flags.dump_opcodes then Logs.app (fun m -> m "%s" (Dumper_.s_of_codevec x)); x)
@
<<function [[Dumper_.s_of_line]]>>=
let s_of_line x =
  let v = Meta_ast.vof_line x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_cmd_sequence]]>>=
let s_of_cmd_sequence x =
  let v = Meta_ast.vof_cmd_sequence x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_cmd]]>>=
let s_of_cmd x =
  let v = Meta_ast.vof_cmd x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_value]]>>=
let s_of_value x =
  let v = Meta_ast.vof_value x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_opcode]]>>=
let s_of_opcode x =
  let v = Meta_opcode.vof_opcode x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_operation]]>>=
let s_of_operation x =
  let v = Meta_opcode.vof_operation x in
  Ocaml.string_of_v v
@

<<function [[Dumper_.s_of_codevec]]>>=
let s_of_codevec x =
  let xs = Array.to_list x in
  let v = Ocaml.vof_list Meta_opcode.vof_opcode xs in
  Ocaml.string_of_v v
@


\section{Bytecode generator trace: [[rc -r]]}

<<constant [[Flags.rflag]]>>=
(* -r, similar to dump_opcodes, but at each step *)
let rflag = ref false
@


<<[[CLI.main()]] [[options]] elements>>=
"-r", Arg.Set Flags.rflag,
" print internal form of commands (opcodes)";
@

<<[[CLI.interpret()]] if [[rflag]]>>=
(* less: cycle =~ codevec pointer *)
if !Flags.rflag
then Logs.app (fun m -> m "pid %d %d %s %s"
            (Unix.getpid ())
            !pc
            (Dumper_.s_of_opcode t.R.code.(!pc))
            ( (t.R.argv::t.R.argv_stack) |> List.map (fun xs ->
                spf "(%s)" (String.concat " " xs)
               ) |> String.concat " "));
@

\section{Printing subprocesses status: [[rc -s]]}

<<constant [[Flags.sflag]]>>=
(* -s, to print status when error in command just ran *)
let sflag = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-s", Arg.Set Flags.sflag,
" print exit status after any command where the status is non-null";
@
<<[[Op_repl.op_REPL()]] if [[sflag]]>>=
(* todo: flush error and reset error count *)
if !Flags.sflag && not (Status.truestatus()) 
then Logs.app (fun m -> m "status=%s" (Status.getstatus ()));
@

\section{Printing commands: [[rc -x]]}

<<constant [[Flags.xflag]]>>=
(* -x, to print simple commands before executing them *)
let xflag = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-x", Arg.Set Flags.xflag,
" print each simple command before executing it";
@


\section{Printing characters: [[rc -v]]}


\section{Printing all characters: [[rc -V]]}





\section{CLI actions}

<<[[CLI.main()]] debugging initializations>>=
let action = ref "" in
@

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-test_parser", Arg.Unit (fun () -> action := "-test_parser"), " ";
@

<<[[CLI.main()]] CLI action processing>>=
(* to test and debug components of mk *)
if !action <> "" then begin 
  do_action caps !action (List.rev !args); 
  raise (Exit.ExitCode 0)
end;
@


<<function [[CLI.do_action]]>>=
let do_action caps s xs =
  match s with
  | "-test_parser" ->
      xs |> List.iter (fun file ->
        let file = Fpath.v file in
        Logs.info (fun m -> m "processing %s" !!file);
        file |> FS.with_open_in caps (fun (chan : Chan.i) ->
          let lexbuf = Lexing.from_channel chan.Chan.ic in

          (* for error reporting I need a runq *)
          let t = Runtime.mk_thread [||] 0 (Hashtbl.create 0) in
          R.runq := t::!R.runq;
          t.R.file <- Some !!file;

          let rec loop () =
            let line = Parse.parse_line lexbuf in
            match line with
            | Some seq -> 
              Logs.app (fun m -> m "%s" (Dumper_.s_of_cmd_sequence seq));
              loop ();
            | None -> ()
          in
          loop ()
       )
      )

  | _ -> failwith ("action not supported: " ^ s)
  (* old: do that in caller now, so more explicit 
  runq := t::!runq
  *)
@


\chapter{Error Management}

<<signature [[Error.error]]>>=
(* Will behave like a 'raise'. Will Return until you reach
 * the interactive thread and set the status to the error argument.
 * Mostly used by the builtins.
 *)
val error : < Cap.exit ; .. > -> string -> unit
@



<<function [[Error.error]]>>=
(* less: error1 similar to error but without %r *)
let error (caps: < Cap.exit; ..>) (s : string) =
  (* less: use argv0 *)
  (* less: use %r *)
  Logs.err (fun m -> m "rc: %s" s);

  Status.setstatus "error";

  while (R.cur ()).R.iflag do
    (* goes up the call stack, like when we have an exception *)
    Process.return caps ();
  done
@

<<constant [[Globals.errstr]]>>=
(* to mimic Plan 9 errstr() *)
let errstr = ref ""
@






\chapter{Examples of [[rc]] scripts TODO}

\section{[[/rc/lib/rcmain]]}


\section{[[/home/pad/lib/profile]]}





%\chapter{Changelog}
% code via make loc = ?? LOC, after full lpized  ? LOC
% orig Rc.nw = ?? LOC, after full lpized and comments in sections ??
% now: =~ ?? LOC so added ?? LOE (Lines of explanations)
% rc in C: ? LOC (but more features)

\chapter{Extra Code}

\section{[[shell/]]}

\subsection*{[[Ast.ml]]}

%-------------------------------------------------------------

<<Ast.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

<<type [[Ast.value]]>>
<<type [[Ast.values]]>>

<<type [[Ast.cmd]]>>
<<type [[Ast.cmd_sequence]]>>

(* todo: RDup does not have a filename? so push value inside RWrite of value*)
<<type [[Ast.redirection]]>>
<<type [[Ast.redirection_kind]]>>

<<type [[Ast.line]]>>

(* less: type any = Line of line | ... so easier dumper *)
@


\subsection*{[[Builtin.ml]]}

%-------------------------------------------------------------

<<Builtin.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

open Common

module R = Runtime
module E = Error
module O = Opcode

<<function [[Builtin.is_builtin]]>>
<<constant [[Builtin.ndots]]>>
<<function [[Builtin.dochdir]]>>
<<constant [[Builtin.dotcmds]]>>
<<function [[Builtin.dispatch]]>>

@


\subsection*{[[CLI.ml]]}

%-------------------------------------------------------------

<<CLI.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

open Common
open Fpath_.Operators

module R = Runtime
module O = Opcode

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of rc, the Plan 9 shell.
 *
 * Main limitations compared to rc:
 *  - no unicode support
 *  - not all of the fancy redirections and fancy pipes
 *  - no storing of functions in the environment
 *    (used by rcmain. But can do the same by using '. rcmain')
 * 
 * Improvements (IMHO):
 *  - a strict mode where we report when deleting undefined function
 *  - Logs with errors and warnings and debug
 *  - more?
 * 
 * todo:
 *  - read environment variables and export variables
 *  - globbing
 *  - Isatty rc -i detection
 *  - add ~ shortcut for HOME (from csh?)
 *  - rc -c
 *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

<<type [[CLI.caps]]>>

(* -d and -p are dead according to man page so I removed them *)
<<constant [[CLI.usage]]>>

(*****************************************************************************)
(* Testing *)
(*****************************************************************************)

<<function [[CLI.do_action]]>>

(*****************************************************************************)
(* Main algorithm *)
(*****************************************************************************)

<<constant [[CLI._bootstrap_simple]]>>
<<function [[CLI.bootstrap]]>>

<<function [[CLI.interpret_boostrap]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[CLI.main]]>>
@


\subsection*{[[Compile.ml]]}

%-------------------------------------------------------------

<<Compile.ml>>=
open Stdcompat (* for |> *)
open Common

module A = Ast
module O = Opcode

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* AST to opcodes.
*)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Compile.split_at_non_assign]]>>
<<function [[Compile.split_when_case]]>>

(*****************************************************************************)
(* Compilation algorithm *)
(*****************************************************************************)

<<function [[Compile.outcode_seq]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Compile.compile]]>>
@


\subsection*{[[Dumper_.ml]]}

%-------------------------------------------------------------

<<Dumper_.ml>>=
module Ocaml = OCaml
(* less: could use Any *)

<<function [[Dumper_.s_of_line]]>>
<<function [[Dumper_.s_of_cmd_sequence]]>>
<<function [[Dumper_.s_of_cmd]]>>
<<function [[Dumper_.s_of_value]]>>

<<function [[Dumper_.s_of_opcode]]>>
<<function [[Dumper_.s_of_operation]]>>
<<function [[Dumper_.s_of_codevec]]>>
  
@

\subsection*{[[Env.ml]]}

%-------------------------------------------------------------

<<Env.ml>>=
@

\subsection*{[[Error.ml]]}

%-------------------------------------------------------------

<<Error.ml>>=
module R = Runtime

<<function [[Error.error]]>>
@

\subsection*{[[Flags.ml]]}

%-------------------------------------------------------------

<<Flags.ml>>=

<<constant [[Flags.interactive]]>>
<<constant [[Flags.login]]>>

<<constant [[Flags.eflag]]>>
<<constant [[Flags.rflag]]>>
<<constant [[Flags.sflag]]>>
<<constant [[Flags.xflag]]>>

(* less: let cflag = ref "" *)

<<global [[Flags.hflags]]>>

<<constant [[Flags.rcmain]]>>

(* pad: I added this one *)
<<constant [[Flags.strict_mode]]>>

<<constant [[Flags.dump_tokens]]>>
<<constant [[Flags.dump_ast]]>>
<<constant [[Flags.dump_opcodes]]>>

<<constant [[Flags.debugger]]>>
@


\subsection*{[[Fn.ml]]}

<<signature [[Fn.flook]]>>=
val flook : string -> Runtime.fn option
@

<<function [[Fn.flook]]>>=
let flook s =
  try 
    Some (Hashtbl.find R.fns s)
  with Not_found -> None
@

%-------------------------------------------------------------

<<Fn.ml>>=
module R = Runtime

<<function [[Fn.flook]]>>

@

\subsection*{[[Glob.ml]]}

%-------------------------------------------------------------

<<Glob.ml>>=
@


\subsection*{[[Globals.ml]]}


<<constant [[Globals.ifnot]]>>=
(* Set to true at the beginning of an if and back to false
 * if rc executes the then branch. Kept to true otherwise
 * so next IfNot will run.
 *)
let ifnot = ref false
@

<<constant [[Globals.eflagok]]>>=
(* this is set after the first . of rcmain *)
let eflagok = ref false
@


%-------------------------------------------------------------

<<Globals.ml>>=

<<constant [[Globals.skipnl]]>>
<<constant [[Globals.errstr]]>>

<<constant [[Globals.ifnot]]>>
<<constant [[Globals.eflagok]]>>
@


\subsection*{[[Heredoc.ml]]}

%-------------------------------------------------------------

<<Heredoc.ml>>=
@


\subsection*{[[Interpreter.ml]]}

%-------------------------------------------------------------

<<Interpreter.ml>>=
open Stdcompat (* for |> *)
open Common

module O = Opcode
module R = Runtime
module E = Error

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Interpreter.file_descr_of_int]]>>
<<function [[Interpreter.int_at_address]]>>

<<function [[Interpreter.vlook_varname_or_index]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Interpreter.interpret_operation]]>>
@


\subsection*{[[Main.ml]]}

%-------------------------------------------------------------

<<Main.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Xix_shell

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<toplevel [[Main._1]]>>
@


\subsection*{[[Meta_ast.ml]]}

<<function [[Meta_ast.vof_line]]>>=
let vof_line v = Ocaml.vof_option vof_cmd_sequence v
@


%-------------------------------------------------------------

<<Meta_ast.ml>>=
(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Ast

module Ocaml = OCaml

let rec vof_value =
  function
  | Word ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_bool v2
      in Ocaml.VSum (("Word", [ v1; v2 ]))
  | List v1 -> let v1 = vof_values v1 in Ocaml.VSum (("List", [ v1 ]))
  | CommandOutput v1 ->
      let v1 = vof_cmd_sequence v1 in Ocaml.VSum (("CommandOutput", [ v1 ]))
  | Dollar v1 -> let v1 = vof_value v1 in Ocaml.VSum (("Dollar", [ v1 ]))
  | Count v1 -> let v1 = vof_value v1 in Ocaml.VSum (("Count", [ v1 ]))
  | Index ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Index", [ v1; v2 ]))
  | Concat ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_value v2
      in Ocaml.VSum (("Concat", [ v1; v2 ]))
  | Stringify v1 ->
      let v1 = vof_value v1 in Ocaml.VSum (("Stringify", [ v1 ]))
and vof_values v = Ocaml.vof_list vof_value v
and vof_cmd =
  function
  | EmptyCommand -> Ocaml.VSum (("EmptyCommand", []))
  | Simple ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Simple", [ v1; v2 ]))
  | Pipe ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("Pipe", [ v1; v2 ]))
  | Async v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("Async", [ v1 ]))
  | Redir ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_redirection v2
      in Ocaml.VSum (("Redir", [ v1; v2 ]))
  | Dup ((v1, v2, v3, v4)) ->
      let v1 = vof_cmd v1
      and v2 = vof_redirection_kind v2
      and v3 = Ocaml.vof_int v3
      and v4 = Ocaml.vof_int v4
      in Ocaml.VSum (("Dup", [ v1; v2; v3; v4 ]))
  | And ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("And", [ v1; v2 ]))
  | Or ((v1, v2)) ->
      let v1 = vof_cmd v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("Or", [ v1; v2 ]))
  | Not v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("Not", [ v1 ]))
  | Match ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      in Ocaml.VSum (("Match", [ v1; v2 ]))
  | If ((v1, v2)) ->
      let v1 = vof_cmd_sequence v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("If", [ v1; v2 ]))
  | IfNot v1 -> let v1 = vof_cmd v1 in Ocaml.VSum (("IfNot", [ v1 ]))
  | While ((v1, v2)) ->
      let v1 = vof_cmd_sequence v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("While", [ v1; v2 ]))
  | Switch ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd_sequence v2
      in Ocaml.VSum (("Switch", [ v1; v2 ]))
  | ForIn ((v1, v2, v3)) ->
      let v1 = vof_value v1
      and v2 = vof_values v2
      and v3 = vof_cmd v3
      in Ocaml.VSum (("ForIn", [ v1; v2; v3 ]))
  | For ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd v2
      in Ocaml.VSum (("For", [ v1; v2 ]))
  | Compound v1 ->
      let v1 = vof_cmd_sequence v1 in Ocaml.VSum (("Compound", [ v1 ]))
  | Fn ((v1, v2)) ->
      let v1 = vof_value v1
      and v2 = vof_cmd_sequence v2
      in Ocaml.VSum (("Fn", [ v1; v2 ]))
  | DelFn v1 -> let v1 = vof_value v1 in Ocaml.VSum (("DelFn", [ v1 ]))
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_value v1
      and v2 = vof_value v2
      and v3 = vof_cmd v3
      in Ocaml.VSum (("Assign", [ v1; v2; v3 ]))
and vof_cmd_sequence v = Ocaml.vof_list vof_cmd v
and vof_redirection (v1, v2) =
  let v1 = vof_redirection_kind v1
  and v2 = vof_value v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_redirection_kind =
  function
  | RWrite -> Ocaml.VSum (("RWrite", []))
  | RRead -> Ocaml.VSum (("RRead", []))
  | RAppend -> Ocaml.VSum (("RAppend", []))
  | RDup ((v1, v2)) ->
      let v1 = Ocaml.vof_int v1
      and v2 = Ocaml.vof_int v2
      in Ocaml.VSum (("RDup", [ v1; v2 ]))
  
<<function [[Meta_ast.vof_line]]>>
  

@


\subsection*{[[Meta_opcode.ml]]}

<<function [[Meta_opcode.vof_operation]]>>=
let vof_operation =
  function
  | Mark -> Ocaml.VSum (("Mark", []))
  | Word -> Ocaml.VSum (("Word", []))
  | Popm -> Ocaml.VSum (("Popm", []))
  | Count -> Ocaml.VSum (("Count", []))
  | Concatenate -> Ocaml.VSum (("Concatenate", []))
  | Stringify -> Ocaml.VSum (("Stringify", []))
  | Glob -> Ocaml.VSum (("Glob", []))
  | Assign -> Ocaml.VSum (("Assign", []))
  | Dollar -> Ocaml.VSum (("Dollar", []))
  | Index -> Ocaml.VSum (("Index", []))
  | Local -> Ocaml.VSum (("Local", []))
  | Unlocal -> Ocaml.VSum (("Unlocal", []))
  | Fn -> Ocaml.VSum (("Fn", []))
  | DelFn -> Ocaml.VSum (("DelFn", []))
  | Simple -> Ocaml.VSum (("Simple", []))
  | Exit -> Ocaml.VSum (("Exit", []))
  | Return -> Ocaml.VSum (("Return", []))
  | If -> Ocaml.VSum (("If", []))
  | IfNot -> Ocaml.VSum (("IfNot", []))
  | Jump -> Ocaml.VSum (("Jump", []))
  | Match -> Ocaml.VSum (("Match", []))
  | Case -> Ocaml.VSum (("Case", []))
  | For -> Ocaml.VSum (("For", []))
  | Wastrue -> Ocaml.VSum (("Wastrue", []))
  | Not -> Ocaml.VSum (("Not", []))
  | False -> Ocaml.VSum ((" False", []))
  | True -> Ocaml.VSum ((" True", []))
  | Read -> Ocaml.VSum (("Read", []))
  | Write -> Ocaml.VSum (("Write", []))
  | ReadWrite -> Ocaml.VSum (("ReadWrite", []))
  | Append -> Ocaml.VSum (("Append", []))
  | Close -> Ocaml.VSum (("Close", []))
  | Dup -> Ocaml.VSum (("Dup", []))
  | Pipe -> Ocaml.VSum (("Pipe", []))
  | PipeWait -> Ocaml.VSum (("PipeWait", []))
  | PipeFd -> Ocaml.VSum (("PipeFd", []))
  | Eflag -> Ocaml.VSum (("Eflag", []))
  | Subshell -> Ocaml.VSum (("Subshell", []))
  | Backquote -> Ocaml.VSum (("Backquote", []))
  | Async -> Ocaml.VSum (("Async", []))
  | REPL -> Ocaml.VSum (("REPL", []))
  | Popredir -> Ocaml.VSum (("Popredir", []))
@

<<function [[Meta_opcode.vof_opcode]]>>=
let vof_opcode =
  function
  | F v1 -> let v1 = vof_operation v1 in Ocaml.VSum (("F", [ v1 ]))
  | I v1 -> let v1 = Ocaml.vof_int v1 in Ocaml.VSum (("I", [ v1 ]))
  | S v1 -> let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("S", [ v1 ]))
@


%-------------------------------------------------------------

<<Meta_opcode.ml>>=
(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Opcode

module Ocaml = OCaml

<<function [[Meta_opcode.vof_operation]]>>
  
<<function [[Meta_opcode.vof_opcode]]>>

@


\subsection*{[[Op_process.ml]]}

%-------------------------------------------------------------

<<Op_process.ml>>=
open Stdcompat (* for |> *)

module R = Runtime
module E = Error

<<function [[Op_process.execute]]>>

<<function [[Op_process.exec]]>>

<<function [[Op_process.forkexec]]>>

<<function [[Op_process.op_Simple]]>>
@


\subsection*{[[Op_repl.ml]]}

%-------------------------------------------------------------

<<Op_repl.ml>>=

module R = Runtime

<<function [[Op_repl.op_REPL]]>>
@


\subsection*{[[Opcode.ml]]}

%-------------------------------------------------------------

<<Opcode.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

<<type [[Opcode.operation]]>>
<<type [[Opcode.opcode]]>>
<<type [[Opcode.codevec]]>>
@


\subsection*{[[PATH.ml]]}

%-------------------------------------------------------------

<<PATH.ml>>=
open Common

module R = Runtime

<<function [[PATH.search_path_for_cmd]]>>
<<function [[PATH.find_in_path]]>>
@


\subsection*{[[Lexer.mli]]}

%-------------------------------------------------------------

<<Lexer.mli>>=
<<signature [[Lexer.token]]>>

<<exception [[Lexer.Lexical_error]]>>
@

\subsection*{[[Lexer.mll]]}

%-------------------------------------------------------------

\subsection*{[[Parser.mly]]}


\subsection*{[[Parse.ml]]}

%-------------------------------------------------------------

<<Parse.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Stdcompat (* for |> *)
open Common

module R = Runtime

<<function [[Parse.error]]>>

<<function [[Parse.parse_line]]>>
@


\subsection*{[[Pattern.ml]]}

<<type [[Pattern.pattern]]>>=
type pattern = string
@

<<function [[Pattern.match_str]]>>=
(* todo: handle [ * ?  *)
let match_str s1 s2 =
  s1 = s2
@


%-------------------------------------------------------------

<<Pattern.ml>>=

<<type [[Pattern.pattern]]>>

<<function [[Pattern.match_str]]>>
@


\subsection*{[[Process.ml]]}

%-------------------------------------------------------------

<<Process.ml>>=
open Stdcompat (* for |> *)
open Common

module R = Runtime

<<function [[Process.s_of_unix_error]]>>

<<function [[Process.exit]]>>

<<function [[Process.return]]>>


<<type [[Process.waitfor_result]]>>

<<function [[Process.waitfor]]>>
@


\subsection*{[[Prompt.ml]]}

%-------------------------------------------------------------

<<Prompt.ml>>=
module R = Runtime

<<constant [[Prompt.doprompt]]>>
<<constant [[Prompt.prompt]]>>

<<function [[Prompt.pprompt]]>>
@


\subsection*{[[Runtime.ml]]}

%-------------------------------------------------------------

<<Runtime.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Stdcompat (* for |> *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types and globals *)
(*****************************************************************************)

<<type [[Runtime.varname]]>>
<<type [[Runtime.value]]>>
<<type [[Runtime.var]]>>
<<type [[Runtime.fn]]>>

<<type [[Runtime.thread]]>>

<<type [[Runtime.redir]]>>

<<type [[Runtime.waitstatus]]>>

<<global [[Runtime.globals]]>>

<<global [[Runtime.fns]]>>

(* less: argv0 *)

<<constant [[Runtime.runq]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Runtime.cur]]>>

<<function [[Runtime.push_list]]>>
<<function [[Runtime.pop_list]]>>

<<function [[Runtime.push_word]]>>
<<function [[Runtime.pop_word]]>>

<<function [[Runtime.push_redir]]>>
<<function [[Runtime.pop_redir]]>>

<<function [[Runtime.turf_redir]]>>

<<function [[Runtime.doredir]]>>

<<function [[Runtime.mk_thread]]>>
@


\subsection*{[[Status.ml]]}

%-------------------------------------------------------------

<<Status.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common

module R = Runtime

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Small helpers to manipulate the "status" special variable (see Var.ml) *)

(*****************************************************************************)
(* API *)
(*****************************************************************************)

<<function [[Status.setstatus]]>>
<<function [[Status.getstatus]]>>
<<function [[Status.concstatus]]>>
<<function [[Status.truestatus]]>>
@


\subsection*{[[Var.ml]]}

%-------------------------------------------------------------

<<Var.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

module R = Runtime

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Helpers to manipulate rc shell variables *)

(*****************************************************************************)
(* API *)
(*****************************************************************************)

<<function [[Var.gvlook]]>>
<<function [[Var.vlook]]>>

<<function [[Var.setvar]]>>

<<function [[Var.vinit]]>>
@


\subsection*{[[Builtin.mli]]}

%-------------------------------------------------------------

<<Builtin.mli>>=
<<signature [[Builtin.is_builtin]]>>

<<signature [[Builtin.dispatch]]>>
@


\subsection*{[[CLI.mli]]}


%-------------------------------------------------------------

<<CLI.mli>>=

<<type [[CLI.caps]]>>

<<signature [[CLI.main]]>>

(* internals *)
<<signature [[CLI.interpret_bootstrap]]>>
@


\subsection*{[[Compile.mli]]}

%-------------------------------------------------------------

<<Compile.mli>>=
<<signature [[Compile.compile]]>>
@


\subsection*{[[Dumper_.mli]]}

%-------------------------------------------------------------

<<Dumper_.mli>>=
<<signature [[Dumper_.s_of_cmd]]>>
<<signature [[Dumper_.s_of_opcode]]>>

(* extra *)

<<signature [[Dumper_.s_of_line]]>>
<<signature [[Dumper_.s_of_cmd_sequence]]>>
<<signature [[Dumper_.s_of_value]]>>
<<signature [[Dumper_.s_of_codevec]]>>
<<signature [[Dumper_.s_of_operation]]>>
@


\subsection*{[[Env.mli]]}

%-------------------------------------------------------------

<<Env.mli>>=
@


\subsection*{[[Error.mli]]}

%-------------------------------------------------------------

<<Error.mli>>=
<<signature [[Error.error]]>>
@


\subsection*{[[Fn.mli]]}

%-------------------------------------------------------------

<<Fn.mli>>=
<<signature [[Fn.flook]]>>
@


\subsection*{[[Glob.mli]]}

%-------------------------------------------------------------

<<Glob.mli>>=
@


\subsection*{[[Heredoc.mli]]}

%-------------------------------------------------------------

<<Heredoc.mli>>=
@

\subsection*{[[Interpreter.mli]]}

%-------------------------------------------------------------

<<Interpreter.mli>>=
<<signature [[Interpreter.interpret_operation]]>>
@

\subsection*{[[PATH.mli]]}

%-------------------------------------------------------------

<<PATH.mli>>=
<<signature [[PATH.find_in_path]]>>

<<signature [[PATH.search_path_for_cmd]]>>
@

\subsection*{[[Parse.mli]]}

%-------------------------------------------------------------

<<Parse.mli>>=
<<signature [[Parse.parse_line]]>>
@

\subsection*{[[Pattern.mli]]}

<<signature [[Pattern.match_str]]>>=
val match_str : string -> pattern -> bool
@

%-------------------------------------------------------------

<<Pattern.mli>>=
(* todo: Glob char *)
<<type [[Pattern.pattern]]>>

<<signature [[Pattern.match_str]]>>
@

\subsection*{[[Process.mli]]}


%-------------------------------------------------------------

<<Process.mli>>=
<<type [[Process.waitfor_result]]>>

<<signature [[Process.return]]>>
<<signature [[Process.exit]]>>
<<signature [[Process.waitfor]]>>
<<signature [[Process.s_of_unix_error]]>>
@

\subsection*{[[Prompt.mli]]}

%-------------------------------------------------------------

<<Prompt.mli>>=
<<signature [[Prompt.doprompt]]>>
<<signature [[Prompt.prompt]]>>

<<signature [[Prompt.pprompt]]>>
@


\subsection*{[[Runtime.mli]]}

%-------------------------------------------------------------

<<Runtime.mli>>=

<<type [[Runtime.varname]]>>
<<type [[Runtime.value]]>>
<<type [[Runtime.var]]>>
<<type [[Runtime.fn]]>>

<<type [[Runtime.thread]]>>
<<type [[Runtime.redir]]>>

<<type [[Runtime.waitstatus]]>>

(* globals *)

<<signature [[Runtime.globals]]>>
<<signature [[Runtime.fns]]>>
<<signature [[Runtime.runq]]>>

(* API *)

<<signature [[Runtime.cur]]>>
<<signature [[Runtime.push_list]]>>
<<signature [[Runtime.pop_list]]>>
<<signature [[Runtime.push_word]]>>
<<signature [[Runtime.pop_word]]>>
<<signature [[Runtime.push_redir]]>>
<<signature [[Runtime.pop_redir]]>>
<<signature [[Runtime.turf_redir]]>>
<<signature [[Runtime.doredir]]>>

<<signature [[Runtime.mk_thread]]>>
@


\subsection*{[[Status.mli]]}

%-------------------------------------------------------------

<<Status.mli>>=
(* helpers to manipulate the "status" special variable (see Var.ml) *)

<<signature [[Status.setstatus]]>>
<<signature [[Status.getstatus]]>>
<<signature [[Status.concstatus]]>>
<<signature [[Status.truestatus]]>>
@


\subsection*{[[Var.mli]]}

%-------------------------------------------------------------

<<Var.mli>>=
(* Helpers to manipulate rc shell variables *)

<<signature [[Var.gvlook]]>>
<<signature [[Var.vlook]]>>
<<signature [[Var.setvar]]>>
<<signature [[Var.vinit]]>>
@



\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
LOC = Lines Of Code
CLI = Command-Line Interface
\end{verbatim}


\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
