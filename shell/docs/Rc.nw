\documentclass[12pt]{report}
%alt: [12pt, twocolumn, landscape]
%coupling: see Config.tex

\input{latex/Packages}
\input{latex/Config}
\input{latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - TODO removed cur_tok in lexerfunc, move it outside

%thx to codemap/codegraph/scheck:

%thx to this manual, I better understand sh:
% - how rc -e works for error strictness (and its interaction with mk)

%history LP-ization:
% - skeleton, mostly copy paste of Shell.nw skeleton
% - put all content of files in the Extra section, via 'lpizer'
%   which also now split in chunks!
%    * function, type, exception, constant, signature
% - read Extra section, identify concepts, first TOC (copy also Shell.nw)
% - distribute parts of the file before
% - aspecify advanced features!
% - TODO add figures
% - TODO add explanations

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Shell [[rc]]
}\\
OCaml edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Tom Duff and Yoann Padioleau
}

\maketitle 
%\onecolumn
\hrule
%\input{latex/Copyright}
%\input{latex/CopyrightPlan9}
\begin{quote}
Copyright \copyright{} 2025 Yoann Padioleau \\
Permission is granted to copy, distribute and/or modify this document,
except all the source code it contains, under the terms of the GNU Free
Documentation License, Version 1.3.
\end{quote}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
\chapter{Introduction}
%******************************************************************************

#include "Intro.nw"

%\chapter{Overview}
% now in Intro.nw too

% essence of shell = fork, exec, wait + rediction and pipe (and fd adjust in fork
% before exec)
% show code for minimalist shell first? just Simple command (and maybe Pipe or redir)

\section{Code organization}

%dup: Assembler.nw
Table~\ref{tab:code-orga} presents short descriptions
of the source files of [[rc]], together with
the main entities (e.g., types, functions, globals) the file defines,
and the corresponding chapter in this document in which the code
contained in the file is primarily discussed.

\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lcllr}
\toprule
{\bf Function}                 & {\bf Ch.}                     & {\bf File}     & {\bf Entities}                                  & {\bf LOC} \\
\otoprule
abstract syntax tree           & \ref{chap:core-ds}            & [[Ast.ml]]       & [<line>] [<cmd>] [<Ast.value>]   & 110 \\
opcodes                        & \ref{chap:core-ds}            & [[Opcode.ml]]     & [<codevec>] [<Opcode.t>] [<operation>]        & 109 \\
runtime structures             & \ref{chap:core-ds}            & [[Runtime.ml]]  & [<var>] [<globals>] [<thread>] [<runq>] [<cur()>] & 233 \\ % push_word() vlook() setvar [<Runtime.value>]
variable management            & \ref{chap:core-ds}            & [[Var.ml]]     & [<gvlook()>] [<vlook()>] [<setvar()>] [<init()>] &  46 \\ % 
function management            & \ref{chap:core-ds}            & [[Fn.ml]]     & [<flook()>] &  10 \\ 

\midrule
entry point                    & \ref{chap:main}               & [[Main.ml]]     &                                       & 18 \\
main functions                 & \ref{chap:main}               & [[CLI.ml]] & [<main()>] [<interpret_bootstrap()>]   & 298 \\ % bootstrap
read eval print loop           & \ref{chap:main}               & [[Op_REPL.ml]] & [<op_REPL()>]   & 61 \\ % bootstrap

\midrule
lexer                          & \ref{chap:lexing}             & [[Lexer.mll]]      & [<Lexer.token()>] [<incr_lineno()>]               & 170 \\
prompt management              & \ref{chap:lexing}             & [[Prompt.ml]]      & [<doprompt>] [<prompt>] [<pprompt()>]    & 39 \\
globals                        & \ref{chap:lexing}             & [[Globals.ml]]      & [<skipnl>] [<ifnot>] [<errstr>]        & 33 \\ % eflagok
parser                         & \ref{chap:parsing}            & [[Parse.ml]]      & [<parse_line()>] [<Parse.error()>]     & 96 \\ 
grammar                        & \ref{chap:parsing}            & [[Parser.mly]]      & [<Parser.tokens>] [<Parser.line()>]    & 311 \\ 

\midrule
opcode generation            & \ref{chap:compile-interpret}  & [[Compile.ml]]     & [<compile()>] [<outcode_seq()>]         & 341 \\
opcode interpretation        & \ref{chap:compile-interpret}  & [[Interpret.ml]]     & [<interpret_operation()>] & 357 \\
simple command interpretation  & \ref{chap:compile-interpret}  & [[Op_process.ml]]   & [<op_Simple()>] [<forkexec()>]     & 120 \\
process status                 & \ref{chap:compile-interpret}  & [[Status.ml]]   & [<setstatus()>] [<getstatus()>]                 & 39 \\
process management             & \ref{chap:compile-interpret}  & [[Process.ml]]   & [<return()>] [<waitfor()>] [<exit()>]                 & 81 \\
error management               & \ref{chap:compile-interpret}  & [[Error.ml]]     & [<Error.error()>]                          & 18 \\
[[$path]] management           & \ref{chap:compile-interpret}  & [[PATH.ml]]     & [<find_in_path()>]                          & 27 \\
pattern matching [[~]]         & \ref{chap:compile-interpret}  & [[Pattern.ml]]     & [<match_str()>]                          & 12 \\
shell builtins                 & \ref{chap:builtins}           & [[Builtin.ml]] & [<dispatch()>] [<dochdir()>]        & 157 \\
shell environment              & \ref{chap:environment}        & [[Env.ml]]      & [<read_environment()>]                        & 2 \\
signal management              & \ref{chap:signals}            & [[Trap.ml]]     &                           & \\
% initialization chapter?

\midrule
wildcard matching              & \ref{chap:globbing}           & [[Glob.ml]]     &                           & 2 \\
Debugging flags                   & \ref{chap:debugging}           & [[Flags.ml]]      & [<xflag>] [<sflag>] [<eflag>] & 58 \\
here documents & \ref{chap:advanced-topics}    & [[Heredoc.ml]]     &                    & 2 \\

\otoprule
Total                          &                               &                &                                                 & 3200 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Chapters and associated [[rc]] source files.}
\label{tab:code-orga}
\end{table*}


\section{Software architecture}

%toc: before presenting soft archi of rc itself, useful to see context
% and how rc fits in the big picture.

\subsection{The command-line user interface}
\n terminal, shell, login

The shell is only one {component} of the command-line user interface (CLI).
Figure~\ref{fig:cui-plan9} shows the components supporting
the CLI under \plan (the components under \unix are very similar).

To run commands, the shell needs first a kernel to create processes. 
%dup: intro/requirements
The kernel provides services to applications (including the shell) through its
{\em system call interface} (also known as {\em syscalls}).
For example, under \plan, [[rfork()]] creates a new process in which
the shell can then [[exec()]] a program (see \book{Kernel}).

\begin{figure}[!tbp]\centering
\begin{verbatim}
   filesystem           +---------------+ +-------------------+
    interface           |               | |                   |  A
   |-- bin              |     Shell     | |command (e.g., ls) |  P
   |   |-- cp  +--------+-> stdin       | |      stdin        |  P
   |   |-- ls  |      +-+---stdout      | |      stdout       |  S
   |   |-- rc  |      | +---------------+ +-------------------+
   |   `-- ... |      |------------syscall interface------------
   |-- boot    |      | +-------------------------------------+
   |-- dev     |      | |               Kernel                |
   |   |--  cons <----+ |                                     |  K
   |   |         < - - +|  device drivers-+                   |  E
   |   |--  draw        |  |              |                   |  R
   |   |--  mouse      +|- + >console     |                   |  N
   |   `--  ...         |  |              |                   |  E
   |-- env           + -|- + -display     |                   |  L
   |-- sys              |  |  keyboard- - |                   |
   `-- ...           |  |  |  mouse - - -|+ - - - - - - +     |
                        |  |              |                   |
                     |  |  +-------------++             |     |
                        +-------------------------------------+
                     v                   |              |        D
                + - - - - - - -                                  E
                               |         v              v        V
                |   Monitor      + - - - - -      + - - - - -    I
                               |   keyboard |        mouse   |   C
                + - - - - - - -  + - - - - -      + - - - - -    E
                            Terminal                             S
                           (console)
\end{verbatim}
\caption{Components of the command-line user interface under \plan.}
\label{fig:cui-plan9}
\end{figure}

A shell needs also device drivers in the kernel handling
the terminal with its keyboard and monitor.
%
To access those devices, the kernel provides a {\em filesystem interface}
(called a {\em namespace} under \plan).
%
An application can [[open()]], [[read()]], [[write()]], or [[close()]]
\n also seek, actually pread(), pwrite()
files in this filesystem. Under \unix and \plan, devices are represented
as files. For example, [[/dev/cons]] (for console) is a file representing
the terminal. 
%dup: intro/requirements
To read characters from the keyboard, an application can simply
read characters from [[/dev/cons]].
%
To write characters on the monitor, an application can simply
write characters in [[/dev/cons]].
\l also /dev/draw, see \book{Graphics}
%
\t when kernel start, connect first process to /dev/cons and
\t following process inherits this configuration when fork, including rc.

\t separate program! huge innovation.

\begin{verbatim}

\t stdin stdout regular program
%plan9:
\t under \plan kernel run rc (see \book{Kernel} and Section{boot.rc}).
%unix:
\t Under \unix run init, then login, then shell in terminal. Even virtual
\t  terminal in Linux, 
\t under windowing system like rio also virtual terminals connected
\t stdin and stdout of process (see \book{Windows}).
% Figure X presents archi for plan9.

% shell = stuff around a kernel in a coquillage.
% history: multics.
% A shell is a bastard. See es paper quote in abstract
%  that reference unix programmnig environment book

% separate prog from kernel, can change shell!
%history: originated in Multics (one of the 2 things Thompson liked about
% Multics, the other being the hierarchical filesystem)

% for a long time actually there was no (external) shell? Shell was
% part of kernel? With Unix it changed and shell can be a regular user program.

% for interactive use, and for programming. Both uses, 
% and different features for those 2 things.

% regular program
% backspace handled by kerne
% line editing not shell
% \footnote not libreadline raw mode, completion


\end{verbatim}



\subsection{[[rc]]'s components}

%dup: (reverted order if figures) Assembler.nw
Figure~\ref{fig:dataflow}    describes the main data    flow of [[rc]], whereas
Figure~\ref{fig:controlflow} describes the main control flow of [[rc]].
%dup: intro/requirements
At its core, [[rc]] is both a {compiler} and a {bytecode interpreter}.
\l like OCaml, Perl, Ruby, etc.
%TODO: do like in Mk.nw and enumerate the big dataflow steps?
As shown by Figure~\ref{fig:dataflow}, given a series of characters
(coming either from what you typed in the terminal or 
from the content of a script),
[[rc]] first groups those characters in {tokens} (with [<Lexer.token()>]). Then,
[[rc]] parses those tokens (with [<Parse.parse_line()>]) and 
builds an {abstract syntax tree} (AST) of the program (see [<Ast.line>] and [<Ast.cmd>]). Finally,
\n actually not lexing -> parsing; for efficiency, parser calls lexer
\n on demand, so it can keep only one token in memory (opti, less important)
[[rc]] transforms this tree in a series of bytecodes or {opcodes} (see [<Opcode.opcode>] and [<Opcode.operation>]).
%
This is similar to what a compiler such as [[5c]] does (see \book{Compiler}),
except an opcode here is not an instruction
from a concrete machine but
from a {\em virtual machine}.

\begin{figure}[!tbp]\centering
\begin{verbatim}
Input characters --> tokens --> AST --> opcodes --> threads --> processes
\end{verbatim}
\caption{Data flow diagram of [[rc]].}\label{fig:dataflow}
\end{figure}

After this compilation, [[rc]] goes through the series of opcodes and 
{interprets} them. [[rc]] keeps track of what is currently executing
in a [<thread>] data structure and in a queue [<runq>]. This data structure
is called a ``thread'' because [[rc]] must sometimes manage 
multiple threads of execution. Indeed,
\t actually from rc point of view they are thread, but many of those
\t threads are attached to and represent external processes
some of the opcodes can create new processes running concurrently
(e.g., [<O.Pipe()>], the opcode handling pipes).
\l confusing then process vs thread? not fully clear in my head too


\begin{figure}[!tbp]\centering
\resizebox{0.9\textwidth}{!}{%
\input{control_flow}
}
\caption{Control flow diagram of [[rc]].}\label{fig:controlflow}
\end{figure}

%trans:
In fact, [[rc]] does not start by compiling, but by interpreting. 
Indeed, [[rc]] starts first by interpreting some special opcodes,
called the {\em bootstrap}, that contains an opcode ([<Opcode.operation.REPL>])
that when interpreted triggers the compiler.
\n lie a bit, there is call to finit instead (said later)
%trans: %dup: Assembler.nw

I will now explain briefly the control flow of [[rc]], starting from 
the top of Figure~\ref{fig:controlflow}.
\l and left to right
%
After some basic initializations,
\n no talk about command-line processing, confusing with command-line user
[<main()>] calls [<interpret_bootstrap()>] which calls itself first a function
[<bootstrap()>] returning the initial set
of opcodes to execute.
%
Internally, [<interpret_bootstrap()>] just modifies the global [<runq>] to point to
a newly created [<thread>], and sets the field [<Runtime.thread.code>] to 
the content of [[bootstrap]].
%
[<interpret_bootstrap()>] then goes in a loop that interprets
the opcodes in [[runq.code]].
\n [[runq->code[pc-1].f()]], 
\l also main set [[runq->argv]]


The most important opcode in [<bootstrap()>] is [<Opcode.operation.REPL>],
\l actually it has a Xsimple "." rcmain and so will run execdot which
\l  will run Xrdcmds (said later?)
which reads and evaluates a command (hence its name) and starts a new [<thread>].
%
[<O.REPL()>] first calls the parser [<parse_line()>], which calls
the lexer [<Lexer.token()>] to get the next token.
\l also print prompt
%
By default, [<parse_line()>] will read characters from a [[lexbuf]] data structure
attached to the current thread (in [<Runtime.thread.lexbuf>]). This [[lexbuf]] is
set initially to be the standard input in [<interpret_bootstrap()>] but this can
be changed if [<O.REPL()>] is asked at some point to parse a script instead.
%
Once you finished to enter a command with a {newline}, [<parse_line()>] will return
\l can be something else when command on multiple lines because skipnl
and [<O.REPL()>] will call [<compile()>] with the AST it built during
parsing as an argument.
%
[<compile()>] then returns the opcodes deriving from the tree.
\n via outcode
Then, [<O.REPL()>] calls
[<Runtime.mk_thread()>] to start a new thread with the returned opcodes as a parameter.
%
[<O.REPL()>] then modifies again the global [<runq>], and when [<O.REPL()>]
returns, the main bytecode interpreter loop will process 
a new series of opcodes stored in [[runq.code]].


Note that [<O.REPL()>] modifies [<runq>] by adding new threads
but keep the old threads in the queue still.
%
Moreover, [<compile()>] adds the opcode [<Opcode.operation.Return>] at the end of
\l also called if error after yyparse, 
\l also exn mechanism?
the series of opcodes deriving from your command.
%
Thus, after the interpreter loop finished interpreting the opcodes of your command,
it will process the [[Return]] opcode in [<O.Return()>], which will modify [<runq>] to point
to the old thread, the one containing the bootstrap opcodes.
%
Then, after [<O.Return()>] returns, the main bytecode interpreter loop
will process again the opcodes from the bootstrap, which
will read another command through [<O.REPL()>].
\n actually Xrdcommands does a [[runq->pc--]] before start, but too specific


In [[rc]], the opcodes are represented by regular constructors
(e.g., [[REPL]], [[Pipe]], [[If]]).
%
Thus, the bytecode interpreter is mainly an opcode dispatcher.
%
Internally, those functions perform {system calls} to the kernel
to create a pipe ([[pipe()]]), 
to fork a new process ([[fork()]]),
to wait for a child process ([[wait()]]),
or to change directory ([[chdir()]]).
%
An important opcode is [<Opcode.operation.Simple>], which is interpreted
by the function [<O.Simple()>], which [[rc]] uses
to run a ``simple'' command.
\n basic, or atomic, one not containing a pipe, or redir
[<O.Simple()>] represents the essence of a shell: with
the series of system calls [[fork()]], [[exec()]], and [[wait()]],
[[rc]] can run a command in a new process and wait for
its termination (or interruption).
\l link to signal chapter.
%
[<O.Simple()>] is also responsible for managing the multiple shell builtins.
Indeed, if the name of the ``simple'' command is a builtin (e.g., [[cd]]),
then [<O.Simple()>] calls [<Builtin.dispatch()>] which dispatches the appropriate function (e.g., [<dochdir()>])
\n another dispatch
instead of forking a new process.
%By convention, the functions representing builtins start with exec
\t except execforkexec which is confusing!

\subsection{Trace of a simple command: [[ls /]]}

You can see the opcodes and the threads created internally by [[rc]] 
by running [[rc]] with the [[-r]] flag.
Here is an example of a {trace} of the simple command [[ls /]]:

\begin{verbatim}
% rc -r
pid 39 cycle 0002D930 1 Xmark ()
...
pid 38 cycle 0001984C 9 Xrdcmds
% ls /
pid 38 cycle 0002CBD0 1 Xmark
pid 38 cycle 0002CBD0 2 Xword ()
pid 38 cycle 0002CBD0 4 Xword (/)
pid 38 cycle 0002CBD0 6 Xsimple (ls /)
bin
boot
...
srv
pid 38 cycle 0002CBD0 7 Xreturn
pid 38 cycle 0001984C 9 Xrdcmds
\end{verbatim}

It is not important to fully understand the format of this trace
(see Section~\ref{sec:rc-r} for the full explanation and
for the code handling [[rc -r]]), but you can recognize a few of
the opcodes I mentioned before: 
[<O.REPL()>], 
[<O.Simple()>], and 
[<O.Return()>].
%
I will explain [<O.Mark()>] and [<O.Word()>] later in this document.

\begin{verbatim}

% It is interesting to understand the full trace of a simple command
% through the multiple layers of the software stack.
% Here is again the trace of the command [[ls /<newline>]] 
% entered in a terminal:

\t full trace ls\n 
\begin{enumerate}
\item After [[rc]] displayed its prompt,
\t 1 shell read(), sysread, connected to /dev/cons, consread
\t blocked (see \book{kernel})

\t item l

\t item s space /

\t item newline
\end{enumerate}

\end{verbatim}

%\subsection{Trace of a pipe}
% later
%\subsection{Trace of a redirection}
% later


\section{Book structure}

%trans: %dup: Assembler.nw
You now have enough background to understand the source code of [[rc]].
%toc:
The rest of the book is organized as follows.
%
I will start by describing the core data structures of [[rc]]
in Chapter~\ref{chap:core-ds}. 
%
Then, I will use a top-down approach, starting with Chapter~\ref{chap:main}
with the description of [<main()>], 
the initialization of [[rc]],
the bytecode interpreter loop, and 
the function [<O.REPL()>].
%
The following chapters will describe the main components of the compiler pipeline:
Chapter~\ref{chap:lexing} will present the lexer,
Chapter~\ref{chap:parsing} the parser, and finally
Chapter~\ref{chap:compile-interpret} the opcode generator and opcode
interpreter for the main features of [[rc]].
%
In Chapter~\ref{chap:builtins}, I will present the code of the different
shell builtins (e.g., [<dochdir()>] for [[cd]]).
%
Chapter~\ref{chap:environment} contains the code to manage the environment
of the processes launched from the shell, and
Chapter~\ref{chap:signals} the code to manage the signals sent to
the processes (also known as {\em notes} under \plan).
%
Chapter~\ref{chap:initialization-real} presents the actual code
initializing [[rc]]. Indeed, Chapter~\ref{chap:main} presents
only a simplified initialization to not introduce too much
complexity early-on.
%dup: Assembler.nw
Then, I will present advanced features of [[rc]] that I did not present 
before to simplify the explanations, for instance,
wildcard matching (e.g., [[ls *.c]]) in Chapter~\ref{chap:globbing},
logging and other debugging helps in Chapter~\ref{chap:debugging},
or command substitutions (e.g., \verb+`{ls}+) in Chapter~\ref{chap:advanced-topics}.
%dup: Assembler.nw
Those advanced features tend to crosscut
many components of [[rc]] with extensions to the lexer, the parser,
the opcode generator, and the opcode interpreter.
%
Finally, Chapter~\ref{chap:conclusion} concludes
and gives pointers to other books in the \principia series.

%toc:
Some appendices present the code of non-functional properties:
code to help debug [[rc]] itself in Appendix~\ref{chap:debugging-appendix}
% and code to manage errors in Appendix~\ref{chap:error}.
%
Finally, Appendix~\ref{chap:examples} presents examples of [[rc]] scripts.


%******************************************************************************
\chapter{Core Data Structures}
%******************************************************************************
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}


% follow mostly data flow order diagram of section X
% token -> AST -> opcodes -> runq

\section{Tokens}

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Word *)*/
/*(*-----------------------------------------*)*/
%token<string * bool(* quoted *)> TWord

/*(*-----------------------------------------*)*/
/*(*2 Operators *)*/
/*(*-----------------------------------------*)*/
%token TPipe
%token<Ast.redirection_kind> TRedir
%token TAndAnd TOrOr TBang
%token TTwiddle  
%token TSemicolon 
%token TAnd
<<Parser tokens, operators other cases>>

/*(*-----------------------------------------*)*/
/*(*2 Variables *)*/
/*(*-----------------------------------------*)*/
%token TEq
%token TDollar
<<Parser tokens, variables other cases>>

/*(*-----------------------------------------*)*/
/*(*2 Punctuation *)*/
/*(*-----------------------------------------*)*/
%token TOPar TCPar
%token TOBrace TCBrace
<<Parser tokens, punctuation other cases>>

/*(*-----------------------------------------*)*/
/*(*2 Keywords *)*/
/*(*-----------------------------------------*)*/
%token TIf TNot TWhile TSwitch TFor TIn TFn

/*(*-----------------------------------------*)*/
/*(*2 Misc *)*/
/*(*-----------------------------------------*)*/
%token TNewline

%token EOF
@
\swdefs{Parser.tokens}

% classic, except TNewline, usually skipped in trad lang but
% here newline has special semantic and trigger special behavior
% like terminating a command and displaying a prompt in interactive mode


\section{Abstract syntax tree (AST)}

%trans: see TNewline, in fact in AST line concept! will see how
% can have multi line command later, especially for statements if/while/...

<<type [[Ast.line]]>>=
(* None when reads EOF *)
type line = cmd_sequence option
@
% parse_line() later

<<type [[Ast.cmd_sequence]]>>=
  and cmd_sequence = cmd list
@
% separated by ';'


<<type [[Ast.cmd]]>>=
and cmd =
  | EmptyCommand

  (* Base *)
  | Simple of value * values
  | Pipe of cmd * cmd (* less: lfd, rfd option *)
  | Async of cmd

  (* Redirections *)
  | Redir of cmd * redirection
  <<[[Ast.cmd]] other redirection cases>>

  (* expressions *)
  | And of cmd * cmd
  | Or of cmd * cmd
  | Not of cmd
  (* can also run the program 'test' for other comparisons ('[' in bash) *)
  | Match of value * values

  (* stmts *)
  | If of cmd_sequence * cmd
  (* Note that you can not put a 'cmd option' in If instead of IfNot below. 
   * rc has to process 'if(...) cmd\n' now! It can not wait for an else.
   *)
  | IfNot of cmd
  | While of cmd_sequence * cmd
  <<[[Ast.cmd]] other statement cases>>

  (* definitions *)
  (* can do x=a; but also $x=b ! 
   * less: could have AssignGlobal and AssignLocal of ... cmd
   *)
  | Assign of value * value * cmd (* can be EmptyCommand *)
  | Fn of value * cmd_sequence
  <<[[Ast.cmd]] other definition cases>>
@
% Assign because actually often do CFLAGS=xxx make

% Simple is important one.
% If Ifnot a bit weird but explained later.
% Fn has no params part but because via $* and $1, $2, ...


%trans: Simple of value * values =~ command call

<<type [[Ast.values]]>>=
(* separated by spaces *)
and values = value list
@


<<type [[Ast.value]]>>=
(* rc does not use types; there is no integer, no boolean, no float.
 * The only value in rc is the list of strings. Even a single
 * string is really a list with one element.
 *)
type value = 
  (* The string can contain the * ? [ special characters.
   * So, even a single word can expand to a list of strings.
   * less: they should be preceded by \001
   * less: W of word_elt list and word_elt = Star | Question | ...Str of string
   *)
  | Word of string * bool (* quoted *)
  | Dollar of value
  | List of values
  <<[[Ast.value]] other cases>>
@

<<type [[Ast.redirection]]>>=
  and redirection = redirection_kind * value (* the filename *)
@

<<type [[Ast.redirection_kind]]>>=
    and redirection_kind = 
      | RWrite (* > *)
      | RRead  (* < *)
      | RAppend (* > > *)
      <<[[Ast.redirection_kind]] other cases>>
@



%TODO: dump AST for ls /etc > /tmp/list.txt, and ref to -dump_ast in appendix



\section{Opcodes}

<<signature [[Compile.compile]]>>=
val compile : Ast.cmd_sequence -> Opcode.codevec
@

<<type [[Opcode.codevec]]>>=
type codevec = t array
@

<<type [[Opcode.opcode]]>>=
type t =
  | F of operation
  | I of int
  | S of string
@
% 'I' useful for Jump pc
% S will be Words mostly

% a bit like assembly, opcodes, operands, but very simple.
% why opcode? why not interpret AST instead?

% Stack machine, Word, Pop, use either inline or on Stack
<<type [[Opcode.operation]]>>=
(* Operations generated by the compiler. 
 * 
 * Semantic of comments below:
 *  - Arguments on stack (...)
 *  - Arguments in line [...]
 *  - Code in line with jump around {...}
 * 
 * alt: type operation = ((unit -> unit) * string)
 *)
type operation =

  (* Stack (argv) *)
  | Mark
  | Word (* [string] *)
  | Popm (* (value) *)
  <<[[Opcode.operation]] other stack cases>>

  (* Variable *)
  | Assign (* (name)(val) *)
  | Dollar (* (name) *)
  <<[[Opcode.operation]] other variable cases>>

  (* Process! *)
  | Simple (* (args) *)
  | Async  (* {... Xreturn} *)

  (* Control flow *)
  | If 
  | IfNot
  (* While are compiled in jumps *)
  | Jump  (* [addr] *)
  | Exit 
  <<[[Opcode.operation]] other control cases>>

  (* Boolean return status  *)
  | Wastrue
  | Not
  | False (* {...} *)
  | True  (* {...} *)
  | Match (* (pat, str) *)

  (* Redirections *)
  | Read (* (file)[fd] *)
  | Write (* (file)[fd] *)
  | Append (* (file)[fd] *)
  <<[[Opcode.operation]] other redirection cases>>

  (* Pipes *)
  | Pipe (* [i j]{... Xreturn}{... Xreturn} *)
  <<[[Opcode.operation]] other pipe cases>>

  (* Functions *)
  | Fn (* (name){... Xreturn } *)

  <<[[Opcode.operation]] other cases>>

  | REPL (* *)
@

% REPL! (was Xrdcmds?)
% Simple again

% will become clearer as we progress

%TODO: show example of opcode for ls /etc > /tmp/list.txt, via -dump ?? with ref to appendix?



\section{Words}
%alt: and lists of words
%alt: TODO: merge with next section?

% runtime value, what will be in the variables bindings
% Not like Ast.value!

<<type [[Runtime.value]]>>=
(* In rc the basic (and only) value is the list of strings.
 * A single word is considered as a list with one element.
 *)
type value = string list
@
% TODO? confusing to use value here with Ast.value?
% or done on purpose to relate?


\section{Variables}

<<type [[Runtime.varname]]>>=
(* can be anything: "foo", but also "*", "1", "2", etc *)
type varname = string
@
% $* $1 will be used (not like in mk where must be ident)

<<type [[Runtime.var]]>>=
type var = { 
  (* can be None when lookup for a value that was never set before,
   * which is different from Some [] (when do A=()), which is also
   * different from Some [""] (when do A='').
   *)
  mutable v: value option;
  (* less: opti: changed: bool *)
}
@
% remember value is string list!

<<signature [[Runtime.globals]]>>=
val globals : (varname, var) Hashtbl.t
@

<<global [[Runtime.globals]]>>=
let globals: (varname, var) Hashtbl.t = 
  Hashtbl.create 101
@

<<signature [[Var.gvlook]]>>=
(* This will only look for globals (in Runtime.globals) *)
val gvlook : Runtime.varname -> Runtime.var
@

<<function [[Var.gvlook]]>>=
let gvlook (name : R.varname) : R.var =
  try 
    Hashtbl.find R.globals name
  with Not_found ->
    let var = { R.v = None } in
    Hashtbl.add R.globals name var;
    var
@





<<signature [[Var.vinit]]>>=
(* Populate Runtime.globals from the current environment *)
val init : < Cap.env ; .. > -> unit
@


\section{Functions}

<<signature [[Runtime.fns]]>>=
val fns : (string, fn) Hashtbl.t
@
<<global [[Runtime.fns]]>>=
let fns: (string, fn) Hashtbl.t = 
  Hashtbl.create 101
@

<<type [[Runtime.fn]]>>=
type fn = {
  code: Opcode.codevec;
  pc: int;
  (* less: fnchanged *)
}
@
% why pc? can't simply start at 0 by convention?

<<signature [[Fn.flook]]>>=
val flook : string -> Runtime.fn option
@

<<function [[Fn.flook]]>>=
let flook s =
  try 
    Some (Hashtbl.find R.fns s)
  with Not_found -> None
@


\section{Threads and run queue}

<<type [[Runtime.thread]]>>=
type thread = {
  code: Opcode.codevec;
  pc: int ref;

  mutable argv: string list;
  locals: (varname, var) Hashtbl.t;

  <<[[Runtime.thread]] other fields>>
}
@
% pc = program counter (a classic in assembly)
% argv =~ sp = stack (also classic in assembly)
% called argv cos ultimately what will be passed to simple commands
%  executed

%less: use Stack.t for argv?

% called "thread" because kinda like thread? But in practice
% will trigger fork/exec of separate process but the
% parent will juggle with those threads structures (Tied possibly
% to external process)


<<signature [[Runtime.runq]]>>=
val runq : thread list ref
@
% when will handle pipe command, will execute in parallel 2 process
% that will be attached to a thread data-structure to synchronize

<<constant [[Runtime.runq]]>>=
(* less: could have also  'let cur = { code = boostrap; pc = 1; chan = stdin }'
 * in addition to runq. Then there will be no need for cur ().
 *)
let runq = ref []
@

<<signature [[Runtime.cur]]>>=
val cur : unit -> thread
@
<<function [[Runtime.cur]]>>=
let cur () =
  match !runq with
  | [] -> failwith "empty runq"
  | x::_xs -> x
@



<<signature [[Runtime.mk_thread]]>>=
val mk_thread :
  Opcode.codevec -> int -> (varname, var) Hashtbl.t -> thread
@

<<function [[Runtime.mk_thread]]>>=
(* This function was called start(), but it does not really start right
 * away the new thread. So better to call it mk_thread.
 * It starts with pc <> 0 when handle async, traps, pipes, etc.
 *)
let mk_thread code pc locals =
  let t = {
    code = code;
    pc = ref pc;
    argv = [];
    locals = locals;

    <<[[Runtime.mk_thread()]] set other fields>>
  } in
  t
@


%TODO? dump a thread for simple command?


\subsection{The stack}

% argv

<<signature [[Runtime.push_word]]>>=
val push_word : string -> unit
@
<<function [[Runtime.push_word]]>>=
let push_word s =
  let t = cur () in
  t.argv <- s::t.argv
@


<<signature [[Runtime.pop_word]]>>=
val pop_word : unit -> unit
@
<<function [[Runtime.pop_word]]>>=
let pop_word () =
  let t = cur () in
  match t.argv with
  | [] -> failwith "pop_word but no word!"
  | _x::xs ->
      t.argv <- xs
@



\subsection{Local variables}


<<signature [[Var.vlook]]>>=
(* This will look first in the locals (in Runtime.cur().locals) and then
 * in globals (in Runtime.globals)
 *)
val vlook : Runtime.varname -> Runtime.var
@

<<function [[Var.vlook]]>>=
let vlook name =
  if !Runtime.runq <> []
  then 
    let t = Runtime.cur () in
    try 
      Hashtbl.find t.R.locals name
    with Not_found ->
      gvlook name
  else gvlook name
@

<<signature [[Var.setvar]]>>=
(* Override the content of a (local or global) variable *)
val setvar : Runtime.varname -> Runtime.value -> unit
@

<<function [[Var.setvar]]>>=
let setvar (name : Runtime.varname) (v : Runtime.value) : unit =
  let var = vlook name in
  var.R.v <- Some v
@



\subsection{Redirections}
%alt: move later? easier to explain later?

<<[[Runtime.thread]] other fields>>=
(* things to do before exec'ing the simple command *)
mutable redirections: (redir list) list;
@
%TODO: list list?? (redir list) stack ?

<<type [[Runtime.redir]]>>=
  and redir =
    (* the file descriptor From becomes To, e.g., /tmp/foo becomes stdout,
     * which means your process output will now go in /tmp/foo.
     *)
    | FromTo of Unix.file_descr (* from *) * Unix.file_descr (* to *)
    | Close of Unix.file_descr
@
%TODO: ???

<<[[Runtime.mk_thread()]] set other fields>>=
redirections = 
  (match !runq with
  | t::_ts -> []::t.redirections
  | [] -> []::[]
  );
@
%TODO: ???

\subsection{Wait status}

<<[[Runtime.thread]] other fields>>=
(* things to wait for after a thread forked a process *)
mutable waitstatus: waitstatus;
@
% threads are attached to external process and pid we need
% to wait for

<<type [[Runtime.waitstatus]]>>=
  and waitstatus =
    | NothingToWaitfor
    (* process pid to wait for in Xpipewait (set from Xpipe) *)
    | WaitFor of int 
    (* exit status from child process returned from a wait() *)
    | ChildStatus of string
@


<<[[Runtime.mk_thread()]] set other fields>>=
waitstatus = NothingToWaitfor;
@


%******************************************************************************
\chapter{[[main()]]}
%******************************************************************************
\label{chap:main}


\section{Overview}

<<type [[CLI.caps]]>>=
(* Need:
 *  - fork/exec/wait: obviously as we are a shell
 *  - chdir: for the builtin 'cd'
 *  - env: to ??
 *  - exit: as many commands can abruptely exit 'rc' itself or children
 *    created by 'rc'
 *  - open_in: for '.' that can source and eval scripts
 *
 * alt: could remove Cap.exit and use Exit.ExitCode exn in Process.ml instead
*)
type caps = < Cap.fork; Cap.exec; Cap.wait; Cap.chdir; Cap.env; Cap.exit; Cap.open_in >
@

<<signature [[CLI.main]]>>=
(* entry point (can also raise Exit.ExitCode) *)
val main: <caps; ..> -> string array -> Exit.t
@

<<toplevel [[Main._1]]>>=
let _ =
  Cap.main (fun (caps : Cap.all_caps) ->
     let argv = CapSys.argv caps in
     Exit.exit caps 
        (Exit.catch (fun () -> 
            CLI.main caps argv))
   )
@



%TODO: ex of use of rc, rc, rc -I, rc ls /foo?


<<function [[CLI.main]]>>=
let main (caps : <caps; .. >) (argv : string array) : Exit.t =
  let args = ref [] in
  <<[[CLI.main()]] debugging initializations>>

  let options = [
    <<[[CLI.main()]] [[options]] elements>>
  ]
  in
  (* old: was Arg.parse but we want explicit argv control *)
  (try 
    Arg.parse_argv argv (Arg.align options) (fun t -> args := t::!args) usage;
  with
  | Arg.Bad msg -> UConsole.eprint msg; raise (Exit.ExitCode 2)
  | Arg.Help msg -> UConsole.print msg; raise (Exit.ExitCode 0)
  );
  <<[[CLI.main()]] logging initializations>>
  <<[[CLI.main()]] CLI action processing>>
  Var.init caps;
  (* todo: trap_init () *)
  <<[[CLI.main()]] other initializations>>
  try 
    interpret_bootstrap (caps :> < caps >) (List.rev !args);
    Exit.OK
  with exn ->
    <<[[CLI.main()]] when [[exn]] thrown in [[interpret()]]>>
@
%$

%meta: argv :) hence argv in thread, cos rc itself is a CLI command

<<[[CLI.main()]] when [[Failure]] [[exn]] thrown in [[interpret()]]>>=
| Failure s -> 
    (* useful to indicate that error comes from rc, not subprocess *)
    Logs.err (fun m -> m  "rc: %s" s);
    Exit.Code 1
@


<<signature [[CLI.interpret_bootstrap]]>>=
val interpret_bootstrap : < caps > -> string list -> unit
@


\section{Command-line arguments processing}
%ocaml: section not that needed

<<constant [[CLI.usage]]>>=
let usage =
  "usage: rc [-SsriIlxepv] [-c arg] [-m command] [file [arg ...]]"
@

% will show gradually

\subsection{Interactive mode: [[rc -i]]}
% and prompt part1

<<constant [[Flags.interactive]]>>=
(* -i (on by default when detects that stdin is /dev/cons *)
let interactive = ref false
@

<<[[CLI.main()]] other initializations>>=
(* todo: 
 * if argc=1 and Isatty then Flags.interactive := true 
 *)
@

<<[[CLI.main()]] [[options]] elements>>=
"-i", Arg.Set Flags.interactive,
" interactive mode (display prompt)";
"-I", Arg.Clear Flags.interactive,
" non-interactive mode (no prompt)";
@

% prompt display when interactive!

% and error management different when interactive
% lots of little things different when interactive.

<<[[Runtime.thread]] other fields>>=
(* to display a prompt or not *)
mutable iflag: bool;
@
<<[[Runtime.mk_thread()]] set other fields>>=
iflag = false;
@

%TODO: why per thread? why not use globals everywhere?


\subsection{Login mode: [[rc -l]]}

<<constant [[Flags.login]]>>=
(* -l (on by default if argv0 starts with a -) *)
let login = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-l", Arg.Set Flags.login,
" login mode (execute ~/lib/profile)";
@

% no code really here but hflags will pick it up and
% rcmain \ref{sec:rcmain} will use whether flag is set
% (same for -p)

%trans: many more flags, shown gradually, especially Chapter X
% advanced features and Y for debugging


%\section{Initialization}
%Var.vinit before
% trapinit?
%\section{Setting [[runq]]}
%\section{Setting [[runq->argv]]}

\section{Bytecode interpreter loop}


<<function [[CLI.interpret_bootstrap]]>>=
let interpret_bootstrap (caps : < caps >) (args : string list) : unit =
  let t = R.mk_thread (bootstrap ()) 0 (Hashtbl.create 11) in
  R.runq := t::!R.runq;

  <<[[CLI.interpret_bootstrap()]] other initializations for [[t]]>>

  while true do
    (* bugfix: need to fetch the current thread each time,
     * as the interpreted code may have modified runq.
     *)
    let t = Runtime.cur () in
    let pc = t.R.pc in
    <<[[CLI.interpret()]] if [[rflag]]>>
    incr pc;
    (match t.R.code.(!pc - 1) with
    (* opcode dispatch ! *)
    | O.F operation ->  Interpreter.interpret_operation caps operation
    | O.S s -> failwith (spf "was expecting a F, not a S: %s" s)
    | O.I i -> failwith (spf "was expecting a F, not a I: %d" i)
    );
    (* todo: handle trap *)
  done
[@@profiling]
@

% will see real one [<bootstrap()>] later, but for now
% essentially this one below

<<constant [[CLI._bootstrap_simple]]>>=
let _bootstrap_simple : O.codevec = 
  [| O.F O.REPL |]
@


% incr pc, so need pc -1 after, and in interpret_operation assume
% pc will be one after and no need to incr, already done, unless
% need extra adjustments


<<signature [[Interpreter.interpret_operation]]>>=
(* Interpret one operation. Called from a loop in main(). *)
val interpret_operation :
  < Cap.fork ; Cap.exec ; Cap.wait; Cap.chdir ; Cap.exit ; Cap.open_in; .. > ->
  Opcode.operation ->
  unit
@


<<function [[Interpreter.interpret_operation]]>>=
let interpret_operation (caps: < Cap.fork; Cap.exec; Cap.chdir; Cap.exit; .. >) op : unit =
  match op with
  <<[[Interpreter.interpret_operation()]] match [[operation]] cases>>
  | (O.Concatenate|O.Stringify    |O.Index|
     O.Unlocal|
     O.Fn|
     O.For|
     O.Read|O.Append |O.ReadWrite|
     O.Close|O.Dup|O.PipeFd|
     O.Subshell|O.Backquote|O.Async
    ) ->
    failwith ("TODO: " ^ Opcode.show (O.F op))
@
%$

%LP: later, when implemented
<<[[Opcode.operation]] other redirection cases>>=
| ReadWrite (* (file)[fd] *)
| Close  (* [fd] *)
| Dup    (* [fd0 fd1] *)
| Popredir (* *)
@
<<[[Opcode.operation]] other pipe cases>>=
| PipeFd (* [type]{... Xreturn} *)
@



<<[[CLI.interpret_bootstrap()]] other initializations for [[t]]>>=
(* less: set argv0 *)
args |> List.rev |> List.iter Runtime.push_word;
@
% in practice empty? rc itself takes arguments?? yes! [file [arg ...]]
% see usage
% but for REPL, empty


<<[[CLI.interpret_bootstrap()]] other initializations for [[t]]>>=
t.R.lexbuf <- Lexing.from_channel stdin;
@

<<[[Runtime.thread]] other fields>>=
(* connected on stdin by default (changed when do '. file') *)
mutable lexbuf: Lexing.lexbuf;
@
% but why need lexbuf? not already compiled and code stored in thread.code?
% yes but this code can be '.' which requires to read more commands
% and evaluate them from a source '. env.sh'
<<[[Runtime.mk_thread()]] set other fields>>=
lexbuf = Lexing.from_function (fun _ _ -> failwith "unconnected lexbuf");
@



<<[[CLI.interpret_bootstrap()]] other initializations for [[t]]>>=
t.R.iflag <- !Flags.interactive;
@
% first thread (the REPL) is interactive if shell was set to be interactive
% some will not?

\section{Reading commands: [[O.REPL()]]}
%c: was Xrdcmds()

% see bootstrap_simple, and interpreter loop, so here we go
% interpret_operation first case. Will gradually show in chapter X
% but important understand this one also for lexing/parsing chapter

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* *)
| O.REPL -> Op_repl.op_REPL caps ()
@
\swdefs{O.REPL}

<<function [[Op_repl.op_REPL]]>>=
(* was called Xrdcmds *)
let op_REPL (caps : < Cap.exit; ..>) () =
  let t = R.cur () in

  <<[[Op_repl.op_REPL()]] if [[sflag]]>>
  <<[[Op_repl.op_REPL()]] set [[prompt]] if [[iflag]]>>
  (* less: call Noerror before yyparse *)

  let lexbuf = t.R.lexbuf in
  try 
    let cmdseq_opt = Parse.parse_line lexbuf in
    match cmdseq_opt with
    | Some seq ->
        (* should contain an op_return *)
        let codevec = Compile.compile seq in

        let newt = R.mk_thread codevec 0 t.R.locals in
        R.runq := newt::!(R.runq);

        decr t.R.pc;
        (* when codevec does a op_return(), then interpreter loop
         * in main should call us back since the pc was decremented above
         *)
    <<[[Op_repl.op_REPL()]] match [[cmdset_opt]] other cases>>

  with Failure s -> 
    <<[[Op_repl.op_REPL()]] when [[Failure s]] thrown>>
@

% lexbuf, parse_line, compile, runq
% and this is a hidden loop because of the decr t.R.pc!

<<signature [[Parse.parse_line]]>>=
val parse_line : Lexing.lexbuf -> Ast.line
@

% and compile seen before, so overview of next chapter right here!



<<[[Op_repl.op_REPL()]] when [[Failure s]] thrown>>=
(* todo: check signals  *)
(* less: was doing Xreturn originally *)
if t.R.iflag
then begin
  Logs.err (fun m -> m "%s" s);
  (* go back for next command *)
  decr t.R.pc;
end
else failwith s
@




%\chapter{Input}
%\section{Overview}
%\section{Reading a character: [[getnext()]]}
%\subsection{End-of-file management}
%\subsection{Multiple lines commands and escaped newlines}
%\section{Looking ahead: [[nextc()]] and [[advance()]]}
%\subsection{Displaying the prompt}


%******************************************************************************
\chapter{Lexing}
%******************************************************************************
\label{chap:lexing}

% Seen tokens before in core DS.

% seen mentioned parse_line in REPL

% parse_line() will call Lexer.token() via lexfunc below

\section{[[lexfunc()]] skeleton}

<<[[Parse.parse_line()]] nested function [[lexfunc]]>>=
let lexfunc lexbuf =
  <<[[Parse.lexfunc()]] possibly print the prompt>>
  let tok = ref (Lexer.token lexbuf) in
  <<[[Parse.lexfunc()]] adjustment for skipnl depending on [[tok]] read>>
  <<[[Parse.lexfunc()]] adjust [[curtok]] with [[tok]]>>
  (* todo: 
     - handle lastdol 
     - handle SUB
     - handle free caret insertion
  *)
  !tok 
  <<[[Parse.lexfunc()]] possibly dump tokens>>
in
@

<<signature [[Lexer.token]]>>=
val token: Lexing.lexbuf -> Parser.token
@

%\section{Error reporting}
<<exception [[Lexer.Lexical_error]]>>=
exception Lexical_error of string
@
<<function [[Lexer.error]]>>=
let error s =
  raise (Lexical_error s)
@


\section{[[token()]] skeleton}


<<Lexer.mll>>=
{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Parser

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Limitations compared to rc:
 *  - no unicode support
*)
<<exception [[Lexer.Lexical_error]]>>
<<function [[Lexer.error]]>>
<<function [[Lexer.incr_lineno]]>>
}
(*****************************************************************************)
(* Regexps aliases *)
(*****************************************************************************)
<<lexer regexp aliases>>

(*****************************************************************************)
(* Main rule *)
(*****************************************************************************)
<<rule [[Lexer.token]]>>

(*****************************************************************************)
(* Quote rule *)
(*****************************************************************************)
<<rule [[Lexer.quote]]>>
@



<<rule [[Lexer.token]]>>=
rule token = parse

  (* ----------------------------------------------------------------------- *)
  (* Spacing/comments *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] space cases>>
  <<[[Lexer.token()]] comment cases>>

  (* ----------------------------------------------------------------------- *)
  (* Symbols *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] symbol cases>>

  (* ----------------------------------------------------------------------- *)
  (* Variables *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] variable cases>>

  (* ----------------------------------------------------------------------- *)
  (* Quoted word *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] quoted word cases>>

  (* ----------------------------------------------------------------------- *)
  (* Keywords and unquoted words *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token()]] keywords and unquoted words cases>>

  (* ----------------------------------------------------------------------- *)
  | eof { EOF }
  | _ (*as c*)   { error (spf "unrecognized character: '%s'" (Lexing.lexeme lexbuf)) }
@
\swdefs{Lexer.token}



<<lexer regexp aliases>>=
(* less: not used yet, special regexp used with lastdol *)
let idchr = ['a'-'z''A'-'Z''0'-'9''_''*']
@




%\section{[[yylex()]]}

\section{Spaces and comments ([[#]])}

<<[[Lexer.token()]] space cases>>=
| [' ''\t']+ { token lexbuf }
@

<<[[Lexer.token()]] comment cases>>=
| '#' [^'\n']* { token lexbuf }
@


\section{Newlines and prompts}
\label{sec:newlines-and-prompts}
\label{sec:display-prompt}

<<[[Lexer.token()]] space cases>>=
| '\n'       { incr_lineno(); Prompt.doprompt := true; TNewline }
@
% TNewline will be important in grammar to terminate a command
% and parse_line() will return triggering compilation and execution
% of new thread.

% incr_lineno later

<<signature [[Prompt.doprompt]]>>=
val doprompt : bool ref
@
<<constant [[Prompt.doprompt]]>>=
(* Set to true so the prompt is displayed before the first character is read.
 *
 * Do we need that global? Can we not just call pprompt() explicitely?
 * No because when we get a newline, we know we should display the prompt,
 * but not before finishing executing the command. So the display
 * prompt should be done before the next round of input.
 * less: actually we could do it in the caller of parse_line, in the REPL.
 *)
let doprompt = ref true
@


<<[[Parse.lexfunc()]] possibly print the prompt>>=
(* less: could do that in caller? would remove need for doprompt *)
if !Prompt.doprompt
then Prompt.pprompt ();
@

<<signature [[Prompt.prompt]]>>=
val prompt : string ref
@
<<constant [[Prompt.prompt]]>>=
let prompt = ref "% "
@

% print prompt
<<signature [[Prompt.pprompt]]>>=
(* !will reset doprompt! *)
val pprompt : unit -> unit
@
<<function [[Prompt.pprompt]]>>=
let pprompt () =
  let t = R.cur () in
  if t.R.iflag then begin
    prerr_string !prompt;
    flush stderr;
    <<[[Prompt.pprompt()]] adjust [[prompt]] for next time>>
  end;
  (* alt: incr t.R.line; this is done in the lexer instead *)
  doprompt := false
@


<<[[Op_repl.op_REPL()]] set [[prompt]] if [[iflag]]>>=
(* set promptstr *)
if t.R.iflag then begin
  let promptv = (Var.vlook "prompt").R.v in
  Prompt.prompt := 
    (match promptv with
    | Some (x::_xs) -> x
    (* stricter? display error message if prompt set but no element?*)
    | Some [] | None -> "% "
    );
end;
@

% prompt has 2 parts? when regular and when follow antislash newline?
% this time the first part of the prompt

<<[[Lexer.token()]] space cases>>=
| '\\''\n'  {
    incr_lineno ();
    Prompt.pprompt ();
    token lexbuf
}    
@
\label{sec:escaping-newline}

<<[[Prompt.pprompt()]] adjust [[prompt]] for next time>>=
(* set promptstr for the next pprompt() *)
let promptv = (Var.vlook "prompt").R.v in
prompt := 
  (match promptv with
  | Some [_x;y] -> y
   (* stricter? display error message if prompt set no 2 elements?*)
  | Some _ | None -> "\t"
  );
@




\section{Operators ([[;]], [[&]], [[|]], [[<]], [[>]], [[$]], [[&&]], [[||]], \ldots)}
%alt: Symbols?

<<[[Lexer.token()]] symbol cases>>=
| ';'  { TSemicolon }
@
<<[[Lexer.token()]] symbol cases>>=
| "&"  { TAnd }
@

<<[[Lexer.token()]] symbol cases>>=
| ">"  { TRedir Ast.RWrite }
| "<"  { TRedir Ast.RRead }
| ">>" { TRedir Ast.RAppend }
@


<<[[Lexer.token()]] variable cases>>=
| "$"   { TDollar }
@

<<[[Lexer.token()]] symbol cases>>=
| '('  { TOPar }   | ')' { TCPar }
| '{'  { TOBrace } | '}' { TCBrace }
@
<<[[Lexer.token()]] symbol cases>>=
| '='  { TEq }
@


<<[[Lexer.token()]] symbol cases>>=
| "|"  { Globals.skipnl := true; TPipe }
@


\label{sec:skipnl}
<<constant [[Globals.skipnl]]>>=
(* This global is used by the lexer and parser to consider certain
 * newlines as regular spaces. Because rc is an interactive
 * interpreter, newline has a special meaning: it terminates a command.
 * However, sometimes we just want to add a newline because the command
 * is too long. Escaping the newline is one way to do it. 
 * But when we start to parse 'cmd1 &&' we know that we are expecting
 * more stuff. So after the && and other binary operators  we consider 
 * the newline not as a command terminator, but as a space.
 * Also we indent the prompt to let the user know he can still enter
 * more characters.
 *)
let skipnl = ref false
@

% reset
<<[[Parse.parse_line()]] locals and inits>>=
Globals.skipnl := false;
@
<<[[Parse.parse_line()]] locals and inits>>=
let got_skipnl_last_round = ref false in
@

<<[[Parse.lexfunc()]] adjustment for skipnl depending on [[tok]] read>>=
if !got_skipnl_last_round then begin
  if !tok = Parser.TNewline 
  then begin
    let rec loop () =
      Prompt.pprompt ();
      tok := Lexer.token lexbuf;
      if !tok = Parser.TNewline
      then loop ()
    in
    loop ()
  end;
  got_skipnl_last_round := false;
end;
if !Globals.skipnl 
then got_skipnl_last_round := true;
Globals.skipnl := false;
@
% subtle, first round when just got |, then got_skipnl_last_round
% is false so big code not executed but then skipnl reseted
% and got_skipnl is set to true
% next time for next token, then big code will be executed, and
% if token was newline then we actually don't return it
% and call tokenized until we have something different.


<<[[Lexer.token()]] symbol cases>>=
| "&&" { Globals.skipnl := true; TAndAnd }
| "||" { Globals.skipnl := true; TOrOr }
@

<<[[Lexer.token()]] symbol cases>>=
| "!" { TBang }
@

<<[[Lexer.token()]] symbol cases>>=
| "~" { TTwiddle } 
@




\section{Quoted strings ([['...']])}
\label{sec:quoting}

<<[[Lexer.token()]] quoted word cases>>=
| "'" { let s = quote lexbuf in TWord (s, true) }
@
% note that s will contain the string inside the quote, without
% enclosing quote! but allow to use special chars inside
% the quote at least, including newline, including quote itself by using it 2 times,
% a bit like %% in printf

% no double quote in rc, just single quote.
%TODO: double quote meaning? dump its AST/tokens for x="a b c d" vs 'a b c d' ??

<<rule [[Lexer.quote]]>>=
and quote = parse
  | "'" { "" } 
  | "''" { "'" ^ quote lexbuf } 
  | "\n" { 
      incr_lineno ();
      Prompt.pprompt ();
      "\n" ^ quote lexbuf
    }
  | [^'\'' '\n']+ { let s = Lexing.lexeme lexbuf in s ^ quote lexbuf }
  (* stricter: generate error *)
  | eof { error "unterminated quote" }
@

\section{Keywords and words ([[if]], [[for]], [[while]], [[switch]], [[fn]], \ldots )}

<<lexer regexp aliases>>=
(* original: !strchr("\n \t#;&|^$=`'{}()<>", c) && c!=EOF;
 * note that wordchr allows '~', '!', '@', '"', ','
 *)
let wordchr = [^'\n' ' ' '\t' '#'
                ';' '&' '|' '^' '$' '=' 
                '`' '\'' 
               '{''}' '('')' '<''>'
                ]
@
% see why need quote! for all those special characters!

<<[[Lexer.token()]] keywords and unquoted words cases>>=
| wordchr+ { 
  match Lexing.lexeme lexbuf with
  | "if"    -> TIf
  | "while" -> TWhile
  | "for"   -> TFor
  | "in"    -> TIn
  | "not"   -> TNot
  | "switch" -> TSwitch
  | "fn"     -> TFn
  | s -> TWord (s, false)
}
@


%******************************************************************************
\chapter{Parsing}
%******************************************************************************
\label{chap:parsing}

\section{[[parse_line()]] skeleton}

%trans: finally parse_line!

<<function [[Parse.parse_line]]>>=
let parse_line lexbuf =
  let curtok = ref (Parser.EOF, "EOF") in
  <<[[Parse.parse_line()]] locals and inits>>
  <<[[Parse.parse_line()]] nested function [[lexfunc]]>>
  try 
    Parser.rc lexfunc lexbuf
    <<[[Parse.parse_line()]] possibly dump AST>>
  with 
    | Parsing.Parse_error ->
        error "syntax error" !curtok
    | Lexer.Lexical_error s ->
        error (spf "lexical error, %s" s) !curtok
@
% 'rc' grammar rule!

<<[[Parse.lexfunc()]] adjust [[curtok]] with [[tok]]>>=
let s = Lexing.lexeme lexbuf in
curtok := (!tok, s);
@
% curtok for error management in parse_line only? ugly
%TODO: get rid of?, can still call Lexing.lexeme in exn handler?
% maybe can do 'Parser.rc (fun lexbuf -> let tok = lexfunc lexbuf; curtok := ....) ?


\section{Error location reporting}

<<[[Runtime.thread]] other fields>>=
(* for error reporting (None when reading from stdin) *)
(* less: file has to be mutable? could be a param of start? like chan? *)
mutable file: Common.filename option;
line: int ref;
@
<<[[Runtime.mk_thread()]] set other fields>>=
file = None;
line = ref 1;
@
% we saw set line to 1 also in?
% for file, who is setting it? when do . foo.sh! TODO ref?


<<function [[Lexer.incr_lineno]]>>=
(* we could do that in pprompt() too *)
let incr_lineno () =
  let t = Runtime.cur () in
  incr t.Runtime.line
@
\swdefs{incr_lineno}
%TODO: what is using t.line ??



<<function [[Parse.error]]>>=
let error s (curtok, curtokstr) =
  let t = R.cur () in
  let locstr =
    match t.R.file, t.R.iflag with
    | Some f, false -> spf "%s:%d: " f !(t.R.line)
    | Some f, true -> spf "%s: " f
    | None, false -> spf "%d: " !(t.R.line)
    | None, true -> ""
  in
  let tokstr = 
    match curtok with
    | Parser.TNewline -> ""
    | _ -> spf "token %s: " (curtokstr)
  in
  let str = spf "rc: %s%s%s" locstr tokstr s in

  (* todo: reset globals like lastdol, lastword *)
  (* less: error recovery, skip until next newline *)
  Status.setstatus s;

  (* less: nerror++; *)
  failwith str
@
%LP: setstatus later?



\section{Grammar overview}

% classic, lex/yacc

<<Parser.mly>>=
%{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Ast

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Parser.mk_seq]]>>
%}

/*(*************************************************************************)*/
/*(*1 Tokens *)*/
/*(*************************************************************************)*/
<<Parser tokens>>

/*(*************************************************************************)*/
/*(*1 Priorities *)*/
/*(*************************************************************************)*/
<<Parser token priorities>>

/*(*************************************************************************)*/
/*(*1 Rules type declaration *)*/
/*(*************************************************************************)*/
<<Parser entry points types>>

%%

<<grammar>>
@



% classic yacc too? some special prio?
% lower means higher priority so $ really tight to var
% TODO: example of AST dump of expression and see prio?

<<Parser token priorities>>=
/*(* from low to high *)*/
%left TIf TWhile TFor TSwitch TCPar TNot
%left TAndAnd TOrOr
%left TBang TSubshell
%left TPipe
%left TCaret
/*(* $$A -> ($ ($ A)) not (($ $) A) *)*/
%right TDollar TCount TStringify
%left TSub
@

<<Parser entry points types>>=
%type <Ast.line> rc
<<Parser other rule types>>
%start rc
@



<<grammar>>=
/*(*************************************************************************)*/
/*(*1 line *)*/
/*(*************************************************************************)*/
rc:
  | line TNewline { Some $1 }
  | EOF           { None }

<<rule [[Parser.line]]>>
<<other line related rules>>

/*(*************************************************************************)*/
/*(*1 Command *)*/
/*(*************************************************************************)*/

<<rule [[Parser.cmd]]>>
<<rule [[Parser.simple]]>>
<<other command related rules>>

/*(*************************************************************************)*/
/*(*1 Word *)*/
/*(*************************************************************************)*/

<<rule [[Parser.comword]]>>
<<rule [[Parser.word]]>>
<<other word related rules>>

/*(*************************************************************************)*/
/*(*1 Redirection *)*/
/*(*************************************************************************)*/

<<rule [[Parser.redir]]>>
<<other redirection related rules>>

/*(*************************************************************************)*/
/*(*1 Skipnl hacks *)*/
/*(*************************************************************************)*/

<<skipnl rules>>
@

%EOF case! None
%TNewline!

\section{Simple commands ([[<cmd> <arg1>...<argn>]]) }

% a line can have a single command (stmt)
<<rule [[Parser.line]]>>=
/*(* =~ stmt *)*/
line:
  | cmd { [$1] }
  <<[[Parser.line]] other cases>>
@
\swdefs{Parser.line}

<<Parser other rule types>>=
%type <Ast.cmd> cmd
@

% a (single) command can be a simple "expression"
<<rule [[Parser.cmd]]>>=
/*(* =~ expr *)*/
cmd:
  | /*empty*/ { EmptyCommand }
  | simple    { 
      let (cmd, args, redirs) = $1 in
      let args = List.rev args in
      let base = Simple (cmd, args) in
      <<[[Parser.cmd]] adjust [[base]] with [[redis]]>>
    }
  <<[[Parser.cmd]] other cases>>
@
% will see redirs later, but for now empty so return just base
% EmptyCommand also here, useful for Assign

<<Parser other rule types>>=
%type <value * value list * (redirection_kind * value, redirection_kind * int * int) either list> simple
@

<<rule [[Parser.simple]]>>=
/*(* =~ primary expr *)*/
simple:
  | first        { $1, [], [] }
  | simple word  { let (cmd, args, redirs) = $1 in (cmd, $2::args, redirs) }
  <<[[Parser.simple]] other cases>>
@
% List.rev above cos reverted here


<<Parser other rule types>>=
%type <Ast.value> first
@

<<other word related rules>>=
first:
  | comword           { $1 }
  <<[[Parser.first]] other cases>>
@

% command word (the first word)
<<rule [[Parser.comword]]>>=
comword:
  | TWord                         { Word (fst $1, snd $1) }
  <<[[Parser.comword]] other cases>>
@


<<rule [[Parser.word]]>>=
word:
  | comword          { $1 }
  | keyword          { Word ($1, false) }
  <<[[Parser.word]] other cases>>
@
% flexible language, not like regular lang where if forbidden,
% here if could be a filename argument of a command! it's just that
% it can't be the command name

<<other word related rules>>=
keyword:
  | TFor { "for" }  | TIn { "in" }
  | TIf { "if" }  | TNot { "not" }
  | TWhile { "while" }
  | TSwitch { "switch" }
  | TFn { "fn" }
  <<[[Parser.keyword]] other cases>>
@



\section{Operators}

\subsection{Sequence ([[;]], [[&]])}

<<[[Parser.line]] other cases>>=
| cmdsa line { $1 $2  }
@

% cmdsa = command sequence or and

<<other line related rules>>=
cmdsa:
  | cmd TSemicolon { (fun x -> mk_Seq ($1, x)) }
  | cmd TAnd       { (fun x -> mk_Seq (Async $1, x)) }
@
% $1 $2 and fun x -> ... grammar idiom

% so cmd1 & cmd2 is really cmd1& ; cmd2

<<function [[Parser.mk_seq]]>>=
(* This is a useful optimisation as you can get lots of EmptyCommand,
 * for instance, in {\nls\n} you will get 2 EmptyCommand (for each \n)
*)
let mk_Seq (a, b) =
  match a, b with
  | EmptyCommand, _ -> b
  | _, [EmptyCommand] -> [a]
  | _ -> a::b
@


\subsection{Logical operators  ([[&&]], [[||]], [[!]])}

<<[[Parser.cmd]] other cases>>=
| cmd TAndAnd cmd { And ($1, $3) }
| cmd TOrOr cmd   { Or  ($1, $3) }
| TBang cmd       { Not $2 }
@


<<[[Parser.keyword]] other cases>>=
| TBang { "!" }
@
% if not first word, then can be a parameter of a command


\subsection{String matching  (\texttt{\textasciitilde})}
%alt: move in advanced section, but nice to have a construct that
% can go inside 'if' otherwise have to talk about 'test' or '[' or bash

<<[[Parser.cmd]] other cases>>=
| TTwiddle word words { Match ($2, $3) }
@
% note that operator appears in first position, not binary operator
% kinda builtin command

% semantic will be if word match one of the other words (List.exists)

<<[[Parser.keyword]] other cases>>=
| TTwiddle { "~" }
@


<<other word related rules>>=
words: words_rev { List.rev $1 }
@
<<other word related rules>>=
words_rev:
  | /*empty*/  { [] }
  | words_rev word { $2::$1 }
@

\subsection{Pipe  ([[|]])}

<<[[Parser.cmd]] other cases>>=
| cmd TPipe cmd  { Pipe ($1, $3) }
@


\subsection{Redirections  ([[>]], [[<]])}

<<[[Parser.simple]] other cases>>=
| simple redir { let (cmd, args, redirs) = $1 in (cmd, args, $2::redirs) }
@
% add to redir, can have multiple redir! ex: cat < foo.txt > out.txt =~ cp :)

<<rule [[Parser.redir]]>>=
redir:
  | TRedir word { Left ($1, $2) }
  <<[[Parser.redir]] other cases>>
@


<<[[Parser.cmd]] adjust [[base]] with [[redis]]>>=
let redirs = List.rev redirs in
redirs |> List.fold_left (fun acc e ->
  match e with
  | Left (kind, word)    -> Redir (acc, (kind, word))
  | Right (kind, fd0, fd1) -> Dup (acc, kind, fd0, fd1)
) base
@

%TODO? dump AST and see tree or Redir enclosing each other

\section{Control flow statements ([[if]], [[if not]], [[while]], [[switch]], [[for]])}

<<[[Parser.cmd]] other cases>>=
| TIf paren_skipnl cmd { If ($2, $3) }
| TIf tnot_skipnl  cmd { IfNot $3 }
@

<<[[Parser.cmd]] other cases>>=
| TWhile paren_skipnl cmd   { While ($2, $3) }
@

<<skipnl rules>>=
paren_skipnl: paren { Globals.skipnl := true; $1 }
tnot_skipnl: TNot   { Globals.skipnl := true; }
@
% see \ref{sec:skipnl} before

<<other command related rules>>=
paren: TOPar body TCPar { $2 }
@
% body later but =~ cmd
% need paren to separate condition from cmd
% not that condition is a command too! exit code will determine
% (or can also be '~' )


<<[[Parser.cmd]] other cases>>=
| TSwitch word_skipnl brace { Switch ($2, $3) }
@
<<[[Ast.cmd]] other statement cases>>=
| Switch of value * cmd_sequence
@


<<[[Parser.cmd]] other cases>>=
/*(* I added the %prec TFor. *)*/
| TFor TOPar word TIn words tcpar_skipnl cmd %prec TFor { ForIn ($3, $5, $7) }
| TFor TOPar word tcpar_skipnl cmd           %prec TFor { For ($3, $5) }
@
<<[[Ast.cmd]] other statement cases>>=
| ForIn of value * values * cmd
(* less: could desugar as ForIn value $* *)
| For of value * cmd
@



<<skipnl rules>>=
word_skipnl: word   { Globals.skipnl := true; $1 }
tcpar_skipnl: TCPar { Globals.skipnl := true; }
@


\section{Grouping (\texttt{\{...\}})} 

% used in Switch above

% but can also be part of cmd

<<[[Parser.cmd]] other cases>>=
| brace epilog   { 
    let cmd = (Compound $1) in
    <<[[Parser.cmd]] in [[brace]] case, adjust [[cmd]] with [[epilog]]>>
}
@

<<[[Ast.cmd]] other statement cases>>=
| Compound of cmd_sequence
@
%$

<<other command related rules>>=
brace: TOBrace body TCBrace { $2 }
@
% so no diff with paren? brace can have epilog after

<<other command related rules>>=
body: 
  | cmd         { [$1] }
  | cmdsan body { $1 $2 }
@
<<other command related rules>>=
cmdsan:
  | cmdsa        { $1 }
  | cmd TNewline { (fun x -> mk_Seq ($1, x)) }
@
% so can have newline now! newline act as semicolon now when in body context!





<<other redirection related rules>>=
epilog:
  | /*empty*/    { [] }
  | redir epilog { $1::$2 }
@

<<[[Parser.cmd]] in [[brace]] case, adjust [[cmd]] with [[epilog]]>>=
$2 |> List.fold_left (fun acc e -> 
  match e with
  | Left (kind, word) -> Redir (acc, (kind, word))
  | Right (kind, fd0, fd1) -> Dup (acc, kind, fd0, fd1)
)  cmd
@


\section{Functions ([[fn <f> { ... }]])}

<<[[Parser.cmd]] other cases>>=
/*(* stricter: allow only word, not words *)*/
| TFn word brace { Fn ($2, $3) }
@

% function use =   [[f ( )]] so parsed as a simple command

\section{Variables ([[<x> = ...]], [[$x]])}

<<[[Parser.cmd]] other cases>>=
| assign cmd %prec TBang { $1 $2 }
@
% again $1 $2 idiom

% need %prec because?

<<other command related rules>>=
assign: first TEq word { (fun x -> Assign ($1, $3, x))  }
@
% x can be EmptyCommand when TNewline

<<[[Parser.comword]] other cases>>=
| TDollar word                  { Dollar $2 }
@

\section{Lists ([[(...)]])}

% note that have seen parens in if/while context but
% here different

<<[[Parser.comword]] other cases>>=
| TOPar words TCPar             { List $2 }
@


%\chapter{Checking}


%******************************************************************************
\chapter{Opcode Generation and Interpretation}
%******************************************************************************
\label{chap:compile-interpret}


\section{Overview}

%\subsection{[[emitxxx()]]}
\subsection{[[compile()]]}

<<function [[Compile.compile]]>>=
let compile (seq : Ast.cmd_sequence) : Opcode.codevec =

  (* a growing array *)
  let codebuf = ref [| |] in
  let len_codebuf = ref 0 in
  (* pointer in codebuf *)
  let idx = ref 0 in

  <<[[Compile.compile()]] nested function [[emit]]>>
  <<[[Compile.compile()]] nested function [[set]]>>

  outcode_seq seq !Flags.eflag (emit, set, idx);
  emit (O.F O.Return);
  (* less: O.F O.End *)
  (* less: heredoc, readhere() *)

  (* return the trimmed array *)
  Array.sub !codebuf 0 !idx
  <<[[Compile.compile()]] possibly dump returned opcodes>>
@

<<[[Opcode.operation]] other control cases>>=
| Return
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Return -> Process.return caps ()
@
\swdefs{O.Return}

<<[[Op_repl.op_REPL()]] match [[cmdset_opt]] other cases>>=
| None -> Process.return caps ()
@
% when return O.REPL(), and interpret_operation, will go gack to
% while loop of interpret_bootstrap and newt at the top of cur!
% so will execute that!

% called when REPL gets EOF too and cmdseq_opt is None (see section X
% with EOF rc case rule)
<<signature [[Process.return]]>>=
val return : < Cap.exit ; .. > -> unit -> unit
@

<<function [[Process.return]]>>=
(* Was called Xreturn but called not only from the opcode interpreter.
 * It is an helper function really.
 *)
let return (caps : < Cap.exit; .. >) () =
  <<[[Process.return()]] initializations>>
  match !R.runq with
  | [] -> failwith "empty runq"
  (* last thread in runq, we exit then *)
  | [_x] -> exit caps (Status.getstatus ())
  | _x::xs -> 
      R.runq := xs
@
% will see exit and getstatus later





<<[[Compile.compile()]] nested function [[emit]]>>=
let emit x =
  <<[[Compile.compile()]] nested function [[emit]] possibly grow [[codebuf]]>>
  !codebuf.(!idx) <- x;
  incr idx
in
@

<<[[Compile.compile()]] nested function [[emit]] possibly grow [[codebuf]]>>=
(* grow the array if needed *)
if !idx = !len_codebuf then begin
  len_codebuf := !len_codebuf + 100;
  codebuf := Array.append !codebuf (Array.make 100 (O.I 0));
end;
@


<<[[Compile.compile()]] nested function [[set]]>>=
let set idx2 x =
  <<[[Compile.compile()]] nested function [[set]] array bound checking>>
  !codebuf.(idx2) <- x;
in
@

<<[[Compile.compile()]] nested function [[set]] array bound checking>>=
if idx2 < 0 || idx2 >= !len_codebuf
then failwith (spf "Bad address %d in set()" idx2);
@

\subsection{[[outcode_seq()]] skeleton}

% return unit cos side effect on enclosing codebuf in compile()
% via emit or set or idx

<<function [[Compile.outcode_seq]]>>=
let outcode_seq (seq : Ast.cmd_sequence) eflag (emit,set,idx) : unit =

  let rec xseq (seq : Ast.cmd_sequence) eflag : unit =
   <<[[Compile.outcode_seq]] in nested [[xseq()]]>>
  
  and xcmd (cmd : Ast.cmd) eflag : unit =
    match cmd with
    <<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>
    | (A.Async _|
       A.Dup (_, _, _, _)|
       A.While (_, _)|
       A.ForIn (_, _, _)|
       A.For (_, _)
       )
       -> failwith ("TODO compile: " ^ Ast.show_cmd cmd)

 (* Do we need to pass eflag here too?
  * Even though types are mutually recursive because of Backquote, the
  * compilation of backquote does not use eflag!
  *)
  and xword (w : Ast.value) : unit =
    match w with
    <<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>
    | (A.CommandOutput _|
       A.Index (_, _)|
       A.Concat (_, _)|
       A.Stringify _
      )
       -> failwith ("TODO compile: " ^ Ast.show_value w)

  and xwords (ws : Ast.value list) : unit =
    <<[[Compile.outcode_seq]] in nested [[xwords()]]>>
  in
  xseq seq eflag
@




\section{Simple commands}

% reminder: ls /etc => Simple (Word "ls", [Word "/etc"])

\subsection{Opcode generation}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Simple (w, ws) -> 
    emit (O.F O.Mark);
    xwords ws;
    xword w;
    emit (O.F O.Simple);
    <<[[Compile.outcode_seq]] in [[A.Simple]] case after emit [[O.Simple]]>>
@
% need Mark so know when finish args

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Word (s, _quoted) ->
    emit (O.F O.Word);
    emit (O.S s);
@


\subsection{Stack management}

<<[[Compile.outcode_seq]] in nested [[xwords()]]>>=
ws |> List.rev |> List.iter (fun w -> xword w);
@
% List.rev! stack!

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.List ws ->
    xwords ws
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [string] *)
| O.Word ->
    let t = R.cur () in
    let pc = t.R.pc in
    let x = t.R.code.(!pc) in
    incr pc;
    (match x with
    | O.S s -> R.push_word s
    (* stricter: but should never happen *)
    | op -> failwith (spf "was expecting a S, not %s" (Opcode.show op))
    )
@
\swdefs{O.Word}
% remember pc already incremented in caller, so incr pc here to increment
% it even more to pass the inline string


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Mark -> R.push_list ()
@
\swdefs{O.Mark}

<<signature [[Runtime.push_list]]>>=
val push_list : unit -> unit
@
<<function [[Runtime.push_list]]>>=
let push_list () =
  let t = cur () in
  t.argv_stack <- t.argv :: t.argv_stack;
  t.argv <- []
@

<<[[Runtime.thread]] other fields>>=
(* Used for switch but also assignments. *)
mutable argv_stack: (string list) list;
@

<<[[Runtime.mk_thread()]] set other fields>>=
argv_stack = [];
@
% how can have enclosing argv_stack we need to save?

\subsection{[[O.Simple()]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (args) *)
| O.Simple -> Op_process.op_Simple caps ()
@
\swdefs{O.Simple}

<<function [[Op_process.op_Simple]]>>=
let op_Simple (caps : < Cap.fork; Cap.exec; Cap.wait; Cap.chdir; Cap.exit; ..>) () =
  let t = R.cur () in
  let argv = t.R.argv in
  <<[[Op_process.op_Simple()]] possibly dump command>>
  match argv with
  <<[[Op_process.op_Simple()]] match [[argv]] empty case>>
  | argv0::args ->
      match argv0 with
      <<[[Op_process.op_Simple()]] match [[argv0]] builtin cases>>
      | _ ->
        <<[[Op_process.op_Simple()]] when default case, before the fork>>
        (try 
          let pid = forkexec caps () in
          R.pop_list ();
          <<[[Op_process.op_Simple()]] when default case, after the fork>>
        with
          | Failure s ->
              E.error caps ("try again: " ^ s)
          | Unix.Unix_error (err, s1, s2) -> 
              E.error caps (Process.s_of_unix_error err s1 s2)
)
@
%$


<<signature [[Runtime.pop_list]]>>=
val pop_list : unit -> unit
@
<<function [[Runtime.pop_list]]>>=
let pop_list () =
  let t = cur () in
  match t.argv_stack with
  (* At the very beginning we do *=(argv) in bootstrap.
   * In that case, Assign will generate two pop_list, but for
   * the second one argv_stack becomes empty. The only thing
   * we must do is to empty argv then.
   *)
  | [] ->
     t.argv <- []
  | x::xs -> 
      t.argv_stack <- xs;
      t.argv <- x
@
% we need push_list with Mark before, so once done we need to restore

<<[[Op_process.op_Simple()]] when default case, before the fork>>=
(* if exitnext opti *)
flush stderr;
(* less: Updenv *)
@


\subsection{Builtin dispatch}

% before seeing main case and forkexec, see builtin special case
% when first word is a builtin

<<[[Op_process.op_Simple()]] match [[argv0]] builtin cases>>=
| s when Builtin.is_builtin s -> Builtin.dispatch caps argv0
@

<<signature [[Builtin.is_builtin]]>>=
val is_builtin : string -> bool
@
<<signature [[Builtin.dispatch]]>>=
(* execute the builtin *)
val dispatch : < Cap.chdir ; Cap.exit ; Cap.open_in; .. > -> string -> unit
@


<<[[Op_process.op_Simple()]] match [[argv0]] builtin cases>>=
(* todo: if argv0 is a function *)
| "builtin" -> 
    (match args with
    | [] ->
        Logs.err (fun m -> m "builtin: empty argument list");
        Status.setstatus "empty arg list";
        R.pop_list ()
    | argv0::_args ->
        R.pop_word ();
        Builtin.dispatch caps argv0
    )
@
%LP: split setstatus and move later


\subsection{Fork}

% Essence of a shell! Fork/exec/wait)! a 50LOC mini shell will be that

<<function [[Op_process.forkexec]]>>=
let forkexec (caps : < Cap.fork; Cap.exec; Cap.exit; .. >) () : int =
  let pid = CapUnix.fork caps () in
  (* child *)
  if pid = 0
  then begin
    (* less: clearwaitpids *)
    (* less: could simplify and remove this word if exec was not a builtin *)
    R.push_word "exec";
    exec caps ();
    (* should not be reached, unless prog could not be executed *)
    Process.exit caps ("can't exec: " ^ !Globals.errstr);
    0
  end
  else 
    (* parent *)
    (* less: addwaitpid *)
    pid
@
%LP: could aspectize the push_word "exec" here and in exec() below

\subsection{Exec}

<<function [[Op_process.exec]]>>=
let exec (caps : < Cap.exec; Cap.exit; .. >) () : unit =
  R.pop_word (); (* "exec" *)

  let t = R.cur () in
  let argv = t.R.argv in
  match argv with
  | [] -> E.error caps "empty argument list" 
  | prog::_xs -> 
      <<[[Op_process.exec()]] before [[execute]]>>
      execute caps argv (PATH.var_PATH_for_cmd_opt prog);
      (* should not be reached, unless prog could not be executed *)
      R.pop_list ()
@
% intermediate exec because also builtin so factorize code
%TODO: rename search_path_for_cmd? it's not actually trying to find prog!
% actually why need prog as a param?

<<function [[Op_process.execute]]>>=
let execute (caps : <Cap.exec; ..>) (args : string list) (var_PATH : Fpath.t list option) =

  let argv = Array.of_list args in
  let arg0 = argv.(0) in
  let errstr = ref "" in

  (* less: Updenv () *)
  let final_path : Fpath.t =
    match var_PATH with
    | None -> Fpath.v arg0
    | Some xs ->
        try 
          let dir = PATH.find_dir_with_cmd_in_PATH arg0 xs in
          dir / arg0
        with Not_found -> 
            Logs.err (fun m -> m "could not find %s in $path" arg0);
            Fpath.v arg0
  in
  (try 
      CapUnix.execv caps !!final_path argv |> ignore
    with Unix.Unix_error (err, s1, s2) ->
     errstr := Process.s_of_unix_error err s1 s2;
     Globals.errstr := s2
  );
  (* reached only when could not find a path *)
  Logs.err (fun m -> m "%s: %s" argv.(0) !errstr)
@
% List.iter ??
% path adjustment??


\subsection{Error management}

<<[[Op_process.op_Simple()]] match [[argv]] empty case>>=
(* How can you get an empty list as Simple has at least one word?
 * If you do A=()\n and then $A\n then Simple has a word, but after
 * expansion the list becomes empty.
 * stricter: I give extra explanations
 *)
| [] -> E.error caps "empty argument list (after variable expansion)" 
@


<<signature [[Error.error]]>>=
(* Will behave like a 'raise'. Will Return until you reach
 * the interactive thread and set the status to the error argument.
 * Mostly used by the builtins.
 *)
val error : < Cap.exit ; .. > -> string -> unit
@



<<function [[Error.error]]>>=
(* less: error1 similar to error but without %r *)
let error (caps: < Cap.exit; ..>) (s : string) =
  (* less: use argv0 *)
  (* less: use %r *)
  Logs.err (fun m -> m "rc: %s" s);

  Status.setstatus "error";

  while (R.cur ()).R.iflag do
    (* goes up the call stack, like when we have an exception *)
    Process.return caps ();
  done
@

<<constant [[Globals.errstr]]>>=
(* to mimic Plan 9 errstr() *)
let errstr = ref ""
@







<<signature [[Process.s_of_unix_error]]>>=
val s_of_unix_error : Unix.error -> string -> string -> string
@
<<function [[Process.s_of_unix_error]]>>=
let s_of_unix_error err _s1 _s2 = 
  spf "%s" (Unix.error_message err)
@

\subsection{[[$status]] management}

% in bash $$?

<<signature [[Status.setstatus]]>>=
val setstatus : string -> unit
@
<<function [[Status.setstatus]]>>=
let setstatus s =
  Var.setvar "status" [s]
@


<<signature [[Status.getstatus]]>>=
val getstatus : unit -> string
@
<<function [[Status.getstatus]]>>=
let getstatus () =
  let v = (Var.vlook "status").R.v in
  match v with
  | None -> ""
  | Some [x] -> x
  (* stricter: should never happen *)
  | Some _ -> failwith "getstatus: $status is a list with more than one element"
@
%$


<<signature [[Status.truestatus]]>>=
val truestatus : unit -> bool
@
<<function [[Status.truestatus]]>>=
let truestatus () : bool =
  let s = getstatus () in
  s = ""
  || s =~ "0+\\(|0+\\)*"
@
% | for pipe


\subsection{Wait}
% fork, exec, wait, the trinity

<<[[Op_process.op_Simple()]] when default case, after the fork>>=
(* do again even if was interrupted *)
while Process.waitfor caps pid = Process.WaitforInterrupted do
  ()
done
@

<<signature [[Process.waitfor]]>>=
val waitfor : < Cap.wait; .. > -> int (* pid *) -> waitfor_result
@


<<type [[Process.waitfor_result]]>>=
type waitfor_result =
  | WaitforInterrupted
  | WaitforFound
  | WaitforNotfound
@

% Capa waitfor!
<<function [[Process.waitfor]]>>=
let waitfor (caps : < Cap.wait; .. >) (pid : int) : waitfor_result =
  (* less: check for havewaitpid *)

  try 
    let rec loop () =
      let (pid2, status) = CapUnix.wait caps () in
      let status_str = 
        match status with
        | Unix.WEXITED i -> spf "%d" i
        | Unix.WSIGNALED i -> spf "signaled %d" i
        | Unix.WSTOPPED i -> spf "stopped %d" i
      in
      if pid = pid2
      then begin
        Status.setstatus status_str;
        WaitforFound
      end else begin
        !R.runq |> List.iter (fun t ->
          match t.R.waitstatus with
          | R.WaitFor pid ->
              if pid = pid2
              then t.R.waitstatus <- R.ChildStatus status_str;
          | R.ChildStatus _ | R.NothingToWaitfor -> ()
        );
        loop ()
      end
    in
    loop ()
  with Unix.Unix_error (err, s1, s2) ->
    Globals.errstr := s_of_unix_error err s1 s2;
    if err = Unix.EINTR
    then WaitforInterrupted
    else WaitforNotfound
@


\subsection{[[$path]] management}
\label{sec:path-management}

<<signature [[PATH.find_in_path]]>>=
val find_dir_with_cmd_in_PATH :
  string (* cmd *) -> Fpath.t list (* $path *) -> Fpath.t
@
%$

<<signature [[PATH.search_path_for_cmd]]>>=
(* Returns None when there is no need to use $path because the cmd is
 * already using an absolute, relative, or special path.
 *)
val var_PATH_for_cmd_opt : string (* cmd *) -> 
  Fpath.t list (* content of $path *) option
@
%$

<<function [[PATH.search_path_for_cmd]]>>=
let var_PATH_for_cmd_opt (s : string) : Fpath.t list option =
  (* no need for PATH resolution when commands use absolute, relative, or
   * special paths.
   *)
  if s =~ "^/" ||
     (* Plan 9 device paths *)
     s =~ "^#" || 
     s =~ "\\./" ||
     s =~ "\\.\\./"
  then None
  else
    let v = (Var.vlook "path").R.v in
    (match v with
    | None -> Some []
    | Some xs -> Some (Fpath_.of_strings xs)
    )
@

<<function [[PATH.find_in_path]]>>=
let find_dir_with_cmd_in_PATH (cmd : string) (paths : Fpath.t list) : Fpath.t =
  paths |> List.find (fun dir ->
    let res = Sys.file_exists !!(dir / cmd) in
    if res
    then Logs.info (fun m -> m "found %s in %s" cmd !!dir);
    res
  )

@
%TODO


%\subsection{Fork optimization}


\section{Operators}


\subsection{Basic sequence}

<<[[Compile.outcode_seq]] in nested [[xseq()]]>>=
(* less set iflast, for if not syntax error checking *)
seq |> List.iter (fun x -> xcmd x eflag)
@

% sequence is simply generating opcode for each cmd!

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.EmptyCommand -> ()
@


\subsection{Logical operators}


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.And (cmd1, cmd2) ->
    xcmd cmd1 false;
    emit (O.F O.True);
    let p = !idx in
    xcmd cmd2 eflag;

    set p (O.I !idx)
@
% True then execute pc+1 otherwise jump

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.True ->
    let t = R.cur () in
    let pc = t.R.pc in
    if Status.truestatus ()
    then incr pc
    else pc := int_at_address t (!pc)
@
\swdefs{O.True}

<<function [[Interpreter.int_at_address]]>>=
let int_at_address t pc =
  match t.R.code.(pc) with
  | O.I i -> i
  (* stricter: generate error, but should never happen *)
  | op -> failwith (spf "was expecting I, not %s at %d" 
                      (Opcode.show op) pc)
@


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Or (cmd1, cmd2) ->
    xcmd cmd1 false;
    emit (O.F O.False);
    let p = !idx in
    xcmd cmd2 eflag;

    set p (O.I !idx)
@

% similar but False

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.False ->
    let t = R.cur () in
    let pc = t.R.pc in
    if Status.truestatus ()
    then pc := int_at_address t (!pc)
    else incr pc
@
\swdefs{O.False}


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Not cmd ->
    xcmd cmd eflag;
    emit (O.F O.Not);
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Not ->
    Status.setstatus (if Status.truestatus() then "false" else "");
@
\swdefs{O.Not}
% "" means true (exit code 0), anything else is error (falsy)

\subsection{String matching}


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Match (w, ws) ->
    emit (O.F O.Mark);
    xwords ws;
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Match);
    <<[[Compile.outcode_seq]] in [[A.Match]] case after emit [[O.Match]]>>
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (pat, str) *)
| O.Match ->
    let t = R.cur () in
    let argv = t.R.argv in
    let subject = String.concat " " argv in
    Status.setstatus "no match";
    R.pop_list ();
    let argv = t.R.argv in
    argv |> List.exists (fun w -> 
      if Pattern.match_str subject w
      then begin
        Status.setstatus "";
        true
      end else false
    ) |> ignore;
    R.pop_list ();
@
\swdefs{O.Match}

\section{Redirection}
% could be part of Operators, but better higher level in TOC

%\subsection{Trace of a redirection}
%\subsubsection{[[Redir]]}
%\subsubsection{[[doredir()]]}

\subsection{Opcode generation}


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Redir (cmd, (redir_kind, word)) ->
    (* resolve the filename *)
    emit (O.F O.Mark);
    xword word;
    emit (O.F O.Glob);

    (match redir_kind with
    | A.RWrite ->
        emit (O.F O.Write);
        emit (O.I 1);
    (* less: and A.RHere *)
    | A.RRead -> 
        emit (O.F O.Read);
        emit (O.I 0);
    | A.RAppend -> 
        emit (O.F O.Append);
        emit (O.I 1);
    | _ -> failwith ("TODO compile: " ^ Ast.show_cmd cmd)
    );
    
    (* perform the command *)
    xcmd cmd eflag;
    emit (O.F O.Popredir);
@

% Glob!

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Popredir ->
    R.pop_redir ()
@
\swdefs{O.Popredir}

\subsection{[[O.Write()]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (file)[fd] *)
| O.Write ->
    let t = R.cur () in
    let argv = t.R.argv in
    let pc = t.R.pc in
    (match argv with
    | [file] ->
        (try 
          let fd_from = 
            Unix.openfile file [Unix.O_CREAT;Unix.O_WRONLY] 0o666 in
          (* should be stdout *)
          let fd_to =
            let i = int_at_address t !pc in
            file_descr_of_int i
          in
          R.push_redir (R.FromTo (fd_from, fd_to));
          incr pc;
          R.pop_list();
        with Unix.Unix_error (_err, _s1, _s2) ->
          prerr_string (spf "%s: " file);
          E.error caps "can't open"
        )
    | []       -> E.error caps "> requires file"
    | _x::_y::_xs -> E.error caps "> requires singleton"
    )
@
\swdefs{O.Write}

<<function [[Interpreter.file_descr_of_int]]>>=
(* could be in runtime.ml *)
let file_descr_of_int i =
  match i with
  | 0 -> Unix.stdin
  | 1 -> Unix.stdout
  | 2 -> Unix.stderr
  (* todo: how do that? if do >[1=4] ?? *)
  | n -> failwith (spf "file_descr_of_int: unsupported int %d" n)
@


<<signature [[Runtime.push_redir]]>>=
val push_redir : redir -> unit
@

<<function [[Runtime.push_redir]]>>=
let push_redir (x : redir) : unit =
  let t = cur () in
  match t.redirections with
  | [] -> failwith "push_redir: no starting redir"
  | xs::xxs -> t.redirections <- (x::xs)::xxs
@


\subsection{[[O.Read()]]}
%TODO: O.Read not implemented yet 

\subsection{[[O.Append()]]}
%TODO: O.Append

\subsection{Closing redirection opened files}




<<signature [[Runtime.pop_redir]]>>=
val pop_redir : unit -> unit
@
<<function [[Runtime.pop_redir]]>>=
let pop_redir () =
  let t= cur () in
  match t.redirections with
  | [] -> failwith "pop_redir: no starting redir"
  | []::_xxs -> failwith "popredir null!"
  | (x::xs)::xxs ->
      t.redirections <- xs::xxs;
      (match x with
      | FromTo (fd_from, _fd_to) ->
          Unix.close fd_from
      | Close _ ->
          ()
      )
@


<<[[Process.return()]] initializations>>=
R.turf_redir ();
@
%???

<<signature [[Runtime.turf_redir]]>>=
val turf_redir : unit -> unit
@

<<function [[Runtime.turf_redir]]>>=
let turf_redir () =
  let t = cur () in
  while List.hd t.redirections <> [] do
    pop_redir ()
  done
@

<<[[Op_process.exec()]] before [[execute]]>>=
R.doredir t.R.redirections;
@

<<signature [[Runtime.doredir]]>>=
val doredir : redir list list -> unit
@
<<function [[Runtime.doredir]]>>=
let doredir xxs =
  xxs |> List.flatten |> List.rev |> List.iter (fun redir ->
    match redir with
    | FromTo (xfrom, xto) ->
        Unix.dup2 xfrom xto;
        Unix.close xfrom
    | Close from ->
        Unix.close from
  )
@



\section{Pipe}

\subsection{Opcode generation}

%\subsubsection{Trace of a pipe}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Pipe (cmd1, cmd2) ->
    emit (O.F O.Pipe);
    emit (O.I 1); (* left fd *)
    emit (O.I 0); (* right fd *)

    let p = !idx in
    emit (O.I 0);
    let q = !idx in
    emit (O.I 0);

    (* will be executed in a forked child, hence Exit *)
    xcmd cmd1 eflag;
    emit (O.F O.Exit);

    (* will be executed in a children thread, hence Return *)
    set p (O.I !idx);
    xcmd cmd2 eflag;
    emit (O.F O.Return);

    (* will be executed by parent once the children thread finished *)
    set q (O.I !idx);
    emit (O.F O.PipeWait);
@

\subsection{[[O.Pipe()]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [i j]{... Xreturn}{... Xreturn} *)
| O.Pipe -> 
    let t = R.cur () in
    let pc = t.R.pc in
    (* left file descriptor, should be stdout *)
    let lfd =
      let i = int_at_address t !pc in
      file_descr_of_int i
    in
    incr pc;
    (* right file descriptor, should be stdin *)
    let rfd =
      let i = int_at_address t !pc in
      file_descr_of_int i
    in
    incr pc;

    let (pipe_read, pipe_write) = Unix.pipe () in
    let forkid = CapUnix.fork caps () in

    (* child *)
    if forkid = 0 then begin
      (* less: clearwaitpids () *)
      (* pc + 2 to jump over the jump addresses *)
      let newt = R.mk_thread t.R.code (!pc + 2) t.R.locals in
      R.runq := [newt];
      Unix.close pipe_read;
      R.push_redir (R.FromTo (pipe_write, lfd));
    (* parent *)
    end else begin
      (* less: addwaitpid () *)
      let newt = 
        R.mk_thread t.R.code (int_at_address t (!pc+0)) t.R.locals in
      R.runq := newt::!R.runq;
      Unix.close pipe_write;
      R.push_redir (R.FromTo (pipe_read, rfd));
    
     (* once newt finished, jump to Xpipewait *)
      pc := int_at_address t (!pc+1);
      t.R.waitstatus <- R.WaitFor forkid;
    end
@
\swdefs{O.Pipe}

\subsection{[[O.Exit()]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Exit -> 
    (* todo: trapreq *)
    Process.exit caps (Status.getstatus())
@
\swdefs{O.Exit}

<<signature [[Process.exit]]>>=
val exit : < Cap.exit ; .. > -> string -> unit
@
<<function [[Process.exit]]>>=
let exit (caps: < Cap.exit; ..>) s =
  (* todo: Updenv *)
  Status.setstatus s;
  (* todo: how communicate error to parent process under Unix? 
   * alt: raise Exit.ExitCode which removes the need for Cap.exit
   *)
  CapStdlib.exit caps (if Status.truestatus () then 0 else 1)
@


\subsection{[[O.PipeWait()]]}

<<[[Opcode.operation]] other pipe cases>>=
| PipeWait (* argument passed through Thread.pid *)
@
<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* argument passed through Thread.pid *)
| O.PipeWait -> 
    let t = R.cur () in
    (match t.R.waitstatus with
    (* stricter: *)
    | R.NothingToWaitfor -> 
        failwith "Impossible: NothingToWaitfor for PipeWait"
    (* a previous waitfor() already got it *)
    | R.ChildStatus status -> 
        Status.setstatus (Status.concstatus status (Status.getstatus()));
    | R.WaitFor pid ->
        let status = Status.getstatus () in
        (* will internally call setstatus() when it found the right child *)
        Process.waitfor caps pid |> ignore;
        t.R.waitstatus <- R.NothingToWaitfor;
        Status.setstatus (Status.concstatus (Status.getstatus()) status);
    )
@
\swdefs{O.PipeWait}

<<signature [[Status.concstatus]]>>=
val concstatus : string -> string -> string
@
<<function [[Status.concstatus]]>>=
let concstatus s1 s2 =
  s1 ^ "|" ^ s2
@


\section{Asynchronous execution}

%TODO: not implemented yet


\section{Control flow statements}

\subsection{[[if]]}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.If (cmds, cmd) ->
    xseq cmds false;
    emit (O.F O.If);
    let p = !idx in
    emit (O.I 0);
    xcmd cmd eflag;
    emit (O.F O.Wastrue);
    set p (O.I !idx);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.If ->
    let t = R.cur () in
    let pc = t.R.pc in

    Globals.ifnot := true;
    if Status.truestatus()
    then incr pc
    else pc := int_at_address t (!pc);
@
\swdefs{O.If}

\subsection{[[if not]]}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.IfNot ->
    let t = R.cur () in
    let pc = t.R.pc in
    if !Globals.ifnot
    then incr pc
    else pc := int_at_address t (!pc);
@
\swdefs{O.IfNot}

<<constant [[Globals.ifnot]]>>=
(* Set to true at the beginning of an if and back to false
 * if rc executes the then branch. Kept to true otherwise
 * so next IfNot will run.
 *)
let ifnot = ref false
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Wastrue ->
    Globals.ifnot := false
@
\swdefs{O.Wastrue}


<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.IfNot cmd ->
    emit (O.F O.IfNot);
    let p = !idx in
    emit (O.I 0);
    xcmd cmd eflag;
    set p (O.I !idx);
@


\subsection{[[while]]}

%TODO: not implemented

\subsection{[[for]]}

%TODO: not implemented

<<[[Opcode.operation]] other control cases>>=
| For   (* (var, list){... Xreturn} *)
@

\subsection{[[switch]]}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Switch (w, cmds) ->

    (match cmds with
    | (A.Simple (A.Word ("case", false), _))::_ -> ()
    | _ -> failwith "case missing in switch"
    );

    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Jump);

    let nextcase = !idx in
    emit (O.I 0);
    let out = !idx in
    emit (O.F O.Jump);
    let leave = !idx in
    emit (O.I 0);
    
    set nextcase (O.I !idx);

    let aux cmds =
      match cmds with
      | [] -> ()
      | (A.Simple (A.Word ("case", false), ws))::cmds ->
          emit (O.F O.Mark);
          xwords ws;
          emit (O.F O.Case);
          let nextcase = !idx in
          emit (O.I 0);

          let cmds_for_this_case, _other_cases = split_when_case cmds in
          cmds_for_this_case |> List.iter (fun cmd ->
            xcmd cmd eflag
          );
          emit (O.F O.Jump);
          emit (O.I out);
          set nextcase (O.I !idx);
      | _ -> failwith "case missing in switch"
    in
    aux cmds;
    set leave (O.I !idx);
    (* can not call pop_list(), here, otherwise circular deps *)
    emit (O.F O.Popm);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* [addr] *)
| O.Jump ->
    let t = R.cur () in
    let pc = t.R.pc in
    pc := int_at_address t (!pc);
@
\swdefs{O.Jump}


<<[[Opcode.operation]] other control cases>>=
| Case  (* (pat, value){...} *)
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (pat, value){...} *)
| O.Case ->
    let t = R.cur () in
    let pc = t.R.pc in
    let s = List.hd t.R.argv_stack |> String.concat " " in
    let argv = t.R.argv in
    let match_found = argv |> List.exists (fun w -> Pattern.match_str s w) in
    (if match_found
    then incr pc
    else pc := int_at_address t (!pc)
    );
    R.pop_list ();
@
\swdefs{O.Case}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (value) *)
| O.Popm ->
    R.pop_list ()
@
\swdefs{O.Popm}


<<function [[Compile.split_when_case]]>>=
let split_when_case cmds =
  cmds |> Common2.span (function
    | (A.Simple (A.Word ("case", false), _)) -> false
    | _ -> true
  )
@


\subsection{Blocks: \texttt{'\{...\}'}}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Compound seq -> xseq seq eflag
@
% simple :)

\section{Functions}

\subsection{Function definitions ([[fn <foo> { ... }]])}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Fn (w, cmds) ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Fn);
    let p = !idx in
    (* less: emit str of fn *)
    emit (O.S "Fn String Todo?");
    xseq cmds eflag;
    emit (O.F O.Unlocal);
    emit (O.F O.Return);
    set p (O.I !idx);
@

%O.Fn TODO

\subsection{Function uses ([[<foo>(...)]])}


\section{Variables}

\subsection{Variable definitions ([[<x>=...]])}

<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.Assign (val1, val2, cmd) ->
    let all_assigns, cmd = 
      split_at_non_assign (A.Assign (val1, val2, cmd)) in
    (match cmd with
    (* A=b; *)
    | A.EmptyCommand -> 
        all_assigns |> List.iter (fun (val1, val2) ->
          emit (O.F O.Mark);
          xword val2;
          emit (O.F O.Mark);
          xword val1;
          emit (O.F O.Assign);
        )

    (* A=b cmd; *)
    | _ -> 
        all_assigns |> List.iter (fun (val1, val2) ->
          emit (O.F O.Mark);
          xword val2;
          emit (O.F O.Mark);
          xword val1;
          emit (O.F O.Local);
        );
        xcmd cmd eflag;
        all_assigns |> List.iter (fun (_, _) ->
          emit (O.F O.Unlocal);
        )
    )
@


<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) (val) *)
| O.Assign ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] ->
        (* no call to globlist for varname as it can be "*" for $* *)
        (* less: deglob varname *)
        let v = Var.vlook varname in
        R.pop_list ();

        (* less: globlist for the arguments *)
        let argv = t.R.argv in
        v.R.v <- Some argv;
        R.pop_list ();

    | _ -> E.error caps "variable name not singleton!"
    )
@
\swdefs{O.Assign}

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) (val) *)
| O.Local ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] ->
      (* less: deglob varname *)
      R.pop_list ();
      (* less: globlist *)
      let argv = t.R.argv in
      Hashtbl.add t.R.locals varname { R.v = Some argv };
      R.pop_list ();
    | _ -> E.error caps "variable name not singleton!"
    )
@
\swdefs{O.Local}

<<function [[Compile.split_at_non_assign]]>>=
let rec split_at_non_assign = function
  | A.Assign (val1, val2, cmd) ->
      let (a,b) = split_at_non_assign cmd in
      (val1, val2)::a, b
  | b -> [], b
@


\subsection{Variable uses ([[$<x>]])} %$

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Dollar w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Dollar);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.Dollar ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] -> 
       (* less: deglob varname *)
       (try 
          let value = vlook_varname_or_index varname in
          R.pop_list ();
          let argv = t.R.argv in
          let newargv = 
            (match value with None -> [] | Some xs -> xs) @ argv in
          t.R.argv <- newargv
        with Failure s -> E.error caps s
       )             
    | _ -> E.error caps "variable name not singleton!"
    )
@
\swdefs{O.Dollar}

\subsection{Special variables} %$
\label{sec:special-variables}

<<function [[Interpreter.vlook_varname_or_index]]>>=
let vlook_varname_or_index varname =
  if varname =~ "^[0-9]+$"
  then
    let i = int_of_string varname in
    let v = (Var.vlook "*").R.v in
    (match v with
    (* stricter: array out of bound checking *)
    | None -> failwith "undefined $*"
    | Some xs -> 
        (* list indexes in rc starts at 1, not 0 *)
        if i >= 1 && i <= List.length xs
        then Some ([List.nth xs (i-1)])
        else failwith (spf "out of bound, $%d too big for $*" i)
    )
  else (Var.vlook varname).R.v
@

%\subsection{Interpolation}


%******************************************************************************
\chapter{Builtins}
%******************************************************************************
\label{chap:builtins}

\section{Overview}

<<function [[Builtin.is_builtin]]>>=
let is_builtin s =
  List.mem s [
    "cd"; 
    "."; 
    "eval";
    "exit";
    "flag";
    "finit";
    (* new in ocaml *)
    "show";
  ]
@
%TODO: "exec" ?

% op_SIMPLE -> <>
<<function [[Builtin.dispatch]]>>=
let dispatch (caps : < Cap.chdir; Cap.exit; Cap.open_in; ..>) s =
  match s with
  <<[[Builtin.dispatch()]] match [[s]] cases>>
  | "show" -> 
      let t = R.cur () in
      let argv = t.R.argv in
      (match argv with
      | [_show;"vars"] ->
          Logs.app (fun m -> m "--- GLOBALS ---");
          R.globals |> Hashtbl_.to_list |> Assoc.sort_by_key_lowfirst |>
          List.iter (fun (k, v) ->
              Logs.app (fun m -> m "%s=%s" k (Runtime.string_of_var v))
          );
          Logs.app (fun m -> m "--- LOCALS ---");
          t.R.locals |> Hashtbl.iter (fun k v ->
              Logs.app (fun m -> m "%s=%s" k (Runtime.string_of_var v))
          );
          Logs.app (fun m -> m "--- FUNCTIONS ---");
          R.fns |> Hashtbl.iter (fun k fn ->
              Logs.app (fun m -> m "%s=%s" k (Runtime.show_fn fn))
          );
          ()
      | _ -> E.error caps ("Usage: show (vars|thread)")
      );


  | _ -> failwith (spf "unsupported builtin %s" s)
@
%$

\section{[[cd]]}

<<[[Builtin.dispatch()]] match [[s]] cases>>=
| "cd" -> 
    let t = R.cur () in
    let argv = t.R.argv in
    (* default value in case something goes wrong below *)
    Status.setstatus "can't cd";

    (* less: cdpath vlook *)
    (match argv with
    | [_cd] -> 
        let v = (Var.vlook "home").R.v in
        (match v with
        | Some (dir::_) ->
          if dochdir caps dir
          then Status.setstatus ""
          (* less: %r *)
          else Logs.err (fun m -> m "Can't cd %s" dir)
        | _ -> Logs.err (fun m -> m "Can't cd -- $home empty")
        )
    | [_cd;dir] ->
        (* less: cdpath iteration *)
        if dochdir caps dir
        then Status.setstatus ""
        else Logs.err (fun m -> m "Can't cd %s" dir)
    | _ ->
        Logs.err (fun m -> m "Usage: cd [directory]");
    );
    R.pop_list()
@

<<function [[Builtin.dochdir]]>>=
let dochdir (caps : < Cap.chdir; .. >) s =
  try 
    Logs.info (fun m -> m "about to chdir to %s" s);
    CapUnix.chdir caps s;
    true
  with Unix.Unix_error _ ->
    false
@

\section{[[show]]}
% new! not in original rc; similar to git show, semgrep show, dune show

\section{[[exit]]}

\section{[['.']]}

<<[[Builtin.dispatch()]] match [[s]] cases>>=
| "." ->
    let t = R.cur () in
    R.pop_word (); (* "." *)

    if !ndots > 0
    then Globals.eflagok := true;
    incr ndots;

    let iflag =
      match t.R.argv with
      | "-i"::_xs -> R.pop_word (); true
      | _ -> false
    in
    (match t.R.argv with
    | [] -> E.error caps "Usage: . [-i] file [arg ...]"
    | zero::args ->
        R.pop_word ();
        (* less: searchpath, also for dot? seems wrong *)
        (try 
          let file = zero in
          Logs.info (fun m -> m "evaluating %s" file);
          let chan = CapStdlib.open_in caps file in
          let newt = R.mk_thread dotcmds 0 (Hashtbl.create 10) in
          R.runq := [newt];
          R.push_redir (R.Close (Unix.descr_of_in_channel chan));
          newt.R.file <- Some file;
          newt.R.lexbuf <- Lexing.from_channel chan;
          newt.R.iflag <- iflag;
          (* push for $* *)
          R.push_list ();
          newt.R.argv <- args;
          (* push for $0 *)
          R.push_list ();
          newt.R.argv <- [zero];

        with Failure _ ->
          prerr_string (spf "%s: " zero);
          E.error caps ".: can't open"
        )
    ) 
@


<<constant [[Builtin.ndots]]>>=
let ndots = ref 0
@


<<constant [[Builtin.dotcmds]]>>=
(* for the builtin '.' (called 'source' in bash) *)
let dotcmds = 
  [|
    O.F O.Mark;
      O.F O.Word;
      O.S "0";
    O.F O.Local;

    O.F O.Mark;
      O.F O.Word;
      O.S "*";
    O.F O.Local;

    O.F O.REPL;

    O.F O.Unlocal;
    O.F O.Unlocal;
    O.F O.Return;
  |]         
@

\section{[[eval]]}%$

\section{[[flag]]}
% put earlier? used heavily in rcmain

<<global [[Flags.hflags]]>>=
let hflags: char Hashtbl_.set = Hashtbl.create 10
@

<<[[CLI.main()]] other initializations>>=
(* for 'flags' builtin (see builtin.ml) *)
argv |> Array.iter (fun s ->
  if s =~ "^-\\([a-zA-Z]\\)"
  then begin
    let letter = Regexp_.matched1 s in
    let char = String.get letter 0 in
    Hashtbl.add Flags.hflags char true
  end
);
@

<<[[Builtin.dispatch()]] match [[s]] cases>>=
| "flag" -> 
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [_flag;letter] ->
        (* stricter: *)
        if String.length letter <> 1
        then E.error caps "flag argument must be a single letter"
        else begin
          let char = String.get letter 0 in
          let is_set = Hashtbl.mem Flags.hflags char in
          Status.setstatus (if is_set then "" else "flag not set");
        end

    | [_flag;_letter;_set] ->
        failwith "TODO: flag letter +- not handled yet"

    | _ -> E.error caps ("Usage: flag [letter] [+-]")
    );
    R.pop_list()

@

\section{[[finit]]}

<<[[Builtin.dispatch()]] match [[s]] cases>>=
| "finit" -> 
   (* less: Xrdfn *)
   R.pop_list ()
@

%TODO: not implemented, partly because rely on /env/ and is
% a bit Plan9 specific in Shell.nw

\section{[[wait]]}



%******************************************************************************
\chapter{Environment}
%******************************************************************************
\label{chap:environment}
%alt: worth a chapter? merge with initialization?

\section{[[Var.init()]]}

<<function [[Var.vinit]]>>=
let init (caps : < Cap.env; .. >) =
  Logs.info (fun m -> m "load globals from the environment");
  let xs = Env.read_environment caps in
  xs |> List.iter (fun (k, vs) ->
    match k, vs with
    | "PATH", [x] ->
       Logs.info (fun m -> m "adjust $PATH to $path");
       let vs = Regexp_.split "[:]" x in
       let k = "path" in
       setvar k vs
    | _ -> setvar k vs
  );
@

\section{[[Var.update_env()]]}



%\section{Functions in the environment}
% see also finit builtin

%******************************************************************************
\chapter{Signals}
%******************************************************************************
\label{chap:signals}




%******************************************************************************
\chapter{Initialization}
%******************************************************************************
\label{chap:initialization-real}

\section{Actual bootstrapping code}

<<function [[CLI.bootstrap]]>>=
(* This is more complex than just [| O.REPL |] in _bootstrap_simple.
 * The opcodes below correspond to this shell code:
 *
 *       *=(argv); . /usr/lib/rcmain $*
 *
 * /usr/lib/rcmain itself contains code roughly equivalent to '. /dev/stdin'
 * that will trigger reading commands from the standard input.
 *
 * Note that boostrap is now a function because it uses a flag that can be
 * modified after startup.
 *)
let bootstrap () : O.codevec = 
  [| 
      O.F O.Mark;
        O.F O.Word;
        O.S "*";
      O.F O.Assign; (* will pop_list twice *)

      O.F O.Mark;
        O.F O.Mark;
          O.F O.Word;
          O.S "*";
        O.F O.Dollar; (* will pop_list once *)
        O.F O.Word;
        O.S !Flags.rcmain; (* can be changed -m *)
        O.F O.Word;
        O.S ".";
      O.F O.Simple; (* will pop_list once *)

      O.F O.Exit;
  |]
@
%$

\section{Intitialization script and [[rc -m /path/to/rcmain]]}

<<constant [[Flags.rcmain]]>>=
(* can be changed with -m *)
let rcmain = ref "/rc/lib/rcmain"
@

<<[[CLI.main()]] [[options]] elements>>=
"-m", Arg.Set_string Flags.rcmain,
" <file> read commands to initialize rc from file, not /rc/lib/rcmain";
@

% show content? also in appendix?

\section{Actual environment}

% C code setvar "pid" and "rcname". Useful?


%******************************************************************************
\chapter{Globbing}
%******************************************************************************
\label{chap:globbing}
%TODO: move in previous chapter like other features? it is an
% opcode in the end

<<[[Opcode.operation]] other cases>>=
(* Globbing *)
| Glob (* (value?) *)
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (value?) *)
| O.Glob ->
    Logs.err (fun m -> m "TODO: interpret Glob");
    ()
@
\swdefs{O.Glob}

%TODO: but should be emitted far more no? Even in Simple
% we should emit no?

\section{Lexing globbing characters}

\section{Expanding globbing characters}

\section{[[glob()]]}

\section{[[match()]]}






%******************************************************************************
\chapter{Debugging for the [[rc]] User}
%******************************************************************************
\label{chap:debugging}

\section{Printing commands: [[rc -x]]}

<<constant [[Flags.xflag]]>>=
(* -x, to print simple commands before executing them *)
let xflag = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-x", Arg.Set Flags.xflag,
" print each simple command before executing it";
@

<<[[Op_process.op_Simple()]] possibly dump command>>=
(* less: globlist () *)
if !Flags.xflag 
then Logs.app (fun m -> m "|%s|" (String.concat " " argv));
@

\section{Printing subprocesses status: [[rc -s]]}

<<constant [[Flags.sflag]]>>=
(* -s, to print status when error in command just ran *)
let sflag = ref false
@

<<[[CLI.main()]] [[options]] elements>>=
"-s", Arg.Set Flags.sflag,
" print exit status after any command where the status is non-null";
@
<<[[Op_repl.op_REPL()]] if [[sflag]]>>=
(* todo: flush error and reset error count *)
if !Flags.sflag && not (Status.truestatus()) 
then Logs.app (fun m -> m "status=%s" (Status.getstatus ()));
@

\section{Logging: [[rc -v]]}
%ocaml: NEW

<<[[CLI.main()]] debugging initializations>>=
let level = ref (Some Logs.Warning) in
@

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
(* TODO: move in a CLI_common.ml *)
"-v", Arg.Unit (fun () -> level := Some Logs.Info),
 " verbose mode";
"-verbose", Arg.Unit (fun () -> level := Some Logs.Info),
" verbose mode";
"-quiet", Arg.Unit (fun () -> level := None),
" ";
"-debug", Arg.Unit (fun () -> level := Some Logs.Debug),
" trace the main functions";
@

<<[[CLI.main()]] logging initializations>>=
Logs.set_level !level;
Logs.info (fun m -> m "ran as %s from %s" argv.(0) (Sys.getcwd ()));
@

\section{Failing fast: [[rc -e]]}
% very important, especially when using rc with mk!

<<constant [[Flags.eflag]]>>=
(* -e, for strict error checking. Abort the script when an error happens.*)
let eflag = ref false
@
% passed down a lot in outcode (why not use Flags.eflag instead
% of passing it down?)

<<[[CLI.main()]] [[options]] elements>>=
"-e", Arg.Set Flags.eflag,
" exit if $status is non-null after a simple command";
@



<<[[Opcode.operation]] other cases>>=
(* Error management *)
| Eflag
@

<<[[Compile.outcode_seq]] in [[A.Simple]] case after emit [[O.Simple]]>>=
if eflag 
then emit (O.F O.Eflag);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
| O.Eflag ->
    if !Globals.eflagok && not (Status.truestatus())
    then Process.exit caps (Status.getstatus())
@
\swdefs{O.Eflag}

<<[[Compile.outcode_seq]] in [[A.Match]] case after emit [[O.Match]]>>=
if eflag 
then emit (O.F O.Eflag);
@
% why eflag also for Match?

\section{Strict mode: [[rc -strict]]}
%ocaml: NEW

<<constant [[Flags.strict_mode]]>>=
let strict_mode = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-strict", Arg.Set Flags.strict_mode,
" strict mode";
@

%******************************************************************************
\chapter{Advanced Features}
%******************************************************************************
\label{chap:advanced-topics}

%alt: Advanced Topics

%\section{Shell-like features implemented outside [[rc]]}
% completion, history (readline?), ...
% done in rio!


\section{Advanced flags}

\subsection{Reading commands from a string: [[rc -c]]}
\label{sec:rc-c}

\subsection{Restrict [[$path]] candidates: [[rc -p]]}

<<[[CLI.main()]] [[options]] elements>>=
"-p", Arg.Unit (fun () -> ()),
" restrict $path to just (/bin /usr/bin)";
@
% -p looks like it was dead code in Shell.nw because never used
% and not used here either in the OCaml code,
% but it's because it is used in rcmain via 'flag p'!!
% see \ref{sec:rcmain}
% to set path to just bin and /usr/bin instead of calling finit
% the man page of rc in 9base says "a no op" but rcmain use it actually

%TODO: what about -d

%\section{Unicode}

\section{Advanced constructs}



<<[[Ast.cmd]] other definition cases>>=
| DelFn of value
@
<<[[Opcode.operation]] other cases>>=
| DelFn (* (name) *)
(* less: RdFn *)
@
<<[[Parser.cmd]] other cases>>=
| TFn word       { DelFn $2 }
@
<<[[Compile.outcode_seq]] in nested [[xcmd()]] match [[cmd]] cases>>=
| A.DelFn w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.DelFn);
@

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.DelFn ->
    let t = R.cur () in
    let argv = t.R.argv in
    argv |> List.iter (fun s ->
      let x = Fn.flook s in
      match x with
      | Some _ -> Hashtbl.remove R.fns s
      | None -> 
          (* stricter: *)
          if !Flags.strict_mode
          then E.error caps (spf "deleting undefined function %s" s)
    );
@
\swdefs{O.DelFn}

\subsection{Subshell: [[@ <cmd>]]}

<<Parser tokens, operators other cases>>=
%token TSubshell
@

<<[[Opcode.operation]] other cases>>=
(* ?? *)
| Subshell (* {... Xexit} *)
@

<<[[Lexer.token()]] symbol cases>>=
| "@" { TSubshell }
@

<<[[Parser.keyword]] other cases>>=
| TSubshell { "@" }
@

\subsection{Count and indexing of variables: [[$#<foo>]], [[$<foo>(...)]]} %$

<<Parser tokens, variables other cases>>=
%token TCount
@

<<[[Compile.outcode_seq]] in nested [[xword()]] match [[w]] cases>>=
| A.Count w ->
    emit (O.F O.Mark);
    xword w;
    emit (O.F O.Count);
@


<<[[Ast.value]] other cases>>=
| Count of value (* $#foo *)
| Index of value * values (* $foo(...) *)
@
%$

<<[[Interpreter.interpret_operation()]] match [[operation]] cases>>=
(* (name) *)
| O.Count ->
    let t = R.cur () in
    let argv = t.R.argv in
    (match argv with
    | [varname] -> 
        (* less: deglob *)
        let value = vlook_varname_or_index varname in
        let num = 
          match value with
          | None -> 0
          | Some xs -> List.length xs
        in
        R.pop_list ();
        R.push_word (spf "%d" num)
    | _ -> E.error caps "variable name not singleton!"
    )
@
\swdefs{O.Count}

<<[[Lexer.token()]] variable cases>>=
| "$#"  { TCount }
@

<<[[Opcode.operation]] other stack cases>>=
| Count (* (name) *)
| Concatenate (* (left)(right) *)
| Stringify (* (name) *)
@

<<[[Opcode.operation]] other variable cases>>=
| Index  (* ??? *)
| Local (* (name)(val) *)
| Unlocal (* *)
@

\subsection{Command output as a file: \texttt{'<\{<cmd>\}'}}

<<Parser tokens, punctuation other cases>>=
%token TBackquote
@

<<[[Ast.value]] other cases>>=
(* this causes the value and cmd types to be mutually recursive. Uses $IFS *)
| CommandOutput of cmd_sequence
@
%$

<<[[Opcode.operation]] other cases>>=
| Backquote (* {... Xreturn} *)
@

<<[[Lexer.token()]] symbol cases>>=
| "`" { TBackquote } 
@

<<[[Parser.comword]] other cases>>=
| TBackquote brace              { CommandOutput $2 }
@

\subsection{Command substitution: \texttt{`\{<cmd>\}}}

\subsection{Read-write redirections: [[<> <file>]]}

\subsection{General redirections: [[>[2] <file>]]}
\label{sec:advanced-redirection}

<<[[Lexer.token()]] symbol cases>>=
| ">[" (['0'-'9']+ (*as fd0*)) "=" (['0'-'9']+ (*as fd1*)) "]" 
       {  let fd0 = failwith "TODO: fd0" in
   let fd1 = failwith "TODO: fd1" in
   TDup (Ast.RWrite, int_of_string fd0, int_of_string fd1)
}
| ">>[" (['0'-'9']+ (*as fd0*)) "=" (['0'-'9']+ (*as fd1*)) "]" 
       {
           let fd0 = failwith "TODO: fd0" in
    let fd1 = failwith "TODO: fd1" in
    TDup (Ast.RAppend, int_of_string fd0, int_of_string fd1)
}
(* less: advanced pipe and redirection *)
@

\subsection{Advanced dup: [[>[<fd0>=<fd1>]] ], [[<>[<fd0>=<fd1>] ]], [[<[<fd0>=<fd1>] ]]}

%LP: distribute to advanced or later
<<Parser tokens, operators other cases>>=
%token<Ast.redirection_kind * int * int> TDup
@

<<[[Parser.redir]] other cases>>=
| TDup        { Right $1 }
@


<<[[Ast.redirection_kind]] other cases>>=
(* less: RHere *) (* < < *)
| RDup of int * int (* >[x=y] *)
@

<<[[Ast.cmd]] other redirection cases>>=
| Dup of cmd * redirection_kind * int * int (* >[1=2] *)
@

\subsection{Advanced pipes: [[|[<fd>] ]], [[|[<fd0>=<fd1>] ]]}

\subsection{Here documents: [[<< <HERE>]]}

\subsection{Stringification of variables: [[$"<foo>]]} %$

<<Parser tokens, variables other cases>>=
%token TStringify
@
<<[[Lexer.token()]] variable cases>>=
| "$\"" { TStringify }
@
%$


<<[[Ast.value]] other cases>>=
| Stringify of value (* $"foo " *)
@
%$

<<[[Parser.comword]] other cases>>=
| TCount word                   { Count $2 }
| TDollar word TSub words TCPar { Index ($2, $4) }
| TStringify word               { Stringify $2 }
@

<<Parser tokens, punctuation other cases>>=
%token TSub
@



\subsection{String concatenation}

<<Parser tokens, punctuation other cases>>=
%token TCaret
@

<<[[Parser.word]] other cases>>=
| word TCaret word { Concat ($1, $3) }
@
<<[[Parser.first]] other cases>>=
| first TCaret word { Concat ($1, $3) }
@

<<[[Lexer.token()]] symbol cases>>=
| "^" { TCaret }
@

<<[[Ast.value]] other cases>>=
(* ^ distributes over lists *)
| Concat of value * value
@

\section{Advanced builtins}

\subsection{[[exec]]}

\subsection{[[whatis]]}

\subsection{[[rfork]]}

\subsection{[[shift]]}


%******************************************************************************
\chapter{Conclusion}
%******************************************************************************
\label{chap:conclusion}


%******************************************************************************
\appendix
%******************************************************************************


%******************************************************************************
\chapter{Debugging for the [[mk]] Developer}
%******************************************************************************
\label{chap:debugging-appendix}

\section{Exception backtraces}
%TODO: disable by default!
%TODO: use -backtrace instead of -debugger, like in Mk.nw
%alt: move in Error management appendix later?

<<constant [[Flags.debugger]]>>=
let debugger = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
"-debugger", Arg.Set Flags.debugger,
" ";
@

<<[[CLI.main()]] when [[exn]] thrown in [[interpret()]]>>=
if !Flags.debugger
then raise exn
else 
  (match exn with
  <<[[CLI.main()]] when [[Failure]] [[exn]] thrown in [[interpret()]]>>
  (* alt: could catch Exit.ExitCode here but this is done in Main.ml *)
  | _ -> raise exn
  )
@

\section{Dumpers}

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-dump_tokens", Arg.Set Flags.dump_tokens,
" dump the tokens as they are generated";
"-dump_ast", Arg.Set Flags.dump_ast,
" dump the parsed AST";
"-dump_opcodes", Arg.Set Flags.dump_opcodes,
" dump the generated opcodes ";
@

\subsection{Dumping tokens}

<<constant [[Flags.dump_tokens]]>>=
let dump_tokens = ref false
@

<<[[Parse.lexfunc()]] possibly dump tokens>>=
|> (fun tok -> 
    if !Flags.dump_tokens 
    then Logs.app (fun m -> m "%s" (Dumper.dump (tok,s)));
    tok)
@


\subsection{Dumping the AST}

<<constant [[Flags.dump_ast]]>>=
let dump_ast = ref false
@

<<[[Parse.parse_line()]] possibly dump AST>>=
|> (fun ast -> if !Flags.dump_ast then Logs.app (fun m -> m "%s" (Ast.show_line ast)); ast)
@

\subsection{Dumping the opcodes}
% see also rc -r

<<constant [[Flags.dump_opcodes]]>>=
let dump_opcodes = ref false
@
<<[[Compile.compile()]] possibly dump returned opcodes>>=
|> (fun x -> if !Flags.dump_opcodes then Logs.app (fun m -> m "%s" (Opcode.show_codevec x)); x)
@

\section{Opcode generator trace: [[rc -r]]}
\label{sec:rc-r}

<<constant [[Flags.rflag]]>>=
(* -r, similar to dump_opcodes, but at each step *)
let rflag = ref false
@


<<[[CLI.main()]] [[options]] elements>>=
"-r", Arg.Set Flags.rflag,
" print internal form of commands (opcodes)";
@

<<[[CLI.interpret()]] if [[rflag]]>>=
(* less: cycle =~ codevec pointer *)
if !Flags.rflag
then Logs.app (fun m -> m "pid %d %d %s %s"
            (Unix.getpid ())
            !pc
            (Opcode.show t.R.code.(!pc))
            ( (t.R.argv::t.R.argv_stack) |> List.map (fun xs ->
                spf "(%s)" (String.concat " " xs)
               ) |> String.concat " "));
@
%TODO: do a better one, that knows that O.Simple accept value and values after in sequence

%\section{Printing characters: [[rc -v]]}
% hmm I've used it for verbose now
%\section{Printing all characters: [[rc -V]]}


\section{CLI actions}

<<[[CLI.main()]] debugging initializations>>=
let action = ref "" in
@

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-test_parser", Arg.Unit (fun () -> action := "-test_parser"), " ";
@

<<[[CLI.main()]] CLI action processing>>=
(* to test and debug components of mk *)
if !action <> "" then begin 
  do_action caps !action (List.rev !args); 
  raise (Exit.ExitCode 0)
end;
@


<<function [[CLI.do_action]]>>=
let do_action caps s xs =
  match s with
  | "-test_parser" ->
      xs |> List.iter (fun file ->
        let file = Fpath.v file in
        Logs.info (fun m -> m "processing %s" !!file);
        file |> FS.with_open_in caps (fun (chan : Chan.i) ->
          let lexbuf = Lexing.from_channel chan.Chan.ic in

          (* for error reporting I need a runq *)
          let t = Runtime.mk_thread [||] 0 (Hashtbl.create 0) in
          R.runq := t::!R.runq;
          t.R.file <- Some !!file;

          let rec loop () =
            let line = Parse.parse_line lexbuf in
            match line with
            | Some seq -> 
              Logs.app (fun m -> m "%s" (Ast.show_cmd_sequence seq));
              loop ();
            | None -> ()
          in
          loop ()
       )
      )

  | _ -> failwith ("action not supported: " ^ s)
  (* old: do that in caller now, so more explicit 
  runq := t::!runq
  *)
@


%\chapter{Error Management}
%\label{chap:error}


%******************************************************************************
\chapter{Examples of [[rc]] scripts}
%******************************************************************************
\label{chap:examples}

\section{[[/rc/lib/rcmain]]}
\label{sec:rcmain}

% Unix version
%coupling: content of ../data/rcmain-unix
\begin{verbatim}
# rcmain: Plan 9 on Unix version
if(~ $#home 0) home=$HOME
if(~ $#home 0) home=/
if(~ $#ifs 0) ifs=' 	
'

switch($#prompt){
case 0
	prompt=('; ' '	')
case 1
	prompt=($prompt '	')
}
if(~ $rcname ?.out ?.rc */?.rc */?.out) prompt=('broken! ' '	')
if(flag p) path=(/bin /usr/bin)
if not{
	finit
	# should be taken care of by rc now, but leave just in case
}
fn sigexit
if(! ~ $#cflag 0){
	if(flag l && test -r $home/lib/profile) . $home/lib/profile
	status=''
	eval $cflag
	exit $status
}
if(flag i){
	if(flag l && test -r $home/lib/profile) . $home/lib/profile
	status=''
	if(! ~ $#* 0) . $*
	. -i '/dev/stdin'
	exit $status
}
if(flag l && test -r $home/lib/profile) . $home/lib/profile
if(~ $#* 0){
	. /dev/stdin
	exit $status
}
status=''
. $*
exit $status
\end{verbatim}

% see flags p! used by rc -p!

\section{[[/home/pad/lib/profile]]}



%\chapter{Changelog}
% code via make loc = ?? LOC, after full lpized  ? LOC
% orig Rc.nw = ?? LOC, after full lpized and comments in sections ??
% now: =~ ?? LOC so added ?? LOE (Lines of explanations)
% rc in C: ? LOC (but more features)

\ifallcode
#include "Rc_extra.nw"
\fi

%******************************************************************************
\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
LOC = Lines Of Code
CLI = Command-Line Interface
\end{verbatim}


\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
