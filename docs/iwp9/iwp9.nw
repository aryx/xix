\documentclass{article}
%CONFIG:
\usepackage{fullpage}

\input{../../principia/docs/latex/Packages}
\usepackage{caption}
\captionsetup{
  justification=centering,
  singlelinecheck=false
}

%alt: \input{../latex/Noweb}
\usepackage{../../principia/docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../../principia/docs/latex/syncweb}

\newif\iffinal\newif\ifverbose\newif\ifallcode
\input{../../principia/docs/latex/Macros}

\title{
XiX: \plan in \ocaml
}
\author{
Yoann Padioleau\\
yoann.padioleau@gmail.com
}

\begin{document}
\date{}
\maketitle

\begin{abstract}
XiX is a work-in-progress project to port parts of \plan to \ocaml:
its build system [[mk]],
its shell [[rc]],
its ARM and MIPS toolchains [[[5v][acl]]], but also
its windowing system [[rio]],
and more.
%other: ed, lex/yacc, cat/ls/...
\end{abstract}

\section{Introduction}

\xix, which stands for ``\xix is \xix''\footnote{\xix is the first project with
a fully recursive acronym.},
is a port of the C source code of major \plan programs to
\ocaml\furl{https://ocaml.org},
an industrial-strength functional programming language.
%alt: statically typed
%alt: ... with an emphasis on expressiveness and safety.
%
Table~\ref{tab:ports} presents the current state of the project.
%
The code of \xix is available at \url{https://github.com/aryx/xix}.


The first question about this project that comes to mind is: why?
%
The main motivation for \xix actually comes from another project of
mine called {\em \principia}\furl{https://github.com/aryx/principia-softwarica}
(I submitted a separate paper to this workshop describing \principia).
%
In short, \principia is a series of books explaining the code
of \plan programs that are essential to programmers, such as the linker,
assembler, build system, and up to the windowing system.
%
One strategy to fully understand a program, in order to explain its
code in a book, is, perhaps surprisingly, to try to port it to
another language.
%
Indeed, during the porting of a program, it is tempting--because
good programmers are lazy--to not implement certain features initially judged 
to be accessory, and instead focus on the main parts of the program.
%
The process of discovering what those essential parts are already
helps in understanding the original code.
%
Moreover, very often the final ported program does not work
at first because those features judged to be accessory turned out to
be essential,
which again helps to better understand the original code and its hidden
subtleties.


I chose \ocaml mainly because it is the programming language I am the
most familiar with, and as it happens it is also my favourite.
% cite semgrep, pfff, coccinelle?
%
The port reached a point, however, where the \xix programs are actually 
useful on their own, independently of \principia.
%
Indeed, first, \ocaml programs are usually portable and
thanks to the \ocaml compiler targeting multiple architectures
and operating systems
most \xix programs work without any extra effort
on Linux, macOS, and Windows
(plan9port\furl{https://9fans.github.io/plan9port/} also helps to
run \plan programs on Linux and macOS),
on amd64 and arm64 architectures.
%
Second, the \ocaml code being smaller (see Table~\ref{tab:ports})
and arguably clearer, I found it easier to modify and I now usually
experiment with new features 
(e.g., adding support for an [[MKSHELL]] environment variable in [[mk]])
first in \ocaml, and only later port the feature to the original C code.
%said-later:
% mk + rc embedded, without extra fork, just reset state of
% interpreter, easier on functional programs with usually less
% globals
%
Finally, \ocaml programs are usually safer, as segmentation faults
or buffer overflows cannot happen, for example.
%well actually it can happen, but usually in C code linked with OCaml code
%said-later: more details on C vs OCaml
%
% then long term easier to explain its code so candidate for \principia II.

\begin{table}[htbp]
\centering
\begin{tabular}{l l r l r}
\hline
\textbf{Category} & \textbf{\plan Program(s)} & \textbf{LOC} & \textbf{\xix Program} & \textbf{LOC} \\
\hline

% I used syncweb -loc to compute those numbers on principia and xix.
% For multi-archs programs, I used syncweb -loc and then manually
% added wc -l *.[chly] or wc -l *.ml* for the other archs code.

Build system      & [[mk]]          & 4350  & [[omk]]            & 2240 \\
Shell             & [[rc]]          & 6500  & [[orc]]            & 2190 \\
Assembler         & [[5a va]]       & 3020  & [[oas]]            & 2190 \\
% also ia, but better hide for now
Linker            & [[5l vl]]       & 12980 & [[olk]]            & 2910 \\
% also ar and nm here, and oar onm
C Compiler        & [[5c vc libcc]]    & 28000 & [[occ]]            & 5310 \\
% lex yacc? but not really plan9 prog in the first place and
% the code does not come from a port really
Editor            & [[ed]]          & 1600  & [[oed]]            & 1220 \\
Graphics          & [[libdraw]] [[clock]]     & 7280  & [[lib_odraw]] [[oclock]]      & 2940 \\
Communication     & [[lib9p]]       & 2920     & [[lib_plan9]]   & 1080 \\
Windowing system  & [[rio]]         & 5960  & [[orio]]           & 2820 \\
Utilities         & [[cat pwd wc]]  & 173   & [[ocat opwd owc]]  & 220 \\
\hline
\textbf{Total: } & & 72783 & & 23120 \\
%origin: the total was computed by chatGPT by copy pasting table
% and asking to compute total
\hline

\end{tabular}
\caption{%
\plan and \xix Programs Statistics.\\
{\footnotesize
(\textbf{LOC} = lines of code, including code comments)
}
}
\label{tab:ports}
\end{table}

\section{Current state}

The port of [[mk]] to \ocaml, called [[omk]] (for [[o]]caml [[mk]]),
is almost complete, with only a few advanced features missing.
% give ex of missing feature ?
The same is true for the shell [[orc]] and editor [[oed]].
%
In fact, the pair [[omk/orc]] is mature enough that it can now be used
to drive the building process of \xix itself, dogfooding\footnote{
The build of this \LaTeX{} article was also driven by [[omk]].
}
those tools.


The ARM and MIPS assembler [[oas]], linker [[olk]], and C compiler [[occ]]
are far from complete. 
%
However, they can already be used to
compile and assemble a toy [[helloprintf.c]] program, and to produce
[[a.out]] and [[ELF]] binaries that can run respectively
on \plan and Linux.
% also RISCV


Finally, the port of [[rio]], [[libdraw]], and [[lib9p]]
reached the point where one can substitute [[rio]] with [[orio]]
in \plan and not notice any difference,
like in Figure~\ref{fig:orio}, which illustrates also the use
of a few other \xix programs.
% screenshot with orio, ocamlrun, oas, olk, occ, even ocat test.s :)
% omk, orc
%
% orio use thread lib of ocaml, and funny story Leroy added first
% thread C library to Linux for OCaml long time ago.
Note that [[orio]] is the only program in the list that requires
\plan to run as it relies on features such as namespaces only
provided by the \plan kernel.
%actually I also ported a rudimentary kernel.
% but also utilities (ed, hoc? grep? sed? awk?), 

%alt:
%Figure~\ref{fig:orio} illustrates the use of most of those programs
%running under \plan, for real, including the windowing system [[orio]].

% could also talk about o9! preliminary, enough to get hello
% link ocamlrun C code with libmemdraw, plan9 libc pool.c, etc.
% and bcm/ C starting code.
% ocaml on bare metal, and port main data structures (Proc, Cpu, ...) and main
% algo (schedule, sysbrk, sysfork, ...) but not connected.

\begin{figure*}
\centering
\includegraphics[%angle=90, 
  height=7.4cm]{orio1}
\caption{[[orio]] in action.}
\label{fig:orio}
\end{figure*}

\section{\ocaml in \plan}

To be able to run [[orio]], an \ocaml program, in \plan requires
first to port \ocaml itself to \plan, but no one has done so.
%
Fortunately, \ocaml has two compilers: 
one producing optimized {\em native code}, called [[ocamlopt]], and
one producing a portable {\em bytecode} for a {\em virtual machine}, called [[ocamlc]];
% instead of object code for a real machine
this bytecode must then be interpreted by a bytecode interpreter,
called [[ocamlrun]].
% a kind of VM, like nodejs, java, etc.
%
Both [[ocamlc]] and [[ocamlopt]] are written in \ocaml, but
the bytecode interpreter is a small C program (12 000 LOC) with
very few external dependencies.
%
I just had to add a few [[ifdef]]s, add a few functions calling the \plan
C library, and finally use the \plan C compiler to cross-compile this
C code to produce an [[ocamlrun]] ([[a.out]]) binary that could run
under \plan.
%Actually I use
%\goken\furl{https://github.com/aryx/goken9cc}
%(I submitted a separate work-in-progress paper to this workshop
%describing the motivations and features of Goken).
%
Thanks to this [[ocamlrun]] you can then run [[ocamlc]] itself (it's a pure
bytecode program) to compile other programs.
% more complicated, for orio need also to link C code, but
% same idea of using plan9 C compiler to assist.
%
To run [[orio]] requires to
compile additional OCaml bindings to the \unix C library,
and link C code implementing \ocaml cooperative threads using [[select()]].
Fortunately, I was able to use the \plan{} [[pcc]] program and
APE\furl{https://9p.io/sys/doc/ape.html} to compile almost as-is
this \unix C code.


This work is available at \url{https://github.com/aryx/ocaml-light}.
I started from an old version of \ocaml (1.07) because it had fewer
% so many forks :)
dependencies than recent versions, making the porting work less difficult.
%
This old version though is good enough to compile \xix because the \xix code
does not use any recent features of \ocaml.
%recent, meaning from the last 20 years, hmmm 

\section{C vs \ocaml}

C is a great programming language, and a real improvement over assembly.
It is arguably the best language to implement system programs\footnote{
Maybe nowadays Rust and Zig are also strong candidates.
} 
such as kernels, virtual machines, just-in-time compilers, etc.
%
C can also be used as a ``portable assembler''; 
% \cite?
this makes C a great language to implement efficiently core libraries,
which can even be used from programs written in different programming languages.
%
For many applications though, especially applications
without strong constraints on memory, speed, or latency, it can
be far more productive for the programmer to use higher-level
languages. 
%
Programming in C is indeed error-prone, with
recurring bugs such as buffer overflows, segmentation faults,
or security holes.
% in fact, coreutils now in Rust, people use Zig, or Go
%
OCaml, a statically-typed functional language, is arguably more expressive
and less error-prone than C;
\l ultimate lang IMHO, even in 2015! actually early ML were in Bell Labs too
it is almost impossible to
have many of the bugs mentioned above while programming
in OCaml.


The numbers in Table~\ref{tab:ports} seem to indicate that
for the programs that have been almost fully ported 
([[mk]], [[rc]], [[ed]], and [[rio]]),
the ratio of LOC between C and \ocaml is around 2, meaning
\ocaml is 2x more succinct than C. 
%
However, the comparison is not totally fair because there
are still advanced features in the C versions not ported
yet to \ocaml, so the real ratio is probably closer to 1.5.
%
This is far lower than what functional programmers zealots
(including myself) would claim when comparing C to \ocaml.
%
In fact, I have been constantly surprised while reading and porting
the code of those \plan programs by the succinctness and ingenuity of
the C code.
%
For example, C lacks \ocaml algebraic data types (ADTs, similar
to tagged unions), pattern-matching, parametric polymorphism, closures,
garbage collection, and more.
% more ocaml advantages: polymorphism factorize code, marshalling remove code
%ocmp pattern matching still a win in OCaml
%
Still, the code of the \plan linkers use
simple enums to
represent the opcodes and abstract syntax trees (ASTs) of assembled programs,
enums and simple comparison functions to
represent a hierarchy of operand classes, 
a large literal array containing enum constants
associated with a function using a simple switch
to represent cases for machine-code generation.
%
All of those together allow one to very succinctly
encode the final machine-code generation phase of the linker.
%
The \ocaml code instead uses ADTs and simple pattern matching
to encode the same machine-code generation, which looks
more elegant and natural, but in the end the \ocaml code is not
that much smaller than the C code.
%
% no need optab.c, ocmp, ... just direct pattern matching on advanced
% SHOW code diff C vs OCaml.
It is, however, arguably clearer to understand.
% BUT! LOE will be bigger!


% C is great but old. Rust, Ziglang new contenders.
% Actually some r9 projects for Rust, and ziglang kinda new toolchain,
% but OCaml has pros compared to Rust/Ziglang. For many programs, simpler
% to not handle memory. 
% Actually original code was not doing much memory management. 
% Simple mm. But even simpler now. 


% plan9 was rethinking and simplifying Unix. Xix is also rethinking
% and simplifying Plan9. Remove more features. Less code!
% even less code than plan9! STEPS project! So even easier 
% to teach. Actually series of books explaining the code, ocaml editions
% of C books in principia softwarica.


%TOC:
% - components:
%   * omk/orc, less features, just essential, so LOC/LOE comparison?
%     can even do mk+rc in same binary? rc as a lib! easy with OCaml!
%     so even better than plan9! perf improv? also if pure
%     program then can reset rc state easily! harder with C. power of FP!
%   * toolchain: assembler/linker/compiler, ar/nm, more reusable code!
%     reuse more in asm, linker, compiler! lots of code dupe in plan9
%     use 'a instr polymorphic type, helpers, arch interfaces, etc.
%     nice use of marshalling to reduce code of IO and special object/ar formats
%     archs: arm, mips, riscv (RISC is simpler)
%     OS: plan9 and Linux ELF
%   * olex, oyacc
%   * oed, and other utilities: ogrep, osed, oawk
%   * orio and threads, and 9p in OCaml for draw device interaction
%     significant! can replace rio by orio on plan9 (more on OCaml for plan9
%     below) screenshot?
%     * libsystem with 9p, mound/bind syscall
%     * libdraw (user side) for orio (below)
%   * ogit! not in plan9
%   * kernel (rudimentary)
% - Plan9 in OCaml, but also OCaml in Plan9 :)
%   ocaml for plan9 (and ocaml-light), especially for orio which requires plan9
%   to work. Port of old ocaml version, simpler,
%   less dependencies, more traditional C and simple use of libc (and stdio? need  APE?)
% - LOC/LOE! compare books on mk vs omk
% - on OCaml
%   also capabilities!
% - git, docker, GHA, testsuite (not much tests in plan9), bootstrap-mk.sh,
%   easy to test on Linux/macOS/Windows (plan9 not so easy by comparison,
%   might have slow down also adoption)
% - Software engineering lessons and improvements after 30 years:
%   abuse int, abuse strings, code dupe, error mangagement OK_0, OK_1,
%   bools, ...
%   we learned stuff in 30 years.
% - Future work

\section{Future work}

An obvious future work is to finish [[oas]], [[olk]], and [[occ]]
to reach parity with the original C code, and then
%
go even further by targeting also Linux, macOS, and Windows
on the AMD64, ARM64, and RISC-V architectures.
% must reach closer LOC-C/LOC-OCAML 1.5 

Another one is to try to port the [[9]] kernel to \ocaml.
%
I was able to run a minimal 
kernel\furl{https://github.com/aryx/xix/tree/master/kernel} in \ocaml
on the bare metal linked with 
\plan C libraries such as [[libc]] and [[memdraw]]; I managed to print [[hello world]], but a lot remain
to implement a full kernel in \ocaml.
% o9, memlayer, libc memory pool.c, 
% raspberry pi C

\end{document}
