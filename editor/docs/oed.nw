\section{Introduction}

% ex: 1,3p for advanced commands with range addresses


\section{Core data structures}

\subsection{Token}

<<type [[Token.t]]>>=
type t =
  | Spaces | Newline | EOF

  (* letter or '=' or '!' for commands. ex: 'p' *)
  | Char of char

  (* start of address tokens. ex: "1,3" => [Int 1; Comma; Int 3] *)
  | Int of int
  | Dot | Dollar
  | Comma
  | Plus | Minus
  <<[[Token.t]] other cases>>
@

% note that filename and lines will be parsed directly as string,
% no need for tokens for those because we will use a different
% parser for those.

\subsection{Parser state}

<<type [[Parser.state]]>>=
type state = {
  stdin: Lexing.lexbuf;
  mutable lookahead : Token.t option;
  <<[[Parser.state]] other fields>>
}
@
% no yacc, classic peek/consume instead and kinda recursive descent

<<signature [[Parser.init]]>>=
val init: <Cap.stdin; ..> -> state
@

<<function [[Parser.init]]>>=
let init (caps : < Cap.stdin; ..>) : state =
  { stdin = Lexing.from_channel (Console.stdin caps);
    lookahead = None;
    globp = None;
  }
@



\subsection{Line addresses}

<<type [[Address.t]]>>=
(* An "address" is a way to specify a line number symbolically or literally *)
type t =
  | Current (* '.' *)
  | Last    (* '$' *)
  | Line of int (* <n> *)
  | Relative of t * int (* -, +, ^ *)
  <<[[Address.t]] other cases>>
@
%$

<<type [[Address.range]]>>=
(* What is parsed before a command. For instance 1,3 will be parsed as
 * { addr1 = Some (Line 1); addr2 = Line 3; given = true; ...}.
 *)
type range = {
  addr1 : t option;
  addr2 : t;
  given : bool;
  <<[[Address.range]] other fields>>
}
@
% '1p' will be parsed as addr1 = None; addr2 = Line 1?
% ',' will be parsed as 1,$ actually



\subsection{The environment}
%alt: globals

<<type [[Env.t]]>>=
(* The globals *)
type t = {
  <<[[Env.t]] in/out fields>>
  <<[[Env.t]] temporary file fields>>
  <<[[Env.t]] zero field>>
  <<[[Env.t]] cursor fields>>
  <<[[Env.t]] other fields>>
  <<[[Env.t]] flag fields>>
}
@

<<[[Env.t]] in/out fields>>=
(* to read the user commands from (and also line input in 'a'/'i' modes) *)
in_: Parser.state;
@
<<[[Env.t]] in/out fields>>=
(* stdout unless oflag is set in which case it's stderr *)
out: Out_channel_.t;
@


\subsection{The backing store: [[tfname]], [[tfile]], and [[tline]]}

<<constant [[Env.tfname]]>>=
let tfname = Fpath.v "/tmp/oed.scratch"
@

<<[[Env.t]] temporary file fields>>=
(* This is the opened temporary tfname file; ed backing store!
 * Note that we can't use the usual {in/out}_channel OCaml types because we
 * need to both read and write in the temporary file, hence the use of the
 * more general Unix.file_descr.
 *)
tfile : Unix_.file_descr;
@

<<[[Env.t]] temporary file fields>>=
(* current write file offset in tfile to append new lines *)
mutable tline : tfile_offset;
@
% kind of a log, only append lines, never delete old lines in there

<<type [[Env.tfile_offset]]>>=
(* offset in tfname file content *)
type tfile_offset = Tfile_offset of int
@
% initialized to 2 (but maybe could be 0 in oed as we use a better
% offset_and_mark type for the zero elements)

\subsection{The lines as file offsets: [[zero]]}

<<[[Env.t]] zero field>>=
(* Growing array of line offsets in tfile. It is a 1-indexed array but the 0
 * entry is used as a sentinel. This array maps lineno -> tfile_offset.
 * The mark is used to remember a matching line in g/re/x operations.
 *)
mutable zero : offset_and_mark array;
@

<<type [[Env.offset_and_mark]]>>=
type offset_and_mark = {
  (* offset in tfile *)
  offset: tfile_offset;
  (* used by the 'g' or 'v' commands to mark matched lines *)
  mutable mark: bool;
}
@

<<constant [[Env.no_line]]>>=
let no_line = { offset = Tfile_offset 0; mark = false }
@
%TODO? alt: use None, which then remove the need to initialize
% tline to Tfile_offset 2 (or 1)

\subsection{Cursors: [[dot]] and [[dol]]}

<<type [[Env.lineno]]>>=
(* ed uses 1-indexed line numbers, but 0 is also used as a special value.
 * alt: call it cursor?
*)
type lineno = int
@
% not to confuse with tfile_offset! This is "user" line numbers.

<<[[Env.t]] cursor fields>>=
(* index entried in zero *)
(* current line *)
mutable dot: lineno;
(* last line (dollar) *)
mutable dol: lineno;
@
% when user will use '$' in command, it will be evaluated to this dol
% lineno.

\subsection{Other globals}

<<[[Env.t]] cursor fields>>=
(* for 1,3p commands. See also Address.range, but here we have
 * concrete line number, not symbolic "addresses".
 *)
mutable addr1: lineno;
mutable addr2: lineno;
mutable given: bool;
@



\section{[[CLI.main()]]}

<<toplevel [[Main._1]]>>=
let _ = 
  Cap.main (fun (caps : Cap.all_caps) ->
     let argv = CapSys.argv caps in
     Exit.exit caps (Exit.catch (fun () -> CLI.main caps argv))
  )
@

<<signature [[CLI.main]]>>=
val main: <caps; ..> ->
  string array -> Exit.t
@

<<type [[CLI.caps]]>>=
type caps = < 
    Cap.stdin; Cap.stdout; Cap.stderr;
    Cap.open_in; (* for 'r' *)
    Cap.open_out; (* for 'w' *)
    Cap.forkew; (* for '!' *)
  >
@


%trans: 
Here is the [<main>] skeleton.

<<function [[CLI.main]]>>=
let main (caps : <caps; ..>) (argv : string array) : Exit.t =

  let args = ref [] in
  <<[[CLI.main()]] local flags>>

  let options = [
     <<[[CLI.main()]] local [[options]] elements>>
  ] |> Arg.align
  in
  (* may raise ExitCode *)
  Arg_.parse_argv caps argv options (fun t -> args := t::!args) 
    (spf "usage: %s [options] [file]" argv.(0));
  <<[[CLI.main()]] setup logging after parsed argv>>
  <<[[CLI.main()]] restrict caps>>

  let env : Env.t = Env.init caps !vflag !oflag !rflag in
  <<[[CLI.main()]] env adjustments>>

  while true do
    (* when neither commands() nor quit() raise Error, then
     * quit() will proceed and raise Exit.ExitCode which
     * will exit this loop (and be caught in Main._)
     *)
    try (
        commands caps env;
        Commands.quit caps env;
    )
    with Error.Error s -> 
        <<[[CLI.main()]] exn handler for [[Error.Error s]]>>
  done;
  (* should never reach *)
  Exit.OK
@

\subsection{[[ed <file>]] and preloaded commands [[globp]]}

<<[[Env.t]] other fields>>=
(* for 'w', 'r', 'f' *)
mutable savedfile: Fpath.t option;
@


<<[[CLI.main()]] env adjustments>>=
(match !args with
| [] -> ()
| [file] -> 
    env.savedfile <- Some (Fpath.v file);
    env.in_.globp <- Some (Lexing.from_string "r")
(* stricter: *)
| _::_::_ -> failwith "too many arguments" 
);
<<[[CLI.main()]] env adjustments if [[oflag]]>>
<<[[CLI.main()]] debug env>>
@

<<[[Parser.state]] other fields>>=
(* for inserting "virtual" commands to process before stdin *)
mutable globp: Lexing.lexbuf option;
@



\subsection{[[ed -]] and [[vflag]]}

<<[[CLI.main()]] local flags>>=
(* "verbose(interactive)" mode is set by default *)
let vflag = ref true in
@
<<[[CLI.main()]] local [[options]] elements>>=
"-", Arg.Clear vflag,
" non-interactive mode (opposite of verbose)";
@
<<[[Env.t]] flag fields>>=
(* verbose (a.k.a. interactive) flag, cleared by 'ed -' *)
vflag: bool;
@

% put code ex of use of vflag

\subsection{[[ed -o]] and [[oflag]]}

<<[[CLI.main()]] local flags>>=
(* when '-o', the command 'w' will write to stdout (useful for filters) *)
let oflag = ref false in
@
<<[[CLI.main()]] local [[options]] elements>>=
"-o", Arg.Set oflag,
" write buffer to standard output";
@
<<[[Env.t]] flag fields>>=
(* output flag, set by 'ed -o'.
 * used just in Out.putchr() so could be removed almost.
 *)
oflag: bool;
@

% code for /dev/fd1 here

<<[[Env.init()]] set local [[savedfile]]>>=
(* will be overwritten possibly in the caller by argv[1] 
 * TODO: works on Linux? /fd/1 exists?
 *)
let savedfile = if oflag then Some (Fpath.v "/fd/1") else None in
@
<<[[Env.init()]] set local [[out]]>>=
let out = if oflag then Console.stderr caps else Console.stdout caps in
@

<<[[CLI.main()]] env adjustments if [[oflag]]>>=
if !oflag then env.in_.globp <- Some (Lexing.from_string "a");
@
% another preloaded command! append mode!


\subsection{[[init()]]}

<<function [[Env.init]]>>=
let init (caps : < Cap.stdin; Cap.stdout; Cap.stderr; ..>) 
     (vflag : bool) (oflag : bool) (rflag:  bool) : t =

  <<[[Env.init()]] set local [[out]]>>
  <<[[Env.init()]] set local [[savedfile]]>>
  { 
    in_ = Parser.init caps;
    out;
    <<[[Env.init()]] [[tfile]] field>>
    <<[[Env.init()]] [[tline]] field>>

    zero = Array.make 10 no_line;
    dot = 0;
    dol = 0;
    addr1 = 0;
    addr2 = 0;
    given = false;

    savedfile;
    fchange = false;
    wrapp = false;
    count = 0;
    pflag = false;
    col = 0;

    vflag = if oflag then false else vflag;
    oflag;
    rflag;
  }
@

% see also oflag => not verbose

<<[[Env.init()]] [[tfile]] field>>=
tfile =
  (try
    Unix.openfile !!tfname [ Unix.O_RDWR; Unix.O_CREAT ] 0o600
  with Unix.Unix_error (err, s1, s2) ->
    Logs.err (fun m -> m "%s %s %s" (Unix.error_message err) s1 s2);
    (* alt: just no try and rely on default exn and backtrace *)
    (* alt: call Out.putxxx funcs but mutual recursion *)
    output_string out "?TMP\n";
    (* ed was doing exits(nil) = exit 0 so we do the same *)
    raise (Exit.ExitCode 0)
   );
@

<<[[Env.init()]] [[tline]] field>>=
(* sentinel value so that file offsets 0 and 1 are reserved and no
 * real line offsets in zero[] can have those values
 * TODO? mark is using a separate bool field now so we could
 * use Tfile_offset 1 too and so start at 1 (or even 0?) now.
 *)
tline = Tfile_offset 2;
@
%alt: could be 1 now, no need 1 for mark


\subsection{[[quit()]]}

<<signature [[Commands.quit]]>>=
(* 'q' (need open_out to remove Env.tfname from the filesystem) *)
val quit: < Cap.open_out; ..> -> Env.t -> unit
@

<<function [[Commands.quit]]>>=
(* 'q' *)
let quit (caps : <Cap.open_out; ..>) (e : Env.t) : unit =
  <<[[Commands.quit()]] check if modified buffer>>
  (* alt: could also Unix.close e.tfile *)
  FS.remove caps Env.tfname;
  raise (Exit.ExitCode 0)
@


<<[[Env.t]] other fields>>=
(* did the buffer changed (mostly tested with dol > 0) *)
mutable fchange: bool;
@

<<[[Commands.quit()]] check if modified buffer>>=
if e.vflag && e.fchange && e.dol != 0 then begin
    (* so a second quit will actually quit *)
    e.fchange <- false;
    Error.e_warn "trying to quit with modified buffer"
end;
@


\section{Displaying and reading text}

\subsection{Displaying text}

<<signature [[Out.putchr]]>>=
val putchr: Env.t -> char -> unit
@
<<function [[Out.putchr]]>>=
let putchr (e : Env.t) (c : char) =
  (* TODO: if listf *)
  output_char e.out c;
  if c = '\n' then flush e.out
@
% use e.out, which can be stdout or stderr depending on -o flag

<<signature [[Out.putst]]>>=
val putst: Env.t -> string -> unit
@
<<function [[Out.putst]]>>=
(* pre: str should not contain '\n' ? *)
let putst (e : Env.t) (str : string) : unit =
  (* ugly? should set after putchr \n? also who uses col? *)
  e.col <- 0;
  (* iterate over str and call putchr to get a chance
   * for the listf code above
   *)
  String.iter (putchr e) str;
  putchr e '\n';
  ()
@

<<[[Env.t]] other fields>>=
(* ?? what functions rely on column number set? *)
mutable col: int;
@


\subsection{Reading text}

% consume/peek here?
% getty here?

<<signature [[In.gety]]>>=
(* return a line (without trailing '\n') *)
val gety :  Env.t -> string
@

<<function [[In.gety]]>>=
(* return a line (without trailing '\n') *)
let gety (e : Env.t) : string =
  Lexer.line e.in_.stdin
@

<<signature [[Lexer.line]]>>=
val line: Lexing.lexbuf -> string
@
<<function [[Lexer.line]]>>=
and line = parse
  | ([^ '\n' ]* as s) '\n' { s }
  | eof { failwith "eof in Lexer.line()" (* alt: None? *) }
@


<<signature [[In.gettty]]>>=
(* Used to read a set of lines from stdin until a single "." on a line
 * is entered marking the end of user text input.
 *)
val gettty : Env.t -> (unit -> string option)
@

<<function [[In.gettty]]>>=
(* Read a line from stdin. Return None when the user entered "." on a single
 * line meaning the end of interactive input.
 * This has a similar interface to getfile() so it can be passed to
 * append().
 *)
let gettty (e : Env.t) () : string option =
  let s = gety e in
  if s = "."
  then begin
    <<[[In.gettty()]] log end of input>>
    None
  end
  else Some s
@


\section{Parsing commands}

<<signature [[Lexer.token]]>>=
val token: Lexing.lexbuf -> Token.t
@

<<constant [[Lexer.space]]>>=
let space = [' ''\t']
@
<<constant [[Lexer.letter]]>>=
let letter = ['a'-'z''A'-'Z''_']
@
<<constant [[Lexer.digit]]>>=
let digit = ['0'-'9']
@
%$

<<function [[Lexer.token]]>>=
rule token = parse
  | space+        { Spaces }
  | '\n'          { Newline }

  (* for the command *)
  | (letter | '=' | '!') as c   { Char c }

  <<[[Lexer.token()]] other cases>>
  | eof { EOF }
@


<<function [[Parser.next_token]]>>=
(* Do not use! this is internal! You should use peek() or consume() instead. *)
let next_token (st : state) : Token.t =
  let t = 
    match st.globp with
    <<[[Parser.next_token()]] match [[globp]] cases>>
    | None -> Lexer.token st.stdin
  in
  <<[[Parser.next_token()]] debug token>>
  t
@

<<signature [[Parser.peek]]>>=
val peek : state -> Token.t
@
<<function [[Parser.peek]]>>=
let peek (st : state) : Token.t =
  match st.lookahead with
  | Some t -> t
  | None ->
      let t = next_token st in
      st.lookahead <- Some t;
      t
@

<<signature [[Parser.consume]]>>=
val consume: state -> Token.t
@
<<function [[Parser.consume]]>>=
let consume (st : state) : Token.t =
  match st.lookahead with
  | Some t -> st.lookahead <- None; t
  | None -> next_token st
@



% not st.stdin this time but passed "virtual" stdin
<<[[Parser.next_token()]] match [[globp]] cases>>=
| Some lexbuf ->
    let t = Lexer.token lexbuf in
    if t = T.EOF
    then st.globp <- None;
    t
@
% see ed file, or also when using -  to preload append


\section{[[CLI.commands()]] interpreter loop}

%trans: ok enough background to now see code of CLI.commands()

%\subsection{Skeleton}

<<function [[CLI.commands]]>>=
let rec commands (caps : < Cap.open_in; Cap.open_out; Cap.forkew; ..>)
                 (e : Env.t) : unit =
  <<[[CLI.commands()]] debug start>>
  let done_ = ref false in
  while not !done_ do
    <<[[CLI.commands()]], at loop start, if [[pflag]]>>
    let range : Address.range = Address.parse_range e.in_ in
    let (addr1, addr2) = Address.eval_range e range in
    (* TODO: use range.set_dot! *)
    e.addr1 <- addr1;
    e.addr2 <- addr2;
    e.given <- range.given;

    (match Parser.consume e.in_ with
    | T.Char c ->
      (match c with
      (* inspecting *)
      <<[[CLI.commands()]] match [[c]] inspecting cases>>
      (* reading *)
      <<[[CLI.commands()]] match [[c]] reading case>>
      (* writing *)
      <<[[CLI.commands()]] match [[c]] writing cases>>
      (* modifying *)
      <<[[CLI.commands()]] match [[c]] modifying cases>>
      (* globals *)
      <<[[CLI.commands()]] match [[c]] global cases>>
      (* other *)
      <<[[CLI.commands()]] match [[c]] other cases>>

      | c -> failwith (spf "unsupported command '%c'" c)
      )
      (* ed: was doing error(Q) here but because ed relied on the commands
       * doing some 'continue' which we can't in OCaml so
       * better not use Error.e here
       *)

    | T.Newline ->
        <<[[CLI.commands()]] [[Newline]] case>>

    | T.EOF ->
       (* old: raise (Exit.ExitCode 0) but bad because we need to get to quit()
        * or to return to global() caller when nested call to commands().
        * TODO? raise (Exit.ExitCode 2) instead and check whether in nested
        * commands? so this would force people to use 'q' to quit cleanly
        * (so an error during quit in a script would fail and would
        * make the whole script fail when EOF is reached)
        * or raise EOF and capture it in global() ?
        *)
       done_ := true
    | t -> Parser.was_expecting_but_got "a letter" t
    )
  done;
  <<[[CLI.commands()]] debug end>>
@

<<signature [[Address.parse_range]]>>=
val parse_range: Parser.state -> range
@

<<signature [[Address.eval_range]]>>=
val eval_range: Env.t -> range -> Env.lineno * Env.lineno
@
% for now can assume will return current line, e.dot which is what is
% returned when no special address are given, as in 'p'

\section{[[r]]eading a file: [[r]]}

<<[[CLI.commands()]] match [[c]] reading case>>=
| 'r' -> 
    let file : Fpath.t = In.filename e c in
    Commands.read caps e file
@

<<signature [[In.filename]]>>=
(* read a filename from stdin or from Env.savedfile otherwise *)
val filename: Env.t -> char (* 'f' or 'e' or 'r' or ? *) -> Fpath.t
@

<<signature [[Commands.read]]>>=
(* 'r' *)
val read: <Cap.open_in; ..> -> Env.t -> Fpath.t -> unit
@

\subsection{Reading a [[filename()]]}


<<function [[In.filename]]>>=
let filename (e : Env.t) (cmd : char) : Fpath.t =
  <<[[In.filename()]] reset [[count]]>>
  match Parser.consume e.in_ with
  | T.Newline | T.EOF ->
      (* no file specified, use maybe e.savedfile then *)
      (match e.savedfile with
      | Some file -> file
      | None when cmd <> 'f' -> Error.e_err "no savedfile and no filename given"
      | None -> failwith "TODO?? what does ed in that case?"
      )
  | T.Spaces ->
      let str = Lexer.filename e.in_.stdin in
      if str = ""
      then Parser.was_expecting "a non empty filename";
      (match Parser.consume e.in_ with
      | T.Newline -> 
            let file = Fpath.v str in
            if e.savedfile = None || cmd = 'e' || cmd = 'f'
            then e.savedfile <- Some file;
            file
      | t -> Parser.was_expecting_but_got "a newline" t
      )
  | t -> Parser.was_expecting_but_got "a newline or space and filename" t
@

<<signature [[Lexer.filename]]>>=
val filename: Lexing.lexbuf -> string
@
<<function [[Lexer.filename]]>>=
and filename = parse
  | [^ '\n' ' ']* { Lexing.lexeme lexbuf }
  | eof { failwith "eof in Lexer.filename()" }
@


<<[[Env.t]] other fields>>=
(* count #chars read, or number of lines; displayed by Out.putd() *)
mutable count: int;
@
<<[[In.filename()]] reset [[count]]>>=
(* alt: do it in the caller, clearer; will be incremented
 * when reading the file in getfile
 *)
e.count <- 0;
@



\subsection{[[read()]]}

% passed file from In.filename (coming from user or savedfile
% set for example when doing 'ed file'

<<function [[Commands.read]]>>=
(* 'r' *)
let read (caps : < Cap.open_in; .. >) (e : Env.t) (file : Fpath.t) : unit =
  <<[[Commands.read()]] restricted mode check>>
  try 
    file |> FS.with_open_in caps (fun chan ->
        setwide e;
        squeeze e 0;
        let change = (e.dol != 0) in
        append e (Disk.getfile e chan) e.addr2 |> ignore;
        exfile e READ;
        e.fchange <- change;
    )
  with Sys_error str ->
    Logs.err (fun m -> m "Sys_error: %s" str);
    Error.e_legacy !!file
@

<<signature [[Commands.setwide]]>>=
(* helpers *)
val setwide: Env.t -> unit
@
<<signature [[Commands.squeeze]]>>=
val squeeze: Env.t -> int -> unit
@

<<signature [[Disk.getfile]]>>=
(* will return one line (without trailing '\n') or None when reached EOF *)
val getfile: Env.t -> Chan.i -> (unit -> string option)
@

<<signature [[Commands.append]]>>=
(* return number of lines added, but usually ignored by caller *)
val append: Env.t -> (unit -> string option) -> Env.lineno -> int
@



\subsection{[[setwide()]] and [[squeeze()]]}

<<function [[Commands.setwide]]>>=
let setwide (e : Env.t) : unit =
  if not e.given then begin
    e.addr1 <- if e.dol > 0 then 1 else 0;
    e.addr2 <- e.dol;
  end;
  ()
@

<<function [[Commands.squeeze]]>>=
let squeeze (e : Env.t) (i : lineno) : unit =
  if e.addr1 < i || e.addr2 > e.dol || e.addr1 > e.addr2 
  then Error.e_warn "can't squeeze"
@

\subsection{[[append()]] and [[getfile()]]}

<<function [[Commands.append]]>>=
(* f can be Disk.getfile() or In.gettty() (or even getsub()?) *)
let append (e : Env.t) (f : unit -> string option) (addr : lineno) : int =
  e.dot <- addr;
  let nline = ref 0 in

  let rec aux () =
    match f () with
    | None -> (* EOF *) !nline
    | Some line ->
        <<[[Commands.append()]] grow [[zero]] if needed>>
        let tl = Disk.putline e line in
        incr nline;
        e.dol <- e.dol + 1;
        (* insert new line after e.dot *)
        e.dot <- e.dot + 1;

        (* shift zero entries from e.dol down to e.dot up one by one *)
        let a1 = ref e.dol in
        let a2 = ref (!a1 + 1) in
        while !a1 > e.dot do
          e.zero.(!a2) <- e.zero.(!a1);
          decr a2; decr a1;
        done;
        (* finally insert the new line reference in zero *)
        e.zero.(e.dot) <- {offset = tl; mark = false};
        aux ()
  in
  aux ()
@
% can append in middle of file, not always at the end,
% at addr (env.addr2 usually), so everything after addr must be
% adjusted

% Figure?

<<signature [[Disk.putline]]>>=
(* store line (with added trailing '\n') in tfile and return its offset *)
val putline : Env.t -> string -> Env.tfile_offset
@


<<[[Commands.append()]] grow [[zero]] if needed>>=
if e.dol + 2 >= Array.length e.zero 
then begin
    let oldz = e.zero in
    let len = Array.length oldz in
    let newz  = Array.make (len + 512) Env.no_line in
    Array.blit oldz 0 newz 0 len;
    e.zero <- newz;
end;
@


<<function [[Disk.getfile]]>>=
(* will return one line (without trailing '\n') or None when reached EOF *)
let getfile (e : Env.t) (chan : Chan.i) () : string option =
  (* alt: use Stdlib.input_line which does some extra magic around newlines
   * and EOF we want, because ed also uniformize the lack of newline before EOF
   * (see the "\\n appended" message below),but we want to to match exactly what
   * ed does and display the same error message so we need to go lower level
   * than input_line and use input_char directly.
   *)
  try 
    (* 's' will not have the trailing '\n' *)
    let s = input_line chan.ic in
    e.count <- e.count + String.length s + 1 (* to count the new line *);
    Some s
  with End_of_file -> None
@

\subsection{[[putline()]]}

<<function [[Disk.putline]]>>=
(* store line in tfile and return its offset *)
let putline (e : Env.t) (line : string) : Env.tfile_offset =
  e.fchange <- true;
  let Tfile_offset old_tline = e.tline in
  Unix.lseek e.tfile old_tline Unix.SEEK_SET |> ignore;
  (* alt: could use a different terminator like '\0' in C but simpler to
   * use \n *)
  let line = line ^ "\n" in
  let len = String.length line in
  Unix.write e.tfile (Bytes.of_string line) 0 len |> ignore;
  e.tline <- Tfile_offset (old_tline + len);
  Tfile_offset old_tline
@

\subsection{[[exfile()]]}

<<type [[Commands.mode]]>>=
type mode = READ | WRITE
@

<<function [[Commands.exfile]]>>=
(* ed: "exit" file =~ close file *)
let exfile (e : Env.t) (_m : mode) : unit =
  (* ed: is using passed mode to flush if WRITE but no need in ocaml
   * because closing the channel will flush any remaining IO.
   *)
  if e.vflag then begin
      Out.putd e;
      Out.putchr e '\n';
  end
@

<<signature [[Out.putd]]>>=
(* will print Env.count *)
val putd: Env.t -> unit
@

<<function [[Out.putd]]>>=
(* display e.count *)
let rec putd (e : Env.t) : unit =
  let r = e.count mod 10 in
  e.count <- e.count / 10;
  if e.count > 0
  then putd e;
  putchr e (Char.chr (Char.code '0' + r))
@





\section{[[w]]riting a file: [[w]]}

<<[[CLI.commands()]] match [[c]] writing cases>>=
| 'w' | 'W' ->
   if c = 'W' then e.wrapp <- true;
   (* TODO: if [wW][qQ] *)
   let file : Fpath.t = In.filename e c in
   Commands.write caps e file;
@

<<[[Env.t]] other fields>>=
(* write append, for 'W' *)
mutable wrapp : bool;
@

<<signature [[Commands.write]]>>=
(* 'w'*)
val write: <Cap.open_out; ..> -> Env.t -> Fpath.t -> unit
@

<<function [[Commands.write]]>>=
(* 'w' *)
let write (caps : < Cap.open_out; ..>) (e : Env.t) (file : Fpath.t) : unit =
  <<[[Commands.write()]] restricted mode check>>
  try 
    file |> FS.with_open_out caps (fun chan ->
        (* TODO: when wq (or do in caller in CLI.ml) *)
        setwide e;
        squeeze e (if e.dol > 0 then 1 else 0);

        (* TODO: e.wrapp open without create mode? *)
        e.wrapp <- false;
        if e.dol > 0
        then Disk.putfile e chan;

        exfile e WRITE;
        if e.addr1 <= 1 && e.addr2 = e.dol
        then e.fchange <- false;
        (* TODO: when wq *)
    )
  with Sys_error str ->
    Logs.err (fun m -> m "Sys_error: %s" str);
    Error.e_legacy !!file
@

<<signature [[Disk.putfile]]>>=
(* dual of getfile() but this time writing all the lines, not just one *)
val putfile: Env.t -> Chan.o -> unit
@

\subsection{[[putfile()]]}

%(* TODO:
%  let string_of_chars xs =
%    (* alt: do that in caller, again cleaner than in filename *)
%    e.count <- e.count + List.length xs;
%    failwith "TODO"
%  in
%  let rec aux acc
%    let copt : char option =
%      try Some (input_char chan.i)
%      with End_of_file -> None
%    in
%    (match copt with
%    | None -> 
%        if acc = []
%        then None
%        else begin 
%           Out.putstr e "\\n appended";
%           Some (('\n'::acc) |> List.rev |> string_of_chars)
%        end
%     | Some c -> aux (c::acc)
%    ...
%*)

<<function [[Disk.putfile]]>>=
(* dual of getfile() but this time writing all the lines, not just one *)
let putfile (e : Env.t) (chan : Chan.o) : unit =
  for a1 = e.addr1 to e.addr2 do
    let l = getline e a1 ^ "\n" in
    e.count <- e.count + String.length l;
    output_string chan.oc l;
  done
@

<<signature [[Disk.getline]]>>=
(* retrieve line in tfile (without trailing '\n') *)
val getline: Env.t -> Env.lineno -> string
@

\subsection{[[getline()]]}

<<function [[Disk.getline]]>>=
(* dual of putline(), retrieve line in tfile (without trailing '\n') 
 * ed: was taking an Env.tfile_offset but cleaner to take addr
 *)
let getline (e : Env.t) (addr : Env.lineno)  : string =
  let tl = e.zero.(addr).offset in
  let Tfile_offset offset = tl in
  Unix.lseek e.tfile offset Unix.SEEK_SET |> ignore;
  (* alt: Stdlib.input_line (Unix.in_channel_of_descr ...) but then
   * need to close it which unfortunately also close the file_descr so
   * we do our own adhoc input_line below.
   *)
  let bytes = Bytes.of_string " " in
  let rec aux acc =
    let n = Unix.read e.tfile bytes 0 1 in
    let c : char = Bytes.get bytes 0 in
    if n = 1 && c <> '\n'
    then aux (c::acc)
    (* no need to add the \n, putshst will add it *)
    else String_.of_chars (List.rev acc)
  in
  aux []
@

%%\subsection{Write and quit: [[wq]]}



\section{Main commands}

\subsection{[[p]]rinting lines: [[p]]}

<<[[CLI.commands()]] match [[c]] inspecting cases>>=
| 'p' | 'P' ->
   In.newline e;
   Commands.printcom e;
@

<<signature [[Commands.printcom]]>>=
(* 'p' *)
val printcom : Env.t -> unit
@

<<signature [[In.newline]]>>=
(* check the next token is a newline (or EOF) and consume it *)
val newline: Env.t -> unit
@

<<function [[In.newline]]>>=
let newline (e : Env.t) : unit =
  match Parser.consume e.in_ with
  | T.Newline -> ()
  (* tricky but is useful to treat EOF as a newline sometimes
   * like for globp "r" but sometimes not in g/re/x globp context so that
   * it is consumed by commands() leading to returning from commands().
   *)
  | T.EOF -> ()
  (* TODO: if special chars pln ? *)
  | t -> Parser.was_expecting_but_got "newline" t
@

<<function [[Commands.printcom]]>>=
(* 'p' *)
let printcom (e : Env.t) : unit =
  nonzero e;
  for a1 = e.addr1 to e.addr2 do
    (* TODO: if listn *)
    Out.putshst e (Disk.getline e a1);
  done;
  e.dot <- e.addr2;
  (* TODO: reset flags *)
  ()
@

<<signature [[Out.putshst]]>>=
(* ed: put "shell" string, legacy name, identical to putst for oed *)
val putshst : Env.t -> string -> unit 
@

<<signature [[Commands.nonzero]]>>=
val nonzero: Env.t -> unit
@
<<function [[Commands.nonzero]]>>=
let nonzero (e : Env.t) =
  squeeze e 1
@

<<function [[Out.putshst]]>>=
(* origin: put shell string? *)
let putshst (e : Env.t) (str : string) : unit =
  (* no diff between rune and chars in oed *)
  putst e str
@


<<[[CLI.commands()]] [[Newline]] case>>=
(* print when no command specified, as in 1\n *)

(* ed: was a1 == nil but simpler to look at given *)
if not range.given then begin
  (* so any subsequent newline will display a successive line *)
  let a1 = e.dot + 1 in
  e.addr2 <- a1;
  e.addr1 <- a1;
end;
(* note that printcom() will internally set e.dot to e.addr2
 * TODO: if lastsep = ';' *)
Commands.printcom e;
@


<<[[CLI.commands()]], at loop start, if [[pflag]]>>=
if e.pflag then begin
    e.pflag <- false;
    e.addr1 <- e.dot;
    e.addr2 <- e.dot;
    Commands.printcom e;
end;
@

<<[[Env.t]] other fields>>=
(* set by ?? effect is to Out.printcom() in commands () before the next cmd *)
mutable pflag: bool;
@


\subsection{printing remembered [[f]]ile: [[f]]}

<<[[CLI.commands()]] match [[c]] inspecting cases>>=
| 'f' ->
   (* alt: move in Commands.file() *)
   Commands.setnoaddr e;
   let file : Fpath.t = In.filename e c in
   assert (e.savedfile = Some file);
   Out.putst e !!file;
@

<<signature [[Commands.setnoaddr]]>>=
val setnoaddr: Env.t -> unit
@
<<function [[Commands.setnoaddr]]>>=
let setnoaddr (e : Env.t) =
  if e.given
  then Error.e_err "setnoaddr ??"
@

\subsection{printing line number: [[=]]}

<<[[CLI.commands()]] match [[c]] inspecting cases>>=
| '=' ->
   (* alt: move in Commands.print_dot_line_number() *)
   Commands.setwide e;
   Commands.squeeze e 0;
   In.newline e;
   e.count <- e.addr2;
   Out.putd e;
   Out.putchr e '\n';
@



\subsection{[[a]]ppend and [[i]]nsert: [[a]], [[i]]}

<<[[CLI.commands()]] match [[c]] modifying cases>>=
| 'a' -> 
   <<[[CLI.commands()]] in [['a']] case, log append mode>>
   Commands.add e 0
@
<<[[CLI.commands()]] match [[c]] modifying cases>>=
| 'i' -> 
   <<[[CLI.commands()]] in [['i']] case, log insert mode>>
   Commands.add e (-1)
@

<<signature [[Commands.add]]>>=
(* 'a' and 'i' *)
val add: Env.t -> int -> unit
@

<<function [[Commands.add]]>>=
(* used for 'a' and 'i' *)
let add (e : Env.t) (i : int) =
  if i <> 0 && (e.given || e.dol > 0) then begin
     e.addr1 <- e.addr1 - 1;
     e.addr2 <- e.addr2 - 1;
  end;
  squeeze e 0;
  In.newline e;
  append e (In.gettty e) e.addr2 |> ignore
@

\subsection{[[q]]uitting: [[q]]}

<<[[CLI.commands()]] match [[c]] other cases>>=
| 'q' | 'Q' ->
   if c = 'Q' then e.fchange <- false;
   Commands.setnoaddr e;
   In.newline e;
   Commands.quit caps e;
@

\subsection{[[d]]eleting lines: [[d]]}

<<[[CLI.commands()]] match [[c]] modifying cases>>=
| 'd' ->
   Commands.nonzero e;
   In.newline e;
   Commands.rdelete e e.addr1 e.addr2;
@

<<signature [[Commands.rdelete]]>>=
(* 'd' and 'c' *)
val rdelete: Env.t -> Env.lineno -> Env.lineno -> unit
@

<<function [[Commands.rdelete]]>>=
(* used for 'r' and 'c' *)
let rdelete (e : Env.t) (ad1 : lineno) (ad2 : lineno) =
  let a1 = ref ad1 in
  let a2 = ref (ad2 + 1) in
  let a3 = e.dol in
  e.dol <- e.dol - (!a2 - !a1);
  let rec aux () =
    e.zero.(!a1) <- e.zero.(!a2);
    incr a1;
    incr a2;
    if !a2 <= a3
    then aux ()
  in
  aux ();
  a1 := ad1;
  if !a1 > e.dol then a1 := e.dol;
  e.dot <- !a1;
  e.fchange <- true
@

\subsection{[[c]]hanging lines: [[c]]}

<<[[CLI.commands()]] match [[c]] modifying cases>>=
| 'c' ->
   Commands.nonzero e;
   In.newline e;
   Commands.rdelete e e.addr1 e.addr2;
   Commands.append e (In.gettty e) (e.addr1 - 1) |> ignore;
@

%\subsection{[[m]]oving and copying lines: [[m]] and [[t]]}



\section{Command addresses}

%ex: 1,3p

\subsection{Parsing addresses}

<<[[Lexer.token()]] other cases>>=
(* for the addresses *)
| digit+        { Int (int_of_string (Lexing.lexeme lexbuf)) }
| '.' { Dot } | '$' { Dollar }

| ',' { Comma } 
| '+' { Plus } | '-' { Minus }
@

<<function [[Address.parse_address]]>>=
let parse_address (st : Parser.state) : t =
  let base =
    match P.peek st with
    | T.Plus | T.Minus | T.Caret ->
      (* implicit '.' for leading + - ^ *)
      Current
    | _ ->
        (match P.consume st with
        | T.Dot -> Current
        | T.Dollar -> Last
        | T.Int n -> Line n
        <<[[Address.parse_address()]] match consumed token other cases>>
        | _ -> P.was_expecting "valid address"
        )
  in
  parse_relatives base st
@

<<function [[Address.parse_relatives]]>>=
let rec parse_relatives (base : t) (st : Parser.state) : t =
  match P.peek st with
  | T.Plus | T.Minus | T.Caret ->
      let d = parse_delta st in
      (* recurse, one can have multiple ++ -- *)
      parse_relatives (Relative (base, d)) st
  | _ ->
      base
@

<<function [[Address.parse_delta]]>>=
let parse_delta (st : Parser.state) : int =
  match P.consume st with
  | T.Plus ->
      (match P.peek st with
       | T.Int n -> ignore (P.consume st); n
       | _ -> 1)
  | T.Minus ->
      (match P.peek st with
       | T.Int n -> ignore (P.consume st); -n
       | _ -> -1)
  <<[[Address.parse_delta()]] match consumed token other cases>>
  | _ ->
      P.was_expecting "relative operator"
@


<<function [[Address.parse_range]]>>=
let parse_range (st : Parser.state) : range =
  let t1 = P.peek st in
  (* optional first address *)
  let first : t option =
    <<[[Address.parse_range()]] compute optional [[first]] address>>
  in

  let t2 = P.peek st in
  match t2 with
  <<[[Address.parse_range()]] [[Comma]] or [[Semicolon]] case>>
  | _ ->
      (* single address or none *)
      (match first with
      | Some a ->
          { addr1 = None; addr2 = a; given = true; set_dot = false; }
      | None ->
          (* no addresses given, implicit "." (Current) *)
          { addr1 = None; addr2 = Current; given = false; set_dot = false; }
      )
@

<<[[Address.parse_range()]] compute optional [[first]] address>>=
match t1 with
| T.Plus | T.Minus | T.Caret
| T.Dot | T.Dollar | T.Int _
| T.Mark _ | T.Slash _ | T.Question _ ->
    (* this will consume some tokens in st *)
    Some (parse_address st)
| T.Comma | T.Semicolon
| T.EOF | T.Spaces | T.Newline | T.Char _ ->
    None
@

<<[[Address.parse_range()]] [[Comma]] or [[Semicolon]] case>>=
| T.Comma | T.Semicolon ->
    P.consume st |> ignore;
    let second = 
      match P.peek st with
      | T.Plus | T.Minus | T.Caret
      | T.Dot | T.Dollar | T.Int _
      | T.Mark _ | T.Slash _ | T.Question _ ->
         parse_address st 
      (* a missing second address default to '$' *)
      | T.Comma | T.Semicolon 
      | T.EOF | T.Spaces | T.Newline | T.Char _ ->
         Last
    in
    {
       (* a missing first address in a range default to '1' so
        * a range like "," will be parsed as "1,$"
        *)
        addr1 = (match first with Some _ -> first | None -> Some (Line 1)); 
        addr2 = second;
        given = true; 
        set_dot = (t2 = T.Semicolon);
       }
@


\subsection{Evaluating addresses}

<<function [[Address.eval_address]]>>=
let rec eval_address (e : Env.t) (adr : t) : Env.lineno =
  match adr with
  | Current -> e.dot
  | Last -> e.dol
  | Line n -> n
  | Relative (x, n) -> eval_address e x + n
  <<[[Address.eval_address()]] match [[adr]] other cases>>
@

<<function [[Address.eval_range]]>>=
let eval_range (e : Env.t) (r : range) : Env.lineno * Env.lineno =
  <<[[Address.eval_range]] debug range>>

  let addr2 = eval_address e r.addr2 in
  let addr1 =
    match r.addr1 with
    | None -> addr2
    | Some a -> eval_address e a
  in
  addr1, addr2
@

% so 1,3p => addr1 = 1, addr2 = 3
% 1p => addr1 = addr2 = 1

\section{Search and replace}

<<type [[Regex.t]]>>=
type t = Str.regexp
@

\subsection{Parsing regexps}

% actually not really parse; loose parsing, just look for /.../
% handling correctly escaping, a bit like when parsing
% a string "", dont look what's inside, just look for ending delimiter.

<<[[Token.t]] other cases>>=
| Slash of string | Question of string
@


<<[[Lexer.token()]] other cases>>=
| '/'              { Buffer.clear buf; Slash (regexp '/' lexbuf) }
| '?'              { Buffer.clear buf; Question (regexp '?' lexbuf) }
@

<<signature [[Lexer.buf]]>>=
(* ugly: should not be needed outside *)
val buf: Buffer.t
@
<<constant [[Lexer.buf]]>>=
let buf = Buffer.create 32
@

<<signature [[Lexer.regexp]]>>=
val regexp: char -> Lexing.lexbuf -> string
@

<<function [[Lexer.regexp]]>>=
and regexp delim = parse
  | '\\' (_ as c) {
      Buffer.add_char buf '\\'; Buffer.add_char buf c; regexp delim lexbuf
    }
  | '/' {
      if delim = '/'
      then Buffer.contents buf
      else begin Buffer.add_char buf '/'; regexp delim lexbuf end
     }
  | '?' {
      if delim = '?'
      then Buffer.contents buf
      else begin Buffer.add_char buf '?'; regexp delim lexbuf end
    }
  | '\n' | eof { failwith "Unterminated regular expression" }
  | _ as c { Buffer.add_char buf c; regexp delim lexbuf }
@

\subsection{Search as addresses: [[/re/]] and [[?re?]]}

%\subsubsection{Evaluating regexp addresses}

<<[[Address.t]] other cases>>=
| SearchFwd of string (* /.../ *)
| SearchBwd of string (* ?...? *)
@

<<[[Address.parse_address()]] match consumed token other cases>>=
| T.Slash r -> SearchFwd r
| T.Question r -> SearchBwd r
@

<<[[Address.eval_address()]] match [[adr]] other cases>>=
| SearchFwd _ | SearchBwd _ -> 
    let dir, re_str = 
      match adr with 
      | SearchFwd re -> 1, re
      | SearchBwd re -> -1, re
      | _ -> raise (Impossible "cases matched above")
    in
    (* less: opti: use SearchFwd of regex instead of str *)
    let re = Str.regexp re_str in

    (* starting point *)
    (* TODO: ed: need to be `a` instead like in C ? *)
    let a = e.dot in
    let b = a in

    let rec aux (a : Env.lineno) : Env.lineno =
      let a = a + dir in
      <<[[Address.eval_address()]] when SearchXxx case, wrap [[a]]>>
      match () with
      | _ when Commands.match_ e re a -> a
      <<[[Address.eval_address()]] when SearchXxx case, when back to start>>
      | _ ->
          aux a
    in
    aux a
@

<<signature [[Commands.match_]]>>=
val match_: Env.t -> Regex.t -> Env.lineno -> bool
@

<<[[Address.eval_address()]] when SearchXxx case, wrap [[a]]>>=
let a =
  match () with
  (* wrap around start/end of buffer *)
  | _ when a <= 0 -> e.dol
  | _ when a > e.dol -> 1
  | _ -> a
in
@

<<[[Address.eval_address()]] when SearchXxx case, when back to start>>=
(* back to starting point and nothing was found *)
| _ when a = b ->
    Error.e_warn (spf "search for %s had no match" re_str)
@

\subsection{[[match()]]}

<<function [[Commands.match_]]>>=
let match_ (e : Env.t) (re : Regex.t) (addr : Env.lineno) : bool =
  let line = Disk.getline e addr in
  Regex.match_str re line
@

%(* val match_str: Regex.t -> string -> bool *)
<<function [[Regex.match_str]]>>=
let match_str (re : t) (str: string) : bool =
  (* old: Str.string_match re line 0, but we need unanchored search *)
  try
    Str.search_forward re str 0 |> ignore;
    true
   with Not_found -> false
@

%%\subsection{Parsing substitutions}

\subsection{[[s]]ubstitute: [[s]]}

<<[[CLI.commands()]] match [[c]] modifying cases>>=
| 's' ->
    Commands.nonzero e;
    Commands.substitute e (e.in_.globp <> None);
@

<<signature [[Commands.substitute]]>>=
(* 's' *)
val substitute: Env.t -> bool (* inglob *) -> unit
@

<<function [[Commands.substitute]]>>=
(* used for 's' *)
let substitute (e : Env.t) (_inglob: bool) : unit =
  (* TODO: handle inglob *)
  match Parser.consume e.in_ with
  (* handle | Question re_str? does not really make sense. *)
  | Slash re_str ->
      let re = Str.regexp re_str in
      (* ugly: *) 
      Buffer.clear Lexer.buf;
      let subst_str = Lexer.regexp '/' e.in_.stdin in
      (* TODO: parse 's/.../.../g' *)
      In.newline e;

      for a1 = e.addr1 to e.addr2 do
        let line = Disk.getline e a1 in
        (* TODO: handle 's/.../.../g' *)
        if Regex.match_str re line
        then begin
           let loc1 = Str.match_beginning () in
           let loc2 = Str.match_end () in
           let len = String.length line in
           
           let before = String.sub line 0 loc1 in
           let _matched = String.sub line loc1 (loc2 - loc1) in
           let after = String.sub line loc2 (len - loc2) in
           (* TODO: handle & and \1 in subst_str *)
           let newline = before ^ subst_str ^ after in

           let tl = Disk.putline e newline in
           (* TODO: mark? *)
           e.zero.(a1) <- { offset = tl; mark = false }
        end
      done

  | t -> Parser.was_expecting_but_got "a regexp" t
@

\subsection{Advanced substitutions}

\subsubsection{mar[[k]]: [[k]]}

<<[[Token.t]] other cases>>=
| Mark of char
@

<<[[Lexer.token()]] other cases>>=
| '\'' ['a'-'z'] as s { Mark s.[1] }
@

<<[[Address.t]] other cases>>=
| Mark of char (* \a *)
@

<<[[Address.parse_address()]] match consumed token other cases>>=
| T.Mark c -> Mark c
@

<<[[Address.eval_address()]] match [[adr]] other cases>>=
| Mark _ -> failwith "TODO: Mark"
@


\subsection{[[g]]lobal commands: [[g/re/cmd]] and [[v/re/cmd]]}

<<[[CLI.commands()]] match [[c]] global cases>>=
| 'g' -> global caps e true
| 'v' -> global caps e false
@

<<function [[CLI.global]]>>=
(* g/re/cmd, v/re/cmd *)
and global caps (e : Env.t) (pos_or_neg : bool) : unit =

  e.in_.globp |> Option.iter (fun _ ->
      Error.e_err "global command already in"
  );
  Commands.setwide e;
  Commands.squeeze e (if e.dol > 0 then 1 else 0);

  match Parser.consume e.in_ with
  | Slash str ->
      let re = Str.regexp str in
      (* TODO: Lexer.line_or_escaped_lines *)
      let line = Lexer.line e.in_.stdin in
      let line = if line = "" then "p" else line in

      (* step1: marking the matching lines *)
      (* ed: was starting at 0, but then special case later in match()
       * so simpler to start at 1 
       * old: I was recording in a local xs the list of matched lineno, but
       * it does not work because commands() in step2 below may modify 
       * zero which would invalidate the matched lineno of step1
       *)
      for a1 = 1 to e.dol do
        if a1 >= e.addr1 && a1 <= e.addr2 &&
            Commands.match_ e re a1 = pos_or_neg then
          e.zero.(a1).mark <- true
      done;

      (* step2: processing the matching lines
       * old: for a1 = 1 to e.dol, but can't work because
       * commands() below might modify zero and delete lines in which case
       * dol will change dynamicaly.
       *)
      let a1 = ref 1 in
      while !a1 <= e.dol do
        if e.zero.(!a1).mark then begin
            e.zero.(!a1).mark <- false;
            e.dot <- !a1;
            (* ugly: need trailing \n otherwise T.EOF would be consumed
             * too early by In.Newline().
             *)
            e.in_.globp <- Some (Lexing.from_string (line ^ "\n"));
            (* recurse!! *)
            commands caps e;
            (* need to restart from scratch, but with one less marked line *)
            a1 := 0
        end;
        incr a1
      done
  
  | t -> Parser.was_expecting_but_got "a regexp" t
@




\section{Advanced features}

\subsection{Running a shell command: [[!]]}

<<[[CLI.commands()]] match [[c]] other cases>>=
| '!' -> 
   Commands.callunix caps e
@

<<signature [[Commands.callunix]]>>=
(* '!' *)
val callunix: <Cap.forkew; ..> -> Env.t -> unit
@

<<function [[Commands.callunix]]>>=
(* '! *)
let callunix (caps : <Cap.forkew; ..>) (e: Env.t) : unit =
  setnoaddr e;
  let s = In.gety e in
  <<[[Commands.callunix()]] restricted mode check>>
  (* ed: was calling rc -c but here we reuse (Cap)Sys.command which relies
   * on the default shell
   *)
  let _ret = CapSys.command caps s in
  if e.vflag
  then Out.putst e "!"
@

\subsection{[[ed -r]] and [[rflag]] restricted mode}

<<[[CLI.main()]] local flags>>=
(* new: restricted ed *)
let rflag = ref false in
@
<<[[CLI.main()]] local [[options]] elements>>=
"-r", Arg.Set rflag,
" restricted mode: no shell commands; edits limited to current directory";
@
<<[[Env.t]] flag fields>>=
(* new: from GNU ed, "restrited mode" *)
rflag: bool;
@

<<[[CLI.main()]] restrict caps>>=
let caps = restrict_caps !rflag caps in
@

<<function [[CLI.restrict_caps]]>>=
let restrict_caps rflag (x : < caps; ..>) =
  object
    method exec = 
      if rflag then Error.e_err "!restricted mode on!"
      else x#exec
    method open_in file = 
      if rflag && not (Fpath.is_seg file)
      then Error.e_err (spf "!restricted mode on, can't read %s!" file)
      else x#open_in file
    method open_out file = 
      if rflag && not (Fpath.is_seg file) &&
         (* need open_out to delete tmp file in Commands.quit() *)
         not (file = !!Env.tfname)
      then Error.e_err (spf "!restricted mode on, can't write %s!" file)
      else x#open_out file
    method fork = x#fork
    method wait = x#wait
    method stdin = x#stdin
    method stdout = x#stdout
    method stderr = x#stderr
  end
@

<<function [[Commands.file_in_current_dir]]>>=
let file_in_current_dir (file : Fpath.t) : bool =
  (* alt: use Unix.realpath, follow symlink and compare to cwd *)
  Fpath.is_seg !!file
@


<<[[Commands.callunix()]] restricted mode check>>=
(* needed only for ocaml-light who does not support method call
 * and so can't provide the dynamic caps of CLI.restrict_caps
 *)
if e.rflag 
then Error.e_err "restricted mode on";
@

<<[[Commands.read()]] restricted mode check>>=
(* ocaml-light: see callunix() comment below *)
if e.rflag && not (file_in_current_dir file)
then Error.e_err (spf "restricted mode on, can't access %s" !!file);
@

<<[[Commands.write()]] restricted mode check>>=
(* ocaml-light: see callunix() comment below *)
if e.rflag && not (file_in_current_dir file)
then Error.e_err (spf "restricted mode on, can't access %s" !!file);
@

\subsection{The caret}

% show ex of need

% why need that? - not enough?
<<[[Token.t]] other cases>>=
| Caret
@
<<[[Lexer.token()]] other cases>>=
| '^' { Caret }
@

<<[[Address.parse_delta()]] match consumed token other cases>>=
| T.Caret -> -1
@

\subsection{The semicolon}

% show ex of need

<<[[Token.t]] other cases>>=
| Semicolon
@

<<[[Lexer.token()]] other cases>>=
| ';' { Semicolon }
@

<<[[Address.range]] other fields>>=
set_dot : bool;
@

%TODO! finish implem!

\section{Error management and logging}

\subsection{Legacy error management}

<<exception [[Error.Error]]>>=
exception Error of string
@

<<function [[Error.e_legacy]]>>=
(* the raise will effectively jump on the exn handler in CLI.main()
 * ed: we emulate the longjmp done in C.
 *)
let e_legacy s =
  raise (Error s)
@

<<[[CLI.main()]] exn handler for [[Error.Error s]]>>=
(* ed: was in a separate error_1() function *)
(* TODO: reset globals too? *)
Out.putchr env '?';
Out.putst env s;
@
% but quite cryptic ... especially because most errors
% are called via Error.e_legacy "" empty string, hmm
% with just a '?' displayed

\subsection{Improved error reporting and logging}

<<[[CLI.main()]] local flags>>=
let level = ref (Some Logs.Warning) in
@

<<[[CLI.main()]] local [[options]] elements>>=
(* new: this is verbose *logging*, different from interactive mode *)
"-verbose", Arg.Unit (fun () -> level := Some Logs.Info),
" verbose logging mode";
"-debug", Arg.Unit (fun () -> level := Some Logs.Debug),
" debug logging mode";
"-quiet", Arg.Unit (fun () -> level := None),
" quiet logging mode";
@
<<[[CLI.main()]] setup logging after parsed argv>>=
Logs_.setup !level ();
@

<<function [[Error.e_warn]]>>=
let e_warn s =
  Logs.warn (fun m -> m "%s" s);
  (* ed: to remain backward compatible *)
  raise (Error "")
@

<<function [[Error.e_err]]>>=
let e_err s =
  Logs.err (fun m -> m "%s" s);
  raise (Error "")
@

<<signature [[Parser.was_expecting]]>>=
(* internals that are used outside for now *)
val was_expecting: string -> 'a
@
<<signature [[Parser.was_expecting_but_got]]>>=
val was_expecting_but_got: string -> Token.t -> 'a
@

<<function [[Parser.was_expecting]]>>=
let was_expecting (expect : string) =
  Error.e_err (spf "was expecting %s" expect)
@
<<function [[Parser.was_expecting_but_got]]>>=
let was_expecting_but_got (expect : string) (tok : Token.t) =
  was_expecting (spf "%s, but got %s" expect (Token.show tok))
@


% common pb with ed is people don't even know they are in insert mode
<<[[CLI.commands()]] in [['a']] case, log append mode>>=
Logs.info (fun m -> m "append mode");
@
<<[[CLI.commands()]] in [['i']] case, log insert mode>>=
Logs.info (fun m -> m "insert mode");
@
<<[[In.gettty()]] log end of input>>=
Logs.info (fun m -> m "end of input, back to ed");
@

\section{Debugging support}

% Logging helps a lot already when using -debug

<<[[CLI.main()]] debug env>>=
Logs.debug (fun m -> m "env = %s" (Env.show env));
@

<<[[Parser.next_token()]] debug token>>=
Logs.debug (fun m -> m "tok = %s" (Token.show t));
@

<<[[Address.eval_range]] debug range>>=
Logs.debug (fun m -> m "range = %s" (show_range r));
@

<<[[CLI.commands()]] debug start>>=
Logs.debug (fun m -> m "commands ->");
@
<<[[CLI.commands()]] debug end>>=
Logs.debug (fun m -> m "commands <-");
@
% useful for nested globals commands

% And added a 'X' to dump internal state

<<[[CLI.commands()]] match [[c]] inspecting cases>>=
(* new: dumping internal state (useful for debugging) *)
| 'X' -> 
   In.newline e;
   Unix.fsync e.tfile;
   Logs.app (fun m -> m "env = %s\ntfile content =\n%s"
              (Env.show e)
              (FS.cat caps Env.tfname |> String.concat "\n"));
@



\ifallcode
\section{Extra code}

\subsection*{[[Address.mli]]}

<<Address.mli>>=
<<type [[Address.t]]>>
<<type [[Address.range]]>>

<<signature [[Address.parse_range]]>>
<<signature [[Address.eval_range]]>>
@

\subsection*{[[Address.ml]]}

<<Address.ml>>=
(* Copyright 2025, 2026 Yoann Padioleau, see copyright.txt *)
open Common
module Str = Re_str

module P = Parser
module T = Token

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Parsing and evaluating command addresses *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Address.t]]>>
[@@deriving show]
<<type [[Address.range]]>>
[@@deriving show]

(*****************************************************************************)
(* Parsing *)
(*****************************************************************************)
<<function [[Address.parse_delta]]>>
<<function [[Address.parse_relatives]]>>

<<function [[Address.parse_address]]>>
<<function [[Address.parse_range]]>>

(*****************************************************************************)
(* Evaluating *)
(*****************************************************************************)

(* TODO? need to pass [[a]] like in C with e.dot and adjust [[a]] as we go
 * like in C? so that /.../ and ?...? start from the right place?
 *)
<<function [[Address.eval_address]]>>
<<function [[Address.eval_range]]>>
@

\subsection*{[[CLI.ml]]}

<<CLI.ml>>=
(* Copyright 2025, 2026 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
module Str = Re_str

open Env
module T = Token
module A = Address

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of ed from Plan 9 (and Unix).
 *
 * Limitations compared to Plan 9 version:
 *  - no unicode (runes) support
 *  - lots of missing features (&, \1, marks, etc.)
 *
 * Improvements over Plan 9 C version:
 *  - support -r restricted mode like in GNU ed
 *  - clearer error messages (via logging)
 *  - far less globals!
 *  - no fixed-size array for saved file, buffers, lines, etc.
 *  - no hard limits on max line size, max size of temp file, 
*)

(*****************************************************************************)
(* Caps *)
(*****************************************************************************)
<<type [[CLI.caps]]>>
<<function [[CLI.restrict_caps]]>>

(*****************************************************************************)
(* Main algorithm *)
(*****************************************************************************)
<<function [[CLI.commands]]>>
<<function [[CLI.global]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[CLI.main]]>>
@

\subsection*{[[CLI.mli]]}

<<CLI.mli>>=
<<type [[CLI.caps]]>>
<<signature [[CLI.main]]>>
@

\subsection*{[[Commands.ml]]}

<<Commands.ml>>=
(* Copyright 2025, 2026 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
module Str = Re_str

open Env

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* The main commands *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Commands.setwide]]>>
<<function [[Commands.squeeze]]>>
<<function [[Commands.nonzero]]>>
<<function [[Commands.setnoaddr]]>>

<<type [[Commands.mode]]>>
<<function [[Commands.exfile]]>>

<<function [[Commands.match_]]>>

<<function [[Commands.file_in_current_dir]]>>

(*****************************************************************************)
(* append in tfile and adjust e.zero *)
(*****************************************************************************)
<<function [[Commands.append]]>>

(*****************************************************************************)
(* Commands *)
(*****************************************************************************)
(* ------------------------------------------------------------------------- *)
(* Inspecting *)
(* ------------------------------------------------------------------------- *)
<<function [[Commands.printcom]]>>
(* ------------------------------------------------------------------------- *)
(* Reading *)
(* ------------------------------------------------------------------------- *)
<<function [[Commands.read]]>>
(* ------------------------------------------------------------------------- *)
(* Writing *)
(* ------------------------------------------------------------------------- *)
<<function [[Commands.write]]>>
(* ------------------------------------------------------------------------- *)
(* Modifying *)
(* ------------------------------------------------------------------------- *)
<<function [[Commands.add]]>>
<<function [[Commands.rdelete]]>>

<<function [[Commands.substitute]]>>

(* ------------------------------------------------------------------------- *)
(* Other *)
(* ------------------------------------------------------------------------- *)
<<function [[Commands.quit]]>>
<<function [[Commands.callunix]]>>
@

\subsection*{[[Commands.mli]]}

<<Commands.mli>>=
<<signature [[Commands.read]]>>
<<signature [[Commands.write]]>>
<<signature [[Commands.add]]>>
<<signature [[Commands.printcom]]>>
<<signature [[Commands.rdelete]]>>
<<signature [[Commands.quit]]>>
<<signature [[Commands.substitute]]>>
<<signature [[Commands.callunix]]>>

<<signature [[Commands.setwide]]>>
<<signature [[Commands.squeeze]]>>
<<signature [[Commands.nonzero]]>>
<<signature [[Commands.setnoaddr]]>>
<<signature [[Commands.match_]]>>

<<signature [[Commands.append]]>>
@

\subsection*{[[Disk.ml]]}

<<Disk.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Helpers to read/write in temporary file (Env.tfile) or specified
 * user file (Env.savedfile).
 *)

(*****************************************************************************)
(* getline/putline (from/to tfile) *)
(*****************************************************************************)
<<function [[Disk.putline]]>>
<<function [[Disk.getline]]>>

(*****************************************************************************)
(* getfile/putfile (from/to savedfile) *)
(*****************************************************************************)
<<function [[Disk.getfile]]>>
<<function [[Disk.putfile]]>>
@

\subsection*{[[Disk.mli]]}

<<Disk.mli>>=
<<signature [[Disk.putline]]>>
<<signature [[Disk.getline]]>>

<<signature [[Disk.getfile]]>>
<<signature [[Disk.putfile]]>>
@

\subsection*{[[Env.ml]]}

<<Env.ml>>=
(* Copyright 2025, 2026 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* A set of globals used by many functions packed in an "environment" record *)

(*****************************************************************************)
(* Hack for deriving show *)
(*****************************************************************************)
module Unix_ = struct
    type file_descr = Unix.file_descr
    let pp_file_descr fmt _fd =
      Format.fprintf fmt "<fd>"
end
module Out_channel_ = struct
    type t = out_channel
    let pp fmt _x =
      Format.fprintf fmt "<out_channel>"
end

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)
(* LATER: use Tmp.with_new_file *)
<<constant [[Env.tfname]]>>

<<type [[Env.tfile_offset]]>>
[@@deriving show]

<<type [[Env.offset_and_mark]]>>
[@@deriving show]
(* alt: use None *)
<<constant [[Env.no_line]]>>

<<type [[Env.lineno]]>>
[@@deriving show]

<<type [[Env.t]]>>
[@@deriving show]

(*****************************************************************************)
(* init() *)
(*****************************************************************************)
<<function [[Env.init]]>>
@

\subsection*{[[Error.ml]]}

<<Error.ml>>=
<<exception [[Error.Error]]>>

<<function [[Error.e_warn]]>>
<<function [[Error.e_err]]>>

<<function [[Error.e_legacy]]>>
@

\subsection*{[[In.ml]]}

<<In.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
open Common
module T = Token

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Additional helpers to read from stdin.
 * alt: could be merged with Parser.ml
 *)

(*****************************************************************************)
(* API *)
(*****************************************************************************)
<<function [[In.newline]]>>

<<function [[In.filename]]>>

<<function [[In.gety]]>>
<<function [[In.gettty]]>>
@

\subsection*{[[In.mli]]}

<<In.mli>>=
<<signature [[In.newline]]>>
<<signature [[In.filename]]>>

<<signature [[In.gety]]>>
<<signature [[In.gettty]]>>
@

\subsection*{[[Lexer.mli]]}

<<Lexer.mli>>=
<<signature [[Lexer.token]]>>
<<signature [[Lexer.regexp]]>>
<<signature [[Lexer.filename]]>>
<<signature [[Lexer.line]]>>

<<signature [[Lexer.buf]]>>
@

\subsection*{[[Lexer.mll]]}

<<Lexer.mll>>=
{
open Common
open Token

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Splitting the user input in tokens which are then assembled in
 * addresses or commands by Parser.ml
 *)
<<constant [[Lexer.buf]]>>
}
(*****************************************************************************)
(* Regexps aliases *)
(*****************************************************************************)
<<constant [[Lexer.space]]>>
<<constant [[Lexer.letter]]>>
<<constant [[Lexer.digit]]>>

(*****************************************************************************)
(* Main rule *)
(*****************************************************************************)
<<function [[Lexer.token]]>>
(*****************************************************************************)
(* Regexp rule *)
(*****************************************************************************)
<<function [[Lexer.regexp]]>>

(*****************************************************************************)
(* Other rules *)
(*****************************************************************************)
<<function [[Lexer.line]]>>
<<function [[Lexer.filename]]>>
@

\subsection*{[[Main.ml]]}

<<Main.ml>>=
<<toplevel [[Main._1]]>>
@

\subsection*{[[Out.ml]]}

<<Out.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Displaying text *)

(*****************************************************************************)
(* API *)
(*****************************************************************************)
<<function [[Out.putchr]]>>

<<function [[Out.putst]]>>
<<function [[Out.putshst]]>>

<<function [[Out.putd]]>>
@

\subsection*{[[Out.mli]]}

<<Out.mli>>=
<<signature [[Out.putchr]]>>
<<signature [[Out.putst]]>>
<<signature [[Out.putshst]]>>

<<signature [[Out.putd]]>>
@

\subsection*{[[Parser.ml]]}

<<Parser.ml>>=
(* Copyright 2025, 2026 Yoann Padioleau, see copyright.txt *)
open Common

module T = Token

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Parsing user input using the lexer.
 *
 * alt: yacc, but overkill; peek/consume tokens seems simpler for ed use case.
 *)

(*****************************************************************************)
(* Hack for deriving show *)
(*****************************************************************************)
module Lexing = struct
    type lexbuf = Lexing.lexbuf
    let pp_lexbuf fmt _lexbuf =
      Format.fprintf fmt "<lexbuf>"
    let from_channel = Lexing.from_channel
end

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Parser.state]]>>
[@@deriving show]

<<function [[Parser.init]]>>

(*****************************************************************************)
(* Error management *)
(*****************************************************************************)
<<function [[Parser.was_expecting]]>>
<<function [[Parser.was_expecting_but_got]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Parser.next_token]]>>

(*****************************************************************************)
(* peek/consume *)
(*****************************************************************************)
<<function [[Parser.peek]]>>
<<function [[Parser.consume]]>>

(*****************************************************************************)
(* Parsing addresses *)
(*****************************************************************************)
(* Done in Address.ml *)

(*****************************************************************************)
(* Parsing Commands *)
(*****************************************************************************)
(* Done in CLI.ml instead *)

(*****************************************************************************)
(* Parsing Filenames and user text *)
(*****************************************************************************)
(* Done in In.ml instead *)
@

\subsection*{[[Parser.mli]]}

<<Parser.mli>>=

<<type [[Parser.state]]>>
[@@deriving show]

<<signature [[Parser.init]]>>

<<signature [[Parser.peek]]>>
<<signature [[Parser.consume]]>>

<<signature [[Parser.was_expecting]]>>
<<signature [[Parser.was_expecting_but_got]]>>
@

\subsection*{[[Token.ml]]}

<<Token.ml>>=
(* The tokens *)

<<type [[Token.t]]>>
[@@deriving show]
@


\subsection*{[[Regex.ml]]}

<<Regex.ml>>=
module Str = Re_str
<<type [[Regex.t]]>>

<<function [[Regex.match_str]]>>
@

\fi

\section{Index}
