
\section{[[CLI.mli]]}

%-------------------------------------------------------------

<<CLI.mli>>=
<<type [[CLI.caps]]>>

<<signature [[CLI.main]]>>
<<signature [[CLI.thread_main]]>>
@

\section{[[CLI.ml]]}

%-------------------------------------------------------------

<<CLI.ml>>=
(* Copyright 2017-2026 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of rio, the Plan 9 windowing system.
 *
 * Main limitations compared to rio:
 *  - no unicode
 *  - just a basic ASCII font for now
 *  - the terminal does not have many features
 * 
 * todo:
 *  - more fonts
 *  - unicode
 *  - need to disable preempt?
 *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)
<<type [[CLI.caps]]>>

<<constant [[CLI.usage]]>>

(*****************************************************************************)
(* Main algorithm *)
(*****************************************************************************)
<<function [[CLI.thread_main]]>>
    
(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[CLI.main]]>>
@

\section{[[Cursors.mli]]}

%-------------------------------------------------------------

<<Cursors.mli>>=

<<signature [[Cursors.crosscursor]]>>
<<signature [[Cursors.boxcursor]]>>
<<signature [[Cursors.sightcursor]]>>

(*
val whitearrow: Cursor.t
val query: Cursor.t
*)

<<signature [[Cursors.which_corner_cursor]]>>
@

\section{[[Cursors.ml]]}

%-------------------------------------------------------------

<<Cursors.ml>>=
(* Copyright 2017-2026 Yoann Padioleau, see copyright.txt *)
open Common

open Cursor
open Point
open Rectangle

(*****************************************************************************)
(* Classic cursors *)
(*****************************************************************************)
(* See also 'arrow' defined in the kernel and in lib_graphics/input/cursor.ml *)

<<constant [[Cursors.crosscursor]]>>
<<constant [[Cursors.boxcursor]]>>
<<constant [[Cursors.sightcursor]]>>

<<constant [[Cursors._whitearrow]]>>
<<constant [[Cursors._query]]>>

(*****************************************************************************)
(* Border and corner cursors *)
(*****************************************************************************)

<<type [[Cursors.corner]]>>
<<type [[Cursors.portion]]>>

<<function [[Cursors.portion]]>>

<<function [[Cursors.which_corner]]>>

<<constant [[Cursors.tl]]>>
<<constant [[Cursors.t]]>>
<<constant [[Cursors.tr]]>>
<<constant [[Cursors.r]]>>
<<constant [[Cursors.br]]>>
<<constant [[Cursors.b]]>>
<<constant [[Cursors.bl]]>>
<<constant [[Cursors.l]]>>

<<function [[Cursors.which_corner_cursor]]>>
@

\section{[[Device.ml]]}

%-------------------------------------------------------------

<<Device.ml>>=
(* Copyright 2017-2026 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Helpers to build "virtual devices" (e.g., a virtual /dev/cons) *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)
<<type [[Device.t]]>>
<<constant [[Device.default]]>>

<<exception [[Device.Error]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Device.honor_offset_and_count]]>>
<<function [[Device.honor_count]]>>
@

\section{[[Dev_graphical_window.mli]]}

%-------------------------------------------------------------

<<Dev_graphical_window.mli>>=
@

\section{[[Dev_graphical_window.ml]]}

%-------------------------------------------------------------

<<Dev_graphical_window.ml>>=
@

\section{[[Dev_textual_window.mli]]}

%-------------------------------------------------------------

<<Dev_textual_window.mli>>=
<<signature [[Dev_textual_window.dev_text]]>>
@


\section{[[Dev_textual_window.ml]]}

%-------------------------------------------------------------

<<Dev_textual_window.ml>>=
open Common

open Device
module W = Window
module T = Terminal

<<constant [[Dev_textual_window.dev_text]]>>
@

\section{[[Dev_wm.mli]]}

%-------------------------------------------------------------

<<Dev_wm.mli>>=
<<signature [[Dev_wm.dev_winid]]>>
@

\section{[[Dev_wm.ml]]}

%-------------------------------------------------------------

<<Dev_wm.ml>>=
open Common

open Device

<<constant [[Dev_wm.dev_winid]]>>
@


\section{[[File.ml]]}

%-------------------------------------------------------------

<<File.ml>>=
(* Copyright 2017-2027 Yoann Padioleau, see copyright.txt *)
open Common

open Plan9 (* for the fields *)
module N = Plan9

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* ?? *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

<<type [[File.fid]]>>

<<type [[File.filecode]]>>
<<type [[File.dir]]>>
    (* less: '/wsys/' *)
  (* '/xxx' *)
<<type [[File.devid]]>>

<<type [[File.fileid]]>>

<<type [[File.dir_entry_short]]>>

<<constant [[File.root_entry]]>>

<<type [[File.t]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[File.int_of_filecode]]>>
<<function [[File.int_of_fileid]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[File.qid_of_fileid]]>>
@

\section{[[Fileserver.mli]]}

%-------------------------------------------------------------

<<Fileserver.mli>>=
(* ?? *)

<<type [[Fileserver.t]]>>

<<signature [[Fileserver.init]]>>
@


\section{[[Fileserver.ml]]}

%-------------------------------------------------------------

<<Fileserver.ml>>=
open Common

module Unix1 = Unix
module Unix2 = ThreadUnix

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)
  
(* Note that pipes created under plan9 are bidirectional! 
 * No need to create 2 pipes for 2-way communication.
 *)

<<type [[Fileserver.t]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Fileserver.init]]>>
@

\section{[[Globals.ml]]}

%-------------------------------------------------------------

<<Globals.ml>>=
(* Copyright 2017, 2025 Yoann Padioleau, see copyright.txt *)
open Common

module W = Window

<<global [[Globals.windows]]>>
<<global [[Globals.hidden]]>>

<<global [[Globals.current]]>>

<<function [[Globals.win]]>>

<<function [[Globals.window_at_point]]>>

<<constant [[Globals.debug_9P]]>>
<<constant [[Globals.debug_draw]]>>

(* alt: could be in global but better to pass it around so more functional
 * mousectl
 * kbdctl
 * fs
 * let display = ref Display.fake_display
 * let view = ref Display.fake_image
 * let font = ref Font.fake_font
 * let desktop = ref Baselayer.fake_baselayer
 *)

(* this is just too annoying to pass around *)
<<constant [[Globals.red]]>>
<<constant [[Globals.title_color]]>>
<<constant [[Globals.title_color_light]]>>
@

\section{[[Main.ml]]}

%-------------------------------------------------------------

<<Main.ml>>=
(* Copyright 2025-2027 Yoann Padioleau, see copyright.txt *)
(* open Xix_windows *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<toplevel [[Main._1]]>>
@

\section{[[Mouse_action.mli]]}

%-------------------------------------------------------------

<<Mouse_action.mli>>=
<<signature [[Mouse_action.sweep]]>>
<<signature [[Mouse_action.point_to]]>>
@

\section{[[Mouse_action.ml]]}

%-------------------------------------------------------------

<<Mouse_action.ml>>=
open Common

(* less: maybe the 'ref m' approach of point_to() is simpler for sweep() too *)
<<type [[Mouse_action.sweep_state]]>>

<<function [[Mouse_action.sweep]]>>

<<function [[Mouse_action.point_to]]>>
@


\section{[[Processes_winshell.mli]]}

%-------------------------------------------------------------

<<Processes_winshell.mli>>=
<<signature [[Processes_winshell.run_cmd_in_window_in_child_of_fork]]>>
@

\section{[[Processes_winshell.ml]]}

%-------------------------------------------------------------

<<Processes_winshell.ml>>=
(* Copyright 2017, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

module Unix1 = Unix
module Unix2 = ThreadUnix

<<function [[Processes_winshell.run_cmd_in_window_in_child_of_fork]]>>
@


\section{[[Terminal.mli]]}

<<signature [[Terminal.alloc]]>>=
val alloc: Image.t -> Font.t -> t
@

<<signature [[Terminal.newline_after_output_point]]>>=
val newline_after_output_point: t -> bool
@

<<signature [[Terminal.repaint]]>>=
val repaint: t -> unit
@

%-------------------------------------------------------------

<<Terminal.mli>>=
<<type [[Terminal.position]]>>

<<type [[Terminal.t]]>>

<<signature [[Terminal.alloc]]>>

<<signature [[Terminal.key_in]]>>
<<signature [[Terminal.runes_in]]>>

<<signature [[Terminal.newline_after_output_point]]>>

<<signature [[Terminal.repaint]]>>
@


\section{[[Terminal.ml]]}

<<type [[Terminal.position]]>>=
type position = {
  i: int;
}
@

<<constant [[Terminal.zero]]>>=
let zero = 
  { i = 0 }
@

<<type [[Terminal.t]]>>=
type t = {
  (* the model *)

  (* growing array (simpler than a gap buffer).
   * alt: a growing string, like in Efuns.
   *)
  mutable text: Rune.t array;
  (* number of runes used in text (<= Array.length term.text) *)
  mutable nrunes: int;

  (* less: lines? like in Efuns? with EOF sentinel to simplify code? *)

  (* where entered text go (and selection start) (old: q0 in rio-C) *)
  mutable cursor: position;
  mutable end_selection: position option;      (* old: q1 in rio-C) *)

  (* Division between characters the host has seen and characters not 
   * yet transmitted. The position in the text that separates output from input.
   * old: qh in rio-C
   *)
  mutable output_point: position;

  (* the view *)

  img: Image.t;

  (* img.r without border and some extra space *)
  r: Rectangle.t;
  (* right side of r, and no bottom rectangle covering a line of
   * text with font below 
   *)
  textr: Rectangle.t;
  (* left side of r *)
  scrollr: Rectangle.t;

  (* first character visible in window from 'text' *)
  mutable origin_visible: position;
  mutable runes_visible: int;

  font: Font.t;

  (* this will alter which color to use to render the text *)
  mutable is_selected: bool;
  (* alt: mutable colors: colors; *)
}
@

<<type [[Terminal.colors]]>>=
type colors = {
  mutable background             : Image.t;
  mutable border                 : Image.t;
  mutable text_color             : Image.t;

  mutable background_highlighted : Image.t;
  mutable text_highlighted       : Image.t;
}
@

<<constant [[Terminal.default_colors]]>>=
let default_colors = {
  background             = Display.fake_image;
  border                 = Display.fake_image;
  text_color             = Display.fake_image;
  background_highlighted = Display.fake_image;
  text_highlighted       = Display.fake_image;
}
@

<<constant [[Terminal.dark_grey]]>>=
let dark_grey = ref Display.fake_image
@

<<constant [[Terminal.scrollbar_width]]>>=
let scrollbar_width = 12
@

<<constant [[Terminal.scrollbar_gap]]>>=
(* gap right of scrollbar *)
let scrollbar_gap = 4
@

<<constant [[Terminal.tick_width]]>>=
let tick_width = 3
@

<<constant [[Terminal.scrollbar_img]]>>=
let scrollbar_img = ref None
@

<<constant [[Terminal.tick_img]]>>=
let tick_img = ref None
@

<<constant [[Terminal.debug_keys_flag]]>>=
let debug_keys_flag = ref false
@

<<constant [[Terminal.debug_keys_pt]]>>=
let debug_keys_pt = ref Point.zero
@

<<function [[Terminal.debug_keys]]>>=
let debug_keys term key =
  if !debug_keys_flag
  then begin
    let display = term.img.I.display in
    (* todo: why cant use display.image? does not draw ... cos desktop? *)
    let img = term.img in
    if !debug_keys_pt = Point.zero
    then debug_keys_pt := Point.sub img.I.r.max (Point.p 200 15);
    debug_keys_pt := 
      Text.string term.img !debug_keys_pt display.D.black Point.zero term.font
      (spf "%X" (Char.code key))
  end
@

<<function [[Terminal.init_colors]]>>=
let init_colors display =
  if default_colors.background == Display.fake_image
  then begin
    default_colors.background <- display.D.white;
    default_colors.background_highlighted <-
      Image.alloc_color display (Color.mk2 0xCC 0xCC 0xCC);
    default_colors.border <-
      Image.alloc_color display (Color.mk2 0x99 0x99 0x99);
    default_colors.text_color <- display.D.black;
    default_colors.text_highlighted <- display.D.black;

    (*/* greys are multiples of 0x11111100+0xFF, 14* being palest */*)
    dark_grey := Image.alloc_color display (Color.mk2 0x66 0x66 0x66);
  end
@

<<function [[Terminal.colors_focused_window]]>>=
let colors_focused_window () = 
  default_colors
@

<<function [[Terminal.colors_unfocused_window]]>>=
let colors_unfocused_window () = 
  { default_colors with text_color = !dark_grey; text_highlighted = !dark_grey}
@

<<function [[Terminal.scroll_pos]]>>=
let scroll_pos r p0 p1 total =
  if total = 0 
  then r 
  else
    let h = Rectangle.dy r in
    let miny = r.min.y + 
      if p0.i > 0
      then p0.i * h / total
      else 0
    in
    let maxy = r.max.y - 
      if p1.i < total
      then (total - p1.i) * h / total
      else 0
    in
    let maxy, miny =
      if maxy < miny + 2
      then 
        if miny+2 <= r.max.y
        then miny+2, miny
        else maxy, maxy-2
      else maxy, miny
    in
    Rectangle.r r.min.x miny r.max.x maxy
@

<<function [[Terminal.repaint_scrollbar]]>>=
let repaint_scrollbar term =
  let r = term.scrollr in
  
  let v = Point.p (Rectangle.dx r) 0 in
  let r1 = Rectangle.sub_pt v r in
  let r2 = scroll_pos r1 
    term.origin_visible 
    { i = term.origin_visible.i + term.runes_visible }
    term.nrunes
  in
  let r2 = Rectangle.sub_pt r1.min r2 in
  let r1 = Rectangle.sub_pt r1.min r1 in

  let img = Fun_.once scrollbar_img (fun () ->
    let display = term.img.I.display in
    let view = display.D.image in
    (* /*factor by which window dimension can exceed screen*/ *)
    let big = 3 in
    let h = big * Rectangle.dy view.I.r in
    let r = Rectangle.r 0 0 32 h in
    Image.alloc display r view.I.chans false Color.white
  )
  in
  Draw.draw_color img r1 default_colors.border;
  Draw.draw_color img r2 default_colors.background;
  let r3 = { r2 with min = { r2.min with x = r2.max.x - 1 } } in
  Draw.draw_color img r3 default_colors.border;

  Draw.draw term.img term.scrollr img None (Point.p 0 r1.min.y)
@

<<function [[Terminal.visible_lines]]>>=
let visible_lines term =
  let maxlines = Rectangle.dy term.textr / term.font.Font.height in
  
  let rec aux acc_lines acc_str nblines_done p =
    if p.i >= term.nrunes || nblines_done >= maxlines
    then Rune.string_of_runes (List.rev acc_str)::acc_lines, p
    else 
      match term.text.(p.i) with
      | '\n' -> 
        aux ((Rune.string_of_runes (List.rev acc_str))::acc_lines) []
          (nblines_done + 1) { i = p.i + 1 }
      | c ->
        aux acc_lines (c::acc_str) nblines_done { i = p.i + 1 }
  in
  let xs, lastp = aux [] [] 0 term.origin_visible in
  List.rev xs, lastp
@

<<function [[Terminal.repaint_content]]>>=
let repaint_content term colors =
  let xs, lastp = visible_lines term in
  term.runes_visible <- lastp.i - term.origin_visible.i;

  let p = ref term.textr.min in
  xs |> List.iter (fun s ->
    let _endpt = 
      Text.string term.img !p colors.text_color Point.zero term.font s
    in
    p := { term.textr.min with y = !p.y + term.font.Font.height };
  )
@

<<function [[Terminal.newline_after_output_point]]>>=
(* "When newline, chars between output point and newline are sent."*)
let newline_after_output_point term =
  (* todo: more elegant way? way to iter over array and stop until cond? *)
  let rec aux p =
    if p.i < term.nrunes
    then 
      let c = term.text.(p.i) in
      if c = '\n'
      then true
      else aux { i = p.i + 1 }
    else false
  in
  aux term.output_point
@

<<function [[Terminal.move_origin_to_see]]>>=
(* assumes term.runes_visible is up to date, so 
 * !!do not call this function if you modified term.textr since the last 
 * repaint_content!!
 *)
let move_origin_to_see term pos =
  if pos.i >= term.origin_visible.i &&
     pos.i <= term.origin_visible.i + term.runes_visible
  then ()
  else failwith "TODO: move_origin_to_see out of range"
@

<<function [[Terminal.point_of_position]]>>=
let point_of_position term pos =
  if pos.i >= term.origin_visible.i && 
     pos.i <=  term.origin_visible.i + term.runes_visible
  then 
    (* some of the logic below is similar in visible_lines *)
    let rec aux pt current_pos =
      if current_pos = pos
      then pt
      else
        let next_pos = { i = current_pos.i + 1 } in
        match term.text.(current_pos.i) with
        | '\n' -> 
          aux (Point.p term.textr.min.x (pt.y + term.font.Font.height)) next_pos
        | c ->
          let width = Text.string_width term.font (spf "%c" c) in
          aux { pt with x = pt.x + width } next_pos
    in
    aux term.textr.min term.origin_visible
  else 
  (* anything out of textr  *)
  term.textr.max
@

<<function [[Terminal.repaint_tick]]>>=
let repaint_tick term colors =
  let img = Fun_.once tick_img (fun () ->
    let display = term.img.I.display in
    let view = display.D.image in
    let font = term.font in
    let height = font.Font.height in

    let r = Rectangle.r 0 0 tick_width height in
    let img = Image.alloc display r view.I.chans false Color.white in
    (*/* background color */*)
    Draw.draw_color img r colors.background;
    (*/* vertical line */*)
    Draw.draw_color img
      (Rectangle.r (tick_width / 2) 0 (tick_width / 2 + 1) height) 
      colors.text_color;
    (*/* box on each end */*)
    Draw.draw_color img (Rectangle.r 0 0 tick_width tick_width) 
      colors.text_color;
    Draw.draw_color img (Rectangle.r 0 (height - tick_width) tick_width height)
      colors.text_color;
    img
  )
  in
  let pt = point_of_position term term.cursor in
  if Rectangle.pt_in_rect pt term.textr then begin
    (*/* looks best just left of where requested */*)
    let pt = { pt with x = pt.x - 1 } in
    (*/* can go into left border but not right */*)
    let maxx = min (pt.x + tick_width) term.textr.max.x in
    let r = Rectangle.r pt.x pt.y 
                        maxx (pt.y + term.font.Font.height) 
    in
    Draw.draw term.img r img None Point.zero
  end
@

<<function [[Terminal.alloc]]>>=
let alloc (img : Image.t) (font : Font.t) : t =
  init_colors img.I.display;
  let r = 
    Rectangle.insetrect (Draw_rio.window_border_size + 1) img.I.r in
  let scrollr = 
    { r with max = { r.max with x = r.min.x + scrollbar_width } } in
  let textr = 
    { min = { r.min with x = scrollr.max.x + scrollbar_gap };
      (* can not use last lines if not enough pixels for a character *)
      max = { r.max with y = r.max.y - (Rectangle.dy r mod font.Font.height) };
    } in
  
  {
    text = [||];
    nrunes = 0;

    cursor = zero;
    end_selection = None;
    output_point = zero;

    origin_visible = zero;
    runes_visible = 0;

    font = font;
    img = img;
    r = r;
    textr = textr;
    scrollr = scrollr;
    is_selected = true;
  }
@

<<function [[Terminal.insert_runes]]>>=
(* less: return pos? used only when delete lines in term.text? *)
let insert_runes term pos runes =
  let n = List.length runes in
  (* stricter: *)
  if n = 0
  then failwith "insert_runes: empty runes";

  (* grow array if necessary *)
  if term.nrunes + n > Array.length term.text then begin
    let old = term.text in
    let oldlen = Array.length old in
    (* todo: high_water, low_water, etc *)
    let increment = 20000 in
    term.text <- Array.make (oldlen + increment) '*';
    Array.blit old 0 term.text 0 oldlen;
  end;

  assert (pos.i <= term.nrunes);
  (* move to the right the runes after the cursor pos to make some space *)
  Array.blit term.text pos.i term.text (pos.i + n) (term.nrunes - pos.i);
  (* fill the space *)
  runes |> List.iteri (fun i rune ->
    term.text.(pos.i + i) <- rune;
  );
  term.nrunes <- term.nrunes + n;

  (* adjust cursors *)
  if pos.i <= term.cursor.i 
  then term.cursor <- { i = term.cursor.i + n };
  term.end_selection |> Option.iter (fun ends ->
    if pos.i <= ends.i
    then term.end_selection <- Some ({ i = ends.i + n});
  );
  (* note the '<' here, not '<=' ! *)
  if pos.i < term.output_point.i
  then term.output_point <- { i = term.output_point.i + n };
  if pos.i < term.origin_visible.i
  then term.origin_visible <- { i = term.origin_visible.i + n };
  ()
@

<<function [[Terminal.delete_runes]]>>=
let delete_runes term pos n =
  (* stricter: *)
  if n = 0
  then failwith "delete_runes: empty delete";
  let pos2 = { i = pos.i + n } in

  Array.blit term.text pos2.i term.text pos.i (term.nrunes - pos2.i);
  term.nrunes <- term.nrunes - n;

  (* adjust cursors *)
  if pos.i < term.cursor.i
  then term.cursor <- { i = term.cursor.i - min n (term.cursor.i - pos.i) };
  term.end_selection |> Option.iter (fun ends ->
    if pos.i < ends.i
    then term.end_selection <- Some ({ i = ends.i - min n (ends.i - pos.i)});
  );

  (match () with
  | _ when term.output_point.i > pos2.i ->
    term.output_point <- { i = term.output_point.i - n };
  | _ when term.output_point.i > pos.i -> 
    term.output_point <- pos;
  | _ -> assert(term.output_point.i <= pos.i);
    ()
  );

  if pos2.i <= term.origin_visible.i
  then term.origin_visible <- { i = term.origin_visible.i -n };
  ()
@

<<function [[Terminal.repaint]]>>=
let repaint term =
  let colors = 
    if term.is_selected
    then colors_focused_window ()
    else colors_unfocused_window ()
  in

  (* start from scratch with blank image, otherwise tick will be
   * paint all over the place.
   * alt: save what was under the tick image.
   *)
  if not !debug_keys_flag
  then Draw.draw_color term.img term.r colors.background;

  (* repaint_content() needs to be before repaint_scrollbar() because it
   * updates term.runes_visible used by repaint_scrollbar().
   *)
  repaint_content term colors;
  repaint_scrollbar term;
  repaint_tick term colors;
  ()
@

<<constant [[Terminal.previous_code]]>>=
let previous_code = ref 0
@

<<function [[Terminal.key_in]]>>=
let key_in term key =
  (match Char.code key with

  (* less: navigation keys are handled in the caller in rio-C, to allow keys
   * navigation even in raw mode, but it's more cohesive to put such
   * code here.
   *)

  (* Left arrow *)
  | 0x91 when !previous_code = 0x80 (* less: and previous_previous = 0xEF *) ->
    let cursor = term.cursor in
    if cursor.i > 0
    then term.cursor <- { i = cursor.i - 1 };
    move_origin_to_see term term.cursor
    
  (* Right arrow *)
  | 0x92 when !previous_code = 0x80 ->
    (* less: use end_position cursor instead? *)
    let cursor = term.cursor in
    if cursor.i < term.nrunes
    then term.cursor <- { i = cursor.i + 1 };
    move_origin_to_see term term.cursor

  (* End of line ^E *)
  | 0x5 ->
    (* alt: have term.newlines as in Efuns so easier *)
    let rec find_eol_or_end pos = 
      if pos.i = term.nrunes || term.text.(pos.i) = '\n'
      then pos
      else find_eol_or_end { i = pos.i + 1 }
    in
    term.cursor <- find_eol_or_end term.cursor;
    move_origin_to_see term term.cursor
  (* Beginning of line ^A *)
  | 0x1 ->
    (* alt: have term.newlines as in Efuns so easier *)
    let rec find_bol_or_start pos = 
      if pos.i = 0 || pos.i = term.output_point.i ||
         term.text.(pos.i - 1) = '\n'
      then pos
      else find_bol_or_start { i = pos.i - 1 }
    in
    term.cursor <- find_bol_or_start term.cursor;
    move_origin_to_see term term.cursor


  (* Erase character ^H  (or Backspace or Delete) *)
  | 0x8 ->
    let cursor = term.cursor in
    if cursor.i = 0 || cursor = term.output_point
    then ()
    else begin
      (* less: adjust if cursor = term.origin_visible *)
      (* this will adjust term.cursor *)
      delete_runes term { i = cursor.i - 1 } 1
    end

  (* todo: should remove once key is directly a rune.
   * less: the sequence we get for Left arrow is really
   * 0xEF 0x80 0x91, but we just check if previous code is 0x80.
   *)
  | 0xEF -> ()
  | 0x80 -> ()

  (* ordinary characters *)
  | _ ->
    debug_keys term key;
    (* this will adjust term.cursor *)
    insert_runes term term.cursor [key] 
  );
  previous_code := Char.code key;
  if !previous_code = 0xEF || !previous_code = 0x80
  then ()
  else 
  repaint term
@

<<function [[Terminal.runes_in]]>>=
(* "when characters are sent from the host, they are inserted at
 * the output point and the output point is advanced."
 *)
let runes_in term runes =
  insert_runes term term.output_point runes;
  term.output_point <- { i = term.output_point.i + List.length runes };
  repaint term;
  ()
@

%-------------------------------------------------------------

<<Terminal.ml>>=
open Common

open Point
open Rectangle

module I = Display
module D = Display

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Routines to support a simple terminal emulator.
 *  
 * A terminal has many features in common with an editor: you can enter
 * text, move around the cursor, copy, cut, paste, etc. The situation
 * is simpler than in Efuns though; there is no need for a gap buffer because
 * most insertions are at the end of the "file". A growing array
 * is good enough. Like in Efuns, we have also a few "cursors" that need
 * to be updated once you insert text.
 * 
 * todo:
 *  - interactive scroll bar
 *  - selection and highlited text
 * less: 
 *  - extract independent stuff and put in lib_graphics/ui/text_ui.ml?  
 *  - extract even more independent stuff in editor.ml somewhere?
 *  - take code from zed opam package?
 *)

(*****************************************************************************)
(* Types, constants, and globals *)
(*****************************************************************************)

(* The type below is called a 'point' in Efuns, but it would be
 * confusing with the Point.t of lib_graphics/geometry/point.ml.
 * We could also call it 'cursor', but this would be 
 * confusing with the Cursor.t of lib_graphics/input/cursor.ml
 * 
 * less: make mutable instead of the fields in 't' below?
 *)
<<type [[Terminal.position]]>>
<<constant [[Terminal.zero]]>>

<<type [[Terminal.t]]>>

<<type [[Terminal.colors]]>>
<<constant [[Terminal.default_colors]]>>
<<constant [[Terminal.dark_grey]]>>

<<constant [[Terminal.scrollbar_width]]>>
<<constant [[Terminal.scrollbar_gap]]>>

<<constant [[Terminal.tick_width]]>>

(* temporary images *)
<<constant [[Terminal.scrollbar_img]]>>
<<constant [[Terminal.tick_img]]>>

(*****************************************************************************)
(* Debug *)
(*****************************************************************************)

<<constant [[Terminal.debug_keys_flag]]>>
<<constant [[Terminal.debug_keys_pt]]>>
<<function [[Terminal.debug_keys]]>>

(*****************************************************************************)
(* Colors *)
(*****************************************************************************)
<<function [[Terminal.init_colors]]>>

<<function [[Terminal.colors_focused_window]]>>
<<function [[Terminal.colors_unfocused_window]]>>

(*****************************************************************************)
(* Scrollbar *)
(*****************************************************************************)
<<function [[Terminal.scroll_pos]]>>
  
<<function [[Terminal.repaint_scrollbar]]>>

(*****************************************************************************)
(* Text content *)
(*****************************************************************************)
<<function [[Terminal.visible_lines]]>>

<<function [[Terminal.repaint_content]]>>

(* helper to know if we should send runes on channel connected to an app *)
<<function [[Terminal.newline_after_output_point]]>>

<<function [[Terminal.move_origin_to_see]]>>
  
(*****************************************************************************)
(* Tick (cursor) *)
(*****************************************************************************)
<<function [[Terminal.point_of_position]]>>

<<function [[Terminal.repaint_tick]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)
<<function [[Terminal.alloc]]>>

<<function [[Terminal.insert_runes]]>>

<<function [[Terminal.delete_runes]]>>
  

<<function [[Terminal.repaint]]>>

(*****************************************************************************)
(* External events *)
(*****************************************************************************)

(* todo: right now 'key' is a byte (a char), but it should be a rune.
 * So for now we need to reconstruct a rune from a series of chars
 * (the utf8 encoding of the rune).
 *)
<<constant [[Terminal.previous_code]]>>

<<function [[Terminal.key_in]]>>

<<function [[Terminal.runes_in]]>>

(* "When newline, chars between output point and newline are sent."
 * let bytes_out term =
 * but the logic is in Threads_window.bytes_out to factorize code
 * with the logic when in raw-mode.
 *)
@


\section{[[Threads_fileserver.mli]]}

%-------------------------------------------------------------

<<Threads_fileserver.mli>>=
<<signature [[Threads_fileserver.thread]]>>
@


\section{[[Threads_fileserver.ml]]}

%-------------------------------------------------------------

<<Threads_fileserver.ml>>=
(* Copyright 2017-2026 Yoann Padioleau, see copyright.txt *)
open Common

module D = Device
module N = Plan9
module P9 = Protocol_9P
module T = P9.Request
module R = P9.Response

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* ??? *)

(*****************************************************************************)
(* Constants *)
(*****************************************************************************)
<<constant [[Threads_fileserver.all_devices]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Threads_fileserver.device_of_devid]]>>

<<constant [[Threads_fileserver.toplevel_entries]]>>

<<function [[Threads_fileserver.answer]]>>

<<function [[Threads_fileserver.error]]>>

<<function [[Threads_fileserver.check_fid]]>>
  
(*****************************************************************************)
(* Dispatch *)
(*****************************************************************************)
<<constant [[Threads_fileserver.first_message]]>>

<<function [[Threads_fileserver.dispatch]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Threads_fileserver.thread]]>>
@

\section{[[Thread_keyboard.mli]]}

%-------------------------------------------------------------

<<Thread_keyboard.mli>>=
<<signature [[Thread_keyboard.thread]]>>
@

\section{[[Thread_keyboard.ml]]}

%-------------------------------------------------------------

<<Thread_keyboard.ml>>=
(* Copyright 2017-2026 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Reads from the keyboard and sends the key to the "current" window *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Thread_keyboard.thread]]>>
@

\section{[[Thread_mouse.mli]]}
%-------------------------------------------------------------

<<Thread_mouse.mli>>=
<<signature [[Thread_mouse.thread]]>>
@

\section{[[Thread_mouse.ml]]}

%-------------------------------------------------------------

<<Thread_mouse.ml>>=
(* Copyright 2017-2026 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Thread_mouse.event]]>>
  (* less: Resize? other? or use other thread and device? (cleaner) in which
   * no need for event type here.
   *)

<<type [[Thread_mouse.under_mouse]]>>

(*****************************************************************************)
(* Menus *)
(*****************************************************************************)

<<function [[Thread_mouse.wm_menu]]>>

<<function [[Thread_mouse.middle_click_system]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Thread_mouse.thread]]>>
@

\section{[[Threads_window.mli]]}

%-------------------------------------------------------------

<<Threads_window.mli>>=
<<signature [[Threads_window.thread]]>>
@

\section{[[Threads_window.ml]]}


<<function [[Threads_window.mouse_out]]>>=
let mouse_out (w : Window.t) (chan : Mouse.state Event.channel) =
  (*/* send a queued event or, if the queue is empty, the current state */
    /* if the queue has filled, we discard all the events it contained. */
    /* the intent is to discard frantic clicking by the user during long latencies. */
  *)
  let m, counter =
    if Queue.length w.mouseclicks_queue > 0
    then Queue.take w.mouseclicks_queue 
    else w.last_mouse, w.mouse_counter
  in
  (* we use last_count_sent later to know if we are ready to send mouse
   * states to someone
   *)
  w.last_count_sent <- counter;
  Event.send chan m |> Event.sync
@

<<function [[Threads_window.bytes_out]]>>=
let bytes_out (w : Window.t) (chan_count, chan_bytes) =
  let cnt = Event.receive chan_count |> Event.sync in
  let buf = Bytes.create cnt in
  let i = ref 0 in

  (match w.raw_mode with
  | true ->
    while !i < cnt && Queue.length w.raw_keys > 0 do
      Bytes.set buf !i (Queue.take w.raw_keys);
      incr i;
    done
  | false ->
    let term : Terminal.t = w.terminal in
    (* "When newline, chars between output point and newline are sent."*)
    while !i < cnt && term.output_point.i < term.nrunes do
      let pos = term.output_point.i in
      Bytes.set buf !i term.text.(pos);
      term.output_point <- { Terminal.i = pos + 1};
      incr i;
    done
  );

  let str =
    if !i < cnt
    then Bytes.sub_string buf 0 !i
    else Bytes.to_string buf
  in
  Event.send chan_bytes str |> Event.sync
@

%-------------------------------------------------------------

<<Threads_window.ml>>=
open Common

open Point
open Rectangle
open Window

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Threads_window.event]]>>

(*****************************************************************************)
(* In and out helpers *)
(*****************************************************************************)
<<function [[Threads_window.key_in]]>>
<<function [[Threads_window.runes_in]]>>

<<function [[Threads_window.mouse_in]]>>
<<function [[Threads_window.mouse_out]]>>

<<function [[Threads_window.bytes_out]]>>

<<function [[Threads_window.cmd_in]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Threads_window.wrap]]>>

<<function [[Threads_window.thread]]>>
@

\section{[[Virtual_cons.mli]]}

%-------------------------------------------------------------

<<Virtual_cons.mli>>=
<<signature [[Virtual_cons.dev_cons]]>>
<<signature [[Virtual_cons.dev_consctl]]>>
@

\section{[[Virtual_cons.ml]]}

%-------------------------------------------------------------

<<Virtual_cons.ml>>=
open Common
open Device

<<constant [[Virtual_cons.dev_cons]]>>

<<constant [[Virtual_cons.dev_consctl]]>>
@

\section{[[Virtual_draw.mli]]}

%-------------------------------------------------------------

<<Virtual_draw.mli>>=
<<signature [[Virtual_draw.dev_winname]]>>
@

\section{[[Virtual_draw.ml]]}

%-------------------------------------------------------------

<<Virtual_draw.ml>>=
open Common
open Device

(* The ancestor of rio (8 1/2) was serving a virtual /dev/draw,
 * which was more elegant but also more inefficient than the
 * /dev/winname (and associated /dev/draw/x/) approach used by rio.
 * 
 * alt: we could also pass the information of winname through 
 * the environment instead of through a /dev virtual file.
 *)

<<constant [[Virtual_draw.dev_winname]]>>
@

\section{[[Virtual_mouse.mli]]}

%-------------------------------------------------------------

<<Virtual_mouse.mli>>=
<<signature [[Virtual_mouse.dev_mouse]]>>
<<signature [[Virtual_mouse.dev_cursor]]>>
@

\section{[[Virtual_mouse.ml]]}

%-------------------------------------------------------------

<<Virtual_mouse.ml>>=
open Common

open Device
open Point

<<constant [[Virtual_mouse.dev_mouse]]>>

<<constant [[Virtual_mouse._dev_cursor]]>>
@

\section{[[Window.ml]]}

<<type [[Window.mouse_counter]]>>=
type mouse_counter = int
@


<<constant [[Window.window_border_size]]>>=
(* important convention to follow for rio and draw to cooperate correctly *)
let window_border_size = Draw_rio.window_border_size (* 4 *)
@

<<type [[Window.border_status]]>>=
type border_status = 
  | Selected
  | Unselected
@

%-------------------------------------------------------------

<<Window.ml>>=
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* The data structure to store all the information about a window! *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

<<type [[Window.wid]]>>

<<type [[Window.mouse_counter]]>>
<<type [[Window.topped_counter]]>>

<<type [[Window.cmd]]>>

<<type [[Window.t]]>>

<<global [[Window.wid_counter]]>>
<<global [[Window.topped_counter]]>>

<<constant [[Window.window_border_size]]>>

<<type [[Window.border_status]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Window.pt_inside_border]]>>
<<function [[Window.pt_on_border]]>>

<<function [[Window.alloc]]>>
  (* less: incref? in caller? *)
@


\section{[[Wm.ml]]}

<<function [[Wm.window_cursor]]>>=
(* less: a rio_cursor? with lastcursor opti? and force parameter? *)
let window_cursor (w : Window.t) (pt : Point.t) (mouse : Mouse.ctl) : unit =
  let cursoropt = 
    (* less: if img is nil? if screenr is 0? *)
    match Globals.window_at_point pt with
    | Some w2 when w2  == w -> w.mouse_cursor
    | _ -> None
  in
  (* less: if menuing? or use corner_cursor() so no need this global? *)
  (* less: if holding *)
  match cursoropt with
  | Some x -> Mouse.set_cursor mouse x
  | None -> Mouse.reset_cursor mouse
@


<<function [[Wm.draw_border]]>>=
let draw_border (w : Window.t) (status : Window.border_status) =
  let img : Display.image = w.img in
  (* less: if holding? *)
  let color = 
    match status with
    | Window.Selected   -> !Globals.title_color
    | Window.Unselected -> !Globals.title_color_light
  in
  Polygon.border img img.r Window.window_border_size color Point.zero
@

<<function [[Wm.repaint]]>>=
(* old: was called wrepaint in rio-C *)
let repaint (w : Window.t) =
  let status = 
    match Globals.win () with
    | Some w2 when w2 == w -> Window.Selected
    | _ -> Window.Unselected
  in
  draw_border w status;
  (* less: wsetcursor again? *)
  w.terminal.Terminal.is_selected <- (status = Window.Selected);
  if not w.mouse_opened 
  then Terminal.repaint w.terminal 
@

%-------------------------------------------------------------

<<Wm.ml>>=
(* Copyright 2017-2026 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* The Window Manager *)

(*****************************************************************************)
(* Cursors *)
(*****************************************************************************)

(* less? move those cursor functions in cursors.ml? *)

<<function [[Wm.window_cursor]]>>

<<function [[Wm._corner_cursor]]>>

<<function [[Wm.corner_cursor_or_window_cursor]]>>

(*****************************************************************************)
(* Borders and content *)
(*****************************************************************************)
<<function [[Wm.draw_border]]>>

(* repaint border, content for textual window, (and todo cursor?) *)
<<function [[Wm.repaint]]>>

<<function [[Wm.set_current_and_repaint]]>>

(*****************************************************************************)
(* Wm *)
(*****************************************************************************)

<<global [[Wm.threads_window_thread_func]]>>

<<function [[Wm.new_win]]>>

<<function [[Wm.close_win]]>>

<<function [[Wm.top_win]]>>

<<function [[Wm.hide_win]]>>

<<function [[Wm.show_win]]>>

(*****************************************************************************)
(* Helper for? *)
(*****************************************************************************)
<<function [[Wm.resize_win]]>>
@

\section{[[Wm.mli]]}

%-------------------------------------------------------------

<<Wm.mli>>=
(* The Window Manager *)

(* main wm actions *)

<<signature [[Wm.new_win]]>>
<<signature [[Wm.close_win]]>>

<<signature [[Wm.hide_win]]>>
<<signature [[Wm.show_win]]>>

<<signature [[Wm.top_win]]>>

<<signature [[Wm.resize_win]]>>

(* helpers for borders *)

<<signature [[Wm.set_current_and_repaint]]>>

(* helpers for cursors *)

<<signature [[Wm.corner_cursor_or_window_cursor]]>>

<<signature [[Wm.window_cursor]]>>

<<signature [[Wm.threads_window_thread_func]]>>
@

\section{[[tests/hellorio.ml]]}

%-------------------------------------------------------------

<<tests/hellorio.ml>>=
open Common

<<type [[Hellorio.event]]>>

<<function [[Hellorio.redraw]]>>

<<function [[Hellorio.thread_main]]>>

<<constant [[Hellorio._]]>>
@
