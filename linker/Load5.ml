(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module A = Ast_asm
module A5= Ast_asm5
module T = Types
module T5 = Types5

(* for field access for ocaml-light *)
open Ast_asm

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(* "Names", modifies global, modifies h *)
let process_global (global : A.global) h (idfile : int) : unit =
  (match global.priv with
  | Some _ -> global.priv <- Some idfile
  | None -> ()
  );
  (* populate symbol table with SXref if new entity *)
  T.lookup_global global h |> ignore

(* Visit globals to populate symbol table with wanted symbols.
 * This is more complicated than in 5l because we can not rely
 * on an ANAME or Operand.sym.
 * less: boilerplate which could be auto generated by ocamltarzan in
 *  a visitor_asm5.ml
 *)
let visit_globals f xs =
  let ximm x =
    match x with
    | Address (Global (x, _)) -> f x
    | Address (Param _ | Local _) -> ()
    | String _ -> ()
  in
  let imm_or_ximm x =
    match x with
    | Either.Left _ -> ()
    | Either.Right x -> ximm x
  in
  let mov_operand x =
    match x with
    | A5.Entity (A.Global (x, _)) -> f x
    | A5.Entity (A.Param _ | A.Local _) -> ()
    | A5.Ximm x -> ximm x
    | A5.Imsr _ | A5.Indirect _ -> ()
  in
  let branch_operand x =
    match !x with
    | A.SymbolJump ent -> f ent
    | A.IndirectJump _ | A.Relative _ | A.LabelUse _ | A.Absolute _ -> ()
  in
  xs |> List.iter (fun (x, _line) ->
    match x with
    | A.Pseudo y ->
      (match y with
      | A.TEXT (ent, _, _) -> f ent
      | A.GLOBL (ent, _, _) -> f ent
      | A.DATA (ent, _, _, ix) -> f ent; imm_or_ximm ix
      | A.WORD (ix) -> imm_or_ximm ix
      )
    | A.Instr (i, _cond) ->
      (match i with
      | A5.MOVE (_, _, m1, m2) -> mov_operand m1; mov_operand m2
      (* ocaml-light: | B b | BL b | Bxx (_, b) -> branch_operand b *)
      | A5.B b -> branch_operand b
      | A5.BL b -> branch_operand b
      | A5.Bxx (_, b) -> branch_operand b
      | A5.Arith _ | A5.SWAP _ | A5.RET | A5.Cmp _ | A5.SWI _ | A5.RFE | A5.NOP -> () 
      )
    | A.LabelDef _ -> ()
  )


(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

(* load() performs a few things:
 * - load objects (of course),
 * - split and concatenate in code vs data all objects,
 * - relocate absolute jumps,
 * - "name" entities by assigning a unique name to every entities
 *   (handling private symbols),
 * - visit all entities (defs and uses) and add them in symbol table
 * alt: take as a parameter (xs : Chan.i list);
 *)
let load (caps : < Cap.open_in; ..>) (xs : Fpath.t list) : Ast_asm5.instr_with_cond T.code array * T.data list * Types.symbol_table=

  (* values to return *)
  let code = ref [] in
  let data = ref [] in
  let h = Hashtbl.create 101 in

  let pc : Types.virt_pc ref = ref 0 in
  let idfile = ref 0 in

  xs |> List.iter (fun file ->
    let ipc : Types.virt_pc = !pc in
    incr idfile;
    (* less: assert it is a .5 file *)
    (* TODO: if lib file! *)

    (* object loading is so much easier in ocaml :) *)
    let (prog, _srcfile) = file |> FS.with_open_in caps Object5.load in
    (* less: could check valid AST, range of registers, shift values, etc *)

    (* naming and populating symbol table h *)
    prog |> visit_globals (fun x -> process_global x h !idfile);

    (* split and concatenate in code vs data, relocate branches, 
     * and add definitions in symbol table h.
     *)
    prog |> List.iter (fun (p, line) ->
      match p with
      | A.Pseudo pseudo ->
          (match pseudo with
          | A.TEXT (global, attrs, size) ->
              (* less: set curtext for better error managment *)
              let v = T.lookup_global global h in
              (match v.T.section with
              | T.SXref -> v.T.section <- T.SText !pc;
              | _ -> failwith (spf "redefinition of %s" global.name)
              );
              (* less: adjust autosize? *)
              code |> Stack_.push (T.TEXT (global, attrs, size), (file, line));
              incr pc;
          | A.WORD v ->
              code |> Stack_.push (T.WORD v, (file, line));
              incr pc;
            
          | A.GLOBL (global, _attrs, size) -> 
              let v = T.lookup_global global h in
              (match v.T.section with
              | T.SXref -> v.T.section <- T.SData size;
              | _ -> failwith (spf "redefinition of %s" global.name)
              );
          | A.DATA (global, offset, size, v) -> 
              data |> Stack_.push (T.DATA (global, offset, size, v))
          )

      | A.Instr (instr) ->

          let relocate_branch opd =
            match !opd with
            | SymbolJump _ | IndirectJump _ -> ()
            | Relative _ | LabelUse _ ->
                raise (Impossible "Relative or LabelUse resolved by assembler")
            | Absolute i -> opd := Absolute (i + ipc)
          in

          (match fst instr with
          | A5.B opd -> relocate_branch opd
          | A5.BL opd -> relocate_branch opd
          | A5.Bxx (_, opd) -> relocate_branch opd
          | _ -> ()
          );
          code |> Stack_.push (T.I instr, (file, line));
          incr pc;

      | A.LabelDef _ -> failwith (spf "label definition in object")
    );
  );
  Array.of_list (List.rev !code), List.rev !data, h
