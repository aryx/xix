\section{[[Arch_compiler.ml]]}

<<type [[Arch_compiler.env]]>>=
type env = {
  structs: (Ast.fullname, Type.struct_kind * Type.structdef) Hashtbl.t;
}
@

%-------------------------------------------------------------

<<Arch_compiler.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

<<type [[Arch_compiler.env]]>>

<<type [[Arch_compiler.t]]>>

(* todo? have a portable asm? ast_asm_common.ml? 
with ATEXT, ANOP, ARET, etc.
*)
@

\section{[[Arch5.mli]]}

%-------------------------------------------------------------

<<Arch5.mli>>=

<<signature [[Arch5.arch]]>>
@


\section{[[Arch5.ml]]}

%-------------------------------------------------------------

<<Arch5.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

open Arch_compiler
module T = Type

<<function [[Arch5.width_of_type]]>>

<<constant [[Arch5.arch]]>>
@


\section{[[Ast.ml]]}


<<function [[Ast.unwrap]]>>=
let unwrap (name, _) = name    
@

<<function [[Ast.is_gensymed]]>>=
(* see also Parser.gensym *)
let is_gensymed str = 
  str =~ "|sym[0-9]+|.*"
@


%-------------------------------------------------------------

<<Ast.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An Abstract Syntax Tree (AST) for C.
 * 
 * The AST below does not match exactly the source code; I do a few
 * simplications at parsing time:
 *  - no nested struct definitions; they are lifted to the toplevel and 
 *    a blockid is associated with the tag name to avoid name conflicts
 *  - no anonymous structure; an artificial name is gensym'ed.
 *  - no anonymous structure element; an artificial field name is gensym'ed
 *  - no mix of typedefs with variable declarations;
 *    again typedefs are lifted to the top
 *  - enums are also lifted to the top (and its constants are tagged with
 *    a blockid)
 * 
 * This AST is actually more a named AST (but not a typed AST). 
 * Indeed, in C, you can not separate completely the naming phase from parsing.
 * The grammar of C has an ambiguity with typedefs, so we need to keep track of 
 * typedefs and identifiers and their scope during parsing. It would be
 * redundant to do this work again in a separate naming phase, so I 
 * name and resolve the scope of identifiers at parsing time
 * (however I check for inconsistencies or redefinitions after parsing).
 * Moreover, because I lift up struct definitions, I also keep track
 * and resolve the scope of tags.
 * 
 * See also pfff/lang_c/parsing/ast_c.ml and pfff/lang_cpp/parsing/ast_cpp.ml
 * 
 * todo: 
 *  - have a (large) integer and (large) double for Int and Float?
 *    Int64.t? if unsigned long long constant? enough? overflow in int64_of_str?
 *)

(*****************************************************************************)
(* The AST related types *)
(*****************************************************************************)

<<type [[Ast.loc]]>>

(* ------------------------------------------------------------------------- *)
(* Name *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast.name]]>>

<<type [[Ast.blockid]]>>

<<type [[Ast.fullname]]>>

<<type [[Ast.idkind]]>>

<<type [[Ast.tagkind]]>>

(* ------------------------------------------------------------------------- *)
(* Types *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.typ]]>>
<<type [[Ast.type_bis]]>>

<<type [[Ast.function_type]]>>

<<type [[Ast.parameter]]>>

(* ------------------------------------------------------------------------- *)
(* Expression *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.expr]]>>
<<type [[Ast.expr_bis]]>>

<<type [[Ast.argument]]>>

<<type [[Ast.const_expr]]>>

<<type [[Ast.unaryOp]]>>
<<type [[Ast.assignOp]]>>
<<type [[Ast.fixOp]]>>

<<type [[Ast.binaryOp]]>>
<<type [[Ast.arithOp]]>>
<<type [[Ast.logicalOp]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Statement *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.stmt]]>>
<<type [[Ast.stmt_bis]]>>

<<type [[Ast.case_list]]>>

(* ------------------------------------------------------------------------- *)
(* Variables *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast.var_decl]]>>
<<type [[Ast.initialiser]]>>
[@@deriving show]


(* ------------------------------------------------------------------------- *)
(* Definitions *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.func_def]]>>

<<type [[Ast.struct_def]]>>
<<type [[Ast.field_def]]>>
[@@deriving show]

<<type [[Ast.enum_def]]>>
<<type [[Ast.enum_constant]]>>
[@@deriving show]

<<type [[Ast.type_def]]>>

(* ------------------------------------------------------------------------- *)
(* Program *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.toplevel]]>>

<<type [[Ast.toplevels]]>>

<<type [[Ast.program]]>>

(* ------------------------------------------------------------------------- *)
(* Any *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast.any]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Ast.tagkind_of_su]]>>

<<function [[Ast.unwrap]]>>

open Common
open Regexp_.Operators
<<function [[Ast.is_gensymed]]>>
@


\section{[[Check.mli]]}

%-------------------------------------------------------------

<<Check.mli>>=

<<type [[Check.error]]>>

<<signature [[Check.string_of_error]]>>

<<exception [[Check.Error]]>>
<<signature [[Check.failhard]]>>

<<signature [[Check.check_program]]>>
@


\section{[[Check.ml]]}


<<function [[Check.inconsistent_tag]]>>=
let inconsistent_tag fullname loc usedef =
  let locbefore = 
    match usedef with
    (* ocaml-light: | { defined = Some loc; _ } | { used = Some loc; _ } *)
    | { defined = Some loc; used = _ } -> loc
    | { used = Some loc; defined = _ } -> loc
    | _ -> raise (Impossible "must have a def or a use")
  in
  error (Inconsistent (
    spf "use of '%s' with tag type that does not match previous declaration "
      (unwrap fullname), loc,
    "previous use is here", locbefore
  ))
@

<<function [[Check.check_inconsistent_or_redefined_tag]]>>=
let check_inconsistent_or_redefined_tag env fullname tagkind loc =
  try 
    let (usedef, oldtagkind) = Hashtbl.find env.tags fullname in
    if tagkind <> oldtagkind
    then inconsistent_tag fullname loc usedef;
    (* the tag may not have be defined, as in a previous 'struct Foo x;' *)
    usedef.defined |> Option.iter (fun locdef ->
      error (Inconsistent (spf "redefinition of '%s'" (unwrap fullname), loc,
                     "previous definition is here", locdef))
    );
    (* now it's defined *)
    usedef.defined <- Some loc;
  with Not_found ->
    Hashtbl.add env.tags fullname ({defined = Some loc; used = None;}, tagkind)
@

<<function [[Check.inconsistent_id]]>>=
let inconsistent_id fullname loc usedef =
  let locbefore = 
    match usedef with
    | { defined = Some loc; used = _ } -> loc
    | { defined = None; used = _ } -> raise (Impossible "id always defined first")
  in
  error (Inconsistent (
    spf "redefinition of '%s' " (unwrap fullname), loc,
    "previous definition is here", locbefore
  ))
@

<<function [[Check.check_inconsistent_or_redefined_id]]>>=
let check_inconsistent_or_redefined_id env fullname idkind loc =
  try 
    let (usedef, oldidkind) = Hashtbl.find env.ids fullname in
    if idkind <> oldidkind
    then inconsistent_id fullname loc usedef
    else
      (match usedef.defined with
      | Some locdef ->
        (* stricter: 5c allows at least for same typedef; I do not. *)
        error (Inconsistent (spf "redefinition of '%s'" (unwrap fullname), loc,
                             "previous definition is here", locdef))
      (* the id must be defined, there is no forward use of ids
       * (enum constants, typedefs, variables)
       *)
      | None -> raise (Impossible "ids are always defined before being used")
      )
  with Not_found ->
    Hashtbl.add env.ids fullname ({defined = Some loc; used = None; }, idkind)
@


%-------------------------------------------------------------

<<Check.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
open Either

open Ast

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This module makes sure every entity used is defined. In some cases
 * it also checks if an entity is unused, or if it is incorrectly redeclared.
 * 
 * For typechecking see typecheck.ml.
 * For naming and scope resolving see parser.mly.
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Check.usedef]]>>

<<type [[Check.env]]>>

<<type [[Check.error]]>>

<<function [[Check.string_of_error]]>>

<<exception [[Check.Error]]>>

<<constant [[Check.failhard]]>>

<<function [[Check.error]]>>
 
(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function [[Check.inconsistent_tag]]>>

<<function [[Check.check_inconsistent_or_redefined_tag]]>>

<<function [[Check.inconsistent_id]]>>

<<function [[Check.check_inconsistent_or_redefined_id]]>>

<<function [[Check.check_unused_locals]]>>

(*****************************************************************************)
(* Use/Def *)
(*****************************************************************************)
<<function [[Check.check_usedef]]>>

(*****************************************************************************)
(* Unreachable code *)
(*****************************************************************************)
(* TODO *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Check.check_program]]>>
@


\section{[[CLI.mli]]}

%-------------------------------------------------------------

<<CLI.mli>>=
<<type [[CLI.caps]]>>

<<signature [[CLI.main]]>>

<<signature [[CLI.compile]]>>
@


\section{[[CLI.ml]]}

%-------------------------------------------------------------

<<CLI.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
open Regexp_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of 5c, the Plan 9 C compiler for ARM.
 *
 * Main limitations compared to 5c/vc/...:
 *  - no unicode support
 *  - can not compile multiple files at the same time
 *    (but you should use mk anyway)
 *  - can not compile from stdin
 *    (but who uses that?)
 *  - no -. to remove auto search for header in current directory
 *    (but who uses that?)
 *  - no error recovery, we stop at the first error (except in check.ml)
 *    (but compiler now fast enough and errors have a domino effect anyway)
 *  - no support for certain kencc extensions: 
 *     * STILL? unnamed structure element
 *       (confusing anyway, and annoying when porting code to gcc/clang)
 *     * typestr
 *       (seems dead)
 *  - no support for certain C features:
 *     * enum float
 *       (who uses that?)
 *
 * stricter:
 *  - stricter for grammar (see parser.mly), for instance force a specific
 *    order between the sign, qualifier, and type.
 *  - disallow implicit declarations of functions
 *  - stricter for typechecking (see typecheck.ml), for instance
 *    we do not support void* conversions (5c -V), and we use name
 *    equality for typechecking structs, not field equality.
 *    we also do not automatically transform 0 in nil; I force to write
 *    nil
 * 
 * improvements:
 *  - we forbid more constructs: 
 *     * typedef and initializers, 
 *     * typedef function definitions, 
 *     * three dots parameter in the middle, 
 *     * far more (see tests/)
 *  - better error location (no use of vague nearln) and
 *    better error messages (a la clang)
 * 
 * todo:
 *  - finish enough to at least handle helloc.c (basic function calls, basic
 *    types)
 *  - safe-linking support
 *  - debugger support
 *  - profiler support
 *)

(*****************************************************************************)
(* Types, constants, and globals *)
(*****************************************************************************)
<<type [[CLI.caps]]>>

(*****************************************************************************)
(* Testing *)
(*****************************************************************************)

<<function [[CLI.do_action]]>>

(*****************************************************************************)
(* Main algorithms *)
(*****************************************************************************)

<<type [[CLI.frontend_result]]>>

<<function [[CLI.frontend]]>>

<<function [[CLI.backend5]]>>
<<function [[CLI.compile5]]>>

<<function [[CLI.compile]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[CLI.main]]>>
@


\section{[[Codegen5.mli]]}

<<signature [[Codegen5.string_of_error]]>>=
val string_of_error: error -> string
@

%-------------------------------------------------------------

<<Codegen5.mli>>=

<<type [[Codegen5.error]]>>
<<signature [[Codegen5.string_of_error]]>>
<<exception [[Codegen5.Error]]>>

<<signature [[Codegen5.codegen]]>>
@


\section{[[Codegen5.ml]]}


<<constant [[Codegen5.rRET]]>>=
let rRET = R 0
@

<<constant [[Codegen5.rEXT1]]>>=
(* for 'extern register xx;', used in ARM kernel *)
let rEXT1 = R 10
@

<<constant [[Codegen5.rEXT2]]>>=
let rEXT2 = R 9
@

<<constant [[Codegen5.regs_initial]]>>=
let regs_initial = 
  let arr = Array.make A5.nb_registers 0 in
  [A5.rLINK; A5.rPC;       (* hardware reseved *)
   A5.rTMP; A5.rSB; A5.rSP; (* linker reserved *)
   rEXT1; rEXT2;         (* compiler reserved *)
  ] |> List.iter (fun (R x) ->
    arr.(x) <- 1
  );
  arr
@

<<type [[Codegen5.integer]]>>=
type integer = int
@


<<type [[Codegen5.error]]>>=
type error = Check.error
@

<<function [[Codegen5.string_of_error]]>>=
let string_of_error err =
  Check.string_of_error err
@

<<exception [[Codegen5.Error]]>>=
exception Error of error
@

<<constant [[Codegen5.fake_instr]]>>=
let fake_instr = A.Virtual A.NOP
@

<<constant [[Codegen5.fake_loc]]>>=
let fake_loc = -1
@

<<constant [[Codegen5.fake_pc]]>>=
let fake_pc = -1
@

<<constant [[Codegen5.noattr]]>>=
@

<<function [[Codegen5.add_instr]]>>=
let add_instr env instr loc = 
  (* grow array if necessary *)
  if !(env.pc) >= Array.length !(env.code)
  then begin
    let increment = 100 in
    let newcode = 
      Array.make (Array.length !(env.code) + increment)  (fake_instr, fake_loc)
    in
    Array.blit !(env.code) (Array.length !(env.code)) newcode 0 0;
    env.code := newcode
  end;

  !(env.code).(!(env.pc)) <- (instr, loc);
  incr env.pc;
  ()
@

<<function [[Codegen5.set_instr]]>>=
let set_instr env pc instr loc =
  if pc >= !(env.pc)
  then failwith (spf "set_instr: pc > env.pc (%d >= %d)" pc !(env.pc));
  !(env.code).(pc) <- (instr, loc)
@

<<function [[Codegen5.add_fake_instr]]>>=
let add_fake_instr env str =
  let spc = !(env.pc) in
  add_instr env (A.LabelDef (str ^ "(fake)")) fake_loc;
  spc
@

<<function [[Codegen5.add_fake_goto]]>>=
let add_fake_goto env loc =
  let spc = !(env.pc) in
  add_instr env (A.Instr (A5.B (ref (Absolute fake_pc)), A5.AL)) loc;
  spc
@

<<function [[Codegen5.patch_fake_goto]]>>=
let patch_fake_goto env pcgoto pcdest =
  match !(env.code).(pcgoto) with
  (* TODO? what about BL? time to factorize B | BL | Bxx ? *)
  (* ocaml-light: | A5.Instr (A5.B aref, A5.AL), _loc | A5.Instr (A5.Bxx (_, aref), A5.AL), _loc *)
  | A.Instr (A5.B aref, A5.AL), _loc ->
    if !aref = (Absolute fake_pc)
    then aref := Absolute pcdest
    else raise (Impossible "patching already resolved branch")
  | A.Instr (A5.Bxx (_, aref), A5.AL), _loc ->
    if !aref = (Absolute fake_pc)
    then aref := Absolute pcdest
    else raise (Impossible "patching already resolved branch")
  | _ -> raise (Impossible "patching non jump instruction")
@

<<function [[Codegen5.global_of_id]]>>=
let global_of_id fullname idinfo = 
  { name = Ast.unwrap fullname;
    priv = 
      (match idinfo.TC.sto with
      | S.Static -> Some (-1)
      | S.Global | S.Extern -> None
      | _ -> raise (Impossible "global can be only Static/Global/Extern")
      );
    (* less: analyse idinfo.typ *)
    signature = None;
  }
@

<<function [[Codegen5.symbol]]>>=
let symbol fullname = Ast.unwrap fullname
@

<<function [[Codegen5.entity_of_id]]>>=
let entity_of_id env fullname offset_extra =
  let idinfo = Hashtbl.find env.ids fullname in
  match idinfo.TC.sto with
  | S.Param -> 
    let offset = Hashtbl.find env.offsets fullname + offset_extra in
    Param (Some (symbol fullname), offset)
  | S.Local ->
    let offset = Hashtbl.find env.offsets fullname + offset_extra in
    (* - offset for locals *)
    A.Local (Some (symbol fullname), - offset)
  | S.Static | S.Global | S.Extern ->
    let offset = offset_extra in
    A.Global (global_of_id fullname idinfo, offset)
@

<<function [[Codegen5.mov_operand_of_opd]]>>=
(* less: opportunity for bitshifted registers? *)
let mov_operand_of_opd env opd =
  match opd.opd with
  | ConstI i   -> A5.Imsr (A5.Imm i)
  | Register r -> A5.Imsr (A5.Reg r)
  | Name (fullname, offset) -> A5.Entity (entity_of_id env fullname offset)
  | Indirect (r, offset) -> A5.Indirect (r, offset)
  | Addr fullname -> A5.Ximm (A.Address (entity_of_id env fullname 0))
@

<<function [[Codegen5.arith_instr_of_op]]>>=
let arith_instr_of_op op r1 r2 r3 =
  A5.Arith (
    (match op with
    | Arith op ->
      (match op with 
      | Plus -> A5.ADD | Minus -> A5.SUB
      | And -> A5.AND | Or -> A5.ORR | Xor -> A5.EOR
      (* todo: need type info for A.SLR *)
      | ShiftLeft -> A5.SLL | ShiftRight -> A5.SRA
      (* todo: need type info for A.MULU, etc *)
      | Mul -> A5.MUL | Div -> A5.DIV | Mod -> A5.MOD
      )
    | Logical _ -> raise Todo
    ),
    None, 
    A5.Reg r1, Some r2, r3
  )
@



<<function [[Codegen5.reguse]]>>=
let reguse env (A.R x) =
  env.regs.(x) <- env.regs.(x) + 1
@

<<function [[Codegen5.regfree]]>>=
let regfree env (A.R x) = 
  env.regs.(x) <- env.regs.(x) - 1;
  if env.regs.(x) < 0
  then raise (Error (E.Misc ("error in regfree", fake_loc)))
@

<<function [[Codegen5.with_reg]]>>=
let with_reg env r f =
  (* less: care about exn? meh, if exn then no recovery anyway *)
  reguse env r;
  let res = f() in
  regfree env r;
  res
@

<<function [[Codegen5.regalloc]]>>=
let regalloc env loc =
  (* less: lasti trick? *)
  let rec aux i n =
    (* This happens in extreme case when the expression tree has a huge
     * depth everywhere. In that case, we should allocate a new temporary
     * on the stack but this complexifies the algorithm.
     *)
    if i >= n 
    then raise (Error(E.Misc("out of fixed registers; rewrite your code",loc)));

    if env.regs.(i) = 0
    then begin
      env.regs.(i) <- 1;
      i
    end
    else aux (i+1) n
  in
  aux 0 (Array.length env.regs)
@

<<function [[Codegen5.opd_regalloc]]>>=
(* We can reuse a previous register if 'tgtopt' is a register.
 * See for example return.c where we can reuse R0 instead of a new R1.
 *)
let opd_regalloc env typ loc tgtopt =
  match typ with
  | T.I _ | T.Pointer _ ->
    let i = 
      match tgtopt with
      | Some { opd = Register (A.R x); typ=_; loc=_ } -> 
        reguse env (A.R x);
        x
      | _ -> regalloc env loc
    in
    { opd = Register (A.R i); typ; loc }
  | _ -> raise Todo
@

<<function [[Codegen5.opd_regfree]]>>=
(*
let opd_regalloc_opd env opd tgtopt =
  opd_regalloc env opd.typ opd.loc tgtopt
let opd_regalloc_e env e tgtopt =
  opd_regalloc env e.e_type e.e_loc tgtopt
*)

let opd_regfree env opd =
  match opd.opd with
  | Register r -> regfree env r;
  | _ -> raise (Impossible "opd_regfree on non-register operand")
@

<<function [[Codegen5.gmove_opt]]>>=
let gmove_opt env opd1 opd2opt = 
  match opd2opt with
  | Some opd2 -> gmove env opd1 opd2
  | None ->
    (* less: should have warned about unused opd in check.ml *)
    ()
@


<<function [[Codegen5.expr_cond]]>>=
let expr_cond env e0 =
  (* todo: *)
  with_reg env rRET (fun () ->
    let dst = { opd = Register rRET; typ = e0.e_type; loc = e0.e_loc } in
    expr env e0 (Some dst);
    (* less: actually should be last loc of e0 *)
    let loc = e0.e_loc in
    add_instr env (A.Instr (A5.Cmp (A5.CMP, A5.Imm 0, rRET), A5.AL)) loc;
    let pc = !(env.pc) in
    add_instr env (A.Instr (A5.Bxx (A5.EQ,(ref (A.Absolute fake_pc))),A5.AL)) loc;
    pc
  )
@

<<function [[Codegen5.expropt]]>>=
let expropt env eopt =
  match eopt with
  | None -> ()
  | Some e -> expr env e None
@


%-------------------------------------------------------------

<<Codegen5.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast_asm
open Ast
module C = Ast
module A = Ast_asm
module A5 = Ast_asm5

module T = Type
module S = Storage
module TC = Typecheck
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * todo:
 *   - funcalls
 *   - fields, structures
 * todo later:
 *   - firstarg opti
 *   - alignment 
 *     * fields (sualign)
 *     * parameters
 *   - other integer types and cast
 *   - float
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Codegen5.env]]>>

<<constant [[Codegen5.rRET]]>>
(* opti: let rARG = A.R 0 *)

<<constant [[Codegen5.rEXT1]]>>
<<constant [[Codegen5.rEXT2]]>>

<<constant [[Codegen5.regs_initial]]>>
   
  
<<type [[Codegen5.integer]]>>

<<type [[Codegen5.operand_able]]>>
<<type [[Codegen5.operand_able_kind]]>>


<<type [[Codegen5.error]]>>
<<function [[Codegen5.string_of_error]]>>
<<exception [[Codegen5.Error]]>>


(*****************************************************************************)
(* Instructions  *)
(*****************************************************************************)

<<constant [[Codegen5.fake_instr]]>>
<<constant [[Codegen5.fake_loc]]>>
<<constant [[Codegen5.fake_pc]]>>
<<constant [[Codegen5.noattr]]>>

<<function [[Codegen5.add_instr]]>>

<<function [[Codegen5.set_instr]]>>


<<function [[Codegen5.add_fake_instr]]>>

<<function [[Codegen5.add_fake_goto]]>>
 
<<function [[Codegen5.patch_fake_goto]]>>


(*****************************************************************************)
(* C to Asm helpers  *)
(*****************************************************************************)

<<function [[Codegen5.global_of_id]]>>

<<function [[Codegen5.symbol]]>>

<<function [[Codegen5.entity_of_id]]>>


<<function [[Codegen5.mov_operand_of_opd]]>>

<<function [[Codegen5.arith_instr_of_op]]>>

(*****************************************************************************)
(* Operand able, instruction selection  *)
(*****************************************************************************)

<<function [[Codegen5.operand_able]]>>

<<constant [[Codegen5.fn_complexity]]>>

<<function [[Codegen5.complexity]]>>

(*****************************************************************************)
(* Register allocation helpers *)
(*****************************************************************************)

<<function [[Codegen5.reguse]]>>

<<function [[Codegen5.regfree]]>>

<<function [[Codegen5.with_reg]]>>
  
<<function [[Codegen5.regalloc]]>>


<<function [[Codegen5.opd_regalloc]]>>

<<function [[Codegen5.opd_regfree]]>>

(*****************************************************************************)
(* Code generation helpers *)
(*****************************************************************************)

(* Even though two arguments are operand_able, it does not mean
 * we can move one into the other with one instruction. 
 * In theory, 5a supports general MOVW, but 5l restricts those
 * MOVW to only store and load (not both at the same time).
 * This is why we must decompose below the move in 2 instructions
 * sometimes.
 *)
let rec gmove env opd1 opd2 =
  match opd1.opd with
  (* a load *)
  | Name _ | Indirect _ ->
    let move_size = 
      match opd1.typ with
      | T.I (T.Int, _) | T.Pointer _ -> A.Word
      | _ -> raise Todo
    in
    (* less: opti which does opd_regfree env opd2 (Some opd2)? worth it? *)
    let opd1reg = opd_regalloc env opd1.typ opd1.loc (Some opd2) in
    gmove_aux env move_size opd1 opd1reg;
    gmove env opd1reg opd2;
    opd_regfree env opd1reg
  | _ ->
    (match opd2.opd with
    (* a store *)
    | Name _ | Indirect _ ->
      let move_size =
        match opd2.typ with
        | T.I (T.Int, _) | T.Pointer _ -> A.Word
        | _ -> raise Todo
      in
      (* less: opti which does opd_regfree env opd2 (Some opd1)?? *)
      let opd2reg = opd_regalloc env opd2.typ opd2.loc None in
      gmove env opd1 opd2reg;
      gmove_aux env move_size opd2reg opd2;
      opd_regfree env opd2reg

    | _ -> 
      (* the simple cases *)
      let move_size = 
        match opd1.typ, opd2.typ with
        | T.I (T.Int, _), T.I (T.Int, _) -> A.Word
        | T.Pointer _, T.Pointer _ -> A.Word
        (* todo: lots of opti related to float *)
        | _ -> raise Todo
      in
      gmove_aux env move_size opd1 opd2
    )

(* At this point, either opd1 or opd2 references memory (but not both),
 * so we can do the move in one instruction.
 *)
and gmove_aux env move_size opd1 opd2 =
  (* less: should happen only for register? *)
  if opd1.opd = opd2.opd
  then ()
  else 
  add_instr env 
    (A.Instr (A5.MOVE (move_size, None, 
                      mov_operand_of_opd env opd1,
                      mov_operand_of_opd env opd2), A5.AL)) opd1.loc

<<function [[Codegen5.gmove_opt]]>>

(*****************************************************************************)
(* Expression *)
(*****************************************************************************)

<<function [[Codegen5.expr]]>>

<<function [[Codegen5.expr_cond]]>>

<<function [[Codegen5.expropt]]>>

(*****************************************************************************)
(* Statement *)
(*****************************************************************************)
<<function [[Codegen5.stmt]]>>

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)
<<function [[Codegen5.codegen]]>>

@


\section{[[Dumper_.mli]]}

%-------------------------------------------------------------

<<Dumper_.mli>>=

<<signature [[Dumper_.s_of_any]]>>

<<signature [[Dumper_.s_of_any_with_types]]>>
@


\section{[[Dumper_.ml]]}

%-------------------------------------------------------------

<<Dumper_.ml>>=

<<function [[Dumper_.s_of_any]]>>

<<function [[Dumper_.s_of_any_with_types]]>>
@


\section{[[Error.mli]]}


%-------------------------------------------------------------

<<Error.mli>>=

<<signature [[Error.warn]]>>

<<signature [[Error.errorexit]]>>
@


\section{[[Error.ml]]}

%-------------------------------------------------------------

<<Error.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

<<function [[Error.warn]]>>

<<function [[Error.errorexit]]>>
@


\section{[[Eval_const.mli]]}

<<signature [[Eval_const.eval]]>>=
(* may raise NotAConstant or Error *)
val eval: env -> Ast.expr -> integer
@


%-------------------------------------------------------------

<<Eval_const.mli>>=

<<exception [[Eval_const.NotAConstant]]>>

<<type [[Eval_const.error]]>>
<<exception [[Eval_const.Error]]>>

<<type [[Eval_const.integer]]>>
<<type [[Eval_const.env]]>>

<<signature [[Eval_const.eval]]>>
@


\section{[[Eval_const.ml]]}

<<type [[Eval_const.integer]]>>=
type integer = int
@

<<type [[Eval_const.env]]>>=
type env = (Ast.fullname, integer * Type.integer_type) Hashtbl.t 
@

<<exception [[Eval_const.NotAConstant]]>>=
exception NotAConstant
@

<<type [[Eval_const.error]]>>=
type error = Check.error
@

<<exception [[Eval_const.Error]]>>=
exception Error of error
@

%-------------------------------------------------------------

<<Eval_const.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common

open Ast
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* less: return also float at some point? *)
<<type [[Eval_const.integer]]>>

(* less: could do that in rewrite.ml so no need to pass is to eval *)
<<type [[Eval_const.env]]>>

<<exception [[Eval_const.NotAConstant]]>>


(* less: could factorize things in error.ml? *)
<<type [[Eval_const.error]]>>

<<exception [[Eval_const.Error]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Eval_const.eval]]>>
@


\section{[[Flags.ml]]}


<<constant [[Flags.debugger]]>>=
let debugger = ref false
@

<<constant [[Flags.backtrace]]>>=
let backtrace = ref false
@


%-------------------------------------------------------------

<<Flags.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

<<constant [[Flags.warn]]>>
<<constant [[Flags.warnerror]]>>

(* see also macroprocessor/flags_cpp.ml *)

<<constant [[Flags.dump_tokens]]>>
<<constant [[Flags.dump_ast]]>>
<<constant [[Flags.dump_typed_ast]]>>
<<constant [[Flags.dump_asm]]>>

<<constant [[Flags.debugger]]>>
<<constant [[Flags.backtrace]]>>
@


\section{[[Globals.ml]]}


%-------------------------------------------------------------

<<Globals.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(* See also globals in ../macroprocessor/location_cpp.ml  *)

<<global [[Globals.hids]]>>
@


\section{[[Lexer.mll]]}

\section{[[Main.ml]]}

%-------------------------------------------------------------

<<Main.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
(* open Xix_compiler *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<toplevel [[Main._1]]>>
@


\section{[[Parse.mli]]}

%-------------------------------------------------------------

<<Parse.mli>>=

<<signature [[Parse.parse]]>>

<<signature [[Parse.parse_no_cpp]]>>
@


\section{[[Parse.ml]]}


%-------------------------------------------------------------

<<Parse.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common

module L = Location_cpp
module T = Parser  (* T for Tokens *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[Parse.parse]]>>

<<function [[Parse.parse_no_cpp]]>>
@

\section{[[Parser.mly]]}

\section{[[Rewrite.mli]]}

%-------------------------------------------------------------

<<Rewrite.mli>>=
@


\section{[[Rewrite.ml]]}

%-------------------------------------------------------------

<<Rewrite.ml>>=

(* todo mandatory:
 *  - pointer arithmetic
 *  - automatic casts
 * todo for opti?:
 *  - OADDR/OIND simplifications
 *  - put constants on the right for commutative operations
 *)
@


\section{[[Storage.ml]]}

%-------------------------------------------------------------

<<Storage.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(* No Typedef here, because a typedef is not a storage! *) 
<<type [[Storage.t]]>>
@


\section{[[Type.ml]]}

%-------------------------------------------------------------

<<Type.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
(* renamed to Type_.ml because conflict with OCaml5 module name *)

<<type [[Type.blockid]]>>
<<type [[Type.fullname]]>>

<<type [[Type.t]]>>

<<type [[Type.integer_type]]>>
<<type [[Type.integer_kind]]>>
<<type [[Type.sign]]>>

<<type [[Type.float_type]]>>

<<type [[Type.struct_kind]]>>
[@@deriving show]

<<type [[Type.qualifier]]>>



<<type [[Type.structdef]]>>

<<constant [[Type.int]]>>
<<constant [[Type.long]]>>
@


\section{[[Typecheck.mli]]}

%-------------------------------------------------------------

<<Typecheck.mli>>=

<<type [[Typecheck.idinfo]]>>

<<type [[Typecheck.error]]>>
<<signature [[Typecheck.string_of_error]]>>
<<exception [[Typecheck.Error]]>>

<<signature [[Typecheck.check_and_annotate_program]]>>
@


\section{[[Typecheck.ml]]}

<<type [[Typecheck.integer]]>>=
type integer = int
@





<<function [[Typecheck.check_compatible_binary]]>>=
(* when you apply an operation between two expressions, this
 * expression can be valid even if the types of those two expressions
 * are not the same. However, they must be "compatible". 
 * The compatibility policy depends on the operation of the expression.
 * 
 * less: better error messages, for instance when want to add 2 pointers.
 *)
let check_compatible_binary op t1 t2 loc =
  match op with
  | Arith Plus ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _)
    | T.Pointer _, T.I _
    | T.I _, T.Pointer _
      -> ()
    (* you can not add 2 pointers *)
    | T.Pointer _, T.Pointer _
    | _ -> type_error2 t1 t2 loc
    )
  | Arith Minus ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _)
    (* you can not sub a pointer to an int (but can sub an int to a pointer) *)
    | T.Pointer _, T.I _
      -> ()
    (* you can sub 2 pointers (if they have the same types, and the
     * result is a long). same_types() will allow a void* to match any pointer.
     *)
    | T.Pointer _, T.Pointer _ when same_types t1 t2 -> ()
    | _ -> type_error2 t1 t2 loc
    )
  | Arith (Mul | Div) ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _) -> ()
    | _ -> type_error2 t1 t2 loc
    )
  | Arith (Mod   | And | Or | Xor  | ShiftLeft | ShiftRight ) ->
    (match t1, t2 with
    | (T.I _), (T.I _ ) 
      -> ()
    (* stricter: I do not allow T.Int _ with T.F _, 5c does (clang does not) *)
    | _ -> type_error2 t1 t2 loc
    )

  | Logical (Eq | NotEq  | Inf | Sup | InfEq | SupEq) ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _) -> ()
    | T.Pointer _, T.Pointer _ when same_types t1 t2 -> ()
    (* you can not compare two structures! no deep equality (nor arrays) *)
    | _ -> type_error2 t1 t2 loc
    )
  | Logical (AndLog | OrLog) ->
    (* stricter? should impose Bool! *)
    (match t1 with
    | (T.I _ | T.F _ | T.Pointer _) ->
      (match t2 with
      | (T.I _ | T.F _ | T.Pointer _) -> ()
      | _ -> type_error t2 loc
      )
    | _ -> type_error t1 loc
    )
@

<<function [[Typecheck.result_type_binary]]>>=
let result_type_binary t1 t2 =
  match t1, t2 with
  | T.I (T.Char, T.Signed), (T.I _ | T.F _ | T.Pointer _) -> t2

  | T.I (T.Char, T.Unsigned), T.I (x, _) -> T.I (x, T.Unsigned)
  | T.I (T.Char, T.Unsigned), (T.F _ | T.Pointer _) -> t2

  | T.I (T.Short, T.Signed), (T.I ((T.Char|T.Short), sign)) -> 
      T.I (T.Short, sign)
  | T.I (T.Short, T.Signed), (T.I _ | T.F _ | T.Pointer _) -> t2

  | T.I (T.Short, T.Unsigned), (T.I ((T.Char|T.Short), _)) -> 
      T.I (T.Short, T.Unsigned)
  | T.I (T.Short, T.Unsigned), T.I (x, _) -> T.I (x, T.Unsigned)
  | T.I (T.Short, T.Unsigned), (T.F _ | T.Pointer _) -> t2

  | T.I (T.Int, T.Signed), (T.I ((T.Char|T.Short|T.Int), sign)) -> 
      T.I (T.Int, sign)
  | T.I (T.Int, T.Signed), (T.I _ | T.F _ | T.Pointer _) -> t2

  | T.I (T.Int, T.Unsigned), (T.I ((T.Char|T.Short|T.Int), _)) -> 
      T.I (T.Int, T.Unsigned)
  | T.I (T.Int, T.Unsigned), T.I (x, _) -> T.I (x, T.Unsigned)
  | T.I (T.Int, T.Unsigned), (T.F _ | T.Pointer _) -> t2

  | T.I (T.Long, T.Signed), (T.I ((T.Char|T.Short|T.Int|T.Long), sign))-> 
      T.I (T.Long, sign)
  | T.I (T.Long, T.Signed), (T.I _ | T.F _ | T.Pointer _) -> t2

  | T.I (T.Long, T.Unsigned), (T.I ((T.Char|T.Short|T.Int|T.Long), _)) -> 
      T.I (T.Long, T.Unsigned)
  | T.I (T.Long, T.Unsigned), T.I (x, _) -> T.I (x, T.Unsigned)
  | T.I (T.Long, T.Unsigned), (T.F _ | T.Pointer _) -> t2

  | T.I (T.VLong, T.Signed),(T.I ((T.Char|T.Short|T.Int|T.Long|T.VLong),sign))->
      T.I (T.VLong, sign)
  | T.I (T.VLong, T.Signed), (T.F _ | T.Pointer _) -> t2

  | T.F T.Float, (T.I _ | T.F T.Float) -> T.F T.Float
  | T.F T.Float, T.F T.Double -> T.F T.Double
  | T.F T.Float, T.Pointer _ -> t2

  | T.F T.Double, (T.I _ | T.F _) -> T.F T.Double
  | T.F T.Double, T.Pointer _ -> t2

  | T.Pointer _, (T.I _ | T.F _) -> t1

  (* see same_types special handling of void* pointers *)
  | T.Pointer T.Void, T.Pointer _ -> t2
  | T.Pointer _, T.Pointer T.Void -> t1

  | T.Pointer _, T.Pointer _ ->
    assert (t1 = t2);
    t1

  | _ -> raise (Impossible "case should be forbidden by compatibility policy")
@

<<function [[Typecheck.check_compatible_assign]]>>=
(* less: could run typ_ext hooks here? and return a new node? for
 * unnamed_inheritance.c?
 *)
let check_compatible_assign op t1 t2 loc =
  match op with
  | SimpleAssign ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _) -> ()
    (* 'void*' special handling done in same_types() *)
    | T.Pointer _, T.Pointer _ when same_types t1 t2 -> ()
    | T.StructName (su1, name1), T.StructName (su2, name2) 
      when su1 = su2 && name1 = name2 -> ()
    | _ -> type_error2 t1 t2 loc
    )
  (* not exactly the same rule than in check_compatible_binary *)
  | OpAssign op ->
    (match op with
    | (Plus | Minus) ->
      (match t1, t2 with
      | (T.I _ | T.F _), (T.I _ | T.F _) -> ()
      (* you can not x += y or x-=y when both x and y are pointers
       * even though you can do x - y because the result type is a long
       * (and so you can not assign than back into x).
       *)
      | T.Pointer _, T.I _ -> ()
      | _ -> type_error2 t1 t2 loc
      )
    | (Mul | Div) 
    | (Mod   | And | Or | Xor  | ShiftLeft | ShiftRight ) 
      -> check_compatible_binary (Arith op) t1 t2 loc
    )
@

<<function [[Typecheck.check_args_vs_params]]>>=
let rec check_args_vs_params es tparams varargs loc =
  match es, tparams, varargs with
  (* stricter? confusing to have foo() and foo(void) *)
  | [], ([] | [T.Void]), _ -> ()
  | [], _, _ -> 
    raise (Error (E.Misc ("not enough function arguments", loc)))
  | _e::_es, [], false -> 
    raise (Error (E.Misc ("too many function arguments", loc)))
  | e::es, [], true -> 
    (match e.e_type with
    | T.I _ | T.F _ | T.Pointer _ | T.StructName _ -> ()
    | _ -> type_error e.e_type loc
    );
    check_args_vs_params es [] true loc
  | e::es, t::ts, _ ->
    (match e.e_type with
    | T.I _ | T.F _ | T.Pointer _ | T.StructName _ -> ()
    | _ -> type_error e.e_type loc
    );
    (try 
       (* todo: convert to int small types? see tcoma *)
       check_compatible_assign SimpleAssign t e.e_type e.e_loc
     with Error _ ->
       raise (Error (E.Misc ("argument prototype mismatch", e.e_loc)))
    );
    check_args_vs_params es ts varargs loc
@

<<function [[Typecheck.merge_storage_toplevel]]>>=
(* If you declare multiple times the same global, we need to make sure
 * the storage declarations are compatible and we need to compute the
 * final (resolved) storage.
 * This function works for toplevel entities (globals but also functions).
 *)
let merge_storage_toplevel name loc stoopt ini old =
  match stoopt, old.sto with
    (* The None cases first *)
  
    (* this is ok, a header file can declare many externs and a C file
     * can then selectively "implements" some of those declarations.
     *)
    | None, S.Extern -> S.Global
    | None, S.Global ->
        (* stricter: even clang does not say anything here *)
        if ini = None
        then raise (Error (E.Inconsistent (
          spf "useless redeclaration of '%s'" name, loc,
          "previous definition is here", old.loc)))
        else S.Global

    (* stricter: 5c just warns for this *)
    | (None | Some S.Extern), S.Static ->
      raise (Error (E.Inconsistent (
       spf "non-static declaration of '%s' follows static declaration" name,loc,
       "previous definition is here", old.loc)))
    | _, (S.Local | S.Param) -> 
      raise (Impossible "globals can't be auto or param")

    (* The Some cases *)

    (* stricter: useless extern *)
    | Some S.Extern, (S.Global | S.Extern) ->
      raise (Error (E.Inconsistent (
        spf "useless extern declaration of '%s'" name, loc,
        "previous definition is here", old.loc)))

    | Some S.Local, _ ->
      raise (Error(E.Misc("illegal storage class for file-scoped entity", loc)))
    | Some S.Static, (S.Extern | S.Global) ->
      raise (Error (E.Inconsistent (
       spf "static declaration of '%s' follows non-static declaration" name,loc,
       "previous definition is here", old.loc)))

    | Some S.Static, S.Static ->
        if ini = None
        then raise (Error (E.Inconsistent (
          spf "useless redeclaration of '%s'" name, loc,
          "previous definition is here", old.loc)))
        else S.Static

    | Some (S.Global | S.Param), _ -> 
      raise (Impossible "param or global are not keywords")
@

<<function [[Typecheck.lvalue]]>>=
(* we assume the typechecker has called expr() on 'e0' before, 
 * so Id of enum constants for example has been substituted to Int
 * and so are not considered an lvalue.
 *)
let lvalue e0 =
  match e0.e with
  | Id _ 
  | Unary (DeRef, _)
  (* todo: lvalue only if leftpart is a lvalue. But when it can not be
   * a lvalue? if bitfield?
   *)
  | RecordAccess _
    -> true
  (* Strings are transformed at some point in Id.
   * We must consider them as an lvalue, because an Id is an lvalue 
   * and because if a string is passed as an argument to a function, we want
   * to pass the address of this string (see array_to_pointer()).
   *)
  | String _ -> 
    (* raise (Impossible "transformed before") *)
    true

  | Int _ | Float _
  | Binary _ 
  | Unary ((GetRef | UnPlus |  UnMinus | Tilde | Not), _)
    -> false
  | ArrayAccess _ | RecordPtAccess _ -> raise (Impossible "transformed before")
  | _ -> raise Todo
@

<<function [[Typecheck.array_to_pointer]]>>=
(* When you mention an array in a context where you want to access the array
 * content, we prefix the array with a '&' and change its type from a T.Array
 * to a T.Pointer. This allows in turn to write typechecking rules
 * mentioning only Pointer (see for example check_compatible_binary).
 *)
let array_to_pointer env e =
  match e.e_type with
  | T.Array (_, t) ->
    (match env.expr_context with
    | CtxWantValue -> 
      if not (lvalue (e))
      then raise (Error (E.Misc ("not an l-value", e.e_loc)));

      { e = Unary (GetRef, e); e_type = T.Pointer t; e_loc = e.e_loc }
    | CtxGetRef -> 
      Error.warn "address of array ignored" e.e_loc;
      e
    | CtxSizeof -> e
    )
  (* stricter? do something for Function? or force to put address? *)
  | T.Func _ ->
    (match env.expr_context with
    | CtxWantValue -> 
      Error.warn "you should get the address of the function" e.e_loc;
      e
    | _ -> e
    )
    
  | _ -> e
@

<<function [[Typecheck.unsugar_anon_structure_element]]>>=
(* X.foo --> X.|sym42|.foo *)
let rec unsugar_anon_structure_element env e0 e name def =
  
  let res = ref [] in

  def |> List.iter (fun (fldname, t) ->
    if fldname = name
    then res |> Stack_.push { e0 with e = RecordAccess (e, name); e_type = t }
    else
      if Ast.is_gensymed fldname
      then
        (match t with
        | T.StructName (_su, fullname) ->
          let (_su2, def) = Hashtbl.find env.structs fullname in
          (try 
             let e = 
               unsugar_anon_structure_element env e0
                 ({ e with e = RecordAccess (e, fldname); e_type = t })
                 name def
             in
             res |> Stack_.push e
           with Not_found -> ()
          )
        | _ -> raise (Impossible "checked anon elements are struct/union")
        )
      else ()
  );
  (match !res with
  | [x] -> x
  | [] -> raise Not_found
  | _x::_y::_xs ->
    raise (Error(E.Misc(spf "ambiguous unnamed structure element %s" name,
                               e.e_loc)))
@

<<function [[Typecheck.type_]]>>=
(* Expand typedefs and resolve constant expressions. *)
let rec type_ env typ0 =
  match typ0.t with
  | TBase t -> t
  | TPointer typ -> T.Pointer (type_ env typ)
  | TArray (eopt, typ) ->
      (match eopt with
      | None -> T.Array (None, type_ env typ)
      | Some e ->
        (try 
           let i = Eval_const.eval env.constants e in
           T.Array (Some i, type_ env typ)
         with Eval_const.NotAConstant ->
           raise (Error
                  (E.Misc("array size must be a positive constant",typ0.t_loc)))
        )
      )
  | TFunction (tret, (tparams, tdots)) ->
      T.Func (type_ env tret, 
                tparams |> List.map (fun p -> 
                  let t = type_ env p.p_type in
                  (match t with
                  (* libc.h has a 'typedef long jmp_buf[2]' and then functions
                   * like 'int setjmp(jmp_buf)' so we need to support that.
                   * less: could warn?
                   *)
                  | T.Array (_, t) -> T.Pointer t
                  (* stricter: could transform T.Func in pointer *)
                  | T.Func _ -> type_error t p.p_loc
                  | _ -> t
                  )
                ), tdots)
  | TStructName (su, fullname) -> T.StructName (su, fullname)
  (* expand enums *)
  | TEnumName fullname -> T.I (Hashtbl.find env.enums fullname)
  (* expand typedefs *)
  | TTypeName fullname -> Hashtbl.find env.typedefs fullname
@



%-------------------------------------------------------------

<<Typecheck.ml>>=
(* Copyright 2016, 2017 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast
module T = Type
module S = Storage
module E = Check

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This module does many things:
 *  - it expands typedefs
 *  - it assigns a final (resolved) type to every identifiers
 *  - it assigns a final storage to every identifiers
 *  - it assigns a type to every expressions
 *  - it returns a typed AST and also transforms this AST
 *    (e.g., enum constants are replaced by their value)
 * 
 * Thanks to the naming done in parser.mly and the unambiguous Ast.fullname,
 * we do not have to handle scope here. 
 * Thanks to check.ml we do not have to check for inconsistencies or
 * redefinition of tags. We can assume everything is fine.
 * 
 * limitations compared to 5c:
 *  - no 'void*' conversions 
 *    (clang does not either? but we do accept so void* vs xxx* )
 *  - no struct equality by field equality. I use name equality.
 *    (who uses that anyway?)
 *  - no float enum
 *    (who uses that anyway?)
 *  - no 0 to nil automatic cast inserted
 *    (I prefer stricter typechecking)
 * 
 * todo: 
 *  - const checking (in check_const.ml?) need types!
 *  - format checking (in check_format.ml?) need types!
 *  - misc checks
 *    * stupid shift bits (need constant evaluation) outside width
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* less: vlong? *)
<<type [[Typecheck.integer]]>>

<<type [[Typecheck.idinfo]]>>
<<type [[Typecheck.env]]>>
<<type [[Typecheck.expr_context]]>>

(* less: could factorize things in error.ml? *)
<<type [[Typecheck.error]]>>

<<function [[Typecheck.string_of_error]]>>

<<exception [[Typecheck.Error]]>>

<<function [[Typecheck.type_error]]>>

<<function [[Typecheck.type_error2]]>>

(*****************************************************************************)
(* Types helpers *)
(*****************************************************************************)

<<function [[Typecheck.same_types]]>>
   
<<function [[Typecheck.merge_types]]>>

(* when processing enumeration constants, we want to keep the biggest type *)
(*
let max_types t1 t2 = ...
*)

<<function [[Typecheck.check_compatible_binary]]>>

<<function [[Typecheck.result_type_binary]]>>

<<function [[Typecheck.check_compatible_assign]]>>

<<function [[Typecheck.check_args_vs_params]]>>
    
(*****************************************************************************)
(* Storage helpers *)
(*****************************************************************************)

<<function [[Typecheck.merge_storage_toplevel]]>>


(*****************************************************************************)
(* Other helpers *)
(*****************************************************************************)

<<function [[Typecheck.lvalue]]>>

<<function [[Typecheck.array_to_pointer]]>>

<<function [[Typecheck.unsugar_anon_structure_element]]>>
  )

(*****************************************************************************)
(* AST Types to Types.t *)
(*****************************************************************************)

<<function [[Typecheck.type_]]>>

(*****************************************************************************)
(* Expression typechecking *)
(*****************************************************************************)

<<function [[Typecheck.expr]]>>
<<function [[Typecheck.expropt]]>>

(*****************************************************************************)
(* Statement *)
(*****************************************************************************)

<<function [[Typecheck.stmt]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Typecheck.check_and_annotate_program]]>>
@


\section{[[macroprocessor/Ast_cpp.ml]]}


<<type [[Ast_cpp.macro]]>>=
  and macro = {
    name: string;
    (* Note that you can have None or Some [] for parameters.
     * The first is a macro without parameter, the second a macro with 
     * 0 parameters (but that still needs to be called by FOO())
     *)
    params: string list option;
    varargs: bool;
    (* The body below has been processed and every parameter occurence
     * is replaced by a #xxx where xxx is the number corresponding to the
     * ith parameter.
     *)
    body: string option
  }
@


%-------------------------------------------------------------

<<macroprocessor/Ast_cpp.ml>>=
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An Abstract Syntax Tree (AST) for the C Pre-Processor (CPP) directives.
*)

(*****************************************************************************)
(* The AST *)
(*****************************************************************************)

<<type [[Ast_cpp.directive]]>>

<<type [[Ast_cpp.macro]]>>
[@@deriving show]
@


\section{[[macroprocessor/Flags_cpp.ml]]}

%-------------------------------------------------------------

<<macroprocessor/Flags_cpp.ml>>=

<<constant [[Flags_cpp.debug_line]]>>
<<constant [[Flags_cpp.debug_include]]>>
<<constant [[Flags_cpp.debug_macros]]>>
@


\section{[[macroprocessor/Lexer_cpp.mll]]}


\section{[[macroprocessor/Location_cpp.mli]]}

<<signature [[Location_cpp.history]]>>=
(* both should be reseted each time you parse a new file *)
val history: location_history list ref
@

<<signature [[Location_cpp.line]]>>=
val line: loc ref
@


<<signature [[Location_cpp.add_event]]>>=
(* add to history *)
val add_event: 
  location_event -> unit
@

<<signature [[Location_cpp.final_loc_of_loc]]>>=
(* !uses history! you should avoid this function in a multifile processing
 * context (e.g., in the linker) *)
val final_loc_of_loc: 
    loc -> final_loc
@

<<signature [[Location_cpp.dump_event]]>>=
val dump_event:
  location_event -> unit
@


%-------------------------------------------------------------

<<macroprocessor/Location_cpp.mli>>=

<<type [[Location_cpp.loc]]>>
<<type [[Location_cpp.final_loc]]>>

<<type [[Location_cpp.location_history]]>>
<<type [[Location_cpp.location_event]]>>
[@@deriving show]

<<signature [[Location_cpp.history]]>>
<<signature [[Location_cpp.line]]>>

<<exception [[Location_cpp.Error]]>>


<<signature [[Location_cpp.add_event]]>>

<<signature [[Location_cpp.final_loc_of_loc]]>>


<<signature [[Location_cpp.dump_event]]>>
@


\section{[[macroprocessor/Location_cpp.ml]]}

<<type [[Location_cpp.loc]]>>=
type loc = int
[@@deriving show]
@

<<type [[Location_cpp.final_loc]]>>=
type final_loc = Fpath.t * int
[@@deriving show]
@

<<type [[Location_cpp.location_history]]>>=
type location_history = {
  location_event: location_event;
  global_line: loc;
}
@

<<type [[Location_cpp.location_event]]>>=
  and location_event =
    (* #include "foo.h" *)
    | Include of Fpath.t
    (* #line 1 "foo.c" *)
    | Line of int * Fpath.t
    (* end of #include, back to includer *)
    | Eof
@

<<constant [[Location_cpp.history]]>>=
let history = ref []
@

<<constant [[Location_cpp.line]]>>=
let line = ref 1
@

<<exception [[Location_cpp.Error]]>>=
exception Error of string * loc
@

<<function [[Location_cpp.dump_event]]>>=
(* for 5c -f 
 * alt: just rely on deriving show but kept this for compatibility with kencc
 *)
let dump_event (event : location_event) : unit =
  match event with
  | Include file -> 
      Logs.app (fun m -> m "%4d: %s" !line !!file)
  | Line (local_line, file) -> 
      Logs.app (fun m -> m "%4d: %s (#line %d)" !line !!file local_line)
  | Eof -> 
      Logs.app (fun m -> m "%4d: <pop>" !line)
@

<<function [[Location_cpp.add_event]]>>=
let add_event (event : location_event) : unit =
  (* alt: use Logs.debug instead of a flag *)
  if !Flags_cpp.debug_line
  then dump_event event;
  history := {location_event = event; global_line = !line }::!history
@

<<function [[Location_cpp.final_loc_of_loc]]>>=
(* 'history' contains the list of location_events in reverse order
 * since we always add an event to the end, for instance: 
 * [200; 150; 130; 60; 1]. The first step is to reverse this list:
 * [1; 60; 130; 150; 200]. Then, if we look for information about line 135, 
 * we want to stop when we encounter 150,
 * so when lineno < x.global_line below succeed for the first time.
 *)
let final_loc_of_loc (lineno : loc) : final_loc =
  let rec aux (lastfile, lastlineno, lastdelta) stack xs =
    match xs with
    | [] -> lastfile, lineno - lastlineno + lastdelta
    | x::xs ->
      if lineno < x.global_line 
      then lastfile, lineno - lastlineno + lastdelta
      else
        (match x.location_event, stack with
        | Eof, (lastfile, _lastlineno, lastdelta)::ys ->
            (* bugfix: wrong!! TODO *)
            aux (lastfile, x.global_line, lastdelta) ys xs
        | Eof, [] -> 
            failwith ("impossible: wrong location history, unpaired Eof")
        | Include file, ys ->
            aux (file, x.global_line, 1)
              ((lastfile, lastlineno, lastdelta)::ys) xs
        | Line (line, file), _y::ys ->
            aux (file, x.global_line, line) ys xs
        | Line (line, file), [] ->
            (* todo: wrong *)
            aux (file, x.global_line, line) [] xs
        )
  in
  aux (Fpath.v "<nofile>", 0, 0) [] (List.rev !history)
@

<<function [[Location_cpp._final_loc_and_includers_of_loc]]>>=
let _final_loc_and_includers_of_loc _lineno =
  raise Todo
@


%-------------------------------------------------------------

<<macroprocessor/Location_cpp.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * less: normalize filenames? use realpath?
 *)

(*****************************************************************************)
(* Types and globals *)
(*****************************************************************************)

(* global line number, after pre-processing *)
<<type [[Location_cpp.loc]]>>

(* final readable location *)
<<type [[Location_cpp.final_loc]]>>

<<type [[Location_cpp.location_history]]>>
<<type [[Location_cpp.location_event]]>>
[@@deriving show {with_path = false}]

(* TODO? move to local in Parse_cpp.ml? *)
<<constant [[Location_cpp.history]]>>

(* Global line number (after pre-processing).
 * Note that you need another data structure to map a global line number 
 * to a (file, line) pair (see history and final_loc_of_loc below).
 *)
<<constant [[Location_cpp.line]]>>

<<exception [[Location_cpp.Error]]>>

(*****************************************************************************)
(* Debugging *)
(*****************************************************************************)

<<function [[Location_cpp.dump_event]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function [[Location_cpp.add_event]]>>


<<function [[Location_cpp.final_loc_of_loc]]>>

<<function [[Location_cpp._final_loc_and_includers_of_loc]]>>
@


\section{[[macroprocessor/Parse_cpp.mli]]}


<<signature [[Parse_cpp.parse]]>>=
(* Wrapper function around a parser/lexer.
 *
 * Regarding Cap.open_in, [parse] will [open_in] the passed file parameter but
 * may also [open_in] other files as [parse] will recursively process
 * [#include] directives.
 *)
val parse: 
  < Cap.open_in; .. > ->
  ('token, 'ast) hook -> Preprocessor.conf -> Fpath.t -> 
  'ast * Location_cpp.location_history list
@


%-------------------------------------------------------------

<<macroprocessor/Parse_cpp.mli>>=

<<type [[Parse_cpp.token_category]]>>
[@@deriving show]

(* wrapper around a parser/lexer (e.g., 5c) to preprocess first the file *)
<<type [[Parse_cpp.hook]]>>

<<signature [[Parse_cpp.parse]]>>

@


\section{[[macroprocessor/Parse_cpp.ml]]}

<<type [[Parse_cpp.token_category]]>>=
type token_category =
  | Eof
  | Sharp
  | Ident of string
  | Other
@

<<type [[Parse_cpp.hook]]>>=
type ('token, 'ast) hook = {
  lexer: Lexing.lexbuf -> 'token;
  parser: (Lexing.lexbuf -> 'token) -> Lexing.lexbuf -> 'ast;
  category: 'token -> token_category;
  (* TODO: delete, redundant with Eof token_category above *)
  eof: 'token;
}
@

<<type [[Parse_cpp.macro]]>>=
type macro = {
  m_name: string;
  m_nbargs: int option;
  m_varargs: bool; (* use "..." *)

  (* body contains #xxx substrings corresponding to the parameter of the macro.
   * For instance, #define foo(a,b) a+b --> {name="foo";nbargs=2;body="#1+#2"}.
   * 
   * Is there a risk of having numbers squashed with the macro parameter?
   * No, because if you have 'a1+b' then 'a1' is a separate identifier 
   * so you can not generate #11+#2 .
   *)
  m_body: string;
}
@

<<constant [[Parse_cpp.hmacros]]>>=
let hmacros = Hashtbl.create 101
@

<<constant [[Parse_cpp._cwd]]>>=
let _cwd = ref (Sys.getcwd ())
@

<<function [[Parse_cpp.error]]>>=
let error s =
  raise (L.Error (s, !L.line))
@

<<function [[Parse_cpp.define_cmdline_def]]>>=
let define_cmdline_def (k, v) =
  Hashtbl.add hmacros k 
    { m_name = k; m_nbargs = None; m_varargs = false; m_body = v; }
@

<<function [[Parse_cpp.define]]>>=
let define (macro : D.macro) =
  let {D.name = s; params; varargs; body} = macro in
  (* We could forbid here 's' to conflict with C keyboard, but this
   * should be done in the caller, as cpp can be used with different
   * languages, which may use different keywords.
   *)
  let sbody = match body with Some x -> x | None -> "1" in
  if Hashtbl.mem hmacros s
  then error (spf "macro redefined: %s" s)
  else begin
    let macro =
      match params with
      | None -> 
          { m_name = s; m_nbargs = None; m_varargs = false; m_body = sbody }
      | Some params ->
          { m_name = s; m_nbargs = Some (List.length params); 
            m_varargs = varargs; m_body = sbody }
    in
    if !Flags_cpp.debug_macros
    then Logs.app (fun m -> m "#define %s %s" s macro.m_body);

    Hashtbl.add hmacros s macro
  end
@

<<function [[Parse_cpp.parse]]>>=
let parse (caps : < Cap.open_in; ..>) hooks (conf : Preprocessor.conf) (file : Fpath.t) = 
  L.history := [];
  L.line := 1;
  Hashtbl.clear hmacros;
  conf.defs |> List.iter define_cmdline_def;

  let chan = CapStdlib.open_in caps !!file in
  Logs.info (fun m -> m "opening %s" !!file);

  L.add_event (L.Include file);
  let lexbuf = Lexing.from_channel chan in
  let stack = ref [(Some chan, lexbuf)] in
  (* less: let push x = check if too deep? *)

  (* for more precise error reporting *)
  let last_ident = ref "" in

  let rec lexfunc () =
    match !stack with
    | (chanopt, lexbuf)::xs ->
        let t = hooks.lexer lexbuf in
        let categ = hooks.category t in

        (match categ with
        | Eof -> 
            stack := xs;
            chanopt |> Option.iter (fun chan ->
              close_in chan;
              L.add_event L.Eof;
            );
            lexfunc ()

        | Sharp ->

            (* treating cpp directives *)
            let t = Lexer_cpp.token lexbuf in
            (match t with
            | D.Include (f, system_hdr) ->
                let path = find_include conf f system_hdr in
                (try 
                  let chan = CapStdlib.open_in caps !!path in
                  Logs.info (fun m -> m "opening included file %s" !!path);
                  L.add_event (L.Include path);
                  let lexbuf = Lexing.from_channel chan in
                  (* less: 
                     if List.length stack > 1000
                     then error "macro/io expansion too deep"
                  *)
                  stack := (Some chan, lexbuf)::!stack;
                with Failure s ->
                  error s
                )
            | D.Define macro_ast ->
               (* todo: stricter: forbid s to conflict with C keyboard *)
                define macro_ast
            | D.Undef s ->
                (* stricter: check that was defined *)
                if not (Hashtbl.mem hmacros s)
                then error (spf "macro %s was not defined" s);
                Hashtbl.remove hmacros s
            | D.Line (line, file) ->
                L.add_event (L.Line (line, file));
            (* less: for "lib" should add a L.PragmaLib event? *)
            | D.Pragma _ -> ()
            | D.Ifdef s ->
                if Hashtbl.mem hmacros s
                then ()
                else Lexer_cpp.skip_for_ifdef 0 true lexbuf
            | D.Ifndef s ->
                if not (Hashtbl.mem hmacros s)
                then ()
                else Lexer_cpp.skip_for_ifdef 0 true lexbuf
            | D.Else ->
                Lexer_cpp.skip_for_ifdef 0 true lexbuf
            | D.Endif -> ()
            );
            lexfunc ()

        | Ident s ->
            last_ident := s;
            if Hashtbl.mem hmacros s
            then 
              let macro = Hashtbl.find hmacros s in
              match macro.m_nbargs with
              | None ->
                  let body = macro.m_body in
                  if !Flags_cpp.debug_macros
                  then Logs.app (fun m -> m "#expand %s %s" s body);
                  let lexbuf = Lexing.from_string body in
                  stack := (None, lexbuf)::!stack;
                  lexfunc ()
              | Some n ->
                  let args = Lexer_cpp.macro_arguments lexbuf in
                  if List.length args <> n
                  then error (spf "argument mismatch expanding: %s" s)
                  else begin
                    let body = macro.m_body in
                    let lexbuf = Lexing.from_string body in
                    let body = 
                      Lexer_cpp.subst_args_in_macro_body s args lexbuf in
                    if !Flags_cpp.debug_macros
                    then Logs.app (fun m -> m "#expand %s %s" s body);
                    let lexbuf = Lexing.from_string body in
                    stack := (None, lexbuf)::!stack;
                    lexfunc ()
                  end
            else t
        | _ -> t
        )
    (* no more stack, could raise Impossible instead? *)           
    | [] -> hooks.eof
  in

  (try 
    let ast = hooks.parser (fun _lexbuf -> lexfunc ()) lexbuf in
    ast, !L.history
  with Parsing.Parse_error ->
    error ("Syntax error" ^ 
              (if !last_ident = "" 
               then ""
               else spf ", last name: %s" !last_ident))
  )
@


%-------------------------------------------------------------

<<macroprocessor/Parse_cpp.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators

module D = Ast_cpp (* D for Directives *)
module L = Location_cpp
module Flags = Flags_cpp

(* for record matching for ocaml-light *)
open Ast_cpp

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Cpp as a library. This is used by 5c but also 5a.
 * 
 * Main limitations compared to the cpp embedded in 5c of Plan 9:
 *  - no support for unicode
 *  - see Lexer_cpp.mll
 * Main limitations compared to ANSI cpp:
 *  - no complex boolean expressions for #ifdefs
 *
 * stricter:
 *  - see Lexer_cpp.mll
 * more general:
 *  - allow any number of arguments for macros 
 *    (not limited to 25 because of the use of #a to #z)
 *  - allow any body size 
 *    (no 8196 buffer limit)
 *  - allow any filename length in #include 
 *    (no 200 limit)
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Parse_cpp.token_category]]>>
[@@deriving show]

<<type [[Parse_cpp.hook]]>>

(* similar to Ast_cpp.macro *)
<<type [[Parse_cpp.macro]]>>

(*****************************************************************************)
(* Globals *)
(*****************************************************************************)

<<constant [[Parse_cpp.hmacros]]>>

(* cwd is used to manage #include "...". It is altered when you
 * include a file. cwd becomes the dirname of the included file??? 
 * TODO: dead? used?
 *)
<<constant [[Parse_cpp._cwd]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Parse_cpp.error]]>>


<<function [[Parse_cpp.define_cmdline_def]]>>

<<function [[Parse_cpp.define]]>>


(* less: Could use Set instead of list for the set of include paths 
 * todo: if absolute path, need to find it.
*)
let rec find_include (conf : Preprocessor.conf) (f : Fpath.t) (system : bool) =
  if system
  then find_include_bis conf.paths f
  else find_include_bis (conf.dir_source_file::conf.paths) f
and find_include_bis (paths : Fpath.t list) (f : Fpath.t) : Fpath.t =
  match paths with 
  (* stricter: better error message *)
  | [] -> failwith (spf "could not find %s in include paths" !!f)
  | x::xs ->
      let path : Fpath.t = 
        if !!x = "."
        (* this will handle also absolute path *)
        then f
        else x // f 
      in
      if Sys.file_exists !!path
      then begin
        if !Flags.debug_include
        then Logs.app (fun m -> m "%d: %s" !L.line !!path);
        path
      end
      else find_include_bis xs f

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function [[Parse_cpp.parse]]>>
@


\section{[[macroprocessor/Preprocessor.ml]]}

<<type [[Preprocessor.conf]]>>=
type conf = {
  (* -D *)
  defs: (string * string) list;
  (* -I + system paths (e.g., /usr/include) *)
  paths: Fpath.t list;
  (* the directory of the C file so it is looked for "" but not for <> *)
  dir_source_file: Fpath.t;
}
[@@deriving show]
@


%-------------------------------------------------------------

<<macroprocessor/Preprocessor.ml>>=
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Data structure containing the command-line data that one can pass to cpp
 * (e.g, -D and -I CLI flags).
 * This is passed then to Parse_cpp.parse() in addition to hooks.
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type [[Preprocessor.conf]]>>
@
