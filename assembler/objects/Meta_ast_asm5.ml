(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)
open Ast_asm
open Ast_asm5

module Ocaml = OCaml

let vof_pos = Ocaml.vof_int
let vof_symbol = Ocaml.vof_string
let vof_label = Ocaml.vof_string
let vof_integer = Ocaml.vof_int
let vof_offset = Ocaml.vof_int
let vof_virt_pc = Ocaml.vof_int
let vof_filename = Ocaml.vof_string

(* pad: I did a few adjustments like shorten to "sig" and
 * remove wrappers like Instr
 *)

let vof_register =
  function | R v1 -> let v1 = Ocaml.vof_int v1 in Ocaml.VSum (("R", [ v1 ]))
let vof_fregister =
  function | FR v1 -> let v1 = Ocaml.vof_int v1 in Ocaml.VSum (("FR", [ v1 ]))


let vof_global { name = v_name; priv = v_priv; signature = v_signature } =
  let bnds = [] in
  let arg = Ocaml.vof_option Ocaml.vof_int v_signature in
  (* pad: shortened to sig *)
  let bnd = ("sig", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option Ocaml.vof_int v_priv in
  let bnd = ("priv", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_symbol v_name in
  let bnd = ("name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  
let rec vof_arith_operand =
  function
  | Imm v1 -> let v1 = vof_integer v1 in Ocaml.VSum (("Imm", [ v1 ]))
  | Reg v1 -> let v1 = vof_register v1 in Ocaml.VSum (("Reg", [ v1 ]))
  | Shift ((v1, v2, v3)) ->
      let v1 = vof_register v1
      and v2 = vof_shift_reg_op v2
      and v3 = Ocaml.vof_either vof_register Ocaml.vof_int v3
      in Ocaml.VSum (("Shift", [ v1; v2; v3 ]))
and vof_shift_reg_op =
  function
  | Sh_logic_left -> Ocaml.VSum (("Sh_logic_left", []))
  | Sh_logic_right -> Ocaml.VSum (("Sh_logic_right", []))
  | Sh_arith_right -> Ocaml.VSum (("Sh_arith_right", []))
  | Sh_rotate_right -> Ocaml.VSum (("Sh_rotate_right", []))
  
let rec vof_mov_operand =
  function
  | Imsr v1 -> let v1 = vof_arith_operand v1 in Ocaml.VSum (("Imsr", [ v1 ]))
  | Ximm v1 -> let v1 = vof_ximm v1 in Ocaml.VSum (("Ximm", [ v1 ]))
  | Indirect ((v1, v2)) ->
      let v1 = vof_register v1
      and v2 = vof_offset v2
      in Ocaml.VSum (("Indirect", [ v1; v2 ]))
  | Entity v1 -> 
    let v1 = vof_entity v1 in
    Ocaml.VSum (("Entity", [v1]))

and vof_entity = 
 function
  | Param ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_symbol v1
      and v2 = vof_offset v2
      in Ocaml.VSum (("Param", [ v1; v2 ]))
  | Local ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_symbol v1
      and v2 = vof_offset v2
      in Ocaml.VSum (("Local", [ v1; v2 ]))
  | Global ((v1, v2)) ->
      let v1 = vof_global v1
      and v2 = vof_offset v2
      in Ocaml.VSum (("Global", [ v1; v2 ]))
and vof_ximm =
  function
  | Int v1 ->
      let v1 = Ocaml.vof_int v1 in Ocaml.VSum (("Int", [ v1 ]))
  | Float v1 ->
      let v1 = Ocaml.vof_float v1 in Ocaml.VSum (("Float", [ v1 ]))
  | String v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("String", [ v1 ]))
  | Address v1 -> let v1 = vof_entity v1 in Ocaml.VSum (("Address", [ v1 ]))
  
let rec vof_branch_operand v = Ocaml.vof_ref vof_branch_operand2 v
and vof_branch_operand2 =
  function
  | Relative v1 ->
      let v1 = Ocaml.vof_int v1 in Ocaml.VSum (("Relative", [ v1 ]))
  | LabelUse ((v1, v2)) ->
      let v1 = vof_label v1
      and v2 = vof_offset v2
      in Ocaml.VSum (("LabelUse", [ v1; v2 ]))
  | SymbolJump v1 ->
      let v1 = vof_global v1 in Ocaml.VSum (("SymbolJump", [ v1 ]))
  | Absolute v1 ->
      let v1 = vof_virt_pc v1 in Ocaml.VSum (("Absolute", [ v1 ]))
  | IndirectJump v1 ->
      let v1 = vof_register v1 in Ocaml.VSum (("IndirectJump", [ v1 ]))
  
let rec vof_instr =
  function
  | Arith ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_arith_opcode v1
      and v2 = vof_arith_option v2
      and v3 = vof_arith_operand v3
      and v4 = Ocaml.vof_option vof_register v4
      and v5 = vof_register v5
      in Ocaml.VSum (("Arith", [ v1; v2; v3; v4; v5 ]))
  | ArithF ((v1, v2), v3, v4, v5) ->
      let v1 = vof_arithf_opcode v1 in
      let v2 = vof_floatp_precision v2 in
      let v3 = OCaml.vof_either OCaml.vof_float vof_fregister v3 in
      let v4 = Ocaml.vof_option vof_fregister v4 in
      let v5 = vof_fregister v5 in 
      Ocaml.VSum (("ArithF", [ v1; v2; v3; v4; v5 ]))
  | MOVE ((v1, v2, v3, v4)) ->
      let v1 = vof_move_size v1
      and v2 = vof_move_option v2
      and v3 = vof_mov_operand v3
      and v4 = vof_mov_operand v4
      in Ocaml.VSum (("MOVE", [ v1; v2; v3; v4 ]))
  | SWAP ((v1, v2, v3, v4)) ->
      let v1 = vof_move_size v1
      and v2 = vof_register v2
      and v3 = vof_register v3
      and v4 = Ocaml.vof_option vof_register v4
      in Ocaml.VSum (("SWAP", [ v1; v2; v3; v4 ]))
  | B v1 -> let v1 = vof_branch_operand v1 in Ocaml.VSum (("B", [ v1 ]))
  | BL v1 -> let v1 = vof_branch_operand v1 in Ocaml.VSum (("BL", [ v1 ]))
  | Cmp ((v1, v2, v3)) ->
      let v1 = vof_cmp_opcode v1
      and v2 = vof_arith_operand v2
      and v3 = vof_register v3
      in Ocaml.VSum (("Cmp", [ v1; v2; v3 ]))
  | CmpF ((v1, v2, v3)) ->
      let v1 = vof_floatp_precision v1
      and v2 = vof_fregister v2
      and v3 = vof_fregister v3
      in Ocaml.VSum (("CmpF", [ v1; v2; v3 ]))
  | Bxx ((v1, v2)) ->
      let v1 = vof_condition v1
      and v2 = vof_branch_operand v2
      in Ocaml.VSum (("Bxx", [ v1; v2 ]))
  | SWI v1 -> let v1 = Ocaml.vof_int v1 in Ocaml.VSum (("SWI", [ v1 ]))
  | RFE -> Ocaml.VSum (("RFE", []))
and vof_arithf_opcode = function
  | ADD_ -> Ocaml.VSum (("ADD", []))
  | SUB_ -> Ocaml.VSum (("SUB", []))
  | MUL_ -> Ocaml.VSum (("MUL", []))
  | DIV_ -> Ocaml.VSum (("DIV", []))
and vof_arith_opcode =
  function
  | AND -> Ocaml.VSum (("AND", []))
  | ORR -> Ocaml.VSum (("ORR", []))
  | EOR -> Ocaml.VSum (("EOR", []))
  | ADD -> Ocaml.VSum (("ADD", []))
  | SUB -> Ocaml.VSum (("SUB", []))
  | MUL -> Ocaml.VSum (("MUL", []))
  | DIV -> Ocaml.VSum (("DIV", []))
  | MOD -> Ocaml.VSum (("MOD", []))
  | SLL -> Ocaml.VSum (("SLL", []))
  | SRL -> Ocaml.VSum (("SRL", []))
  | SRA -> Ocaml.VSum (("SRA", []))
  | BIC -> Ocaml.VSum (("BIC", []))
  | ADC -> Ocaml.VSum (("ADC", []))
  | SBC -> Ocaml.VSum (("SBC", []))
  | RSB -> Ocaml.VSum (("RSB", []))
  | RSC -> Ocaml.VSum (("RSC", []))
  | MOV -> Ocaml.VSum (("MOV", []))
  | MVN -> Ocaml.VSum (("MVN", []))
and vof_arith_option v = Ocaml.vof_option vof_arith_cond v
and vof_arith_cond =
  function | Set_condition -> Ocaml.VSum (("Set_condition", []))
and vof_floatp_precision =
  function
  | F -> Ocaml.VSum (("F", []))
  | D -> Ocaml.VSum (("D", []))
and vof_cmp_opcode =
  function
  | CMP -> Ocaml.VSum (("CMP", []))
  | TST -> Ocaml.VSum (("TST", []))
  | TEQ -> Ocaml.VSum (("TEQ", []))
  | CMN -> Ocaml.VSum (("CMN", []))
and vof_condition =
  function
  | EQ -> Ocaml.VSum (("EQ", []))
  | NE -> Ocaml.VSum (("NE", []))
  | GT v1 -> let v1 = vof_sign v1 in Ocaml.VSum (("GT", [ v1 ]))
  | LT v1 -> let v1 = vof_sign v1 in Ocaml.VSum (("LT", [ v1 ]))
  | GE v1 -> let v1 = vof_sign v1 in Ocaml.VSum (("GE", [ v1 ]))
  | LE v1 -> let v1 = vof_sign v1 in Ocaml.VSum (("LE", [ v1 ]))
  | MI -> Ocaml.VSum (("MI", []))
  | PL -> Ocaml.VSum (("PL", []))
  | VS -> Ocaml.VSum (("VS", []))
  | VC -> Ocaml.VSum (("VC", []))
  | AL -> Ocaml.VSum (("AL", []))
  | NV -> Ocaml.VSum (("NV", []))
and vof_move_size =
  function
  | Word -> Ocaml.VSum (("Word", []))
  | HalfWord v1 -> let v1 = vof_sign v1 in Ocaml.VSum (("HalfWord", [ v1 ]))
  | Byte v1 -> let v1 = vof_sign v1 in Ocaml.VSum (("Byte", [ v1 ]))
and vof_sign =
  function
  | S -> Ocaml.VSum (("Signed", []))
  | U -> Ocaml.VSum (("Unsigned", []))
and vof_move_option v = Ocaml.vof_option vof_move_cond v
and vof_move_cond =
  function
  | WriteAddressBase -> Ocaml.VSum (("WriteAddressBase", []))
  | PostOffsetWrite -> Ocaml.VSum (("PostOffsetWrite", []))


let rec vof_pseudo_instr =
  function
  | TEXT ((v1, v2, v3)) ->
      let v1 = vof_global v1
      and v2 = vof_attributes v2
      and v3 = Ocaml.vof_int v3
      in Ocaml.VSum (("TEXT", [ v1; v2; v3 ]))
  | GLOBL ((v1, v2, v3)) ->
      let v1 = vof_global v1
      and v2 = vof_attributes v2
      and v3 = Ocaml.vof_int v3
      in Ocaml.VSum (("GLOBL", [ v1; v2; v3 ]))
  | DATA ((v1, v2, v3, v4)) ->
      let v1 = vof_global v1
      and v2 = vof_offset v2
      and v3 = Ocaml.vof_int v3
      and v4 = vof_ximm v4
      in Ocaml.VSum (("DATA", [ v1; v2; v3; v4 ]))
  | WORD v1 -> let v1 = vof_ximm v1 in Ocaml.VSum (("WORD", [ v1 ]))
and vof_virtual_instr =
  function
  | RET -> Ocaml.VSum (("RET", []))
  | NOP -> Ocaml.VSum (("NOP", []))

and vof_attributes { dupok = v_dupok; prof = v_prof } =
  let bnds = [] in
  let arg = Ocaml.vof_bool v_prof in
  let bnd = ("prof", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_bool v_dupok in
  let bnd = ("dupok", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let vof_line =
  function
  | Pseudo v1 ->
      let v1 = vof_pseudo_instr v1 in Ocaml.VSum (("Pseudo", [ v1 ]))
  | Virtual v1 ->
      let v1 = vof_virtual_instr v1 in Ocaml.VSum (("Virtual", [ v1 ]))
  | Instr ((v1, v2)) ->
      let v1 = vof_instr v1
      and v2 = vof_condition v2
      in
      (* pad: Ocaml.VSum (("Instr", [ v1; v2 ])) *)
      Ocaml.VTuple (([ v1; v2 ]))
  | LabelDef v1 -> let v1 = vof_label v1 in Ocaml.VSum (("LabelDef", [ v1 ]))
  
let vof_program (v, _locs) =
  Ocaml.vof_list
    (fun (v1, v2) ->
       let v1 = vof_line v1 and v2 = vof_pos v2 in Ocaml.VTuple [ v1; v2 ])
    v
