# -*- org -*-

* Big plan

** big plan
# get mk/rc working, release mk and rc on OPAM? SEMI LPized version of it
# and then efuns -> ogit -> lex/yacc and far later finish 5a/5c/5l, and capabilities
# testbed! and make it work in plan9

** LATER

* Last

* Ported (partially working)

** rc in ocaml

*** Last

**** RELAX use CapConsole for Bad|Help in rc and also for pprompt!! tedious
to pass down?
can be nice though

mk should also use CapConsole!

**** RELAX try use curtok in closure around lexfunc

**** implement Env.Updenv
putenv! what fails if you don't implement this when using mk/rc?

**** use RCMAIN env var to set path to rcmain in addition to -m
so can get rid of /rc/lib/rcmain on my linux machine

**** implement isatty detection
so can get prompt even without using rc -i

copy paste ANSITerminal.isatty and move to CapConsole.ml (and UConsole.ml before?)

**** add e2e regression tests for tests/rc/*.rc
just evaluate and check output? can handle echo? special builtin
for echo?

**** use Chan.i for lexbuf+file so have both together ?
but lexbuf != in_channel :(

*** fix rc so it can work on the xix source and replace plan9port rc

*** export environment variables
only when change? needed in practice?
write test infra and test case before fixing

*** consolidate different rc versions
https://github.com/Homebrew/homebrew-core/blob/1ebef261e5b820b6d00f219c90a7e7c2362aa8a1/Formula/r/rc.rb

*** ----------------------------

*** subshell

*** implement all rcmain?
function definition

*** => can run 95% of what I need?
well, not really, cos miss arrow for history, and TAB for completion.

*** implicit caret insertion (lastword global)

*** ------------------------------- 

*** less: isatty auto detection interactive
right now have to use -i explicitely

*** signals stuff!
and signal debugging! pr2 when something happens related to signals

*** less: why wrong status when do  ls | foo
why not |1 
?
still pb?

*** less: look if cover all error messages in lexer and parser

*** less: other lexing tricks
$foo(...) SUB
lastdol? for caret insertion?

** mk in ocaml

*** Last

**** RELAX no need for Cap.stdout when running mk? use CapConsole more!

**** RELAX look at mk/*.mli and try to improve things, use Fpath.t, use more caps

**** infinite loop detection and limits

all: hello_linux_amd64
%: %.s
   6a -c $prereq
   6l $stem.6 -o $target

*** quiet mode, and maybe buffer output and a very synthetic
DONE xxx.pdf :)
luisa will be happy :)

mk -quiet
mk -verbose

update: was a very old feature luisa wanted me to do because she was scared
 about me looking at all those scrolling mk lines when compiling plan9
 but in 2025 I've actually added -quiet and -verbose for Logs but this time
 I can probably use -quiet! just need use Logs.app for a few calls
 to display the command run and if I use -quiet I will not see them!
 easy!

*** test: add test for mk/rc that check -e works correctly and error
in nested mk abort the whole thing when inside a rc for loop in enclosing
mkfile

*** ----------------------------

*** LATER: add tests for 'mk', run in GHA
# note that if we use mk to build xix, that's also good tests 

.merlin:QV:
	echo '# -*- sh -*-' > .merlin
	echo '# Auto-generated by make .merlin' >> .merlin
	for (i in $SUBDIRS) { echo S $i >> .merlin || exit 1 }
	for (i in $SUBDIRS) { echo B $i >> .merlin || exit 1 }

*** mk divergence
if an HFILES does not exist, then mk-in-ocaml does not say anything
but original (rightfully) complain about 'dont know how to make xxx.h'

*** mk: don't know how to make 'screen.h' in /Users/pad/github/fork-plan9/sys/src/9/pc
=> improve error! at least say where this screen.h come from

*** pb infinite mk when have rules like
%: %.cmo (see windows/tests/)

*** warn when use prereqs instead of prereq?
could detect also by use of undefined variable in command?
or edit distance with builtin?

*** seems slow in plan9-ml/kernel
use -trace, nothing abnormal?
add a -profile?

*** substitution variables
so can remove CMI in plan9-ml/kernel/
update: but I added support for subst variables already no?

*** mk-ocaml: 'default' is already up-to-date ->
'mk' (<- default <- "") is already up to date)

*** infinite rule detection or restriction
so mk does not loop forever on mk-infinite

*** see PB_WITH_MKDEBUG also for dependencies
wrong. mk depend does not solve the issue.

** ocamllex
opportunity to have a debug mode where better see the lexer
 and parser actions and what's going on!

*** 'as' feature
hmm maybe not if complexify too much the code
maybe not worth it as we need to make a literate program for CompilerGenerators.nw 

*** ----------------------------

*** ocamllex: read dragon book, confusing 'pos'
firstpos, followpos, etc

do different algo first?

*** ocamllex: understand followpos and the whole algorithm

*** ocamllex: eof handled correctly in Lexing.ml??
port old lexing.ml? Lexing.of_string should append '\000'

*** later: ocamllex: understand fully compaction
it's an optimisation

*** later: ocamllex: understand lex running, lex_engine
it's an optimisation

** ocamlyacc

*** try ocamllex and ocamlyacc bootstrap? :)
need lalr? conflicts?

*** try ocamllex and ocamlyacc on tiger?

*** ----------------------------

*** LATER: opportunity to add EBNF to yacc!
hmm but then can't use regular ocamlyacc so maybe not

** git in ocaml 
(start from dulwich? ocaml-git?), so self sustaining, can use it
 to communicate with github! can use it to do stuff under plan9 itself!

*** less: compile with ocaml-light ogit? missing features? missing libraries?


*** ----------------------------

*** port zip so can skip camlzip from Leroy 
and simplify soft archi (no extern C lib dependencies)

**** basic unzip that bytes -> bytes?
simpler code? using IO.ml is complicated?

**** deflate_data() and call as you need
need to duplicate what was done for unzip.ml
z.zneeded

understand window? why double size of sliding window? (64K instead of 32K)

**** try naive zip? 
generate format with uncompressed (Flat) blocks!
still need generate right bits and bytes!
can assert unzip (zip s) = s

**** try using lz77 and fixed huffman? works? 
generate good format?

**** look code of libflate?
incorporate some opti from there?

**** less: get rid of camlzip at this point?
or nice to keep to compare

**** less: incorporate decompress pure zlib implem?
less important maybe, because can still use libflate
when port my git to plan9!
or even use my own simplified non-compressed simply marshalled
format for gitfiles.

**** try do same for jpeg?
there was a nice paper or literate paper about jpeg, a pearl maybe

*** EASY support --author for cmd_commit.ml

*** timezone inference in cmd_commit.ml

*** look at packing code, start implement pack.ml

**** port code from dulwich and ocamlgit?

*** git merge

**** merge trees! 
easy cases version where do not require diff3

**** merge files

**** fix conflict and do the merge
MERGE_HEADS?

**** look how done in C version (dulwich did not have merge)

*** ------------------------------

*** less: look code of gat, gitlet, cmtcontrol, etc.

*** less: write refs atomically
bugfix where No_more_input when commit with set_new_if_same_old
after second commit in new repo

*** less: git status --short

*** less: git log <path>
useful, so need filter when walk_history on diff (so need
do tree_changes)

*** less: read tags

** rio in ocaml
Now that I understand better the ocaml thread implementation, I can port 
rio to ocaml and test it under qemu-system-386 (or even qemu-system-arm?)

Test with plan9port? with drawterm? 9wm? possible?

*** ----------------------------

*** EASY implement readdir, so can ls /dev

*** EASY /mnt/wsys/label
need hide window to test if works and make special app writing on 
/mnt/wsys/label (test_graph_app2?)

*** up/down keys? or automatic scroll?
in any case, need to move origin

*** finish delete window, delete timeout proc, winclosechan
and exitchan and deletechan

**** remove window once child has finished

*** how to handle when process die?
non blocking waitpid! ThreadUnix has one!

*** less: get the refcount right to windows, wclose, winclosechan

*** -------------------------------------------------

*** implement stuff in section{Window borders click}

*** move
backend part done when I did the hide/unhide

*** resize
backend part done when I did the hide/unhide

*** /mnt/wsys/cursor
can put with virtual_mouse.ml

*** later: /mnt/wsys/resize? 
instead of abusing /dev/mouse?


*** improve terminal

**** less: ^D
delete_runes too, but different cursor

**** less: wrong tab 8 vs ?
see when type 'lc'
actually, how lc knows width of window? read /dev/window?

**** less: copy stuff from Efuns? simplify the code?
action should just move cursor and the rest should follow
and be updated automatically
hmm actually no, can have cursor at the end but still origin high
(so no need less)

sentinel to simplify code for EOF?

*** bugfix: when I quit rio-ocaml, terminal is weird
need atexit  draw shutdown? kernel does not do it?
rio-c seems to not have this pb
same when I run hellorio-ocaml outside rio and I quit it.

because of raw mode on /dev/consctl probably!

*** still? bugfix: display chars on screen for hellorio? why?
because did not reassign stdout? but why echo because
asked raw mode?

still? hellorio-ocaml or hellorio-c?

*** less: bugfix: weird crash and debug trace output after reassigned stderr
in processes_winshell.ml 

less because I fixed it by calling correctly openfile (but still it would
be nice to not crash ...)

"double sleep" kernel error
I got it fixed by not using dup2, but dup2 should work! we should
not be able to crash the kernel

it was when I was duping something that I closed and not reopened?
(I forgot the perm argument to openfile, so I was doing something wrong
and not reopening)

  Unix1.close Unix1.stdin;
  let fd = Unix1.openfile "/dev/cons" [Unix1.O_RDONLY] 0o666 in
  if fd <> Unix1.stdin
  then failwith "could not reassign stdin";

  Unix1.close Unix1.stdout;
  let fd = Unix1.openfile "/dev/cons" [Unix1.O_WRONLY] 0o666 in
  if fd <> Unix1.stdout
  then failwith "could not reassign stdout";
  
  (* todo: Unix1.dup2 Unix1.stdout Unix1.stderr; 
   * this creates a kernel crash! 'double sleep' error.
  *)
 (*
  Unix1.close Unix1.stderr;
  let _ = Unix1.openfile "/dev/cons" [Unix1.O_WRONLY] 0o666 in
 *)  


*** bugfix: it selects immediately the first entry, why?
QEMU issue with mouse? because does not happen after

*** less: complex channels for cpid 
needed if pb when mount and bind, but then
internal pb no?
how to handle when pb in child process when mount, bind,
this is why need cpid? how do that with ocaml model of threads and fork?
How communicate information?

*** less: sanitize integer values with a constructor like the one for Int32.xx
so can check if overflow

*** less: cornercursor
need return pos in sweep? then need pass pos to callback? more functional?
more tedious?
alt: store mouse state in mousectl

*** less: port preemptive feature of threads library to plan9?
replace setitimer by equivalent under plan9?
maybe also use APE so can use select and so can use threadUnix.ml.

use APE alarm? but then granularity is second. Ok? Anyway
rio should need only cooperative scheduling?

actually might be bad. Maybe better to be fully cooperative,
otherwise may need some mutex at a few places (e.g. for
atomic access to the queue)

** 5c in ocaml
5c -w -I/arm/include -I/sys/include

*** ----------------------------

*** branch 5c_todo for test files to commit
now only in my macbook air repo? in IN_SURFACE_BOOK2/prev_github

*** -depend
to generate .depend! better than plan9!

*** useless-include detector! finally :)
alexandrescu would be proud

*** precise codegraph using 5c frontend! finally!

*** support ## in macro (as in ocaml/.../memory.h)
so can use recent ocaml macros

*** --------------------

*** void vs non void
void (*hook_ioalloc)(void);
vs
void (*hook_ioalloc)();

one is old style proto without argument checking

*** unreachable code analysis

*** typecheck rio!
allow redundant typedefs?
(just warn)


*** ---------------------------------

*** test 5c-ocaml on plan9/buiders/mk
need modify bio.h to remove anon field though.
pb in regexp.h then
anon union subelement

*** support anon subelements?
clang seems to have some support for it


*** dereference pointer and assign
reglcgen 
see pointer.c

*** what can generate an INDREG? since anyway can not
generate OREGISTER so easily.
look opportunities in mov_operand() converter

*** deadheads?

*** EASY handle strings, at least OSTRING

*** -------------------------------------------------- 

*** x = y = z  parsed as?
result of x = y  is still an lvalue??
add comment in Compiler.nw

*** EASY put back pragma code?
put it next to relevant section? e.g., format checking?

*** EASY assembly pretty printer from ast_asm5.ml

*** typedef and tcopy??
write test case
why need that?? forbid cases mentioned (typedef to incomplete array)

*** -------------------------------------------------- 

*** valid break/continue
in check.ml? during unreachable analysis?

*** unreachable code?
aspectize code to manage canreach, oldreach, warnreach, etc.

deadheads?
and supgen?
nbreak, ncontinue

*** unused result op check

*** const checking
should be easy

*** -------------------------------------------------- 

*** add casts, finish port arith()
or just adjust return types as said in Compiler.nw

*** do FIGURE so can brain dump what I learned (otherwise
next time will have to redo that again)

also try to find/add a -dump_ast option so can put FIGURE
with just AST and then show the dump.

**** how store in symbol table nested things when backtrack?
nested struct defs? field point to which thing in the symbol table?
Because return newly allocated type for struct, that is filled later.
Because dont really use symbol table to store permanently things!
Copy to node the information, or fill later. Symbol table used
really just for scope.

*** replace string messages with constructor, so
localize error reporting in one place, and avoid noise in code

*** HARD bugfix error location on archive.c
compare with regular 5c
maybe explain the code in Compiler.nw so good basis to port in ocaml.

need to take pen and paper! I never get it right.
look at (correct) original code to report error in 5c

*** fix shift/reduce conflict? still 6
original had 3?

** 5l in ocaml

** 5a in ocaml

*** ----------------------------

*** give better error message on quote.s and accept '\''

** libcore

*** LATER: add semgrep-libs/libs/process_limits/
other stuff to copy from semgrep-libs/?
maybe Unix.realpath!


*** Last

**** RELAX Proc.pid, but need to make it compatible with ocaml-light then!
remove use of labels and default arg in Proc.ml

**** RELAX port part of Cmd.ml and add also the exec part in it, but
with capabilities only! and then add in
CapUnix and CapSys should use Cmd

Cmd.exec? Cmd.run?
imitate some of Bos API? or too complex IMHO.


*** merge commons/ and commons2/? 

*** can have more recent obj.ml?
replace all stdlib.cma by my own?
=> can use ocamltarzan for dumping kernel stuff?

*** LATER: try to compile with -nopervasives or -nostdlib
and rely only on stuff in lib_core/

*** use camomile for unicode?
or extlib/utf8.ml good enough?

or uchar.ml enough?

* Infra

** Capabilities

*** RELAX use Cap.exit in compiler/Error.errorexit
but will need to thread it from many files?

*** less: get rid of IO.ml from canasse and do my own capability based file IO!
but used heavily in version_control/

*** less: integrate back TCB.ml? and UXxx.ml ? works with ocaml-light?
try to add TCB.ml and -open TCB?
can it compile with ocaml-light though? 
if use -open TCB in dune, the mkfile and ocaml-light should be fine

**** less: add (-open TCB) in a few dune files?

**** need backport ocamlc -open, for TCB

** Bench infra

*** RELAX try profiling ppx, report diagnostics with -profile! for mk and rc
need to compile it also for ocaml-light, mkfile and boostrap-mk.sh

** Build infra

*** fix mk warnings on xix whole project compilation
(now that they are more visible)

*** less: fix shift/reduce conflicts? from which parser? mk? rc? 5c?

** Dev infra

*** try to use ocamlformat?
but exclude lex/ yacc/ lib_parsing/ version_control/ for now
because of our use of syncweb there?

but need OCaml 4.04.1 at least

but then can messup possible diffs with older version?
make sure everything works fine before?

*** setup pre-commit and ocamlformat and trailing space fix?
but syncweb issue

* Partially ported

** lib_system

*** port mkfile to mkfile-ocaml for lib_system/plan9
pb when try build .a because need mk-C extension for libs.

** draw in ocaml?

*** EASY add .mli in lib_graphics/geometry

*** EASY add .mli in lib_graphics/draw


*** use camlidl? or implement low-level stuff that writes
into /dev/draw/x/ directly?

***  client/server with simple marshalling protocol?
type msg = Draw of ... | Line of ... | Alloc of ...

*** memdraw in ocaml
do no need kernel to have memdraw or memlayer. Can be used entirely
in userspace

can port memdraw first and can even test under qemu thx to 9 in ocaml
DONE can also port draw first and test for rio. 2 independent halves.

**** continue go through Graphics.nw; add %ocaml

** Kernel in ocaml
So can do draw and then rio in ocaml? How?
Need full understanding of ocamlrun before I think. Will need still to
have part in C to setup for ocamlrun. How to deal with stdlib for ocamlrun?
Need to forbid most functions in pervasives.mli. Have a -nopervasives and then 
another specific pervasives.mli ?

need to understand C code in ocaml to check whether I could use
ocaml to do the plan9 kernel in ocaml!

Gain deeper understanding of ocamlrun and its GC! And also of FFI.
Gain also far deeper understanding of 9 in C.

panic("pc = %lux, link = %lux", &sys_get_argv, getcallerpc(&unit));

*** for the kernel in ocaml, use https://github.com/mirage/ocaml-freestanding ?

*** LATER: try compile xix kernel with kencc
old?
export ROOT=`pwd`
export objtype=386
ocamlrun ./bootstrap/mk depend
ocamlrun ./bootstrap/mk


*** ----------------------------------

*** alarmkproc

*** hz_checkalarms

*** read sleep.ps and subtle condition for rendez vous

*** continue user_addr, phys_addr'fication


*** test Thread.thread_delay
my gettimeofday is working?

*** connect mutex to tas or spinlock?
Threads.critical_section := true?

*** ocaml threads and processes

**** archi?

Maybe disable interrupt at each instruction boundaries and
also when enter Gc. Then reenable and look if
interrupt in the mean time (just like look if signal in the mean time)
and then dispatch interrupt upper-half handler.
Bottom-half interrupt just set a global flag.

use Thread.t and scheduler.c from otherlibs/threads/ ?
but use interrupt instead of signal for timer and
and use splhi before reseting the pending_signal.
Also use Mutex.lock? or just imitate Mutex.lock in my
Qlock?

**** new thread for process, how? in newproc, sysrfork, but how?
just have s cheding and then Critical_section:=true; wakeup schedinit; sleep
and schedinit when up is s cheding can just ready it too, like
for Running

**** modify scheduler it to have reference to process Ureg?

**** find archi design for preempt when not in kernel mode
thread RFE? how get back thread to execute on behalf of proc?
execute back thread closure? thread clos should be either
syscall handler or fault handler?

*** first user process

**** try first user process, manual text, data, bss, initcode
SWI

**** try sysnop! and maybe a syssleep in 2 processes that print A, B!
syscall is a different kind of signal

**** syscall interface:
2 strings pointers, 2 ints, one for arg in, one for arg out,
and ints for size of those buffers
then marshal in/out both.
(and do same later for 9p?)

**** try start main.ml calling init functions?

*** finalize
take care of TODOs in Byterun/!! Bcm/ Port/
take care to update mem.h to agree with memory.ml lower limits

*** less: remove coproc.c? write 2 functions needed in asm?

*** rendez vous type and sleep hook
also modif relevant section in Kernel.nw
understand how locking and rendez vous works?

*** env_.ml
and adjust sysrfork

*** namespace_.ml ? (complicated probably)
and adjust sysrfork

*** EASY rwlock.ml

*** EASY nspinlocks in ocaml

*** EASY ilockdepth in ocaml

*** EASY okaddr

*** EASY vmemchr (user_memory.ml)

*** less: mk depend for C code? use 5c-ocaml to generate .depend?
less important because we should not modify much C code. Most of the
modifs are on ocaml code and mk depend works for that

*** look other OS or programs

**** look how done in Rust? Maybe give ideas on how to separate
code between ocaml and C and asm.
https://os.phil-opp.com/handling-exceptions.html

**** less: look redox kernel?
look paper about RUST and kernel programming

**** how map low-level structures?
mirage?
cstruct? can reuse portable part of cstruct? need bigarray then also!
need port back bigarray to ocaml 1.07

**** look other kernels to get some good ideas?
mezzano OS?
stuff embedding scheme interpreter I saw recently, femtolisp?
minoca OS?
redox?

** xv6 in ocaml for ARM?
Can learn another way to write an OS. 
Can contrast some of the design decisions in plan9 and also compare 
the choice of variable names (e.g., xv6 also use a cpu and up), but it seems
xv6 is quite similar to 9 (ken thompson wrote both in some sense so normal)

*** how xv6_rpi_port handle the keyboard?
seems it does not handle it ... it uses UART?

* To port

** EASY tree in ocaml
http://blog.shaynefletcher.org/2017/10/how-to-render-trees-like-unix-tree.html
plan9-ml/utilities/misc/tree.ml

copy paste walk_dir? or move in lib_system? or Common.Sys_ ?

** lib_gui/ in ocaml?
#step towards better mmm?

*** basic line drawing, basic porting of draw to use Graphics of OCaml

*** better Vector type? separate from Point?
same for Size? meh.

*** basic label

** Tiger backend for ARM :)
maybe good to transition to book on 5c?
but then need 5i in ocaml

*** resume, compile, still works? make sync?

*** understand Tiger.nw, add explanations? more LP split? more aspectize?

*** generate assembly file from .tig? need extra phase?
register allocation? read Appel?

*** port gc?

*** generate assembly via ast_asm5.ml directly?
Once I have 5l in ocaml! which can codegen!!! and
run on 5i!! woohoo! will have 8 queens in Tiger running!

Can even generate directly Asm5 using OCaml constructor and ast_asm5.ml!
Safer than generating strings (similar to 5c in the end).

** 5i in ocaml

so can try to run things directly on my mac (but need 5c-ocaml before
 to get interesting program to test on). Also can be used by Tiger-ARM!

* Old

** Mysterious entries

*** less: merge use_diff_bytes now that fixed many issues with working mk toplevel

*** EASY factorize a few things with bit vs little endian stuff
so factorize code in protocol_9P and linker exec generation
and a_out header generation.

need genio.ml in commons2/ then, so need remove keyword arg
stuff first?

*** factorize little/big endian and generation of int
in a module? then reference cstruct and mstruct.
Why need bigarray? simple API on top of string (now called
bytes in recent ocaml) not enough?

** Send patches?

*** send patch to github for esthetic changes in ocaml :)
remove useless file I spotted

*** send patch to github for dulwich?

*** less: report bug on simple-diff
see diff.ml for example of problematic input
