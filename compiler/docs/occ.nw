\documentclass[12pt]{report}

\input{latex/Packages}
\input{latex/Config}
\input{latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - Typecheck.typed_program intermediate type, frontend()/backend()

%thx to this manual, I better understand 5c/compiler:

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 C Compiler [[5c]]
}\\
ARM (32 bits) edition\\
OCaml edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Ken Thompson and Yoann Padioleau
}


\maketitle 

\hrule
\begin{quote}
Copyright \copyright{} 2025 Yoann Padioleau \\
Permission is granted to copy, distribute and/or modify this document,
except all the source code it contains, under the terms of the GNU Free
Documentation License, Version 1.3.
\end{quote}
\hrule

\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup

%******************************************************************************
\chapter{Introduction}
%******************************************************************************

#include "Intro.nw"

\section{Code organization}

\section{Software architecture}

%data flow:
% tokens -> AST -> Typed AST + env -> ASM -> serialized object file

\section{Book structure}

%###############################################################################

%******************************************************************************
\chapter{Core Data Structures}
%******************************************************************************

%toc: tokens -> AST -> Typed AST + env -> ASM -> serialized object file
% so essentially same than data flow picture

\section{Tokens}

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Constants and identifiers *)*/
/*(*-----------------------------------------*)*/
%token <Ast.loc * string * Type.integer_type> TIConst
%token <Ast.loc * string * Type.float_type> TFConst
%token <Ast.loc * string * Type.t> TString
%token <Ast.loc * string> TName TTypeName
@
% yacc tokens, see \book{CompilerGenerator}

% Ast.loc next section
% Type.xxx_type also soon

% string now int or float because delay evaluation
% (also tricky because OCaml ints are not as a big as in C)

% TName vs TTypeName! subtle and problematic! C not context-free!
% need global to remember context

% TString Type.t because Array of char or Array of unicode

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Keywords *)*/
/*(*-----------------------------------------*)*/
%token <Ast.loc> Tvoid  Tchar Tshort Tint Tlong  Tdouble Tfloat  
%token <Ast.loc> Tsigned Tunsigned
%token <Ast.loc> Tstruct Tunion Tenum
%token <Ast.loc> Ttypedef
%token <Ast.loc> Tconst Tvolatile  Trestrict Tinline
%token <Ast.loc> Tauto Tstatic Textern Tregister
%token <Ast.loc> Tif Telse  Twhile Tdo  Tfor  Tbreak Tcontinue  Treturn Tgoto
%token <Ast.loc> Tswitch Tcase Tdefault
%token <Ast.loc> Tsizeof
@

% classic: types, qualifiers, storage, stmts, and one expr keyword

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Operators *)*/
/*(*-----------------------------------------*)*/
%token <Ast.loc> TPlus TMinus  TMul TDiv TMod
%token <Ast.loc> TEq TEqEq TBang TBangEq
%token <Ast.loc> TAnd TOr TXor TAndAnd TOrOr
%token <Ast.loc> TTilde
%token <Ast.loc> TPlusPlus TMinusMinus
%token <Ast.loc> TInf TSup  TInfEq TSupEq
%token <Ast.loc> TInfInf TSupSup
%token <Ast.loc * Ast.arithOp> TOpEq
@

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Punctuation *)*/
/*(*-----------------------------------------*)*/
%token <Ast.loc> TOPar TCPar  TOBrace TCBrace TOBra TCBra
%token <Ast.loc> TComma TSemicolon 
%token <Ast.loc> TArrow TDot TQuestion TColon
@

<<Parser tokens>>=
/*(*-----------------------------------------*)*/
/*(*2 Misc *)*/
/*(*-----------------------------------------*)*/
%token TSharp
%token EOF
@
% TSharp special for cpp preprocessor, see \ref{chap:preprocessing}

%ex: show list of tokens for simple helloc.c!
% -dump_tokens and ref to appendix



\section{Abstract syntax tree} %%: [[Node]]


\subsection{Location}

<<type [[Ast.loc]]>>=
(* global linenumber after preprocessing *)
type loc = Location_cpp.loc
@
% See chapter{chap:preprocessing} again.
% =~ int for line number

\subsection{Names and namespaces}
%alt: and scopes

<<type [[Ast.name]]>>=
type name = string
@

<<type [[Ast.blockid]]>>=
(* for scope *)
type blockid = int (* same than Type_.blockid, repeated here for clarity *)
@

<<type [[Ast.fullname]]>>=
(* A fully resolved and scoped name. 
 *
 * 5c: uses a reference to a symbol in a symbol table to fully qualify a name.
 * Instead, I use a unique blockid and an external hash or environment that
 * maps this fullname to the appropriate information.
 * I think it offers a better separation of concerns.
 * 
 * 'name' below can be a gensym'ed name for anonymous struct/union/enum.
 *)
type fullname = name * blockid (* same than Type_.fullname *)
@

<<type [[Ast.idkind]]>>=
(* Used in Globals.ml/Lexer.mll/Parser.mly to recognize typedef identifiers.
 * alt: could be moved in a separate Naming.ml, but not worth it for just two types.
 *)
type idkind =
  | IdIdent
  | IdTypedef
  | IdEnumConstant
@

<<global [[Globals.hids]]>>=
(* to recognize typedefs in the lexer *)
let hids: (string, Ast.idkind) Hashtbl.t = 
  Hashtbl.create 101
@
\label{sec:typedef-trick-part0}
% see section{sec:typedef-trick-part1}


<<type [[Ast.tagkind]]>>=
(* to manage the scope of tags *)
type tagkind =
  | TagStruct
  | TagUnion
  | TagEnum
@
% TagEnum is different from EnumConstant! it's to allow 'enum xx'
% as types (but nobody uses that? or enum tag considered a typedef alias?)

\subsection{Types}

<<type [[Ast.typ]]>>=
(* What are the differences between typ below and Type.t? 
 * - typedef expansion is not done here
 * - constant expressions are not resolved yet 
 *  (those expressions can involve enum constants which will be resolved later).
 * Again, I think it offers a better separation of concerns.
 * 
 * Note that 'type_' and 'expr' are mutually recursive (because of const_expr).
 * todo: qualifier type
 *)
type typ = {
  t: type_bis;
  t_loc: loc;
}
@

<<type [[Ast.type_bis]]>>=
  and type_bis = 
  | TBase of Type.t (* only the basic stuff *)
  | TPointer of typ
  | TArray of const_expr option * typ
  | TFunction of function_type

  (* no StructDef here; they are lifted up; just StructName *)
  | TStructName of Type.struct_kind * fullname
  (* In C an enum is really like an int. However, we could do
   * extended checks at some point to do more strict type checking! 
   *)
  | TEnumName of fullname
  | TTypeName of fullname
@
% Type.t later
% function_type later

<<type [[Type.struct_kind]]>>=
 and struct_kind = Struct | Union
@

<<function [[Ast.tagkind_of_su]]>>=
let tagkind_of_su = function
  | Type.Struct -> TagStruct
  | Type.Union -> TagUnion
@

\subsection{Expressions}

<<type [[Ast.expr]]>>=
and expr = { 
  e: expr_bis;
  e_loc: loc;
  <<[[Ast.expr]] other fields>>
}
@

<<type [[Ast.expr_bis]]>>=
  and expr_bis = 
  (* Note that characters are transformed in Int at parsing time; no need Char *)
  | Int of string * Type.integer_type
  | Float of string * Type.float_type
  (* codegen: converted to Id after typechecking *)
  | String of string * Type.t (* always array of chars for now, no unicode *)

  (* Global, local, parameter, enum constant (can be scoped), function.
   * Not that the storage, type, usage of ids is computed later and stored
   * in external hashtbl.
   * codegen: Id converted to Int when the fullname refers to a enum constant 
   *)
  | Id of fullname

  | Call of expr * argument list

  (* should be a statement really *)
  | Assign of assignOp * expr * expr

  (* codegen: converted to pointer arithmetic, *(x+y) *)
  | ArrayAccess of expr * expr (* x[y] *)
  (* codegen: converted to pointer offset access *)
  | RecordAccess of expr * name (* x.y *)
  (* codegen: converted to RecordAccess, ( *x ).y *)
  | RecordPtAccess of expr * name (* x->y,  and not x.y!! *)

  (* less: bool (* explicit cast (xcast) *) *)
  | Cast of typ * expr

  | Postfix of expr * fixOp
  | Prefix of fixOp * expr
  (* contains GetRef and Deref!! pointers!  *)
  | Unary of unaryOp * expr
  | Binary of expr * binaryOp * expr

  | CondExpr of expr * expr * expr
  (* 'x, y', but really should be a statement, and could be removed.
   * I think mostly used in 'for(...;...;...)' 
   *)
  | Sequence of expr * expr

  (* codegen: converted to Int *)
  | SizeOf of (expr, typ) Either_.t

  <<[[Ast.expr]] initialiser cases>>
  <<[[Ast.expr]] extension cases>>
@

<<type [[Ast.argument]]>>=
and argument = expr
@

<<type [[Ast.const_expr]]>>=
(* Because we call the preprocessor first, the remaining cases
 * where const_expr is not a constant are basic arithmetic expressions
 * like 2 < < 3, or enum constants.
 *)
and const_expr = expr
@

<<type [[Ast.unaryOp]]>>=
  and unaryOp  = 
    (* less: could be lifted up; those are really important operators *)
    | GetRef | DeRef 
    (* codegen: converted to binary operation with 0 (-x => 0-x) *)
    | UnPlus |  UnMinus 
    (* codegen: converted to -1 ^ x *)
    | Tilde 
    | Not 
@

<<type [[Ast.assignOp]]>>=
  and assignOp = Eq_ | OpAssign of arithOp
@

<<type [[Ast.fixOp]]>>=
  and fixOp    = Dec | Inc
@

<<type [[Ast.binaryOp]]>>=
  and binaryOp = Arith of arithOp | Logical of logicalOp
@

<<type [[Ast.arithOp]]>>=
       and arithOp   = 
         | Plus | Minus 
         | Mul | Div | Mod
         | ShiftLeft | ShiftRight 
         | And | Or | Xor
@

<<type [[Ast.logicalOp]]>>=
       and logicalOp = 
         | Inf | Sup | InfEq | SupEq 
         | Eq | NotEq 
         | AndLog | OrLog
@

\subsection{Statements}

<<type [[Ast.stmt]]>>=
type stmt = {
  s: stmt_bis;
  s_loc: loc;
}
@
% no need for type field here, stmt have no type (well it's 'unit' really)

<<type [[Ast.stmt_bis]]>>=
  and stmt_bis = 
  | ExprSt of expr
  (* empty statement is simply Block [] *)
  | Block of stmt list

  (* else is optional and represented as an empty Block *)
  | If of expr * stmt * stmt

  (* expr must have an integer type; it can not be a pointer like in a If *)
  | Switch of expr * case_list

  | While of expr * stmt
  | DoWhile of stmt * expr
  | For of (expr option, var_decl list) Either_.t * 
           expr option * 
           expr option * 
           stmt

  | Return of expr option
  (* no argument to continue or break as in PHP *)
  | Continue | Break

  (* labels have a function scope, so no need to use 'fullname' here *)
  | Label of name * stmt
  | Goto of name

  (* should occur only in Switch *)
  | Case of expr * stmt
  | Default of stmt

  | Var of var_decl
@

<<type [[Ast.case_list]]>>=
(* Can we have a specific case type? It is hard in C because they mix labels
 * and 'case' a lot (see the code in the lexer of 5c).
 *)
and case_list = stmt
@


\subsection{Declarations and definitions}

<<type [[Ast.toplevel]]>>=
type toplevel =
  | StructDef of struct_def
  | TypeDef of type_def
  | EnumDef of enum_def
  (* globals, but also extern decls and prototypes *)
  | VarDecl of var_decl
  | FuncDef of func_def
@

<<type [[Ast.toplevels]]>>=
type toplevels = toplevel list
@

<<type [[Ast.program]]>>=
type program = toplevels * Location_cpp.location_history list
@

%ex: show AST for simple helloc.c!
% -dump_ast and ref to appendix

\subsubsection{Variables}

<<type [[Ast.var_decl]]>>=
and var_decl = {
  v_name: fullname;
  v_loc: loc;
  v_storage: Storage.t option;
  v_type: typ;
  v_init: initialiser option;
}
@

<<type [[Ast.initialiser]]>>=
 (* can have ArrayInit and RecordInit here in addition to other expr *)
 and initialiser = expr
@

<<[[Ast.expr]] initialiser cases>>=
(* should appear only in a variable initializer, or after GccConstructor *)
| ArrayInit of (const_expr option * expr) list
| RecordInit of (name * expr) list
@

<<[[Ast.expr]] extension cases>>=
(* gccext: kenccext: *)
| GccConstructor  of typ * expr (* always an ArrayInit (or RecordInit?) *)
@
%TODO: move in Advanced topics?

\subsubsection{Functions}

<<type [[Ast.func_def]]>>=
type func_def = {
  (* functions have a global scope; no need for fullname here *)
  f_name: name;
  f_loc: loc;
  (* everything except Param or Auto *)
  f_storage: Storage.t option;
  f_type: function_type;
  (* always a Block *)
  f_body: stmt;
}
@

<<type [[Ast.function_type]]>>=
 and function_type = (typ * (parameter list * bool (* var args '...' *)))
@
% saw already in Ast.type_bis

<<type [[Ast.parameter]]>>=
  and parameter = {
    (* When part of a prototype, the name is not always mentionned, hence
     * the option below.
     * 
     * I use 'fullname' here for consistency; parameters are treated like,
     * locals, so we can have below simply 'Id of fullname' and have 
     * no differences between accessing a local or a parameter.
     *)
    p_name: fullname option;
    p_loc: loc;

    p_type: typ;
  }
@


\subsubsection{Structures and unions}

<<type [[Ast.struct_def]]>>=
(* struct and union *)
type struct_def = {
  su_name: fullname;
  su_loc: loc;
  su_kind: Type.struct_kind;
  (* todo: bitfield annotation *)
  su_flds: field_def list;
}
@

<<type [[Ast.field_def]]>>=
  (* Not the same than var_decl; fields have no storage and can have bitflds.*)
  and field_def = { 
   (* kenccext: anonymous structure element get an artificial field name
    * (see is_gensymed()) 
    *)
    fld_name: name;
    fld_loc: loc;
    fld_type: typ;
  }
@

\subsubsection{Enumerations}

<<type [[Ast.enum_def]]>>=
type enum_def = { 
  (* this name is rarely used; C programmers rarely write 'enum Foo x;' *)
  enum_name: fullname;
  enum_loc: loc;
  enum_constants: enum_constant list;
}
@

<<type [[Ast.enum_constant]]>>=
  and enum_constant = {
  (* we also need to use 'fullname' for constants, to scope them *)
    ecst_name: fullname;
    ecst_loc: loc;
    ecst_value: const_expr option;
  }
@

\subsubsection{Type aliases}

<<type [[Ast.type_def]]>>=
type type_def = { 
  typedef_name: fullname;
  typedef_loc: loc;
  typedef_type: typ;
}
[@@deriving show { with_path = false } ]
@

%ex: of typedef.c and see dumped AST



\section{Type system}

%trans: seen AST of a type, but then here different. Type system.
% ex of difference: const_expr are resolved! it's Array of int option below
% not const_expr

<<type [[Type.t]]>>=
(* The C type system.
 *
 * There is no Typedef below. The typechecker expands typedefs. 
 * There is no Enum either because variables using enum 
 * (as in 'enum Foo x;') gets their type expanded to an integer type.
 *
 * less: put qualifier here?
 * todoext: Bool! with strict bool checking. 
 * todoext: Enum of fullname with stricter checking.
 *)
type t =
  (* basic types *)
  | Void
  | I of integer_type
  | F of float_type

  (* composite types *)
  | Pointer of t
  (* Why not unsugar Array to Pointer? Because the type system checks 
   * for some array incompatibilities. int[2] != int[3].
   * However, the Array type usually gets converted to Pointer
   * during typechecking (see array_to_pointer())
   *)
  | Array of int option * t
  | Func of t * t list * bool (* varargs '...' *)
  | StructName of struct_kind * fullname
@

<<[[Ast.expr]] other fields>>=
(* properly set during typechecking in typecheck.ml *)
e_type: Type.t;
@
% not typ here! Type.t!
% also not mutable! Typecheck return a new AST

<<type [[Type.integer_type]]>>=
  and integer_type = integer_kind * sign
@

<<type [[Type.integer_kind]]>>=
    and integer_kind = 
    | Char
    | Short
    | Int
    | Long
    | VLong
@

<<type [[Type.sign]]>>=
    and sign = Signed | Unsigned
@

<<type [[Type.float_type]]>>=
  and float_type = 
  | Float
  | Double
@


<<type [[Type.qualifier]]>>=
type qualifier = 
  | Volatile
  | Const
  (* less: unsupported: | Restrict | Inline *)
@
%TODO: not used for now

% a few useful shortcuts

<<constant [[Type.int]]>>=
let int = I (Int, Signed)
@

<<constant [[Type.long]]>>=
let long = I (Long, Signed)
@
% int vs long! subtle! but on 64 bits arch long is actually 64 bits!
% so in goken they actually did lots of s/long/int32 to fix it
% because the previous assumption that long was 32 bits was now wrong.

<<type [[Type.blockid]]>>=
type blockid = int
@
<<type [[Type.fullname]]>>=
type fullname = string * blockid
@

\section{Storage class}%[[Storage_class]]

<<type [[Storage.t]]>>=
(* No Typedef here, because a typedef is not a storage! *) 
type t =
  | Local  (* local (a.k.a., Auto) *)
  | Param  (* parameter *)

  | Extern (* public global defined elsewhere *)
  | Global (* public global defined here *)
  | Static (* Private global less: could rename Private *)

  (* less:  | Inline? | Register? | ExternRegister? *)
@
% typedef in the grammar is put with extern/static/volatile but ugly
% and abuse

%%\section{Node and type attributes}

%%\section{[[Sym]]bols and [[hash]] table}
%%\subsection{[[Sym]]}
%%\subsection{[[hash]]}
%%\subsection{[[slookup()]] and [[lookup()]]}
%%\subsection{Identifier symbols}
%%\subsection{Tag symbols}
%%\subsection{Other symbols}
%%\section{Declarations, namespaces, and scope}%%: [[Decl]]

\section{Frontend result: typed program}


<<type [[Typecheck.typed_program]]>>=
type typed_program = {
  (* resolved type and storage information for identifiers and tags *)
  ids: (Ast.fullname, idinfo) Hashtbl_.t;

  (* resolved struct definitions *)
  structs: (Ast.fullname, Type.struct_kind * Type.structdef) Hashtbl_.t;

  (* functions annotated with types for each expression nodes
   * (so you can more easily generate code later).
   * 
   * The enum constants should also be internally resolved and replaced
   * with constants and some constant expressions (e.g., for
   * array size) should also be resolved (and evaluated).
   *)
  funcs: Ast.func_def list;
}
@
%ex: of simple program and dump of typed_program? deriving show?
%  use Hashtblt_.t with my own deriving!
% -dump_typed_ast

<<type [[Typecheck.idinfo]]>>=
type idinfo = {
    typ: Type.t;
    sto: Storage.t;
    loc: Location_cpp.loc;
    (* typed initialisers (fake expression for function definitions) *)
    ini: Ast.initialiser option;
  }
@
%TODO: also used for tags?? like said in ids; field comment? true?

<<type [[Type.structdef]]>>=
(* Note that the field can be gensym'ed for anonymous struct/union elements.
 * Note also structdef is not part of Type.t above; structdef is used
 * instead in Typecheck.typed_program
 * todo: bitfield
 *)
type structdef = (string * t) list
@



\section{Backend result: assembly instructions}

% see Ast_Asm.ml and Ast_asm5.ml in \book{Assembler} (and also \book{Linker}).


%******************************************************************************
\chapter{Main functions}
%******************************************************************************
\label{chap:main}

%trans:
%toc:

\section{[[main()]]}

% first, the entry point, actually not main, in OCaml any toplevel
% definition is evaluated at runtime, var def, constant def, or func def
% here let _ var we don't care about name, we only care about effect
% of its evaluation

<<toplevel [[Main._1]]>>=
let _ = 
  Cap.main (fun (caps : Cap.all_caps) ->
     let argv = CapSys.argv caps in
     Exit.exit caps (Exit.catch (fun () ->
         CLI.main caps argv))
  )
@

<<signature [[CLI.main]]>>=
(* entry point (can also raise Exit.ExitCode) *)
val main: <caps; ..> ->
  string array -> Exit.t
@

<<type [[CLI.caps]]>>=
(* Need:
 * - open_in: for argv derived file but also for #include'd files
 *   because 5c does its own preprocessing
 * - open_out for -o object file or 5.argv[0]
 * - env: for INCLUDE (for cpp)
 *)
type caps = < Cap.open_in; Cap.open_out; Cap.env >
@


\subsection{[[main()]] skeleton}
% skeleton main

<<function [[CLI.main]]>>=
let main (caps : <caps; ..>) (argv : string array) : Exit.t =
  <<[[CLI.main()]] set [[arch]] and [[thechar]]>>
  let usage = spf "usage: %s [-options] file.c" argv.(0) in

  (* in *)
  let args = ref [] in
  (* out *)
  let outfile = ref "" in

  <<[[CLI.main()]] macroprocessor locals>>
  <<[[CLI.main()]] other locals>>

  let options = [
    <<[[CLI.main()]] [[options]] elements>>
  ] |> Arg.align
  in
  <<[[CLI.main()]] parse [[argv]] and set [[args]] and flags>>
  <<[[CLI.main()]] logging setup>>
  (* less: process the old style -Dname=val and -Idir attached *)
  <<[[CLI.main()]] [[action]] management>>

  try 
    <<[[CLI.main()]] matching [[args]] and [[outfile]]>>
  with exn ->
    if Sys.file_exists !outfile
    then begin 
       Logs.info (fun m -> m "removing %s because of error" !outfile);
       FS.remove caps (Fpath.v !outfile);
    end;
    <<[[CLI.main()]] when [[exn]]>>
@


<<[[CLI.main()]] [[options]] elements>>=
"-o", Arg.Set_string outfile,
" <file> place output (an object) in file";
@

%ex: o5c foo.c -o foo.o =>
%  file is foo.c, outfile is foo.o

\subsection{Main code path}

<<[[CLI.main()]] main code path with [[cfile]] and [[outfile]]>>=
let outfile : Fpath.t = 
  <<[[CLI.main()]] main code path, define [[outfile]]>>
in
        
<<[[CLI.main()]] main code path, define macropreprocessor [[conf]]>>
outfile |> FS.with_open_out caps (fun chan ->
  compile caps conf arch (Fpath.v cfile) chan
);
@

<<signature [[CLI.compile]]>>=
(* main algorithm; works by side effect on outfile *)
val compile: < Cap.open_in; .. > ->
  Preprocessor.conf -> Arch.t -> Fpath.t (* infile *) -> Chan.o (* outfile *) ->
  unit
@
% conf will see in \ref{chap:preprocessing}

<<[[CLI.main()]] set [[arch]] and [[thechar]]>>=
let arch : Arch.t = 
  match Filename.basename argv.(0) with
  | "o5c" -> Arch.Arm
  | "ovc" -> Arch.Mips
  | s -> failwith (spf "arch could not detected from argv0 %s" s)
in

let thechar = Arch.thechar arch in
let thestring = Arch.thestring arch in
@


<<[[CLI.main()]] main code path, define [[outfile]]>>=
let base = Filename.basename cfile in
(if outstr = ""
then begin
  let res = 
    if base =~ "\\(.*\\)\\.c"
    then Regexp_.matched1 base ^ (spf ".o%c" thechar)
    else base ^ (spf ".o%c" thechar)
  in
  outfile := res;
  res
end
else outstr
) |> Fpath.v
@


\subsection{Arguments processing}

<<[[CLI.main()]] parse [[argv]] and set [[args]] and flags>>=
(try
  Arg.parse_argv argv options (fun t -> 
    args := t::!args
  ) usage;
with
| Arg.Bad msg -> UConsole.eprint msg; raise (Exit.ExitCode 2)
| Arg.Help msg -> UConsole.print msg; raise (Exit.ExitCode 0)
);
@

<<[[CLI.main()]] matching [[args]] and [[outfile]]>>=
(match !args, !outfile with
| [], "" -> 
    Arg.usage options usage;
    Exit.Code 1
| [cfile], outstr ->
    <<[[CLI.main()]] main code path with [[cfile]] and [[outfile]]>>
    Exit.OK
| _ -> 
  (* stricter: *)
    failwith 
      "compiling multiple files at the same time is not supported; use mk"
)
@


\subsection{Error management}

<<[[CLI.main()]] when [[exn]]>>=
<<[[CLI.main()]] when [[exn]] if [[backtrace]]>>
else 
  <<[[CLI.main()]] match [[exn]]>>
@
% see ref{chap:error-management}

<<[[CLI.main()]] match [[exn]]>>=
(match exn with
| Failure s -> 
    (* useful to indicate that error comes from 5c? *)
    Error.errorexit (spf "%cc: %s" thechar s)

<<[[CLI.main()]] match [[exn]] other cases>>

| _ -> raise exn
)
@

<<[[CLI.main()]] match [[exn]] other cases>>=
| Location_cpp.Error (s, loc) ->
    (* less: could use final_loc_and_includers_of_loc loc *)
    let (file, line) = Location_cpp.final_loc_of_loc loc in
    Error.errorexit (spf "%s:%d %s" !!file line s)
(* ocaml-light: | Check.Error err | Typecheck.Error err | ...  *)
| Check.Error err -> Error.errorexit (Check.string_of_error err)
| Typecheck.Error err -> Error.errorexit (Check.string_of_error err)
| Eval_const.Error err -> Error.errorexit (Check.string_of_error err)
| Codegen5.Error err -> Error.errorexit (Check.string_of_error err)
@

% we will see those Xxx.Error exn gradually. See also
% \ref{chap:error-management}

\section{[[compile()]]}


<<function [[CLI.compile]]>>=
let compile (caps : < Cap.open_in; ..>) (conf : Preprocessor.conf) (arch : Arch.t)
    (infile : Fpath.t) (outfile : Chan.o) :
    unit =
  let tast : Typecheck.typed_program = frontend caps conf infile in
  let asm_prog : 'a Ast_asm.program = backend arch tast in
  Object_file.save arch asm_prog outfile
@

<<function [[CLI.compile5]]>>=
@

\section{[[frontend()]]}


<<function [[CLI.frontend]]>>=
let frontend (caps : < Cap.open_in; .. >) (conf : Preprocessor.conf)
     (infile : Fpath.t) :
    Typecheck.typed_program =

  let ast = Parse.parse caps conf infile in
  <<[[CLI.frontend()]] if [[dump_ast]]>>

  (* use/def checking, unused entity, redefinitions, etc. *)
  Check.check_program ast;
  (* typedef expansion, type and storage resolution, etc. *)
  let typed_program : Typecheck.typed_program = 
    Typecheck.check_and_annotate_program ast 
  in
  <<[[CLI.frontend()]] if [[dump_typed_ast]]>>
  typed_program
@

\section{[[backend()]]}

<<function [[CLI.backend5]]>>=
let backend (arch : Arch.t) (tast : Typecheck.typed_program) :
    'a Ast_asm.program =

  (* todo: Rewrite.rewrite *)
  match arch with
  | Arch.Arm -> 
    let (asm, _locs) = Codegen5.codegen tast in
    <<[[CLI.backend5()]] if [[dump_asm]]>>
  | _ -> 
     failwith (spf "TODO: arch not supported yet: %s" (Arch.thestring arch))
  
@

<<signature [[Codegen5.codegen]]>>=
(* can raise Error *)
val codegen: 
  Typecheck.typed_program ->  Ast_asm5.program
@

%%\section{[[gclean()]]}

%%\section{Initializations}
%%\subsection{[[tinit()]]}
%%\subsection{[[cinit()]]}
%%\subsection{[[ginit()]]}
%%\subsection{[[arginit()]]}

%******************************************************************************
%%\chapter{Input}
%******************************************************************************
%%\section{Files management: [[iostack]]}
%%\section{Buffer management: [[fi]]}
%%\section{[[GETC()]]}

%******************************************************************************
%alt:\chapter{Frontend}
%******************************************************************************

%******************************************************************************
\chapter{Lexing}
%******************************************************************************
\label{chap:lexing}


\section{Overview}

<<Lexer.mll>>=
{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Regexp_.Operators

open Parser
module A = Ast
module L = Location_cpp
module T = Type

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Limitations compared to 5c:
 *  - no L"" and L'' unicode strings or unicode characters
 *  - no \x hexadecimal escape sequence in strings or characters
 *  - no unicode identifier
 *  - no typestr
 *    (seems dead extension anyway)
 *  - no signof
 * 
 * todo: handle big numbers here? or let later phases do that?
 *  check for overflow, truncation, sign-extended character constant, etc
 *  see yyerror and warn in Compiler.nw
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<Lexer helpers>>
}

(*****************************************************************************)
(* Regexps aliases *)
(*****************************************************************************)
<<constant [[Lexer.space]]>>
<<constant [[Lexer.letter]]>>
<<constant [[Lexer.digit]]>>
<<constant [[Lexer.oct]]>>
<<constant [[Lexer.hex]]>>

(*****************************************************************************)
(* Main rule *)
(*****************************************************************************)
<<rule [[Lexer.token]]>>

(*****************************************************************************)
(* String rule *)
(*****************************************************************************)
<<rule [[Lexer.string]]>>

(*****************************************************************************)
(* Character rule *)
(*****************************************************************************)
<<rule [[Lexer.char]]>>

(*****************************************************************************)
(* Comment rule *)
(*****************************************************************************)
(* dup: lexer_asm5.mll *)
<<rule [[Lexer.comment]]>>
@

%%\section{[[yylex()]]}
%%\section{Peek, seek, and look ahead}


<<rule [[Lexer.token]]>>=
rule token = parse
  (* ----------------------------------------------------------------------- *)
  (* Spacing/comments *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] space/comment cases>>

  (* ----------------------------------------------------------------------- *)
  (* Symbols *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] symbol cases>>

  (* ----------------------------------------------------------------------- *)
  (* Numbers *)
  (* ----------------------------------------------------------------------- *)
  (* dup: lexer_asm5.mll *)
  <<[[Lexer.token]] number cases>>

  (* ----------------------------------------------------------------------- *)
  (* Chars/Strings *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] chars/strings cases>>

  (* ----------------------------------------------------------------------- *)
  (* Keywords and identifiers *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] keywords/identifiers cases>>

  (* ----------------------------------------------------------------------- *)
  (* CPP *)
  (* ----------------------------------------------------------------------- *)
  <<[[Lexer.token]] cpp cases>>

  (* ----------------------------------------------------------------------- *)
  | eof { EOF }
  | _ (*as c*)   { let c = char_ lexbuf in
                   error (spf "unrecognized character: '%c'" c) }
@

<<function [[Lexer.error]]>>=
let error s =
  raise (L.Error (spf "Lexical error: %s" s, !L.line))
@

<<function [[Lexer.loc]]>>=
let loc () = !L.line
@
% see \ref{sec:preprocessing-line}

<<function [[Lexer.char_]]>>=
(* needed only because of ocamllex limitations in ocaml-light
 * which does not support the 'as' feature.
 *)
let char_ lexbuf =
  let s = Lexing.lexeme lexbuf in
  String.get s 0
@



<<[[Lexer.token]] cpp cases>>=
(* See ../macroprocessor/lexer_cpp.mll *)
| "#" { TSharp }
@
% see \ref{sec:preprocessing-sharp}




\section{Comments and spaces}

<<constant [[Lexer.space]]>>=
let space = [' ''\t']
@

<<[[Lexer.token]] space/comment cases>>=
| space+        { token lexbuf }
@

<<[[Lexer.token]] space/comment cases>>=
| "//" [^'\n']* { token lexbuf }
| "/*"          { comment lexbuf }
@

<<rule [[Lexer.comment]]>>=
and comment = parse
  | "*/"          { token lexbuf }
  | [^ '*' '\n']+ { comment lexbuf }
  | '*'           { comment lexbuf }
  | '\n'          { incr Location_cpp.line; comment lexbuf }
  | eof           { error "eof in comment" }
@

<<[[Lexer.token]] space/comment cases>>=
| '\n'          { incr Location_cpp.line; token lexbuf }
@


\section{Keywords and identifiers}

<<constant [[Lexer.letter]]>>=
let letter = ['a'-'z''A'-'Z']
@
<<constant [[Lexer.digit]]>>=
let digit = ['0'-'9']
@

<<[[Lexer.token]] keywords/identifiers cases>>=
| (letter | '_') (letter | digit | '_')* {
    let s = Lexing.lexeme lexbuf in

    match s with
    | "static" -> Tstatic (loc()) 
    | "extern" -> Textern (loc())
    (* we could forbid those constructs; they are not really useful *)
    | "auto" -> Tauto (loc()) 
    | "register" -> Tregister (loc())

    | "const" -> Tconst (loc()) | "volatile" -> Tvolatile (loc())
    | "inline" -> Tinline (loc()) | "restrict" -> Trestrict (loc())

    | "void" -> Tvoid (loc())
    | "char" -> Tchar (loc()) | "short" -> Tshort (loc()) 
    | "int"  -> Tint  (loc()) | "long"  -> Tlong  (loc())
    | "float"  -> Tfloat  (loc()) | "double"   -> Tdouble   (loc())

    | "signed" -> Tsigned (loc()) | "unsigned" -> Tunsigned (loc())

    | "struct" -> Tstruct (loc()) | "union" -> Tunion (loc()) 
    | "enum" -> Tenum (loc())
    | "typedef" -> Ttypedef (loc())

    | "if" -> Tif (loc()) | "else" -> Telse (loc())
    | "while" -> Twhile (loc()) | "do" -> Tdo (loc()) | "for" -> Tfor (loc())
    | "break" -> Tbreak (loc()) | "continue" -> Tcontinue (loc())
    | "switch" -> Tswitch (loc()) 
    | "case" -> Tcase (loc()) | "default" -> Tdefault (loc())
    | "return" -> Treturn (loc()) | "goto" -> Tgoto (loc())

    | "sizeof" -> Tsizeof (loc())
    (* less: USED/SET here? or manage via symbol table *)

    | _ ->
      <<[[Lexer.token()]] in identifier case, typedef trick>>
      else TName (loc(), s)
}
@

\subsection{Unicode identifiers}

%TOPORT

\subsection{Typedef trick, part 1}
\label{sec:typedef-trick-part1}

<<[[Lexer.token()]] in identifier case, typedef trick>>=
if Hashtbl.mem Globals.hids s
then 
  (* typedef trick, because ambiguity in C grammar *)
  (match Hashtbl.find Globals.hids s with
  | A.IdIdent | A.IdEnumConstant -> TName (loc(), s)
  | A.IdTypedef -> TTypeName (loc(), s)
  )
@

%ex: void main() { foo foo; } => foo?

\section{Operators}

<<[[Lexer.token]] symbol cases>>=
| "+" { TPlus (loc()) } | "-" { TMinus (loc()) }
| "*" { TMul  (loc()) } | "/" { TDiv   (loc()) } | "%" { TMod (loc()) }

| "&"  { TAnd  (loc()) }  | "|"  { TOr     (loc()) } | "^" { TXor (loc()) }
| "<<" { TInfInf (* TLsh *) (loc()) } | ">>" { TSupSup (* TRsh *) (loc()) }
| "~"  { TTilde  (loc()) }

| "&&" { TAndAnd (loc()) } | "||" { TOrOr (loc()) }
| "!"  { TBang   (loc()) }

| "++" { TPlusPlus (loc()) } | "--" { TMinusMinus (loc()) }

| "="  { TEq   (loc()) }
| "==" { TEqEq (loc()) }  | "!=" { TBangEq (loc()) }

| "+=" { TOpEq (loc(), A.Plus) } | "-=" { TOpEq (loc(), A.Minus) }
| "*=" { TOpEq (loc(), A.Mul) }  | "/=" { TOpEq (loc(), A.Div) }
| "%=" { TOpEq (loc(), A.Mod) }
| "&=" { TOpEq (loc(), A.And) }        | "|="  { TOpEq (loc(), A.Or) }
| "^=" { TOpEq (loc(), A.Xor) }
| ">>="{ TOpEq (loc(), A.ShiftRight) } | "<<=" { TOpEq (loc(), A.ShiftLeft) }

| "<"  { TInf   (loc()) } | ">"  { TSup   (loc()) }
| "<=" { TInfEq (loc()) } | ">=" { TSupEq (loc()) }
@

\section{Punctuations}
%new:

<<[[Lexer.token]] symbol cases>>=
| "(" { TOPar   (loc()) } | ")" { TCPar   (loc()) }
| "{" { TOBrace (loc()) } | "}" { TCBrace (loc()) }
| "[" { TOBra   (loc()) } | "]" { TCBra   (loc()) }
           
| ","  { TComma (loc()) } | ";"  { TSemicolon (loc()) }
| "->" { TArrow (loc()) }
| "."  { TDot   (loc()) }
| "?"  { TQuestion (loc()) }
| ":"  { TColon    (loc()) }
@

\section{Numbers}

<<[[Lexer.token]] number cases>>=
<<[[Lexer.token]] octal case>>
<<[[Lexer.token]] hexadecimal case>>
| "0x" { error "malformed hex constant" }

<<[[Lexer.token]] decimal case>>

<<[[Lexer.token]] float case>>
(* special regexp for better error message *)
| (digit+ | digit* '.' digit+) ['e''E'] ('+' | '-')?
   { error "malformed fp constant exponent" }
@


\subsection{Decimals}

<<[[Lexer.token]] decimal case>>=
| (['0'-'9'] digit*) (*as s*) (['U''u']? (*as unsigned*)) (['L''l']* (*as long*))
    { let (s, unsigned, long) = 
         let s = Lexing.lexeme lexbuf in
         s =~ "\\([0-9]+\\)\\([Uu]?\\)\\([Ll]*\\)" |> ignore;
         Regexp_.matched3 s
      in
      TIConst (loc(), s, inttype_of_suffix unsigned long)}
@

%%\subsection{[[convvtox()]]}

\subsection{Octals and hexadecimals}

<<constant [[Lexer.oct]]>>=
let oct = ['0'-'7']
@

<<[[Lexer.token]] octal case>>=
| "0"  (oct+ (*as s*)) (['U''u']? (*as unsigned*)) (['L''l']* (*as long*))
    { let (s, unsigned, long) = 
         let s = Lexing.lexeme lexbuf in
         s =~ "0\\([0-7]+\\)\\([Uu]?\\)\\([Ll]*\\)" |> ignore;
         Regexp_.matched3 s
      in
      TIConst(loc(), "0o" ^ s, inttype_of_suffix unsigned long)}
@

<<constant [[Lexer.hex]]>>=
let hex = (digit | ['A'-'F''a'-'f'])
@

<<[[Lexer.token]] hexadecimal case>>=
| "0x" (hex+ (*as s*))  (['U''u']? (*as unsigned*)) (['L''l']* (*as long*))
    { let (s, unsigned, long) = 
         let s = Lexing.lexeme lexbuf in
         s =~ "0x\\([0-9A-Fa-f]+\\)\\([Uu]?\\)\\([Ll]*\\)" |> ignore;
         Regexp_.matched3 s
      in
      TIConst(loc(), "0x" ^ s, inttype_of_suffix unsigned long)}
@


\subsection{Unsigned and long numbers}

<<function [[Lexer.inttype_of_suffix]]>>=
let inttype_of_suffix sign size =
  let sign =
    match String.lowercase_ascii sign with
      | "" -> T.Signed
      | "u" -> T.Unsigned
      | s -> error (spf "Impossible: wrong sign suffix: %s" s)
  in
  match String.lowercase_ascii size with
  | "" -> T.Int, sign
  | "l" -> T.Long, sign
  | "ll" -> T.VLong, sign
  | s -> error (spf "Impossible: wrong int size suffix: %s" s)
@

\subsection{Floats}

<<[[Lexer.token]] float case>>=
(* stricter: I impose some digit+ after '.' and after 'e' *)
| ((digit+ | digit* '.' digit+) (['e''E'] ('+' | '-')? digit+)?) (*as s*)
    (['F''f']* (*as float*))
   { let (s, float) =
        let s = Lexing.lexeme lexbuf in
        s =~ "\\([^Ff]+\\)\\([Ff]*\\)$" |> ignore;
        Regexp_.matched2 s
      in
      TFConst (loc(), s, floattype_of_suffix float) }
@

<<function [[Lexer.floattype_of_suffix]]>>=
let floattype_of_suffix s =
  match String.lowercase_ascii s with
  | "" -> T.Double
  | "f" -> T.Float
  | s -> error (spf "Impossible: wrong float size suffix: %s" s)
@

\section{Characters}

<<[[Lexer.token]] chars/strings cases>>=
(* converting characters in integers *)
| "'" { TIConst (loc(), spf "%d" (char lexbuf), (T.Char, T.Signed)) }
@
% TIConst! chars are converted to integers with T.Char type

<<rule [[Lexer.char]]>>=
and char = parse
  | "''"                            { Char.code '\'' }
  (* less: 5c allows up to 8 octal number when in L'' mode *)
  | "\\" ((oct oct? oct?) (*as s*)) "'" 
      { let s = Lexing.lexeme lexbuf |>
           String_.drop_prefix 1 |> String_.drop_suffix 1
        in
        int_of_string ("0o" ^ s) }
  | "\\" (['a'-'z' '\\' '\''] (*as c*)) "'"       
      { let c = String.get (Lexing.lexeme lexbuf) 1 in
        code_of_escape_char c }
  | '\\' '\n' { char lexbuf }
  | [^ '\\' '\'' '\n'] (*as c*)  "'"    
      { let c = String.get (Lexing.lexeme lexbuf) 0 in
        Char.code c }
  | '\n' { error "newline in character" }
  | eof  { error "end of file in character" }
  | _    { error "missing '" }
@


\subsection{Escaping characters}

<<function [[Lexer.code_of_escape_char]]>>=
let code_of_escape_char c =
  match c with
  | 'n' -> Char.code '\n' | 'r' -> Char.code '\r' 
  | 't' -> Char.code '\t' | 'b' -> Char.code '\b' 

  (* compatibility with plan 9 C code? *)
  | 'f' -> Logs.err (fun m -> m "unknown \\f"); 0x00
  (* could be removed, special 5c escape char *)
  | 'a' -> 0x07 | 'v' -> 0x0b 

  | '\\' | '\'' | '"' -> Char.code c 
  (* stricter: we disallow \ with unknown character *)
  | _ -> error "unknown escape sequence"
@

\subsection{Unicode characters}

%TOPORT

\section{Strings}

<<[[Lexer.token]] chars/strings cases>>=
| '"' { TString (loc(), string lexbuf, T.Array (None, T.I (T.Char,T.Signed)))}
@
% Strings are Array of chars

<<rule [[Lexer.string]]>>=
and string = parse
  | '"' { "" }
  | "\\" ((oct oct oct) (*as s*))
      { let s = Lexing.lexeme lexbuf |> String_.drop_prefix 1 in
        let i = int_of_string ("0o" ^ s) in string_of_ascii i ^ string lexbuf }
  | "\\" (['a'-'z' '\\' '"'] (*as c*)) 
      { let c = String.get (Lexing.lexeme lexbuf) 1 in
        let i = code_of_escape_char c in string_of_ascii i ^ string lexbuf  }
  (* strings can contain newline! but they must be escaped before *)
  | '\\' '\n' { "\n" ^ string lexbuf }
  | [^ '\\' '"' '\n']+   
      { let x = Lexing.lexeme lexbuf in x ^ string lexbuf }
  | '\n' { error "newline in string" }
  | eof  { error "end of file in string" }
  | _    { error "undefined character in string" }
@

<<function [[Lexer.string_of_ascii]]>>=
let string_of_ascii i =
  String.make 1 (Char.chr i)
@

\subsection{Unicode strings}

%TOPORT

%******************************************************************************
\chapter{Parsing}
%******************************************************************************
\label{chap:parsing}



\section{Overview}

<<signature [[Parse.parse]]>>=
(* will macropreprocess internally first *)
val parse: 
  < Cap.open_in; .. > -> Preprocessor.conf -> Fpath.t -> Ast.program
@

% but see later in \ref{chap:preprocessing}. For now let's simplify
% and assume no cpp:

<<signature [[Parse.parse_no_cpp]]>>=
(* internals *)
val parse_no_cpp:
  Chan.i -> Ast.program
@

<<function [[Parse.parse_no_cpp]]>>=
let parse_no_cpp (chan : Chan.i) =
  L.line := 1;
  let lexbuf = Lexing.from_channel chan.ic in
  (try 
      Parser.prog Lexer.token lexbuf, []
    with Parsing.Parse_error ->
        failwith (spf "Syntax error: line %d" !L.line)
  )
@

%trans:
% seen Lexer.token before, now Parser.prog


<<Parser.mly>>=
%{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast
module T = Type
module L = Location_cpp

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* The original 5c does many things during parsing; Instead, we 
 * do the minimum here. We just return a very simple AST.
 * 
 * Limitations compared to 5c (and sometimes also to ANSI C or C11):
 *  - no support for old style parameter declaration
 *    (obsolete practice anyway)
 *  - impose a certain order for the storage, qualifier, and type
 *    (everybody follow this convention anyway)
 *  - no implicit single 'signed' means 'signed int'. 
 *    Signed has to have an explicit int-type after.
 *  - sure? forbid definitions (typedefs, struct, enum) not at toplevel
 *    (confusing anyway?)
 *    (but then would no need blockid for those, or just for nested struct def)
 *  - forbid typedefs inside forexpr
 *    (who uses that anyway?)
 *  - can not mix qualified and not qualified elements in initializers lists
 * 
 * todo: 
 *  - add qualifiers in AST
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<Parser helpers>>
%}

/*(*************************************************************************)*/
/*(*1 Tokens *)*/
/*(*************************************************************************)*/
<<Parser tokens>>

/*(*************************************************************************)*/
/*(*1 Priorities *)*/
/*(*************************************************************************)*/
<<Parser tokens priorities>>

/*(*************************************************************************)*/
/*(*1 Rules type declaration *)*/
/*(*************************************************************************)*/
<<Parser type declarations>>
%start prog

%%
<<Parser grammar>>
@

% start prog!!




<<function [[Parser.error]]>>=
let error s =
  raise (L.Error (spf "Syntax error: %s" s, !L.line))
@

\section{Parsing environment and scope management}

<<global [[Parser.block_counter]]>>=
let block_counter : Ast.blockid ref = ref 0
@

<<type [[Parser.env]]>>=
(* To manage scope (used notably to recognize typedefs in the lexer)
 *
 * alt: could have a recursive environment with 'parent: env;' and so
 * we could remove the need for those xxx_scope.
 * we would need then a lookup_id and lookup_tag that would
 * possibly look in the parent field.
 *)
type env = {
  (* there are mainly two namespaces in C: one for ids and one for tags *)
  ids:  (string, idkind * Ast.blockid) Hashtbl.t;
  tags: (string, tagkind * Ast.blockid) Hashtbl.t;

  mutable block: Ast.blockid;

  mutable ids_scope:  (string list) list;
  mutable tags_scope: (string list) list;
  mutable block_scope: Ast.blockid list;
}
@


<<global [[Parser.env]]>>=
let env = {
  ids = Hashtbl_.create ();
  tags = Hashtbl_.create ();
  block = 0;
  
  ids_scope = [];
  tags_scope = [];
  block_scope = [];
}
@
%TODO? use block = !block_counter ? cleaner?

<<function [[Parser.add_id]]>>=
(* Should we warn if 'id' already declared? No, because at the toplevel
 * it is ok to redeclare the same variable or prototype.
 * So better to do those checks in another phase (in Check.ml and Typecheck.ml).
 *)
let add_id env id idkind =
  Hashtbl.add Globals.hids id idkind;

  Hashtbl.add env.ids id (idkind, env.block);
  match env.ids_scope with
  | xs::xss -> env.ids_scope <- (id::xs)::xss
  | [] -> env.ids_scope <- [[id]]
@
% Globals.hids!
\label{sec:typedef-trick-part2}

<<function [[Parser.add_tag]]>>=
let add_tag env tag tagkind =
  Hashtbl.add env.tags tag (tagkind, env.block);
  match env.tags_scope with
  | xs::xss -> env.tags_scope <- (tag::xs)::xss
  | [] -> env.tags_scope <- [[tag]]
@


<<function [[Parser.new_scope]]>>=
let new_scope env =
  incr block_counter;
  env.block <- !block_counter;
  env.block_scope <- env.block :: env.block_scope;
  env.ids_scope <- []::env.ids_scope;
  env.tags_scope <- []::env.tags_scope;
  ()
@

<<function [[Parser.pop_scope]]>>=
let pop_scope env =
  (match env.block_scope, env.ids_scope, env.tags_scope with
  | x::xs, ys::yss, zs::zss -> 
      env.block <- x;
      env.block_scope <- xs;
      ys |> List.iter (fun id ->
        Hashtbl.remove env.ids id;

        Hashtbl.remove Globals.hids id;
      );
      zs |> List.iter (fun tag -> 
        Hashtbl.remove env.tags tag
      );
      env.ids_scope <- yss;
      env.tags_scope <- zss;
  | _ -> raise (Impossible "pop empty declaration stack, grammar wrong")
  )
  (* less: return an optional list of instructions at some point *)
@
% remember Hashtbl.add can handle multiple times same key and remove
% will remove last binding, so perfect for us
\label{sec:typedef-trick-part3}

\section{Lifting nested definitions to the toplevel}

<<global [[Parser.defs]]>>=
(* 'defs' contains things we lift up in the AST (struct defs, enums, typedefs).
 * Note that we tag those defs with a blockid, so there is no escape-scope
 * problem.
 *)
let defs =
  ref []
@

<<function [[Parser.get_and_reset]]>>=
let get_and_reset x =
  let v = !x in
  x := [];
  v
@

\section{Naming anonymous definitions}
\label{sec:gensyn}

<<function [[Parser.gensym]]>>=
(* for anonymous struct/union/enum and structure elements *)
let gensym_counter = ref 0
let gensym () =
  incr gensym_counter;
  spf "|sym%d|" !gensym_counter
@

\section{Grammar overview}


<<Parser grammar>>=
/*(*************************************************************************)*/
/*(*1 Program *)*/
/*(*************************************************************************)*/
<<rule [[Parser.prog]]>>
<<rule [[Parser.prog1]]>>

/*(*************************************************************************)*/
/*(*1 Declarations *)*/
/*(*************************************************************************)*/
/*(*-----------------------------------------*)*/
/*(*2 External declarators *)*/
/*(*-----------------------------------------*)*/
<<rule [[Parser.xdecl]]>>
<<rule [[Parser.xdlist]]>>
<<rule [[Parser.storage_and_type_xdecor]]>>

/*(*-----------------------------------------*)*/
/*(*2 Automatic declarators *)*/
/*(*-----------------------------------------*)*/
<<rule [[Parser.adecl]]>>
<<rule [[Parser.adlist]]>>

/*(*************************************************************************)*/
/*(*1 Statements *)*/
/*(*************************************************************************)*/
<<rule [[Parser.block]]>>
<<other block related rules>>

<<rule [[Parser.stmnt]]>>
<<rule [[Parser.ulstmnt]]>>
<<other stmt related rules>>

/*(*************************************************************************)*/
/*(*1 Expressions *)*/
/*(*************************************************************************)*/
<<rule [[Parser.expr]]>>
<<other expr related rules>>
<<other expr ebnf rules>>

<<rule [[Parser.string]]>>

/*(*************************************************************************)*/
/*(*1 Initializers *)*/
/*(*************************************************************************)*/
<<rule [[Parser.init]]>>
<<other init related rules>>

/*(*************************************************************************)*/
/*(*1 Types *)*/
/*(*************************************************************************)*/
/*(*-----------------------------------------*)*/
/*(*2 Types part 1 (left part of a type) *)*/
/*(*-----------------------------------------*)*/
<<rule [[Parser.type_]]>>
<<rule [[Parser.simple_type]]>>
<<rule [[Parser.complex_type]]>>

<<other struct related rules>>

/*(*-----------------------------------------*)*/
/*(*2 Types part 2 (right part of a type) *)*/
/*(*-----------------------------------------*)*/
<<rule [[Parser.xdecor]]>>
<<other declarator related rules>>

<<rule [[Parser.paramlist]]>>
<<rule [[Parser.zparamlist]]>>

/*(*-----------------------------------------*)*/
/*(* abstract declarators *)*/
/*(*-----------------------------------------*)*/
<<rule [[Parser.abdecor]]>>
<<other abstract declarator related rules>>

/*(*-----------------------------------------*)*/
/*(*3 qualifiers *)*/
/*(*-----------------------------------------*)*/
<<rule [[Parser.qualifier]]>>
<<other qualifier related rules>>

/*(*************************************************************************)*/
/*(*1 Struct/union/enum body *)*/
/*(*************************************************************************)*/
<<rule [[Parser.sbody]]>>
<<other structure body related rules>>

<<rule [[Parser.enum]]>>
<<rule [[Parser.const_expr]]>>

/*(*************************************************************************)*/
/*(*1 Storage, qualifiers *)*/
/*(*************************************************************************)*/
<<rule [[Parser.storage]]>>
<<rule [[Parser.storage_and_type]]>>
@


% do not LP split, order matters!
<<Parser tokens priorities>>=
/*(* must be at the top so that it has the lowest priority *)*/
%nonassoc LOW_PRIORITY_RULE
/*(* see conflicts.txt *)*/
%nonassoc Telse

/*(* in 5c but not in orig_c.mly *)*/
%left   TSemicolon
%left   TComma
%right  TEq TOpEq
%right  TQuestion TColon

/*(* same than in orig_c.mly *)*/
%left   TOrOr
%left   TAndAnd
%left   TOr
%left   TXor
%left   TAnd
%left   TEqEq TBangEq
%left   TInf TSup TInfEq TSupEq
%left   TInfInf TSupSup
%left   TPlus TMinus
%left   TMul TDiv TMod

/*(* in 5c but not in orig_c.mly *)*/
%right  TMinusMinus TPlusPlus TArrow TDot TOBra TOPar
@



<<Parser type declarations>>=
%type <Ast.toplevels> prog
@

<<rule [[Parser.prog]]>>=
prog: prog1 EOF   { $1 }
@
<<rule [[Parser.prog1]]>>=
prog1:
 |  /*(*empty*)*/ { [] }
 | prog1 xdecl    { $1 @ $2 }
@
%new: I introduced prog1 intermediate for EOF needed in prog in OCaml

\section{Declarations and definitions, part one}

% xdecl for "external" decl, for toplevel decl outside func (external?)

<<rule [[Parser.xdecl]]>>=
xdecl:
  <<[[Parser.xdecl]] cases>>
@

\subsection{No-declarator declarations}

<<[[Parser.xdecl]] cases>>=
| storage_and_type        TSemicolon 
    { (* stricter: *)
      if !defs = [] 
      then error "declaration without any identifier";

      get_and_reset defs;
    }
@


\subsection{Declarator-based declarations}

<<[[Parser.xdecl]] cases>>=
| storage_and_type xdlist TSemicolon 
    { (* less: could suggest to separate struct/enum def from vardecl *)
      get_and_reset defs @
      ($2 |> List.map (fun (((id, loc), typ2), v_init) ->
         let (sto_or_typedef, typ1) = $1 in
         let typ = typ2 typ1 in
         (match sto_or_typedef, v_init with
         | Left v_storage, _ -> 
             add_id env id IdIdent;
             VarDecl { v_name = (id, env.block (* 0 *));
                       v_loc = loc; v_type = typ; v_storage; v_init; }
         (* stricter: clang also reports this, but not 5c *)
         | Right (), Some _ ->
             error "initializer with typedef"
         | Right (), None ->
             add_id env id IdTypedef;
             TypeDef { typedef_name = (id, env.block); 
                       typedef_loc = loc; typedef_type = typ; }
         )
       )) 
    }
@

<<rule [[Parser.xdlist]]>>=
xdlist:
 | xdecor          { [$1, None] }
 <<[[Parser.xdlist]] other cases>>
 | xdlist TComma xdlist { $1 @ $3 }
@

\subsection{Entity declarations, the declarator}

% xdecor = identifier for now.

<<rule [[Parser.xdecor]]>>=
/*
(* declarator return a couple: 
 *  (name, partial type (a function to be applied to return type))
 *
 * Note that with 'int* foo(int)' we must return 
 * TFunction(Pointer int, [int]) and not Pointer (Func(int,[int])).
 * The grammar parses the xdecor part  '*foo(int)' as:
 *         *
 *         |
 *         ()
 *       /   \
 *      foo     [ int]
 * 
 * So when we return the partial function for TMul, we must
 * apply first TPointer to the return type 'x', and then apply
 * the function for xdecor.
 * 
 * 
 * 
 * less: handle qualifiers
 *)*/
xdecor:
 | xdecor2                { $1 }
 <<[[Parser.xdecor]] other cases>>
@

<<other declarator related rules>>=
/*(* use 'tag' here too, because you can have 'foo foo;' declarations *)*/
xdecor2:
 | tag                
     { (snd $1, fst $1), (fun x -> x) }
 | TOPar xdecor TCPar 
     { $2 }
 <<[[Parser.xdecor2]] other cases>>
@


<<rule [[Parser.tag]]>>=
tag: 
 | TName     { $1 }
 | TTypeName { $1 }
@
% different namespace than struct/union/enum tags or idents(and types) so
% don't care if already used for ident or type


\subsection{Function definitions}


<<[[Parser.xdecl]] cases>>=
| storage_and_type_xdecor block_no_new_scope
    { let ((id, f_loc), f_type, f_storage) = $1 in
      (* pop_scope from new_scope done in storage_and_type_xdecor *)
      pop_scope env;
      [ FuncDef { f_name = id; f_loc; f_type; f_body = $2; f_storage; } ]
    }
@

% intermerdiate rule so have opportunity to do stuff before entering
% in block_no_new_scope
<<rule [[Parser.storage_and_type_xdecor]]>>=
storage_and_type_xdecor: storage_and_type xdecor
    { (* stricter: *)
      if !defs <> []
      then error "move struct or typedef definition outside the function";

      let ((id, loc), typ2) = $2 in
      let (sto_or_typedef, typ1) = $1 in
      let typ = typ2 typ1 in

      (match typ.t, sto_or_typedef with
      | TFunction (ret, (params, varargs)), Left sto -> 
          (* add in global scope the function name *)
          add_id env id IdIdent;

          (* add in new scope the parameters *)
          new_scope env;
          let params = params |> List.map (fun p ->
            match p.p_name with
            | Some (id, _) -> 
                add_id env id IdIdent;
                { p with p_name = Some (id, env.block) }
            | None -> p
          )
          in
          let ft = (ret, (params, varargs)) in
          ((id, loc), ft, sto)

      (* stricter: *)
      | TFunction _, Right _ ->
          error "a function definition can not be a type definition"
      (* stricter: it could be TTypeName that resolves to a TFunction, but 
       * I resolve typedefs later so I have to forbid it here, and it is
       * confusing anyway as you can not see the parameter.
       *)
      | _, _ -> error "not a function type"
      )
    }
@


<<rule [[Parser.block_no_new_scope]]>>=
block_no_new_scope: TOBrace slist TCBrace { mk_st (Block $2) $1 }
@
% sill see soon why call that way and what is slist (statement list)
% no_new_scope because done in storage_and_type_xdecor


\section{Statements}


<<rule [[Parser.stmnt]]>>=
stmnt: 
 |        ulstmnt { $1 }
 | labels ulstmnt { $1 $2 }
@


<<rule [[Parser.ulstmnt]]>>=
ulstmnt: 
 <<[[Parser.ulstmnt]] cases>>
@
% ul for unlabeled

<<[[Parser.ulstmnt]] cases>>=
| cexpr TSemicolon { mk_st (ExprSt $1) $2 }
/*(* used when do for(...) ; to have an empty statement *)*/
|       TSemicolon { mk_st (Block []) $1 }
@
%cexpr for comma expr but =~ expr

<<function [[Parser.mk_st]]>>=
let mk_st st loc = { s = st; s_loc = loc }
@


\subsection{Blocks}

<<[[Parser.ulstmnt]] cases>>=
| block { $1 }
@


<<rule [[Parser.block]]>>=
block: tobrace slist tcbrace { mk_st (Block $2) $1 }
@
% seen similar before in funcdef

<<other block related rules>>=
<<rule [[Parser.tobrace]]>>
<<rule [[Parser.tcbrace]]>>
<<rule [[Parser.slist]]>>

<<rule [[Parser.block_no_new_scope]]>>
@

<<rule [[Parser.slist]]>>=
slist:
 | /*(*empty*)*/ { [] }
 | slist adecl   { $1 @ $2 }
 | slist stmnt   { $1 @ [$2] }
@
% and back to stmnt!
% adecl for locals, see later

<<rule [[Parser.tobrace]]>>=
tobrace: TOBrace { new_scope env; $1 }
@
<<rule [[Parser.tcbrace]]>>=
tcbrace: TCBrace { pop_scope env; $1 } 
@



\subsection{Conditionals}

<<[[Parser.ulstmnt]] cases>>=
| Tif TOPar cexpr TCPar stmnt %prec LOW_PRIORITY_RULE 
    { 
      if $5.s = Block []
      then Error.warn "empty if body" $5.s_loc;
      mk_st (If ($3, $5, mk_st (Block[]) $1)) $1
    }
| Tif TOPar cexpr TCPar stmnt Telse stmnt 
    { 
      if $5.s = Block []
      then Error.warn "empty if body" $5.s_loc;
      if $7.s = Block []
      then Error.warn "empty else body" $7.s_loc;
      mk_st (If ($3, $5, $7)) $1
    }
@

\subsection{Loops}

<<[[Parser.ulstmnt]] cases>>=
| Twhile TOPar cexpr TCPar stmnt                { mk_st (While ($3, $5)) $1 }
| Tdo stmnt Twhile TOPar cexpr TCPar TSemicolon { mk_st (DoWhile ($2, $5)) $1 }
| tfor TOPar forexpr TSemicolon zcexpr TSemicolon zcexpr TCPar stmnt
    { pop_scope env;
      mk_st (For ($3, $5, $7, $9)) $1
    }
@

<<other expr ebnf rules>>=
zcexpr:
 | /*(*empty*)*/ { None }
 | cexpr         { Some $1 }
@

<<rule [[Parser.tfor]]>>=
tfor: Tfor { new_scope env; $1 }
@

<<rule [[Parser.forexpr]]>>=
forexpr: 
 | zcexpr 
     { Left $1 }
 | storage_and_type adlist 
     { Right 
         (* less: could factorize code with xdecl *)
         ($2 |> List.map (fun (((id, v_loc), typ2), v_init) ->
          let (sto_or_typedef, typ1) = $1 in
          let v_type = typ2 typ1 in
          (match sto_or_typedef with
          | Left v_storage -> 
            add_id env id IdIdent;
            { v_name = (id, env.block); v_loc; v_type; v_storage; v_init; }
          (* stricter: *)
          | Right _ -> error "typedefs inside 'for' are forbidden"
          )
       ))
     }
@

\subsection{Control flow jumps}

<<[[Parser.ulstmnt]] cases>>=
| Treturn zcexpr TSemicolon { mk_st (Return $2) $1 }
@

<<[[Parser.ulstmnt]] cases>>=
| Tbreak TSemicolon         { mk_st Break $1 }
| Tcontinue TSemicolon      { mk_st Continue $1 } 
@

\subsection{Labels and goto}

<<[[Parser.ulstmnt]] cases>>=
| Tgoto tag TSemicolon      { mk_st (Goto (snd $2)) $1 }
@


% also used for su?

<<rule [[Parser.labels]]>>=
labels:
 | label        { (fun st -> $1 st)  }
 | labels label { (fun st -> $1 ($2 st)) }
@

<<rule [[Parser.label]]>>=
label:
 /*(* less: not tag here? can not conflict with typedef? *)*/
 | TName      TColon  { (fun st -> mk_st (Label (snd $1, st)) $2)  }
 <<[[Parser.label]] other cases>>
@

\subsection{Switch}

<<[[Parser.ulstmnt]] cases>>=
/*(* stricter: I impose a block, not any stmnt *)*/
| Tswitch TOPar cexpr TCPar block 
    { (* less: generate (0:int - (0:int - x)) *)
      mk_st (Switch ($3, $5)) $1
    }
@

<<[[Parser.label]] other cases>>=
| Tcase expr TColon  { (fun st -> mk_st (Case ($2, st)) $3) }
| Tdefault   TColon  { (fun st -> mk_st (Default st) $2) }
@




\section{Expressions}

<<rule [[Parser.expr]]>>=
expr:
 | xuexpr { $1 }
 <<[[Parser.expr]] other cases>>
@

<<other expr related rules>>=
<<rule [[Parser.xuexpr]]>>
<<rule [[Parser.uexpr]]>>
<<rule [[Parser.pexpr]]>>
<<rule [[Parser.cexpr]]>>
<<rule [[Parser.lexpr]]>>
@

% xu = extended unary(cast), u = unary, p = primary, c = comma
%  intermediate for priority (%left/%right not enough always?)

<<rule [[Parser.xuexpr]]>>=
xuexpr:
 | uexpr { $1 }
 <<[[Parser.xuexpr]] other cases>>
@


<<rule [[Parser.uexpr]]>>=
uexpr:
 | pexpr { $1 }
 <<[[Parser.uexpr]] other cases>>
@

<<rule [[Parser.pexpr]]>>=
pexpr:
 <<[[Parser.pexpr]] cases>>
@



<<[[Parser.pexpr]] cases>>=
| TOPar cexpr TCPar { $2 }
@

<<rule [[Parser.cexpr]]>>=
cexpr:
 | expr { $1 }
 | cexpr TComma cexpr { mk_e (Sequence ($1, $3)) $2 }
@
%ugly C, can have sequence also in expression, hmmm


\subsection{Numeric constants}

<<[[Parser.pexpr]] cases>>=
| TIConst { let (loc, a,b) = $1 in mk_e (Int (a,b))    loc } 
| TFConst { let (loc, a,b) = $1 in mk_e (Float (a,b))  loc }
@

<<function [[Parser.mk_e]]>>=
let mk_e e loc = { e = e; e_loc = loc; e_type = T.Void }
@
% e_type set later in Typechecking phase

%5c: split it finer subsubsection Integer, Floats

\subsection{String constants}

<<[[Parser.pexpr]] cases>>=
| string  { let (loc, a,b) = $1 in mk_e (String (a,b)) loc }
@

<<rule [[Parser.string]]>>=
string:
 | TString        { $1 }
 | string TString 
     { let (loc1, s1,t1) = $1 in let (_loc2, s2,t2) = $2 in
       (* stricter: better error message, 5c just says "syntax error" *)
       if t1 <> t2
       then error "incompatible strings"
       else loc1, s1 ^ s2, t1
     }
@

\subsection{Entity uses}

<<[[Parser.pexpr]] cases>>=
| TName   
    { let (loc, id) = $1 in
      try 
        let (idkind, blockid) = Hashtbl.find env.ids id in
        assert (idkind <> IdTypedef);
        mk_e (Id (id, blockid)) loc
      with Not_found ->
        (* stricter: if caller is Call, still forbid implicit decl of func! *)
        error (spf "name not declared: %s" id)
        (*Id ($1, 0)*)
    }
@
% Can have TTypeName here? no, see the assert.

\subsection{Arithmetic expressions}

<<[[Parser.uexpr]] other cases>>=
| TPlus xuexpr  { mk_e (Unary (UnPlus, $2)) $1 }
| TMinus xuexpr { mk_e (Unary (UnMinus, $2)) $1 }
@

<<[[Parser.expr]] other cases>>=
| expr TPlus expr   { mk_e (Binary ($1, Arith Plus, $3)) $2 }
| expr TMinus expr  { mk_e (Binary ($1, Arith Minus, $3)) $2 }
| expr TMul expr    { mk_e (Binary ($1, Arith Mul, $3)) $2 }
| expr TDiv expr    { mk_e (Binary ($1, Arith Div, $3)) $2 }
| expr TMod expr    { mk_e (Binary ($1, Arith Mod, $3)) $2 }
@


% Bit operation

<<[[Parser.expr]] other cases>>=
| expr TAnd expr    { mk_e (Binary ($1, Arith And, $3)) $2 }
| expr TXor expr    { mk_e (Binary ($1, Arith Xor, $3)) $2 }
| expr TOr expr     { mk_e (Binary ($1, Arith Or, $3)) $2 }
@

<<[[Parser.uexpr]] other cases>>=
| TTilde xuexpr { mk_e (Unary (Tilde, $2)) $1 }
@

<<[[Parser.expr]] other cases>>=
| expr TSupSup expr { mk_e (Binary ($1, Arith ShiftRight, $3)) $2 }
| expr TInfInf expr { mk_e (Binary ($1, Arith ShiftLeft , $3)) $2 }
@


\subsection{Boolean expressions}

<<[[Parser.expr]] other cases>>=
| expr TAndAnd expr { mk_e (Binary ($1, Logical AndLog, $3)) $2 }
| expr TOrOr expr   { mk_e (Binary ($1, Logical OrLog, $3)) $2 }
@

<<[[Parser.uexpr]] other cases>>=
| TBang xuexpr  { mk_e (Unary (Not, $2)) $1 }
@


<<[[Parser.expr]] other cases>>=
| expr TEqEq expr   { mk_e (Binary ($1, Logical Eq, $3)) $2 }
| expr TBangEq expr { mk_e (Binary ($1, Logical NotEq, $3)) $2 }
@
<<[[Parser.expr]] other cases>>=
| expr TInf expr    { mk_e (Binary ($1, Logical Inf, $3)) $2 }
| expr TSup expr    { mk_e (Binary ($1, Logical Sup, $3)) $2 }
| expr TInfEq expr  { mk_e (Binary ($1, Logical InfEq, $3)) $2 }
| expr TSupEq expr  { mk_e (Binary ($1, Logical SupEq, $3)) $2 }
@

\subsection{Assignments}

%ugly: should be a statement!
<<[[Parser.expr]] other cases>>=
| expr TEq expr     { mk_e (Assign (SimpleAssign, $1, $3)) $2 }
| expr TOpEq expr   { mk_e (Assign (OpAssign (snd $2), $1, $3)) (fst $2) }
@

\subsection{Pointers}

<<[[Parser.uexpr]] other cases>>=
| TMul xuexpr  { mk_e (Unary (DeRef, $2)) $1 }
| TAnd xuexpr  { mk_e (Unary (GetRef, $2)) $1 }
@

\subsection{Array accesses}

<<[[Parser.pexpr]] cases>>=
/*(* stricter: was cexpr, but ugly to allow cexpr here *)*/
| pexpr TOBra expr TCBra  { mk_e (ArrayAccess ($1, $3)) $2 }
@

\subsection{Field accesses}

<<[[Parser.pexpr]] cases>>=
/*(* we could unsugar here RecordPtAccess; instead we do it in typecheck.ml*)*/
| pexpr TDot tag   { mk_e (RecordAccess ($1, snd $3)) $2 }
| pexpr TArrow tag { mk_e (RecordPtAccess ($1, snd $3)) $2 } 
@


\subsection{Function calls}

<<[[Parser.pexpr]] cases>>=
/*(* less: could do implicit declaration of unknown function *)*/
| pexpr TOPar zelist TCPar { mk_e (Call ($1, $3)) $2 }
@

<<other expr ebnf rules>>=
zelist:
 | /*(*empty*)*/ { [] }
 | elist         { $1 }
@
<<other expr ebnf rules>>=
elist:
 | expr { [$1] }
 | elist TComma elist { $1 @ $3 }
@

\subsection{Cast}

<<[[Parser.xuexpr]] other cases>>=
| TOPar qualifier_and_type abdecor TCPar xuexpr  { mk_e (Cast ($3 $2, $5)) $1 }
@

% abdecor, abstract declarator, no name, just type with left and right part
% without anything in the middle as in  int[]

\subsection{Ternary expressions}

<<[[Parser.expr]] other cases>>=
| expr TQuestion cexpr TColon expr { mk_e (CondExpr ($1, $3, $5)) $2 }
@

\subsection{Prefix/postfix}

<<[[Parser.uexpr]] other cases>>=
| TPlusPlus xuexpr   { mk_e (Prefix (Inc, $2)) $1 }
| TMinusMinus xuexpr { mk_e (Prefix (Dec, $2)) $1 } 
@

<<[[Parser.pexpr]] cases>>=
| pexpr TPlusPlus   { mk_e (Postfix ($1, Inc)) $2 }
| pexpr TMinusMinus { mk_e (Postfix ($1, Dec)) $2 } 
@

\subsection{[[sizeof()]]}

<<[[Parser.pexpr]] cases>>=
| Tsizeof TOPar qualifier_and_type abdecor TCPar 
    { mk_e (SizeOf (Right ($4 $3))) $1 }
| Tsizeof uexpr 
    { mk_e (SizeOf (Left $2)) $1 }
@


\section{Initializers and designators}

<<[[Parser.xdlist]] other cases>>=
| xdecor TEq init { [$1, Some $3] }
@


<<rule [[Parser.init]]>>=
init: 
 | expr                  { $1 }
 | TOBrace ilist comma_opt TCBrace 
     { match $2 with
       | [] -> raise (Impossible "grammar force at least one element")
       | (Left x)::xs ->
           mk_e (ArrayInit (x::(xs |> List.map (function
             | Left x -> x
             | Right _ -> error "mixing array and record initializer forbidden"
           )))) $1
       | (Right x)::xs ->
           mk_e (RecordInit (x::(xs |> List.map (function
             | Right x -> x
             | Left _ -> error "mixing array and record initializer forbidden"
           )))) $1
     }
@

<<other init related rules>>=
<<rule [[Parser.comma_opt]]>>
<<rule [[Parser.ilist]]>>
<<rule [[Parser.ilist2]]>>
<<rule [[Parser.qual]]>>
@

<<rule [[Parser.ilist]]>>=
ilist:
 | init2              { [$1] }
 | ilist TComma init2 { $1 @ [$3] }
@

<<rule [[Parser.comma_opt]]>>=
comma_opt:
 | /*(*empty*)*/ { }
 | TComma { }
@


<<rule [[Parser.ilist2]]>>=
init2:
 | init          { Left (None, $1) }
 | qual TEq init { $1 $3 }
@


<<rule [[Parser.qual]]>>=
qual:
 | TOBra lexpr TCBra { (fun x -> Left (Some $2, x)) }
 | TDot tag          { (fun x -> Right (snd $2, x)) }
@

<<rule [[Parser.lexpr]]>>=
/*(*todo: (long expr) is wrapping expr in a (long) cast *)*/
lexpr: expr { $1 }
@


\section{Types and storage classes}

<<rule [[Parser.type_]]>>=
type_:
  | simple_type  { let (t, loc) = $1 in mk_t (Ast.TBase t) loc }
  | complex_type { $1 }
@

<<function [[Parser.mk_t]]>>=
let mk_t t loc = { t = t; t_loc = loc }
@


<<rule [[Parser.simple_type]]>>=
simple_type:
 <<[[Parser.simple_type]] cases>>
@

<<rule [[Parser.complex_type]]>>=
complex_type:
 <<[[Parser.complex_type]] cases>>
@


\subsection{Basic types}


<<[[Parser.simple_type]] cases>>=
| Tchar            { (T.I (T.Char, T.Signed), $1) }
/*(* meh, I should remove all Signed variants *)*/
| Tsigned Tchar    { (T.I (T.Char, T.Signed), $1) }
| Tunsigned Tchar  { (T.I (T.Char, T.Unsigned), $1) }

| Tshort           { (T.I (T.Short, T.Signed), $1) }
| Tunsigned Tshort { (T.I (T.Short, T.Unsigned), $1) }

| Tint             { (T.I (T.Int, T.Signed), $1) }
| Tunsigned Tint   { (T.I (T.Int, T.Unsigned), $1) }
/*(*bad: should be removed, but for compatibility with plan9 code I keep it*)*/
| Tunsigned        { (T.I (T.Int, T.Unsigned), $1) }

| Tlong            { (T.I (T.Long, T.Signed), $1) }
| Tunsigned Tlong  { (T.I (T.Long, T.Unsigned), $1) }

| Tlong Tlong      { (T.I (T.VLong, T.Signed), $1) }
| Tunsigned Tlong Tlong { (T.I (T.VLong, T.Unsigned), $1) }


| Tfloat  { (T.F (T.Float), $1) }
| Tdouble { (T.F (T.Double), $1) }

| Tvoid   { (T.Void, $1) }
/*(* less: allow more combinations, so better than just "syntax error"? *)*/
@

\subsection{Storage classes}

<<rule [[Parser.storage]]>>=
/*(* less: allow some combinations? like extern register? *)*/
storage:
 | Tauto     { Storage.Local }
 | Tstatic   { Storage.Static }
 | Textern   { Storage.Extern }
 /*(* stricter: 5c just skips register declarations, I forbid them *)*/
 | Tregister { error "register not supported" }
 | Tinline   { error "inline not supported" }
/*(* less: allow more combinations, so better than just "syntax error"? *)*/
@

<<rule [[Parser.storage_and_type]]>>=
/*(* stricter: I impose an order. c(lass) then g(arbage) then t(type). *)*/
storage_and_type:
 |          qualifiers type_ { Left None, $2 }
 | storage  qualifiers type_ { Left (Some $1), $3 }
 <<[[Parser.storage_and_type]] other cases>>
/*(* less: allow more combinations, so better than just "syntax error"? *)*/
@
% referenced a few times: in toplevel xdecl, in for, in function def

% will see Typedef case later

\subsection{Qualifiers}

<<rule [[Parser.qualifier]]>>=
qualifier:
 | Tconst    { T.Const }
 | Tvolatile { T.Volatile }
 | Trestrict { error "restrict not supported" }
@

<<other qualifier related rules>>=
qualifier_and_type: qualifiers type_ { $2 }
/*(* less: allow storage here, so better than just "syntax error"? *)*/

qualifiers:
 | /*(*empty*)*/        { [] }
 | qualifiers qualifier { $1 @ [$2] }
@

\subsection{Structures and unions}


\subsubsection{Structure/union uses}
% or forward decl?

<<[[Parser.complex_type]] cases>>=
| su tag { 
    let (su, loc) = $1 in
    let (_, id) = $2 in
    try 
      let (_tagkind, bid) = Hashtbl.find env.tags id in
      (* assert takind = $1? let check.ml do this check *)
      let fullname = id, bid in
      mk_t (Ast.TStructName (su, fullname)) loc
    with Not_found ->
      (* will check in check.ml whether struct defined later *)
      let fullname = id, 0 (* less: or env.block? *) in
      mk_t (Ast.TStructName (su, fullname)) loc
}
@
% tag again

<<rule [[Parser.su]]>>=
su:
 | Tstruct { T.Struct, $1 }
 | Tunion  { T.Union, $1 }
@


\subsubsection{Structure/union definitions}

<<[[Parser.complex_type]] cases>>=
| su tag_opt sbody {
    let (su_kind, su_loc) = $1 in
    let id = $2 in
    let fullname = id, env.block in
    (* check if already defined in check.ml *)
    defs := (StructDef { su_name = fullname; su_loc; su_kind; su_flds = $3 })::!defs;
    add_tag env id (Ast.tagkind_of_su su_kind);
    mk_t (Ast.TStructName (su_kind, fullname)) loc
}
@

<<other struct related rules>>=
<<rule [[Parser.su]]>>
<<rule [[Parser.tag_opt]]>>
@

<<rule [[Parser.tag_opt]]>>=
tag_opt:
 | tag           { snd $1 }
 | /*(*empty*)*/ { gensym () }
@
% gensym!! no anonymous struct/union, which simplifies things


<<rule [[Parser.sbody]]>>=
/*(* note that a structure does not define a new scope *)*/
sbody: TOBrace edecl TCBrace { $2 }
@


%%\subsubsection{Fields}

<<other structure body related rules>>=
edecl:
 |       edecl_elem TSemicolon { $1 }
 | edecl edecl_elem TSemicolon { $1 @ $2 }

edecl_elem: 
 | qualifier_and_type edlist
   { $2 |> List.map (fun ((id, loc), typ2) -> 
       (* note that this element can introduce a nested struct definition! *)
       let typ1 = $1 in
       let typ = typ2 typ1 in
       { fld_name = id; fld_loc = loc; fld_type = typ }
     )
   }
/*(* kenccext: c99ext? unnamed structure elt; used in u.h/regexp.h/bio.h/.. *)*/
 | qualifier_and_type
   { let s = gensym () in
    (* note that this anon elt can even be a nested anon struct definition! *)
     let typ = $1 in
     (* check that struct/union done later after typedef expansion *)
     [ { fld_name = s; fld_loc = typ.t_loc; fld_type = typ } ]
   }

/*(* todo: bitfield *)*/
edlist:
 | edecor               { [$1] }
 | edlist TComma edecor { $1 @ [$3] }

edecor: xdecor { $1 }
@

% note that no storage in edecl_elem, we use qualified_and_type, not
% storage_and_type

\subsection{Enums}

\subsubsection{Enumeration type uses and definitions}

<<[[Parser.complex_type]] cases>>=
| Tenum tag   { 
    let (_, id) = $2 in
    try 
      let (_tagkind, bid) = Hashtbl.find env.tags id in
      let fullname = id, bid in
      mk_t (Ast.TEnumName fullname) $1
    with Not_found ->
      let fullname = id, 0 (* less: or env.block? *) in
      mk_t (Ast.TEnumName fullname) $1
   }
@

<<[[Parser.complex_type]] cases>>=
| Tenum tag_opt TOBrace enum TCBrace {
    let id = $2 in
    let enum_name = id, env.block in
    defs := (EnumDef { enum_name; enum_loc = $1; enum_constants = $4 })::!defs;
    add_tag env id TagEnum;
    mk_t (Ast.TEnumName enum_name) $1
}
@

\subsubsection{Enumeration constant definitions}

<<rule [[Parser.enum]]>>=
enum:
 | TName                
     { let (loc, id) = $1 in
       add_id env id IdEnumConstant; 
       [ { ecst_name = (id, env.block); ecst_loc = loc; ecst_value = None } ] 
     }
 | TName TEq const_expr 
     { let (loc, id) = $1 in
      (* note that const_expr can reference enum constants defined before *)
       add_id env id IdEnumConstant;
       [ { ecst_name = (id, env.block); ecst_loc = loc; ecst_value = Some $3 } ] 
     }

 | enum TComma enum { $1 @ $3 }
 | enum TComma      { $1 }
@

<<rule [[Parser.const_expr]]>>=
const_expr: expr { $1 }
@


\subsection{Pointer and array types}
%alt: types part 2, the right part

<<[[Parser.xdecor]] other cases>>=
| TMul qualifiers xdecor 
    { let (id, f) = $3 in 
      id, (fun x -> f (mk_t (TPointer x) $1))
    }
@
% qualifiers also here, subtle!

<<[[Parser.xdecor2]] other cases>>=
| xdecor2 TOBra zexpr TCBra 
    { let (id, f) = $1 in 
      (* bug: not 'id, (fun x -> mk_t (TArray ($3, f x)) $2)' *)
      id, (fun x -> f (mk_t (TArray ($3, x)) $2))
    }
@

<<other expr ebnf rules>>=
zexpr:
 | /*(*empty*)*/ { None }
 | lexpr         { Some $1 }
@


\subsection{Function types, parameter types}

<<[[Parser.xdecor2]] other cases>>=
/*(* add parameters in scope in caller, when processing the function body *)*/
| xdecor2 TOPar zparamlist TCPar
    { let (id, f) = $1 in 
      (* bug: not 'id, (fun x -> mk_t (TFunction (f x, $3)) $2)' *)
      id, (fun x -> f (mk_t (TFunction (x, $3)) $2)) 
    }
@

% will see paramlist later
<<rule [[Parser.zparamlist]]>>=
zparamlist:
 | /*(*empty*)*/ { [], false }
 | paramlist     { $1 }
@


\subsection{Typedefs}

<<[[Parser.complex_type]] cases>>=
| TTypeName 
    { let (loc, id) = $1 in
      try 
        let (idkind, bid) = Hashtbl.find env.ids id in 
        assert (idkind = IdTypedef);
        mk_t (Ast.TTypeName (id, bid)) loc
      with Not_found -> 
        raise (Impossible (spf "could not find typedef for %s" id))
    }
@

<<[[Parser.storage_and_type]] other cases>>=
| Ttypedef qualifiers type_ { Right (), $3 }
@
% typedef const int myint;
% Right () and many Right cases before (and will see a few more later)



\section{Declarations and definitions, part two}
% a bit ugly to have those 2 parts, but good way to also see again the split
% type left/right,
% some typedef handling, some xdecor, so good way to recapitulate in another
% way stuff we've seen before.

\subsection{Globals, external declarator}

% have seen already before xdecl, xdlist, xdecor, xdecor2

\subsection{Function parameters}

<<rule [[Parser.paramlist]]>>=
paramlist:
 | qualifier_and_type xdecor  
     { let ((id, p_loc), typ2) = $2 in
       (* the final blockid will be assigned when we create the scope of the
        * function body.
        *)
       [ { p_name = Some (id, -1); p_loc; p_type = typ2 $1 } ], false
     }
 | qualifier_and_type abdecor 
     { [{ p_name = None; p_loc = $1.t_loc; p_type = $2 $1 }], false }

 | paramlist TComma paramlist 
     { let (xs, isdot1) = $1 in
       let (ys, isdot2) = $3 in
       (* stricter: 5c does not report *)
       if isdot1
       then error "dots allowed only in last parameter position";

       xs @ ys, isdot2
     }
 | TDot TDot TDot { [], true }
@


\subsection{Locals, automatic declarator}

% adecl for automatic declarations, for stuff inside functions or blocks ?
% very similar to xdecl. Why can't use xdecl instead?
% no func def here!

<<rule [[Parser.adecl]]>>=
adecl:
 | storage_and_type        TSemicolon 
     { if !defs = [] 
       then error "declaration without any identifier";

       (* stricter: *)
       error "move struct or typedef definitions to the toplevel";
       (* TODO? could allow at least structdef and just return [] here *)
     }

 | storage_and_type adlist TSemicolon 
     { (* stricter: *)
       if !defs <> [] 
       then error "move struct or typedef definitions to the toplevel";

       (* less: could factorize code with xdecl *)
       ($2 |> List.map (fun (((id, v_loc), typ2), v_init) ->
          let (sto_or_typedef, typ1) = $1 in
          let v_type = typ2 typ1 in
          (match sto_or_typedef with
          | Left v_storage -> 
              add_id env id IdIdent;
              mk_st (Var { v_name = (id, env.block);
                           v_loc; v_type; v_storage; v_init;}) loc
          (* stricter: *)
          | Right () -> error "typedefs not at the toplevel are forbidden"
          )
       ))
     }
@
<<rule [[Parser.adlist]]>>=
adlist: xdlist { $1 }
@


\subsection{Types, abstract declarator}

% nice to see all rules together for once.

<<rule [[Parser.abdecor]]>>=
abdecor:
 | /*(*empty*)*/ { (fun x -> x) }
 | abdecor1      { $1 }
@

<<other abstract declarator related rules>>=
abdecor1:
 | TMul qualifiers          { (fun x -> mk_t (TPointer x) $1) }
 | TMul qualifiers abdecor1 { (fun x -> $3 (mk_t (TPointer x) $1)) }
 | abdecor2  { $1 }

abdecor2:
 | abdecor3 { $1 }
 | abdecor2 TOPar zparamlist TCPar { (fun x -> $1 (mk_t (TFunction (x, $3))$2))}
 | abdecor2 TOBra zexpr TCBra      { (fun x -> $1 (mk_t (TArray ($3, x))$2))}

abdecor3:
 | TOPar TCPar          { (fun x -> mk_t (TFunction (x, ([], false))) $1)  }
 | TOBra zexpr TCBra    { (fun x -> mk_t (TArray ($2, x)) $1) }
 | TOPar abdecor1 TCPar { $2 }
@

% subtle, and ugly


%******************************************************************************
\chapter{Checking}
%******************************************************************************
\label{chap:checking}
%alt: Use/def checking

\section{Overview}

% main check: use/def (and scope) and few smaller one

%alt: 2 checks, use/def (and scope), and typecheck the big one!

<<signature [[Check.check_program]]>>=
(* can raise Error if failhard, otherwise print on stderr *)
val check_program: Ast.program -> unit
@

% returns unit, main effect is whether raise Error or not.
% so it's sanity checking things.

<<exception [[Check.Error]]>>=
exception Error of error
@
<<type [[Check.error]]>>=
type error = 
  | Inconsistent of 
      string * Location_cpp.loc * (* error here *) 
      string * Location_cpp.loc   (* previous decl/def/whatever here *)
  | Misc of string * Location_cpp.loc
@
%ex: ??
%TODO: add Redefinition of ... | UseButNotDefined of ... 
% | Unused of ... (or make this just a warning?)

<<function [[Check.error]]>>=
let error err =
  if !failhard
  then raise (Error err)
  else Logs.err (fun m -> m "%s" (string_of_error err))
@

<<signature [[Check.failhard]]>>=
val failhard : bool ref
@
<<constant [[Check.failhard]]>>=
let failhard = ref true
@
% who sets that?



<<function [[Check.check_program]]>>=
let check_program (prog : Ast.program) : unit =
  check_usedef prog
@

\section{Printing warnings: [[5c -w]] and [[5c -W]]}
% now -w and -werror ?

%trans: before showing code of Check.check and typecheck.check_and_annotate_program
% mention -w

<<global [[Flags.warn]]>>=
let warn = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
"-w", Arg.Set Flags.warn,
" enable warnings";
@
<<signature [[Error.warn]]>>=
val warn: string -> Location_cpp.loc -> unit
@

<<global [[Flags.warnerror]]>>=
let warnerror = ref false
@
<<[[CLI.main()]] [[options]] elements>>=
"-werror", Arg.Set Flags.warnerror,
" warnings generate error exceptions";
@



<<function [[Error.warn]]>>=
let warn s loc =
  if !Flags.warn
  then 
    if !Flags.warnerror
    then raise (Location_cpp.Error (spf "Warning: %s" s, loc))
    else 
      let (file, line) = Location_cpp.final_loc_of_loc loc in
      Logs.warn (fun m -> m "%s:%d: %s" !!file line s)
@
% final_loc_of_loc described later

% actually used before during parsing, for empty body warnings
%TODO? or move here this code?

%%\section{Symbol resolution}
% done before during parsing

%%\section{Storage resolution}
% done before during parsing
%%\subsection{xdecl}
%%\subsection{doinit}
%%\subsection{pdecl}
%%\subsection{adecl}

%\section{Use/def checking}
%alt: Lint checking


\section{Checking environment}

<<type [[Check.usedef]]>>=
type usedef = {
  mutable defined: Ast.loc option;
  mutable used: Ast.loc option;
}
@
% so can detect both 'used but not defined' and 'defined but not used' errors
% (first worse than second).

<<type [[Check.env]]>>=
type env = {
  ids:      (fullname, usedef * Ast.idkind) Hashtbl.t;
  tags:     (fullname, usedef * Ast.tagkind) Hashtbl.t;

  (* to reset after each function (because labels have a function scope) *)
  mutable labels:   (string, usedef) Hashtbl.t;

  (* block scope *)
  mutable local_ids: fullname list;

  (* todo: inbreakable: bool; incontinueable: bool *)
}
@


<<[[Check.check_usedef()]] set initial [[env]]>>=
let env = {
  ids = Hashtbl.create 101;
  tags = Hashtbl.create 101;
  labels = Hashtbl.create 101;

  local_ids = [];
}
in
@

\section{Checking a program}

<<function [[Check.check_usedef]]>>=
(* use of undefined, redefined, redeclared, unused, inconsistent tags, etc. *)
let check_usedef (program : Ast.program) : unit =

  <<function [[Check.check_usedef.toplevel]]>>
  <<function [[Check.check_usedef.stmt]]>>
  <<function [[Check.check_usedef.expr]]>>
  <<function [[Check.check_usedef.type_]]>>

  <<[[Check.check_usedef()]] set initial [[env]]>>
  fst program |> List.iter (toplevel env);

  <<[[Check.check_usedef()]] check used but not defined tags after program visit>>
  (* less: could check unused static var decl? *)
  ()
@

\subsection{Checking toplevel definitions}

<<function [[Check.check_usedef.toplevel]]>>=
let rec toplevel env = function
  <<[[Check.check_usedef.toplevel()]] match cases>>
@


<<[[Check.check_usedef.toplevel()]] match cases>>=
| StructDef { su_kind=su; su_name=fullname; su_loc=loc; su_flds=flds }->

  (* checking the tag *)
  let tagkind = Ast.tagkind_of_su su in
  check_inconsistent_or_redefined_tag env fullname tagkind loc;

  (* checking the fields *)
  let hflds = Hashtbl_.create () in
  flds |> List.iter 
   (fun {fld_name = name; fld_loc = loc; fld_type = typ} ->
      (* stricter: 5c reports at use time, clang does immediately *)
      if Hashtbl.mem hflds name
      then error (Inconsistent (spf "duplicate member '%s'" name, loc,
                                "previous declaration is here", 
                                Hashtbl.find hflds name));
      Hashtbl.add hflds name loc;
      type_ env typ
  )
@
% TODO: use more precise than Inconsistent? Duplicate | UsedBeforeSet | ...
%  imitate ocaml-light?

<<[[Check.check_usedef.toplevel()]] match cases>>=
| EnumDef { enum_name = fullname; enum_loc = loc; enum_constants = csts }->

  (* checking the tag *)
  let tagkind = TagEnum in
  check_inconsistent_or_redefined_tag env fullname tagkind loc;

  (* checking the constants *)
  csts |> List.iter 
      (fun { ecst_name = fullname; ecst_loc = loc; ecst_value = eopt } ->
        check_inconsistent_or_redefined_id env fullname IdEnumConstant loc;
        eopt |> Option.iter (expr env)
      );
@

<<[[Check.check_usedef.toplevel()]] match cases>>=
| TypeDef { typedef_name = fullname; typedef_loc = loc; typedef_type =typ}->
  check_inconsistent_or_redefined_id env fullname IdTypedef loc;
  type_ env typ
@

<<[[Check.check_usedef.toplevel()]] match cases>>=
| VarDecl { v_name = fullname; v_loc; v_type = t; v_init = eopt; v_storage = _} ->

  (if Hashtbl.mem env.ids fullname &&
      snd (Hashtbl.find env.ids fullname) = IdIdent
  (* this can be ok, you can redeclare toplevel identifiers as you
   * can give a final storage. It depends on the situation, 
   * see typecheck.ml
   *)
   then ()
   else check_inconsistent_or_redefined_id env fullname IdIdent v_loc
  );
  type_ env t;
  eopt |> Option.iter (expr env)
@


<<[[Check.check_usedef.toplevel()]] match cases>>=
(* todo: if use struct tags params, they must be complete at this point *)
| FuncDef { f_name = name; f_loc = loc; f_type = ftyp; f_body = st; f_storage = _ } ->
  let fullname = name, 0 in

  (if Hashtbl.mem env.ids fullname &&
      snd (Hashtbl.find env.ids fullname) = IdIdent
  (* this can be ok, you can redeclare toplevel identifiers as you
   * can give a final storage. It depends on the situation, 
   * see typecheck.ml
   *)
   then ()
   else check_inconsistent_or_redefined_id env fullname IdIdent loc
  );

  type_ env {t = TFunction ftyp; t_loc = loc };

  (* new function scope *)
  let env = { env with local_ids = []; labels = Hashtbl_.create () } in
  let (_tret, (tparams, _dots)) = ftyp in
  tparams |> List.iter (fun { p_name = fullnameopt; p_loc; p_type = _} ->
    fullnameopt |> Option.iter (fun fullname ->

      check_inconsistent_or_redefined_id env fullname IdIdent p_loc;
      env.local_ids <- fullname :: env.local_ids;
    );
  );

  (* We could match st to a Block and avoid new scope for it, but
   * it does not matter here. We do it correctly in parser.mly so
   * a parameter and local with the same name will have the same
   * blockid so we will detect if you redefine an entity even
   * if in different scope here.
   *)
  stmt env st;

  (* check function scope *)
  check_unused_locals env;
  check_labels env;
@
    

\subsection{Checking statements}

% nothing to check really, just visit and check for its expressions
% and just make sure set right env and handle scope correctly

<<function [[Check.check_usedef.stmt]]>>=
and stmt env st0 =
  match st0.s with
  <<[[Check.check_usedef.stmt()]] match [[st0.s]] cases>>
@

<<[[Check.check_usedef.stmt()]] match [[st0.s]] cases>>=
| ExprSt e -> expr env e
| Block xs ->
    (* new block scope *)
    let env = { env with local_ids = [] } in
    List.iter (stmt env) xs;

    (* check block scope *)
    check_unused_locals env
@
% but hashtbl populated in children? ok? need Hashtbl.remove
% for all locals ?

<<[[Check.check_usedef.stmt()]] match [[st0.s]] cases>>=
| Var { v_name = fullname; v_loc = loc; v_type = typ; v_init = eopt; v_storage = _ } ->
  (* less: before adding in environment? can have recursive use? *)
  eopt |> Option.iter (expr env);
  (* todo: if local VarDEcl, can actually have stuff nested like
   *  extern int i;  in which case we must go back to global
   *  scope for i! so rewrite AST? or just in typecheck.ml
   *  generate right storage for it.
   * can also be nested prototype (but I should forbid it
   *)
  check_inconsistent_or_redefined_id env fullname IdIdent loc;
  env.local_ids <- fullname :: env.local_ids;
  type_ env typ;
@


<<[[Check.check_usedef.stmt()]] match [[st0.s]] cases>>=
| If (e, st1, st2) ->
    expr env e;
    stmt env st1;
    stmt env st2;
(* ocaml-light: | While (e, st)  | Switch (e, st) | Case (e, st) *)
| While (e, st) ->
    expr env e;
    stmt env st;
| Switch (e, st) ->
    expr env e;
    stmt env st;
| Case (e, st) ->
    expr env e;
    stmt env st;
| DoWhile (st, e) ->
    stmt env st;
    expr env e
@

<<[[Check.check_usedef.stmt()]] match [[st0.s]] cases>>=
| For (e1either, e2opt, e3opt, st) ->
    (* new block scope again *)
    let env = { env with local_ids = [] } in

    (match e1either with
    | Left e1opt -> e1opt |> Option.iter (expr env)
    | Right decls ->
        decls |> List.iter (fun decl -> 
          stmt env ({s = Var decl; s_loc = decl.v_loc }) 
        )
    );
    e2opt |> Option.iter (expr env);
    e3opt |> Option.iter (expr env);
    stmt env st;

    (* check block scope *)
    check_unused_locals env
@

<<[[Check.check_usedef.stmt()]] match [[st0.s]] cases>>=
| Return eopt -> eopt |> Option.iter (expr env)
(* todo: check that inside something that be continue/break *)
| Continue | Break -> ()
@

<<[[Check.check_usedef.stmt()]] match [[st0.s]] cases>>=
(* checks on labels are done in FuncDef once we analyzed the whole body *)
| Label (name, st) ->
    (try
       let usedef = Hashtbl.find env.labels name in
       usedef.defined |> Option.iter (fun locprev ->
         error (Inconsistent (spf "redefinition of label '%s'" name, 
                              st0.s_loc,
                              "previous definition is here", locprev))
       );
       usedef.defined <- Some st0.s_loc;
     with Not_found ->
       Hashtbl.add env.labels name 
         {defined = Some st0.s_loc; used = None}
    );
    stmt env st;

| Goto name ->
    (try 
       let usedef = Hashtbl.find env.labels name in
       usedef.used <- Some st0.s_loc
     with Not_found ->
       Hashtbl.add env.labels name { defined = None; used = Some st0.s_loc }
    )
@
%TODO? put check_labels here?

<<[[Check.check_usedef.stmt()]] match [[st0.s]] cases>>=
| Default st -> stmt env st
@


\subsection{Checking expressions}

<<function [[Check.check_usedef.expr]]>>=
and expr env e0 =
  match e0.e with
  <<[[Check.check_usedef.expr()]] match [[e0.e]] cases>>
and exprs env xs = xs |> List.iter (expr env)
@

<<[[Check.check_usedef.expr()]] match [[e0.e]] cases>>=
| Int _ | Float _ | String _ -> ()
@

<<[[Check.check_usedef.expr()]] match [[e0.e]] cases>>=
| Id fullname ->
    (try 
       let (usedef, _idkind) = Hashtbl.find env.ids fullname in
       usedef.used <- Some e0.e_loc
     with Not_found ->
       (* todo: can be USED or SET *)
       raise (Impossible (spf "ids are always declared first: %s" 
                            (unwrap fullname)))
    )
@
% Why impossible? seems classic use but not defined case? because
% fullname so already resolved during parsing I think

<<function [[Ast.unwrap]]>>=
let unwrap (name, _) = name    
@


<<[[Check.check_usedef.expr()]] match [[e0.e]] cases>>=
| Call (e, es) -> exprs env (e::es)
(* ocaml-light: | Assign (_, e1, e2) | Binary (e1, _, e2) | Sequence (e1, e2) | ArrayAccess (e1, e2) *)
| Assign (_, e1, e2) -> exprs env [e1; e2]
| Binary (e1, _, e2) -> exprs env [e1; e2]
| Sequence (e1, e2) -> exprs env [e1; e2]
| ArrayAccess (e1, e2) -> exprs env [e1; e2]
(* ocaml-light: | RecordAccess (e, _) | RecordPtAccess (e, _) 
| Postfix (e, _) | Prefix (_, e) | Unary (_, e) *)
| RecordAccess (e, _) -> expr env e
| RecordPtAccess (e, _) -> expr env e
| Postfix (e, _) -> expr env e
| Prefix (_, e) -> expr env e
| Unary (_, e) -> expr env e
(* ocaml-light: | Cast (typ, e) | GccConstructor (typ, e) *)
| Cast (typ, e) ->
  type_ env typ;
  expr env e
| GccConstructor (typ, e) ->
  type_ env typ;
  expr env e
| CondExpr (e1, e2, e3) -> exprs env [e1; e2; e3]
| SizeOf either ->
    (match either with
    | Left e -> expr env e
    | Right t -> type_ env t
    )
| ArrayInit xs -> 
  xs |> List.iter (fun (eopt, e) -> 
    eopt |> Option.iter (expr env);
    expr env e
  )
| RecordInit xs -> xs |> List.iter (fun (_, e) -> expr env e)
@


\subsection{Checking types}

<<function [[Check.check_usedef.type_]]>>=
and type_ env = fun typ ->
  match typ.t with
  <<[[Check.check_usedef.type_()]] match [[typ.t]] cases>>
in
@

<<[[Check.check_usedef.type_()]] match [[typ.t]] cases>>=
| TBase _ -> ()
| TPointer t -> type_ env t
| TArray (eopt, t) -> 
  eopt |> Option.iter (expr env);
  type_ env t;
| TFunction (tret, (params, _dots)) ->
  type_ env tret;
  params |> List.iter (fun p ->
    (* nothing to do with p.p_name here *)
    type_ env p.p_type
  )
@

<<[[Check.check_usedef.type_()]] match [[typ.t]] cases>>=
| TStructName (_, _) | TEnumName _ ->
  let tagkind, fullname = 
    match typ.t with
    | TStructName (su, fullname) -> Ast.tagkind_of_su su, fullname
    | TEnumName fullname -> TagEnum, fullname
    | _ -> raise (Impossible "see pattern above")
  in
  (try 
    let (usedef, oldtagkind) = Hashtbl.find env.tags fullname in
    if tagkind <> oldtagkind
    then inconsistent_tag fullname typ.t_loc usedef;
    usedef.used <- Some typ.t_loc;
  with Not_found ->
    (* forward decl *)
    Hashtbl.add env.tags fullname 
      ({defined = None; used = Some typ.t_loc; }, tagkind)
  )
@

<<[[Check.check_usedef.type_()]] match [[typ.t]] cases>>=
| TTypeName fullname ->
    (try 
       let (usedef, idkind) = Hashtbl.find env.ids fullname in
       if idkind <> IdTypedef
       then raise (Impossible "typename returned only if typedef in scope");
       usedef.used <- Some typ.t_loc
     with Not_found ->
       raise (Impossible "typename returned only if typedef in scope")
    )
@

\section{Checks}

\subsection{Inconsistent or redefined tag}

<<function [[Check.check_inconsistent_or_redefined_tag]]>>=
let check_inconsistent_or_redefined_tag env fullname tagkind loc =
  try 
    let (usedef, oldtagkind) = Hashtbl.find env.tags fullname in
    if tagkind <> oldtagkind
    then inconsistent_tag fullname loc usedef;
    (* the tag may not have be defined, as in a previous 'struct Foo x;' *)
    usedef.defined |> Option.iter (fun locdef ->
      error (Inconsistent (spf "redefinition of '%s'" (unwrap fullname), loc,
                     "previous definition is here", locdef))
    );
    (* now it's defined *)
    usedef.defined <- Some loc;
  with Not_found ->
    Hashtbl.add env.tags fullname ({defined = Some loc; used = None;}, tagkind)
@

<<function [[Check.inconsistent_tag]]>>=
let inconsistent_tag fullname loc usedef =
  let locbefore = 
    match usedef with
    (* ocaml-light: | { defined = Some loc; _ } | { used = Some loc; _ } *)
    | { defined = Some loc; used = _ } -> loc
    | { used = Some loc; defined = _ } -> loc
    | _ -> raise (Impossible "must have a def or a use")
  in
  error (Inconsistent (
    spf "use of '%s' with tag type that does not match previous declaration "
      (unwrap fullname), loc,
    "previous use is here", locbefore
  ))
@


\subsection{Inconsistent or redefined identifier}

<<function [[Check.check_inconsistent_or_redefined_id]]>>=
let check_inconsistent_or_redefined_id env fullname idkind loc =
  try 
    let (usedef, oldidkind) = Hashtbl.find env.ids fullname in
    if idkind <> oldidkind
    then inconsistent_id fullname loc usedef
    else
      (match usedef.defined with
      | Some locdef ->
        (* stricter: 5c allows at least for same typedef; I do not. *)
        error (Inconsistent (spf "redefinition of '%s'" (unwrap fullname), loc,
                             "previous definition is here", locdef))
      (* the id must be defined, there is no forward use of ids
       * (enum constants, typedefs, variables)
       *)
      | None -> raise (Impossible "ids are always defined before being used")
      )
  with Not_found ->
    Hashtbl.add env.ids fullname ({defined = Some loc; used = None; }, idkind)
@

<<function [[Check.inconsistent_id]]>>=
let inconsistent_id fullname loc usedef =
  let locbefore = 
    match usedef with
    | { defined = Some loc; used = _ } -> loc
    | { defined = None; used = _ } -> raise (Impossible "id always defined first")
  in
  error (Inconsistent (
    spf "redefinition of '%s' " (unwrap fullname), loc,
    "previous definition is here", locbefore
  ))
@



\subsection{Unused variables}

<<function [[Check.check_unused_locals]]>>=
let check_unused_locals (env : env) : unit =
  (* less: could also delete entries in env.ids *)
  env.local_ids |> List.iter (fun fullname ->
    let (usedef, idkind) = Hashtbl.find env.ids fullname in
    assert (idkind = IdIdent);
    match usedef with
    | { defined = Some loc; used = None } ->
        (* 5c says whether 'auto' or 'param' *) 
        Error.warn 
          (spf "variable declared and not used: '%s'" (unwrap fullname)) loc
    | { defined = Some _; used = Some _ } -> ()
    | { defined = None; used = _} -> 
          raise (Impossible "locals are always defined")
  )
@


\subsection{Used before set}

\subsection{Used but not defined tags}

<<[[Check.check_usedef()]] check used but not defined tags after program visit>>=
(* stricter: check if used but not defined tags (5c does not, clang does) *)
env.tags |> Hashtbl.iter (fun fullname (usedef, _idkind) ->
  match usedef with
  | { used = Some loc; defined = None } ->
    error (Misc (spf "use of tag '%s' that is never completed"
                        (unwrap fullname), loc))
  (* this can happen, header file are big and can cover multiple modules *)
  | { defined = Some _; used = None } -> ()
  (* perfect *)
  | { defined = Some _; used = Some _} -> ()
  | { defined = None; used = None } -> 
      raise (Impossible "one or the other")
);
@


\subsection{False positives silencing: [[SET()/USED()]]}

<<toplevel [[Parser._1]]>>=
(* a few builtins.
 * less: 5c manages USED/SET at a lower level; they are lexical keywords
 * and they are in the AST with special nodes (OUSED/OSET)
 *)
let _ =
  add_id env "USED" IdIdent;
  add_id env "SET" IdIdent;
  ()
@

%%\subsection{Redeclared or unused labels}
\subsection{Use of undeclared labels or unused labels}

% call at end of scope, like check_unused_locals
<<function [[Check.check_labels]]>>=
let check_labels env =
  env.labels |> Hashtbl.iter (fun name usedef ->
    match usedef with
    | { defined = Some _; used = Some _ } -> ()

    | { used = Some loc; defined = None } ->
        error (Misc (spf "use of undeclared label '%s'" name, loc))
    | { defined = Some loc; used = None } ->
        Error.warn (spf "label declared and not used '%s'" name) loc

    | { defined = None; used = None } -> 
      raise (Impossible "at least one of used or defined")
  )
@

\subsection{Unreachable code}

\subsection{Missing return}

\subsection{Unused expression}

\subsection{Constant if: [[5c -c]]}

\subsection{Out of range shifting}

\subsection{Useless comparisons}





%******************************************************************************
\chapter{Typechecking}
%******************************************************************************
\label{chap:typechecking}
%alt: \section{Type checking} part of Checking chapter


\section{Overview}

<<signature [[Typecheck.check_and_annotate_program]]>>=
(* Returns resolved type and storage information for identifiers and tags.
 * Annotate also with types each expression nodes in the returned functions
 * (so you can more easily generate code later).
 * 
 * It also internally resolves enum constants and replaces them
 * with constants and evaluates some constant expressions (e.g., for
 * array size). It also does a few simple rewrites like +x => x + 0,
 * -x => 0 - x, add & before arrays in certain context, add some
 * explicit Cast operations, convert ArrayAccess in pointer arithmetic
 * operation, etc.
 * 
 * can raise Error.
 *)
val check_and_annotate_program: 
  Ast.program -> typed_program
@
% can raise Error, but here important part is typed_program


<<exception [[Typecheck.Error]]>>=
exception Error of error
@

<<type [[Typecheck.error]]>>=
type error = Check.error
@
% reuse. Ex of typecheck error raised: ??


%alt: define our own IncompatibleType exn or error kind?
<<function [[Typecheck.type_error]]>>=
let type_error _t loc =
  (* less: dump t? *)
  raise (Error (E.Misc ("incompatible type", loc)))
@

<<function [[Typecheck.type_error2]]>>=
(* todo: for op xxx *)
let type_error2 t1 t2 loc =
  let s1 = Dumper_.s_of_any (FinalType t1) in
  let s2 = Dumper_.s_of_any (FinalType t2) in
  raise (Error (E.Misc (spf "incompatible types (%s and %s)" s1 s2, loc)))
@



%trans: saw check if defined what you use
% now we will see if use correctly given the type of what was defined

<<function [[Typecheck.check_and_annotate_program]]>>=
(* 5c: was called tcom *)
let check_and_annotate_program (prog: Ast.program) : typed_program =
  let (ast, _locs) = prog in

  let funcs = ref [] in

  <<function [[Typecheck.check_and_annotate_program.toplevel]]>>
  <<[[Typecheck.check_and_annotate_program()]] set initial [[env]]>>

  ast |> List.iter (toplevel env);

  { ids = env.ids_; structs = env.structs_; funcs = List.rev !funcs }
@

% saw typed_program before, with ids, structs, funcs


\section{Typechecking environment}

<<type [[Typecheck.env]]>>=
(* Environment for typechecking *)
type env = {

  (* those 2 fields will be returned ultimately by check_and_annotate_program *)
  ids_:  (Ast.fullname, idinfo) Hashtbl.t;
  structs_: (Ast.fullname, Type.struct_kind * Type.structdef) Hashtbl.t;

  (* internal *)
  typedefs: (Ast.fullname, Type.t) Hashtbl.t;
  (* stricter: no float enum *)
  enums: (fullname, Type.integer_type) Hashtbl.t;

  (* stricter: no support for float enum constants either *)
  constants: (Ast.fullname, integer * Type.integer_type) Hashtbl.t;

  (* return type of function; used to typecheck Return *)
  return_type: Type.t;

  <<[[Typecheck.env]] other fields>>
}
@

<<[[Typecheck.env]] other fields>>=
(* used to add some implicit GetRef for arrays and functions *)
expr_context: expr_context;
@

<<type [[Typecheck.expr_context]]>>=
and expr_context = 
  | CtxWantValue 
  <<[[Typecheck.expr_context]] other cases>>
@


% saw idinfo before in core DS as well as Type.structdef and most
% types used above.

<<[[Typecheck.check_and_annotate_program()]] set initial [[env]]>>=
let env = {
  ids_ = Hashtbl_.create ();
  structs_ = Hashtbl_.create ();

  typedefs = Hashtbl_.create ();
  enums = Hashtbl_.create ();
  constants = Hashtbl_.create ();
  
  return_type = T.Void;
  expr_context = CtxWantValue;
}
in
@

%\subsection{Typechecking helpers}

\section{Typechecking helpers}

\subsection{Type equality} %%: [[sametype()]]

<<function [[Typecheck.same_types]]>>=
(* if you declare multiple times the same global, we need to make sure
 * the types are the same. ex: 'extern int foo; ... int foo = 1;'
 * This is where we detect inconsistencies like 'int foo; void foo();'.
 * 
 * Because we expand typedefs before calling same_types, and because
 * we do struct equality by name not fields, testing the equality of 
 * two types is simple.
 *)
let same_types (t1 : Type.t) (t2 : Type.t) : bool =
  match t1, t2 with

  (* 'void*' can match any pointer! The generic trick of C
   * (but only when the pointer is at the top of the type).
   *)
  | T.Pointer T.Void, T.Pointer _      -> true
  | T.Pointer _,      T.Pointer T.Void -> true

  (* stricter: struct equality by name, not by fields *)
  | _ -> t1 =*= t2
@

\subsection{Type compatibility} %%: [[tcompat()]]



\subsection{Type merge} %%: [[tmerge()]]
%%\subsection{Set of types constants: [[typexxx[]]]}

<<function [[Typecheck.merge_types]]>>=
(* if you declare multiple times the same global, we must merge types. *)
let merge_types t1 _t2 =
  t1
  (* TODO? what is doing 5c? *)
@

\subsection{generic [[void*]] pointer conversions: [[5c -V]]}

\subsection{Compatibility policies} %%: [[txxx]]

%%\subsection{Typechecker} %%: [[tcom()]]

\subsection{Array to pointer conversions}

<<function [[Typecheck.array_to_pointer]]>>=
(* When you mention an array in a context where you want to access the array
 * content, we prefix the array with a '&' and change its type from a T.Array
 * to a T.Pointer. This allows in turn to write typechecking rules
 * mentioning only Pointer (see for example check_compatible_binary).
 *)
let array_to_pointer (env : env) (e : expr) : expr =
  match e.e_type with
  | T.Array (_, t) ->

    (match env.expr_context with
    | CtxWantValue -> 
      if not (lvalue (e))
      then raise (Error (E.Misc ("not an l-value", e.e_loc)));

      { e = Unary (GetRef, e); e_type = T.Pointer t; e_loc = e.e_loc }
    <<[[array_to_pointer()]] when [[Array]] case, match context cases>>
    )

  (* stricter? do something for Function? or force to put address? *)
  | T.Func _ ->
    (match env.expr_context with
    | CtxWantValue -> 
      Error.warn "you should get the address of the function" e.e_loc;
      e
    | _ -> e
    )
  
  | _ -> e
@

%\subsection{lvalue check}
% later with Assign

%alt:\section{Typechecking programs}

\section{Expressions}

%trans: ok, now let's see the actual typechecking code

<<function [[Typecheck.expr]]>>=
let rec expr (env : env) (e0 : expr) : expr (* but type annotated *) =
  (* default env for recursive call *)
  let newenv = { env with expr_context = CtxWantValue } in

  match e0.e with
  <<[[Typecheck.expr()]] match [[e0.e]] cases>>

  | ArrayInit _
  | RecordInit _
  | GccConstructor _
      -> raise Todo
@

<<function [[Typecheck.expropt]]>>=
and expropt (env : env) (eopt : expr option) : expr option = 
    match eopt with
    | None -> None
    | Some e -> Some (expr env e)
@


<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| Sequence (e1, e2) -> 
  let e1 = expr newenv e1 in
  let e2 = expr newenv e2 in
  { e0 with e = Sequence (e1, e2); e_type = e2.e_type }
@

\subsection{Numeric constants}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| Int    (_s, inttype)   -> { e0 with e_type = T.I inttype }
@
<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| Float  (_s, floattype) -> { e0 with e_type = T.F floattype }
@

\subsection{String constants}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
(* less: transform in Id later? *)
| String (_s, t)         -> { e0 with e_type = t } |> array_to_pointer env
@

\subsection{Entity uses}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| Id fullname ->
   if Hashtbl.mem env.constants fullname
   then
     let (i, inttype) = Hashtbl.find env.constants fullname in
     { e0 with e = Int (spf "%d" i, inttype); e_type = T.I inttype }
   else
     let idinfo = Hashtbl.find env.ids_ fullname in
     { e0 with e_type = idinfo.typ } |> array_to_pointer env
@
% enum constant replaced by Int


\subsection{Arithmetic and boolean expressions}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=

| Binary (e1, op, e2) ->
  let e1 = expr newenv e1 in
  let e2 = expr newenv e2 in

  check_compatible_binary op e1.e_type e2.e_type e0.e_loc;

  (* todo: add casts if left and right not the same types? or do it later? *)
  let finalt : Type.t = 
    match op with

    | Arith Minus ->
      (match e1.e_type, e2.e_type with
      | T.Pointer _, T.Pointer _ -> T.long (* TODO? depend on Arch.t? *)
      | _ -> result_type_binary e1.e_type e2.e_type
      )

    | Arith (Plus | Mul | Div | Mod    
            | And | Or | Xor
            (* todo: also add T.int cast when shl/shr on right operand *)
            | ShiftLeft | ShiftRight
            ) -> 
      result_type_binary e1.e_type e2.e_type

    | Logical (Eq | NotEq  
              | Inf | Sup | InfEq | SupEq
              | AndLog | OrLog
              ) ->
      (* ugly: should be a T.Bool! C is ugly. *)
      T.int
  in
  (* TODO: add int cast for ShiftLeft, ShiftRight right operand 
   * TODO: call arith() to do "usual arithmetic conversions"? or do that
   * alt: later in Codegen? on in Rewrite.ml? 
   *)

  { e0 with e = Binary (e1, op, e2); e_type = finalt }
@

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| Unary (op, e) ->
  (match op with
  (* + E -~> 0 + E *)
  | UnPlus -> 
    let e = Binary ({e0 with e = Int ("0",(T.Int,T.Signed))}, Arith Plus,e) in
    expr env { e0 with e = e }
  (* - E -~> 0 - E *)
  | UnMinus -> 
    let e = Binary ({e0 with e = Int ("0",(T.Int,T.Signed))}, Arith Minus,e)in
    expr env { e0 with e = e }
  (* ~ E -~> -1 ^ E *)
  | Tilde ->
    let e = Binary ({e0 with e = Int ("-1",(T.Int,T.Signed))}, Arith Xor,e) in
    expr env { e0 with e = e }

  | Not ->
    let e = expr newenv e in
    (match e.e_type with
    (* what about T.Array? see array_to_pointer above *)
    | T.I _ | T.F _ | T.Pointer _ -> ()
    | _ -> type_error e.e_type e.e_loc 
    );
    { e0 with e = Unary (Not, e); e_type = T.int }
   <<[[Typecheck.expr()]] in [[Unary]], match [[op]] other cases>>
   )
@
% ugly C, Not x is T.int, grrr

<<function [[Typecheck.check_compatible_binary]]>>=
(* when you apply an operation between two expressions, this
 * expression can be valid even if the types of those two expressions
 * are not the same. However, they must be "compatible". 
 * The compatibility policy depends on the operation of the expression.
 * 
 * less: better error messages, for instance when want to add 2 pointers.
 *)
let check_compatible_binary op (t1 : Type.t) (t2 : Type.t) loc : unit =
  match op with
  | Arith Plus ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _)
    | T.Pointer _, T.I _
    | T.I _, T.Pointer _
      -> ()
    (* you can not add 2 pointers *)
    | T.Pointer _, T.Pointer _
    | _ -> type_error2 t1 t2 loc
    )
  | Arith Minus ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _)
    (* you can not sub a pointer to an int (but can sub an int to a pointer) *)
    | T.Pointer _, T.I _
      -> ()
    (* you can sub 2 pointers (if they have the same types, and the
     * result is a long). same_types() will allow a void* to match any pointer.
     *)
    | T.Pointer _, T.Pointer _ when same_types t1 t2 -> ()
    | _ -> type_error2 t1 t2 loc
    )
  | Arith (Mul | Div) ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _) -> ()
    | _ -> type_error2 t1 t2 loc
    )
  | Arith (Mod   | And | Or | Xor  | ShiftLeft | ShiftRight ) ->
    (match t1, t2 with
    | (T.I _), (T.I _ ) 
      -> ()
    (* stricter: I do not allow T.Int _ with T.F _, 5c does (clang does not) *)
    | _ -> type_error2 t1 t2 loc
    )

  | Logical (Eq | NotEq  | Inf | Sup | InfEq | SupEq) ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _) -> ()
    | T.Pointer _, T.Pointer _ when same_types t1 t2 -> ()
    (* you can not compare two structures! no deep equality (nor arrays) *)
    | _ -> type_error2 t1 t2 loc
    )
  | Logical (AndLog | OrLog) ->
    (* stricter? should impose Bool! *)
    (match t1 with
    | (T.I _ | T.F _ | T.Pointer _) ->
      (match t2 with
      | (T.I _ | T.F _ | T.Pointer _) -> ()
      | _ -> type_error t2 loc
      )
    | _ -> type_error t1 loc
    )
@

\subsection{Arithmetic conversions}

% =~ lub ?
<<function [[Typecheck.result_type_binary]]>>=
let result_type_binary (t1 : Type.t) (t2 : Type.t) : Type.t =
  match t1, t2 with
  | T.I (T.Char, T.Signed), (T.I _ | T.F _ | T.Pointer _) -> t2

  | T.I (T.Char, T.Unsigned), T.I (x, _) -> T.I (x, T.Unsigned)
  | T.I (T.Char, T.Unsigned), (T.F _ | T.Pointer _) -> t2

  | T.I (T.Short, T.Signed), (T.I ((T.Char|T.Short), sign)) -> 
      T.I (T.Short, sign)
  | T.I (T.Short, T.Signed), (T.I _ | T.F _ | T.Pointer _) -> t2

  | T.I (T.Short, T.Unsigned), (T.I ((T.Char|T.Short), _)) -> 
      T.I (T.Short, T.Unsigned)
  | T.I (T.Short, T.Unsigned), T.I (x, _) -> T.I (x, T.Unsigned)
  | T.I (T.Short, T.Unsigned), (T.F _ | T.Pointer _) -> t2

  | T.I (T.Int, T.Signed), (T.I ((T.Char|T.Short|T.Int), sign)) -> 
      T.I (T.Int, sign)
  | T.I (T.Int, T.Signed), (T.I _ | T.F _ | T.Pointer _) -> t2

  | T.I (T.Int, T.Unsigned), (T.I ((T.Char|T.Short|T.Int), _)) -> 
      T.I (T.Int, T.Unsigned)
  | T.I (T.Int, T.Unsigned), T.I (x, _) -> T.I (x, T.Unsigned)
  | T.I (T.Int, T.Unsigned), (T.F _ | T.Pointer _) -> t2

  | T.I (T.Long, T.Signed), (T.I ((T.Char|T.Short|T.Int|T.Long), sign))-> 
      T.I (T.Long, sign)
  | T.I (T.Long, T.Signed), (T.I _ | T.F _ | T.Pointer _) -> t2

  | T.I (T.Long, T.Unsigned), (T.I ((T.Char|T.Short|T.Int|T.Long), _)) -> 
      T.I (T.Long, T.Unsigned)
  | T.I (T.Long, T.Unsigned), T.I (x, _) -> T.I (x, T.Unsigned)
  | T.I (T.Long, T.Unsigned), (T.F _ | T.Pointer _) -> t2

  | T.I (T.VLong, T.Signed),(T.I ((T.Char|T.Short|T.Int|T.Long|T.VLong),sign))->
      T.I (T.VLong, sign)
  | T.I (T.VLong, T.Signed), (T.F _ | T.Pointer _) -> t2

  | T.F T.Float, (T.I _ | T.F T.Float) -> T.F T.Float
  | T.F T.Float, T.F T.Double -> T.F T.Double
  | T.F T.Float, T.Pointer _ -> t2

  | T.F T.Double, (T.I _ | T.F _) -> T.F T.Double
  | T.F T.Double, T.Pointer _ -> t2

  | T.Pointer _, (T.I _ | T.F _) -> t1

  (* see same_types special handling of void* pointers *)
  | T.Pointer T.Void, T.Pointer _ -> t2
  | T.Pointer _, T.Pointer T.Void -> t1

  | T.Pointer _, T.Pointer _ ->
    assert (t1 =*= t2);
    t1

  | _ -> raise (Impossible "case should be forbidden by compatibility policy")
@

\subsection{Pointer arithmetic}

% seen before, can substract pointer, can do arith ops with pointers

%%\subsection{Boolean expressions}

\subsection{Assignments}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| Assign (op, e1, e2) ->
  let e1 = expr newenv e1 in
  let e2 = expr newenv e2 in

  if not (lvalue (e1))
  then raise (Error (E.Misc ("not an l-value", e0.e_loc)));

  check_compatible_assign op e1.e_type e2.e_type e0.e_loc;

  (* todo: add cast on e2 if not same type,
   * todo: mixedasop thing?
   *)
  { e0 with e = Assign (op, e1, e2); e_type = e1.e_type }
@

% lvalue vs rvalue, cite classic paper by ??

<<function [[Typecheck.lvalue]]>>=
(* we assume the typechecker has called expr() on 'e0' before, 
 * so Id of enum constants for example has been substituted to Int
 * and so are not considered an lvalue.
 * 5c: was cached in an 'addable' field
 *)
let lvalue (e0 : expr) : bool =
  match e0.e with
  | Id _ 
  | Unary (DeRef, _)
  (* todo: lvalue only if leftpart is a lvalue. But when it can not be
   * a lvalue? if bitfield?
   *)
  | RecordAccess _
    -> true

  (* Strings are transformed at some point in Id.
   * We must consider them as an lvalue, because an Id is an lvalue 
   * and because if a string is passed as an argument to a function, we want
   * to pass the address of this string (see array_to_pointer()).
   *)
  | String _ -> 
    (* raise (Impossible "transformed before") *)
    true

  | Int _ | Float _
  | Binary _ 
  | Unary ((GetRef | UnPlus |  UnMinus | Tilde | Not), _)
    -> false
  | ArrayAccess _ | RecordPtAccess _ -> raise (Impossible "transformed before")
  (* TODO? what remains? should be just false no? *)
  | _ -> raise Todo
@
%5c: was done via an 'addable' (address-able) field

<<function [[Typecheck.check_compatible_assign]]>>=
(* less: could run typ_ext hooks here? and return a new node? for
 * unnamed_inheritance.c?
 *)
let check_compatible_assign op (t1 : Type.t) (t2 : Type.t) loc : unit =
  match op with
  | Eq_ ->
    (match t1, t2 with
    | (T.I _ | T.F _), (T.I _ | T.F _) -> ()
    (* 'void*' special handling done in same_types() *)
    | T.Pointer _, T.Pointer _ when same_types t1 t2 -> ()
    | T.StructName (su1, name1), T.StructName (su2, name2) 
      when su1 =*= su2 && name1 =*= name2 -> ()
    | _ -> type_error2 t1 t2 loc
    )
  (* not exactly the same rule than in check_compatible_binary *)
  | OpAssign op ->
    (match op with
    | (Plus | Minus) ->
      (match t1, t2 with
      | (T.I _ | T.F _), (T.I _ | T.F _) -> ()
      (* you can not x += y or x-=y when both x and y are pointers
       * even though you can do x - y because the result type is a long
       * (and so you can not assign than back into x).
       *)
      | T.Pointer _, T.I _ -> ()
      | _ -> type_error2 t1 t2 loc
      )
    | (Mul | Div) 
    | (Mod   | And | Or | Xor  | ShiftLeft | ShiftRight ) 
      -> check_compatible_binary (Arith op) t1 t2 loc
    )
@

\subsection{Pointers}

<<[[Typecheck.expr()]] in [[Unary]], match [[op]] other cases>>=
| GetRef ->

    (* we dont want an additional '&' added before an array *)
    let e = expr { env with expr_context = CtxGetRef } e in

    if not (lvalue (e))
    then raise (Error (E.Misc ("not an l-value", e0.e_loc)));

    (* less: warn if take address of array or function, ADDROP *)
    { e0 with e = Unary (GetRef, e); 
              e_type = T.Pointer (e.e_type) }
@
%5c: add-able, for address-able, that is you are able to GetRef it
% to get its address

<<[[Typecheck.expr_context]] other cases>>=
| CtxGetRef 
@
<<[[array_to_pointer()]] when [[Array]] case, match context cases>>=
| CtxGetRef -> 
  Error.warn "address of array ignored" e.e_loc;
  e
@

<<[[Typecheck.expr()]] in [[Unary]], match [[op]] other cases>>=
| DeRef ->
    let e = expr newenv e in

    (match e.e_type with
    | T.Pointer t -> 
      { e0 with e = Unary (DeRef, e); 
                e_type = t } |> array_to_pointer env
    (* what about T.Array? no need, see array_to_pointer() *)
    | _ -> type_error e.e_type e.e_loc
    )
@


\subsection{Array accesses}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
(* x[y] --> *(x+y), pointer arithmetic power *)
| ArrayAccess (e1, e2) ->
  let e = Unary (DeRef, { e0 with e = Binary (e1, Arith Plus, e2) }) in
  expr env { e0 with e = e }
@


\subsection{Field accesses}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| RecordAccess (e, name) ->
  let e = expr newenv e in

  (match e.e_type with
  | T.StructName (_su, fullname) ->
    let (_su2, def) = Hashtbl.find env.structs_ fullname in
    (try
       let t = List.assoc name def in
       { e0 with e = RecordAccess (e, name);
                 e_type = t } |> array_to_pointer env
     with Not_found ->
       <<[[Typecheck.expr()]] when field name not found and gensymed field exn>>
       else 
         raise (Error(E.Misc(spf "not a member of struct/union: %s" name,
                      e.e_loc)))
    )
  | _ -> type_error e.e_type e.e_loc
  )
@

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
(* x->y --> ( *x).y *)
| RecordPtAccess (e, name) ->
  let e = RecordAccess ({ e0 with e = Unary (DeRef, e)}, name) in
  expr env { e0 with e = e }
@




%TODO: move later
<<[[Typecheck.expr()]] when field name not found and gensymed field exn>>=
if def |> List.exists (fun (fld, _) -> Ast.is_gensymed fld)
then 
  try 
    unsugar_anon_structure_element env e0 e name def 
      |>array_to_pointer env
  with Not_found ->
    raise (Error(E.Misc(spf "not a member of struct/union: %s" name,
                        e.e_loc)))
@

% kenccext? remove it? or move to advanced topic ?
<<function [[Typecheck.unsugar_anon_structure_element]]>>=
(* X.foo --> X.|sym42|.foo *)
let rec unsugar_anon_structure_element (env : env) e0 e name def =
  
  let res = ref [] in

  def |> List.iter (fun (fldname, t) ->
    if fldname = name
    then res |> Stack_.push { e0 with e = RecordAccess (e, name); e_type = t }
    else
      if Ast.is_gensymed fldname
      then
        (match t with
        | T.StructName (_su, fullname) ->
          let (_su2, def) = Hashtbl.find env.structs_ fullname in
          (try 
             let e = 
               unsugar_anon_structure_element env e0
                 ({ e with e = RecordAccess (e, fldname); e_type = t })
                 name def
             in
             res |> Stack_.push e
           with Not_found -> ()
          )
        | _ -> raise (Impossible "checked anon elements are struct/union")
        )
      else ()
  );
  (match !res with
  | [x] -> x
  | [] -> raise Not_found
  | _x::_y::_xs ->
    raise (Error(E.Misc(spf "ambiguous unnamed structure element %s" name,
                               e.e_loc)))
  )
@

<<function [[Ast.is_gensymed]]>>=
(* see also Parser.gensym *)
let is_gensymed str = 
  str =~ "|sym[0-9]+|.*"
@




\subsection{Function calls}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| Call (e, es) ->
  (* less: should disable implicit OADDR for function here in env *)
  let e = expr newenv e in

  (match e.e_type with
  | T.Func (tret, tparams, varargs) ->
     (* we enable GetRef for array here (and functions) 
      * TODO? why not use newenv?
      *)
    let es = List.map (expr { env with expr_context = CtxWantValue }) es in

    check_args_vs_params es tparams varargs e0.e_loc;

    (* todo: add cast *)
    (* less: format checking *)
    { e0 with e = Call (e, es); 
              e_type = tret }

  | T.Pointer (T.Func (_tret, _tparams, _varargs)) ->
    (* stricter?: we could forbid it, but annoying for my print in libc.h *)
    let e = { e with e = Unary (DeRef, e); } in
    expr newenv { e0 with e = Call (e, es) }

  | _ -> type_error e.e_type e.e_loc
  )
@

%TODO: LP split
<<function [[Typecheck.check_args_vs_params]]>>=
(* 5c: was called tcoma() *)
let rec check_args_vs_params (es : expr list) tparams (varargs : bool) loc =
  match es, tparams, varargs with

  (* stricter? confusing to have foo() and foo(void) *)
  | [], ([] | [T.Void]), _ -> ()

  | [], _, _ -> 
    raise (Error (E.Misc ("not enough function arguments", loc)))

  | _e::_es, [], false -> 
    raise (Error (E.Misc ("too many function arguments", loc)))

  | e::es, [], true -> 
    (match e.e_type with
    (* ??? *)
    | T.I _ | T.F _ | T.Pointer _ | T.StructName _ -> ()
    (* TODO: enumerate possible remaining, and why type_error? *)
    | _ -> type_error e.e_type loc
    );
    check_args_vs_params es [] true loc

  | e::es, t::ts, _ ->
    (match e.e_type with
    | T.I _ | T.F _ | T.Pointer _ | T.StructName _ -> ()
    (* TODO: enumerate possible remaining, and why type_error? *)
    | _ -> type_error e.e_type loc
    );
    (try 
       (* todo: convert to int small types? see tcoma *)
       check_compatible_assign Eq_ t e.e_type e.e_loc
     with Error _ ->
       (* TODO? actual error message of 5c? *)
       raise (Error (E.Misc ("argument prototype mismatch", e.e_loc)))
    );
    check_args_vs_params es ts varargs loc
@

\subsection{Cast}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| Cast (typ, e) ->
  (* todo? set special env ADDROF|CASTOF? CASTOF seemed unused *)

  let t = type_ env typ in
  let e = expr newenv e in

  (match e.e_type, t with
  | T.I _, (T.I _ | T.F _ | T.Pointer _ | T.Void)
  | T.F _, (T.I _ | T.F _ | T.Void)
  | T.Pointer _, (T.I _ | T.Pointer _ | T.Void)
    -> ()
  (* less: seems pretty useless *)
  | T.Void, T.Void -> ()
  (* less: seems pretty useless *)
  | T.StructName (su1, _) , T.StructName (su2, _) when su1 =*= su2 -> ()
  | T.StructName _, T.Void -> ()
  | _ -> type_error2 e.e_type t e0.e_loc
  );
  { e0 with e = Cast (typ, e); 
            e_type = t } (* |> array_to_pointer ? *)
@

\subsection{Ternary expressions}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| CondExpr (e1, e2, e3) ->
  let e1 = expr newenv e1 in
  let e2 = expr newenv e2 in
  let e3 = expr newenv e3 in

  (* stricter? should enforce e1.e_type is a Bool *)
  check_compatible_binary (Logical Eq) e2.e_type e3.e_type e0.e_loc;

  (* todo: special nil handling? need? *)
  let finalt = result_type_binary e2.e_type e3.e_type in

  (* todo: add cast, and special nil handling *)
  { e0 with e = CondExpr (e1, e2, e3); 
            e_type = finalt }
@


\subsection{Prefix/postfix}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
(* ocaml-light: | Postfix (e, op) | Prefix (op, e) *)
| Postfix (_, _) | Prefix (_, _) ->
  let (e, op) =
      match e0.e with
      | Postfix (e, op) -> e, op
      | Prefix (op, e) -> e, op
      | _ -> raise (Impossible "pattern match only those cases")
  in
  let e = expr newenv e in

  if not (lvalue (e))
  then raise (Error (E.Misc ("not an l-value", e.e_loc)));

  check_compatible_binary (Arith Plus) e.e_type T.int e0.e_loc;

  (match e.e_type with
  | T.Pointer T.Void ->
    raise (Error (E.Misc ("inc/dec of a void pointer", e.e_loc)));
  | _ -> ()
  );

  { e0 with e = 
      (match e0.e with 
      | Postfix _ -> Postfix (e, op)
      | Prefix _ -> Prefix (op, e)
      | _ -> raise (Impossible "pattern match only those cases")
      ); 
      e_type = e.e_type }
@

\subsection{[[sizeof()]]}

<<[[Typecheck.expr()]] match [[e0.e]] cases>>=
| SizeOf(te) ->

  (match te with
  | Left e ->
    (* we pass a special context because if t2 mentions an array, 
     * we want the size of the array, not the size of a pointer to an array
     *)
    let e = expr { env with expr_context = CtxSizeof  } e in
    { e0 with e = SizeOf (Left e); 
              e_type = T.int }

  (* todo: build a fake expression but with the right expanded type
   * so the codegen later does not have to redo the job of expanding
   * typedefs.
   *)
  | Right typ ->
    { e0 with e = SizeOf (Right typ); 
              e_type = T.int }
  )
@

<<[[Typecheck.expr_context]] other cases>>=
| CtxSizeof
@
<<[[array_to_pointer()]] when [[Array]] case, match context cases>>=
| CtxSizeof -> e
@




\section{Statements}

<<function [[Typecheck.stmt]]>>=
(* The code below is boilerplate, mostly.
 * expr() should not do any side effect on the environment, so we can
 * call recursively in any order stmt() and expr() (including the
 * reverse order of evaluation of OCaml for arguments).
 *)
let rec stmt (env : env) (st0 : stmt) : stmt (* with exprs inside annotated *) =
  { st0 with s = 
    (match st0.s with
    <<[[Typecheck.stmt()]] match [[st0.s]] cases>>
    )
  }
@

<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
| ExprSt e -> ExprSt (expr env e)
| Block xs -> Block (List.map (stmt env) xs)
@



<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
(* stricter? should require Bool, not abuse pointer *)
| While (e, st) -> 
  While (expr env e, stmt env st)
| DoWhile (st, e) -> 
  DoWhile (stmt env st, expr env e)
@

<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
| For (e1either, e2opt, e3opt, st) ->
  (* we may have to do side effects on the environment, so we process
   * e1either first
   *)
  let e1either = 
    (match e1either with 
    | Left e1opt -> Left (expropt env e1opt)
    | Right _decls -> raise Todo
    )
  in
  For (e1either, expropt env e2opt, expropt env e3opt, stmt env st)
@


<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
| Continue -> Continue
| Break -> Break
@

<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
| Label (name, st) -> Label (name, stmt env st)
| Goto name -> Goto name
@



\subsection{[[if]]}

<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
| If (e, st1, st2) -> 
  let e = expr env e in

  (match e.e_type with
  (* ugly: no real bool type in C; abuse int, float, and worse pointers *)
  | T.I _ | T.F _ | T.Pointer _ -> ()
  (* stricter: error when does not typecheck, not just set null type on e *)
  (* TODO: list remaining cases explicitely *)
  | _ -> type_error e.e_type e.e_loc
  );
  If (e, stmt env st1, stmt env st2)
@


\subsection{[[switch]]}

<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
| Switch (e, xs) -> 
  let e = expr env e in

  (* ensure e is a number! not a pointer 
   * TODO? I originally accepted T.F _  but I think that was a bug as
   * 5c does not seem to allow it.
   *)
  (match e.e_type with
  | T.I _ -> ()
  | _ -> type_error e.e_type e.e_loc
  );
  (* TODO: do the 0:int - (0:int - x) rewrite? *)
  Switch (e, stmt env xs)
@

<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
(* less: should enforce int expr? *)
| Case (e, st) -> Case (expr env e, stmt env st)
| Default st -> Default (stmt env st)
@

\subsection{[[return]]}

<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
| Return eopt -> 
  Return 
    (match eopt with
    | None -> 
      if env.return_type =*= T.Void
      then None 
      (* stricter: error, not warn *)
      else raise (Error (E.Misc ("null return of a typed function", 
                                 st0.s_loc)))
    | Some e -> 
      let e = expr env e in
      check_compatible_assign Eq_ env.return_type e.e_type e.e_loc;
      (* todo: add cast *)
      Some e
    )
@
% return_type set when visiting function, we well see soon

%alt:\subsection{Var}
% later instead

%\section{Typechecking types}
%later in typedef expansion

\section{Declarations} %% and constant evaluation


<<function [[Typecheck.check_and_annotate_program.toplevel]]>>=
let toplevel (env : env) = function
  <<[[Typecheck.check_and_annotate_program.toplevel()]] cases>>
in
@

\subsection{Structures and unions}

<<[[Typecheck.check_and_annotate_program.toplevel()]] cases>>=
| StructDef { su_kind=su; su_name=fullname; su_loc=loc; su_flds=flds }->

  Hashtbl.add env.structs_ fullname 
    (su, flds |> List.map 
        (fun {fld_name = name; fld_loc=_; fld_type = typ } ->
          let t = type_ env typ in

          <<[[Typecheck.check_and_annotate_program()]] if gensymed name>>
          (name, t)
        )
    )
@


%TODO: move to advanced topics
<<[[Typecheck.check_and_annotate_program()]] if gensymed name>>=
(* kenccext: c99ext?:
 * less: if there are multiple anon structure elements, we 
 * could check eagerly if no ambiguous fields instead
 * of checking it when you use a field.
 *)
(match Ast.is_gensymed name, t with
| false, _ -> ()
| true, T.StructName _ -> ()
| true, _ -> 
  raise (Error (E.Misc 
         ("unnamed structure element must be struct/union", loc)))
);
@

\subsection{Enumerations}

<<[[Typecheck.check_and_annotate_program.toplevel()]] cases>>=
| EnumDef { enum_name = fullname; enum_loc = _loc; enum_constants = csts }
  ->
  (* stricter: no support for float enum constants *)
  let lastvalue = ref 0 in
  let maxt = ref (T.Int, T.Signed) in
  csts |> List.iter (fun 
    { ecst_name = fullname; ecst_loc = loc; ecst_value = eopt } ->
      (match eopt with
      | Some e ->
        (try 
           (* less: should also return an integer type *)
           let i = Eval_const.eval env.constants e in
           let t = (T.Int, T.Signed) in
           (* todo: maxt := max_types !maxt t; *)
           Hashtbl.add env.constants fullname (i, t);
           lastvalue := i;
         with Eval_const.NotAConstant ->
           raise (Error (E.Misc (spf "enum not a constant: %s"
                                        (unwrap fullname), loc)))
        )
      | None ->
        (* todo: curt *)
        let t = (T.Int ,T.Signed) in
        Hashtbl.add env.constants fullname (!lastvalue, t);
      );
      incr lastvalue
  );
  Hashtbl.add env.enums fullname !maxt
@

% Eval_const later

%%\subsection{Arrays}
% ??

\subsection{Typedef expansions}

<<[[Typecheck.check_and_annotate_program.toplevel()]] cases>>=
| TypeDef { typedef_name = fullname; typedef_loc = _loc; typedef_type =typ}->
  Hashtbl.add env.typedefs fullname (type_ env typ)
@


<<function [[Typecheck.type_]]>>=
(* Expand typedefs and resolve constant expressions. *)
let rec type_ (env : env) (typ0 : typ) : Type.t =
  match typ0.t with
  | TBase t -> t
  | TPointer typ -> T.Pointer (type_ env typ)
  | TArray (eopt, typ) ->
      (match eopt with
      | None -> T.Array (None, type_ env typ)
      | Some e ->
        (try 
           let i = Eval_const.eval env.constants e in
           T.Array (Some i, type_ env typ)
         with Eval_const.NotAConstant ->
           raise (Error
                  (E.Misc("array size must be a positive constant",typ0.t_loc)))
        )
      )
  | TFunction (tret, (tparams, tdots)) ->
      T.Func (type_ env tret, 
                tparams |> List.map (fun p -> 
                  let t = type_ env p.p_type in
                  (match t with
                  (* libc.h has a 'typedef long jmp_buf[2]' and then functions
                   * like 'int setjmp(jmp_buf)' so we need to support that.
                   * less: could warn?
                   *)
                  | T.Array (_, t) -> T.Pointer t
                  (* stricter: could transform T.Func in pointer *)
                  | T.Func _ -> type_error t p.p_loc
                  | _ -> t
                  )
                ), tdots)
  | TStructName (su, fullname) -> T.StructName (su, fullname)
  (* expand enums! *)
  | TEnumName fullname -> T.I (Hashtbl.find env.enums fullname)
  (* expand typedefs! *)
  | TTypeName fullname -> Hashtbl.find env.typedefs fullname
@

% Eval_const again later

\subsection{Variables}

\subsubsection{Local vars}

<<[[Typecheck.stmt()]] match [[st0.s]] cases>>=
| Var { v_name = fullname; v_loc = loc; v_type = typ;
        v_storage = stoopt; v_init = eopt} -> 

  let t = type_ env typ in
  let ini = expropt env eopt in
  (match t with
  (* stricter: forbid nested prototypes *)
  | T.Func _ -> 
     raise (Error(E.Misc("prototypes inside functions are forbidden",loc)));
  | _ -> ()
  );
  let sto =
    match stoopt with
    | None -> S.Local
    (* stricter? forbid? confusing anyway to shadow locals *)
    | Some S.Extern ->
      raise(Error(E.Misc 
                 ("extern declaration inside functions are forbidden",loc)))
    | Some S.Static -> 
      raise Todo
    | Some S.Local -> 
      (* stricter: I warn at least *)
      Error.warn "useless auto keyword" loc;
      S.Local
    | Some (S.Global | S.Param) -> 
      raise (Impossible "global/param are not keywords")
  in

  (match ini with
  | None -> ()
  | Some e ->
    (* less: no const checking for this assign *)
    check_compatible_assign Eq_ t e.e_type loc
    (* todo: add cast if not same type *)
  );
  Hashtbl.add env.ids_ fullname { typ = t; sto; ini; loc };

  Var { v_name = fullname; v_loc = loc; v_type = typ; v_storage = stoopt;
        v_init = ini }
@


\subsubsection{Global vars}


<<[[Typecheck.check_and_annotate_program.toplevel()]] cases>>=
(* remember that VarDecl covers also prototypes *)
| VarDecl { v_name = fullname; v_loc = loc; v_type = typ;
            v_storage = stoopt; v_init = eopt} ->
  let t = type_ env typ in
  let ini = expropt env eopt in

  (* step 0: typechecking initializer *)
  (match ini with
  | None -> ()
  | Some e ->
    (* less: no const checking for this assign *)
    check_compatible_assign Eq_ t e.e_type loc
  );

  (* step1: check for weird declarations *)
  (match t, ini, stoopt with
  | T.Func _, Some _, _ -> 
    raise (Error(E.Misc 
                 ("illegal initializer (only var can be initialized)",loc)))
  (* stricter: 5c says nothing, clang just warns *)
  | _, Some _, Some S.Extern ->
    raise (Error (E.Misc ("'extern' variable has an initializer", loc)))
  | _ -> ()
  );

  (try 
     (* step2: check for weird redeclarations *)
     let old = Hashtbl.find env.ids_ fullname in

     (* check type compatibility *)
     if not (same_types t old.typ)
     then raise (Error (E.Inconsistent (
          (* less: could dump both type using vof_type *)
           spf "redefinition of '%s' with a different type" 
             (unwrap fullname), loc,
           "previous definition is here", old.loc)))
     else
       let finalt = 
         merge_types t old.typ in
       let finalini = 
         match ini, old.ini with
         | Some x, None  -> Some x
         | None, Some x -> Some x
         | None, None -> None
         | Some _x, Some _y ->
           raise (Error (E.Inconsistent (
           spf "redefinition of '%s'" (unwrap fullname), loc,
           "previous definition is here", old.loc)))
       in
       (* check storage compatibility and compute final storage *)
       let finalsto = 
         merge_storage_toplevel (unwrap fullname) loc stoopt ini old in

       Hashtbl.replace env.ids_ fullname 
         {typ = finalt; sto = finalsto; loc = loc; ini = finalini }
   with Not_found ->
     let finalsto =
       match stoopt with
       | None -> S.Global
       | Some S.Extern -> S.Extern
       | Some S.Static -> S.Static
       | Some S.Local -> 
         raise (Error(E.Misc 
                      ("illegal storage class for file-scoped entity",loc)))
       | Some (S.Global | S.Param) -> 
         raise (Impossible "global or param are not keywords")
     in
     Hashtbl.add env.ids_ fullname 
       {typ = t; sto = finalsto; loc = loc; ini = ini }
  )
@


\subsection{Functions}


<<[[Typecheck.check_and_annotate_program.toplevel()]] cases>>=
| FuncDef ({f_name=name; f_loc=loc; f_type=ftyp; 
           f_storage=stoopt; f_body=st;} as def) ->

  (* less: lots of code in common with Var_decl; we could factorize
   * but a few things are different still.
   *)
  let t = type_ env ({t = TFunction ftyp; t_loc = loc}) in
  let fullname = (name, 0) in
  (* we use a fake initializer for function definitions to 
   * be able to store those definitions in env.ids. That way
   * we can detect function redefinitions, useless redeclarations, etc.
   *)
  let ini = Some { e = Id fullname; e_loc = loc; e_type = T.Void } in

  (try 
     (* check for weird redeclarations *)
     let old = Hashtbl.find env.ids_ fullname in

     (* check type compatibility *)
     if not (same_types t old.typ)
     then raise (Error (E.Inconsistent (
          (* less: could dump both type using vof_type *)
           spf "redefinition of '%s' with a different type" 
             (unwrap fullname), loc,
           "previous definition is here", old.loc)))
     else
       let finalt = 
         merge_types t old.typ in
       let finalini = 
         match ini, old.ini with
         | Some x, None -> Some x
         | None, Some x -> Some x
         | None, None -> None
         | Some _x, Some _y ->
           raise (Error (E.Inconsistent (
           spf "redefinition of '%s'" (unwrap fullname), loc,
           "previous definition is here", old.loc)))
       in
       (* check storage compatibility and compute final storage *)
       let finalsto = 
         merge_storage_toplevel (unwrap fullname) loc stoopt ini old in

       Hashtbl.replace env.ids_ fullname 
         {typ = finalt; sto = finalsto; loc = loc; ini = finalini }
   with Not_found ->
     let finalsto =
       match stoopt with
       | None -> S.Global
       | Some S.Static -> S.Static
       (* different than for VarDecl here *)
       | Some S.Extern -> 
         raise (Error (E.Misc ("'extern' function with initializer", loc)))
       | Some S.Local -> 
         raise (Error(E.Misc 
                      ("illegal storage class for file-scoped entity",loc)))
       | Some (S.Global | S.Param) -> 
         raise (Impossible "global or param are not keywords")
     in
     Hashtbl.add env.ids_ fullname 
       {typ = t; sto = finalsto; loc = loc; ini = ini }
  );

  (* add params in environment before process st *)
  let (tret, (tparams, _dots)) = ftyp in
  tparams |> List.iter (fun p ->
    p.p_name |> Option.iter (fun fullname ->
      let t = type_ env p.p_type in
      (match t with
      (* stricter: 5c and clang says nothing, could convert in pointer *) 
      | T.Array _ | T.Func _ -> type_error t p.p_loc
      (* todo: convert small types to int? see paramconv? *)
      | _ -> ()
      );
      Hashtbl.add env.ids_ fullname 
        {typ = t; sto = S.Param; loc = loc; ini = None }
    )
  );
  (* the expressions inside the statements are now annontated with types *)
  let st = stmt { env with return_type = type_ env tret } st in

  funcs := { def with f_body = st }::!funcs;
@



<<function [[Typecheck.merge_storage_toplevel]]>>=
(* If you declare multiple times the same global, we need to make sure
 * the storage declarations are compatible and we need to compute the
 * final (resolved) storage.
 * This function works for toplevel entities (globals but also functions).
 *)
let merge_storage_toplevel name loc stoopt ini old =
  match stoopt, old.sto with
    (* The None cases first *)
  
    (* this is ok, a header file can declare many externs and a C file
     * can then selectively "implements" some of those declarations.
     *)
    | None, S.Extern -> S.Global
    | None, S.Global ->
        (* stricter: even clang does not say anything here *)
        if ini =*= None
        then raise (Error (E.Inconsistent (
          spf "useless redeclaration of '%s'" name, loc,
          "previous definition is here", old.loc)))
        else S.Global

    (* stricter: 5c just warns for this *)
    | (None | Some S.Extern), S.Static ->
      raise (Error (E.Inconsistent (
       spf "non-static declaration of '%s' follows static declaration" name,loc,
       "previous definition is here", old.loc)))
    | _, (S.Local | S.Param) -> 
      raise (Impossible "globals can't be auto or param")

    (* The Some cases *)

    (* stricter: useless extern *)
    | Some S.Extern, (S.Global | S.Extern) ->
      raise (Error (E.Inconsistent (
        spf "useless extern declaration of '%s'" name, loc,
        "previous definition is here", old.loc)))

    | Some S.Local, _ ->
      raise (Error(E.Misc("illegal storage class for file-scoped entity", loc)))
    | Some S.Static, (S.Extern | S.Global) ->
      raise (Error (E.Inconsistent (
       spf "static declaration of '%s' follows non-static declaration" name,loc,
       "previous definition is here", old.loc)))

    | Some S.Static, S.Static ->
        if ini =*= None
        then raise (Error (E.Inconsistent (
          spf "useless redeclaration of '%s'" name, loc,
          "previous definition is here", old.loc)))
        else S.Static

    | Some (S.Global | S.Param), _ -> 
      raise (Impossible "param or global are not keywords")
@


\section{Const checking and evaluation}

<<signature [[Eval_const.eval]]>>=
(* may raise NotAConstant or Error *)
val eval: env -> Ast.expr -> integer
@

<<type [[Eval_const.env]]>>=
(* less: could do that in rewrite.ml so no need to pass is to eval *)
type env = (Ast.fullname, integer * Type.integer_type) Hashtbl.t 
@
<<type [[Eval_const.integer]]>>=
(* less: return also float at some point? *)
type integer = int
@

<<exception [[Eval_const.NotAConstant]]>>=
exception NotAConstant
@



<<exception [[Eval_const.Error]]>>=
exception Error of error
@
<<type [[Eval_const.error]]>>=
(* less: could factorize things in error.ml? *)
type error = Check.error
@
% used when?




<<function [[Eval_const.eval]]>>=
(* stricter: I do not handle float constants for enums *)
let rec eval (env : env) (e0 : expr) : integer =
  match e0.e with
  (* todo: enough for big integers? 
   * todo: we should also return an inttype in addition to the integer value.
   *)
  | Int (s, _inttype) -> int_of_string s

  | Id fullname ->
     if Hashtbl.mem env fullname
     then
       let (i, _inttype) = Hashtbl.find env fullname in
       i
     else raise NotAConstant
  | Binary (e1, op, e2) ->
    let i1 = eval env e1 in
    let i2 = eval env e2 in
    (match op with
    | Arith op -> 
      (match op with
      | Plus -> i1 + i2
      | Minus -> i1 - i2
      | Mul -> i1 * i2
      | Div -> 
        (* stricter: error, not warning *)
        if i2 = 0 
        then raise (Error (E.Misc ("divide by zero", e0.e_loc)))
        else i1 / i2
      | Mod -> 
        if i2 = 0 
        then raise (Error (E.Misc ("modulo by zero", e0.e_loc)))
        else i1 mod i2
      | And -> i1 land i2
      | Or -> i1 lor i2
      | Xor -> i1 lxor i2
      | ShiftLeft -> i1 lsl i2
      (* less: could be asr! need type information! *)
      | ShiftRight -> i1 lsr i2
      )
    | Logical op ->
      (match op with
      (* ugly: bools are considered ints in C *)
      | Eq    -> if i1 =  i2 then 1 else 0
      | NotEq -> if i1 <> i2 then 1 else 0
      | Inf   -> if i1 <  i2 then 1 else 0
      | Sup   -> if i1 >  i2 then 1 else 0
      | InfEq -> if i1 <= i2 then 1 else 0
      | SupEq -> if i1 >= i2 then 1 else 0
      | AndLog -> raise Todo
      | OrLog -> raise Todo
      )
    )
  | Unary (op, e) ->
    let i = eval env e in
    (match op with
    | UnPlus -> i
    | UnMinus -> - i
    | Tilde -> lnot i (* sure? *)
    | _ -> raise Todo
    )

  | _ -> 
    raise NotAConstant (* todo: more opporunities? *)
@





%******************************************************************************
%alt:\chapter{Backend}
%******************************************************************************

%******************************************************************************
\chapter{Assembly Generation}
%******************************************************************************



\section{Overview}


\section{Arch-specific settings}
%alt: Type width

<<type [[Arch_compiler.t]]>>=
type t = {
  width_of_type: env -> Type.t -> int;
}
@
<<type [[Arch_compiler.env]]>>=
type env = {
  (* same than Typecheck.typed_program.structs? *)
  structs: (Ast.fullname, Type.struct_kind * Type.structdef) Hashtbl.t;
}
@

<<function [[Arch5.width_of_type]]>>=
let rec width_of_type (env : Arch_compiler.env) (t : Type.t) : int =
  match t with
  | T.Void -> 0
  | T.I (inttype, _sign) ->
    (match inttype with
    | T.Char -> 1
    | T.Short -> 2
    | T.Int -> 4
    | T.Long -> 4
    | T.VLong -> 8
    )
  | T.F T.Float -> 4
  | T.F T.Double -> 8
  | T.Pointer _ -> 4

  | T.Func _ -> raise (Impossible "width of Func")
  | T.Array (iopt, t) ->
    (match iopt with
    | None -> raise (Impossible "width of incomplete array")
    | Some i -> i * width_of_type env t
    )
  | T.StructName (_su, fullname) ->
      let (_su, flds) = Hashtbl.find env.structs fullname in
      (* todo: align so extra size *)
      flds 
      |> List.map (fun (_fld, t) -> width_of_type env t)
      |> List.fold_left (+) 0
@

<<signature [[Arch5.arch]]>>=
val arch: Arch_compiler.t
@
<<constant [[Arch5.arch]]>>=
let arch = { width_of_type }
@

\section{Code generation environment}

% again, and [[env]] type, like for parsing, use/def check, typechecking,
% eval_const

<<type [[Codegen5.env]]>>=
(* Environment for code generation *)
type env = {

  (* computed by previous typechecking phase *)
  ids_:     (Ast.fullname, TC.idinfo) Hashtbl.t;
  structs_: (Ast.fullname, Type.struct_kind * Type.structdef) Hashtbl.t;

  (* less: compute offset for each field?
   * fields: (Ast.fullname * string, A.offset) Hashtbl.t
   *)

  arch: Arch_compiler.t;

  (* the output *)

  pc: Ast_asm.virt_pc ref;

  (* growing array *)
  code: (A5.instr_with_cond A.line * A.loc) array ref;
  (* should contain only DATA or GLOBL *)
  data: (A5.instr_with_cond A.line * A.loc) list ref;

  (* reinitialized for each function *)

  (* reference counting the used registers (size = 16), 
   * really a (A.register, int) Hashtbl.t;
   *)
  regs: int array;
  <<[[Codegen5.env]] other function fields>>
}
@






\section{[[codegen()]] skeleton}

<<function [[Codegen5.codegen]]>>=
let codegen (tp : Typecheck.typed_program) : Ast_asm5.program =
  let env = env_of_tp tp in
  tp.funcs |> List.iter (codegen_func env);

  (* todo: generate code for ids after, for CGLOBAL *)
  let instrs = 
    (Array.sub !(env.code) 0 !(env.pc) |> Array.to_list) @
     List.rev !(env.data)
  in
  (* TODO *)
  let locs = [] in
  instrs, locs
@

<<function [[Codegen5.env_of_tp]]>>=
let env_of_tp (tp : Typecheck.typed_program) : env =   
  {
    ids_ = tp.ids;
    structs_ = tp.structs;

    arch = Arch5.arch;

    pc = ref 0;
    code = ref [||];
    data = ref [];

    (* TODO: move in nested struct so then can reuse default_xxx () *)
    size_locals = 0;
    size_maxargs = 0;
    offset_locals = ref 0;
    offsets       = Hashtbl_.create ();
    labels        = Hashtbl_.create ();
    forward_gotos = Hashtbl_.create ();

    break_pc = None;
    continue_pc = None;

    regs          = Array.make 0 A5.nb_registers;
  }
@

<<type [[Codegen5.error]]>>=
type error = Check.error
@
<<exception [[Codegen5.Error]]>>=
exception Error of error
@


%%\section{[[pc]], [[p]], and [[nextpc()]]}

\section{Functions} %%: [[codgen()]]

%%\subsection{[[gpseudo()]]}
%%\subsection{[[gbranch()]]}
%%\subsection{[[patch()]]}
%%\subsection{Offset}

<<function [[Codegen5.codegen_func]]>>=
let codegen_func (env : env) (func : func_def) : unit =
  let { f_name=name; f_loc; f_body=st; f_type=typ; f_storage=_ } = func in

  let fullname = (name, 0) in
  let idinfo = Hashtbl.find env.ids_ fullname in
  (* todo: if Flag.profile (can be disabled by #pragma) *)
  let attrs = A.default_attr in

  let spc = add_fake_instr env "TEXT" in

  <<[[Codegen5.codegen_func()]] set [[offsets]] for parameters>>
  <<[[Codegen5.codegen_func()]] adjust [[env]]>>

  stmt env st;

  set_instr env spc 
    (A.Pseudo (A.TEXT (global_of_id env fullname, attrs, 
                       env.size_locals + env.size_maxargs))) f_loc;
  add_instr env (A.Virtual A.RET) f_loc;

  <<[[Codegen5.codegen_func()]] sanity check [[env.regs]]>>
  ()
@


<<function [[Codegen5.add_fake_instr]]>>=
let add_fake_instr env str =
  let spc = !(env.pc) in
  add_instr env (A.LabelDef (str ^ "(fake)")) fake_loc;
  spc
@

<<function [[Codegen5.set_instr]]>>=
let set_instr env pc instr loc =
  if pc >= !(env.pc)
  then failwith (spf "set_instr: pc > env.pc (%d >= %d)" pc !(env.pc));

  !(env.code).(pc) <- (instr, loc)
@


<<function [[Codegen5.add_instr]]>>=
let add_instr env instr loc =
  (* grow array if necessary *)
  if !(env.pc) >= Array.length !(env.code)
  then begin
    let increment = 100 in
    let newcode = 
      Array.make (Array.length !(env.code) + increment)  (fake_instr, fake_loc)
    in
    Array.blit !(env.code) (Array.length !(env.code)) newcode 0 0;
    env.code := newcode
  end;

  !(env.code).(!(env.pc)) <- (instr, loc);
  incr env.pc;
  ()
@

<<constant [[Codegen5.fake_instr]]>>=
let fake_instr = A.Virtual A.NOP
@
<<constant [[Codegen5.fake_loc]]>>=
let fake_loc = -1
@
<<constant [[Codegen5.fake_pc]]>>=
let fake_pc = -1
@



<<function [[Codegen5.global_of_id]]>>=
let global_of_id env fullname = 
  let idinfo = Hashtbl.find env.ids_ fullname in
  { name = Ast.unwrap fullname;
    priv = 
      (match idinfo.TC.sto with
      | S.Static -> Some (-1)
      | S.Global | S.Extern -> None
      | S.Local | S.Param ->
          raise (Impossible "global can be only Static/Global/Extern")
      );
    (* less: analyse idinfo.typ *)
    signature = None;
  }
@


<<[[Codegen5.env]] other function fields>>=
mutable size_locals: int;
mutable size_maxargs: int; (* 5c: maxargssafe *)
@
% will be modified in stmt() call by side effect

<<[[Codegen5.env]] other function fields>>=
(* for parameters and locals *)
offsets: (Ast.fullname, int) Hashtbl.t;
@

<<[[Codegen5.codegen_func()]] set [[offsets]] for parameters>>=
(* TODO: introduce helper *)
(* set offsets for parameters *)
let offsets = Hashtbl_.create () in

let (_typret, (typparams, _varargs)) = typ in

let t = idinfo.TC.typ in
let tparams = 
  match t with
  | T.Func (_tret, tparams, _varargs) -> tparams
  | _ -> raise (Impossible "not a FUNC")
in
assert (List.length tparams =|= List.length typparams);

let xs = List_.zip typparams tparams in

let offset = ref 0 in
xs |> List.iter (fun (p, t) ->
  let sizet = env.arch.width_of_type {Arch_compiler.structs = env.structs_} t in
  p.p_name |> Option.iter (fun fullname ->
    Hashtbl.add offsets fullname !offset
  );
  (* todo: align *)
  offset := !offset + sizet;
);
@  


<<[[Codegen5.codegen_func()]] adjust [[env]]>>=
(* todo: align offset_locals with return type *)
let env = { env with
  size_locals = 0;
  size_maxargs = 0;
  offset_locals = ref 0;
  offsets       = offsets;
  labels        = Hashtbl_.create ();
  forward_gotos = Hashtbl_.create ();
  regs          = Array.copy regs_initial;
}
in
@


<<[[Codegen5.codegen_func()]] sanity check [[env.regs]]>>=
(* sanity check register allocation *)
env.regs |> Array.iteri (fun i v ->
  if regs_initial.(i) <> v
  then raise (Error (E.Misc (spf "reg %d left allocated" i, f_loc)));
);
@

\section{Register allocation}

<<constant [[Codegen5.regs_initial]]>>=
let regs_initial = 
  let arr = Array.make A5.nb_registers 0 in
  (* note that rRET is not in the list; it can be used! *)
  [A5.rLINK; A5.rPC;       (* hardware reseved *)
   A5.rTMP; A5.rSB; A5.rSP; (* linker reserved *)
   rEXT1; rEXT2;         (* compiler reserved *)
  ] |> List.iter (fun (R x) ->
    arr.(x) <- 1
  );
  arr
@

<<constant [[Codegen5.rEXT1]]>>=
(* for 'extern register xx;', used in ARM kernel *)
let rEXT1 = R 10
@
<<constant [[Codegen5.rEXT2]]>>=
let rEXT2 = R 9
@
% move to Ast_asm5.ml instead?

<<function [[Codegen5.reguse]]>>=
let reguse env (A.R x) =
  env.regs.(x) <- env.regs.(x) + 1
@

<<function [[Codegen5.regfree]]>>=
let regfree env (A.R x) = 
  env.regs.(x) <- env.regs.(x) - 1;
  if env.regs.(x) < 0
  then raise (Error (E.Misc ("error in regfree", fake_loc)))
@

<<function [[Codegen5.with_reg]]>>=
let with_reg env (r : A.register) f =
  (* less: care about exn? meh, if exn then no recovery anyway *)
  reguse env r;
  let res = f () in
  regfree env r;
  res
@
% use this when you know the register you want to use,
% ex rRET


<<function [[Codegen5.regalloc]]>>=
let regalloc (env : env) loc : int =
  (* less: lasti trick? *)
  let rec aux (i : int) (n : int) : int =
    (* This happens in extreme case when the expression tree has a huge
     * depth everywhere. In that case, we should allocate a new temporary
     * on the stack but this complexifies the algorithm.
     *)
    if i >= n 
    then raise (Error(E.Misc("out of fixed registers; rewrite your code",loc)));

    (* TODO: lasti opti *)
    if env.regs.(i) =|= 0
    then begin
      env.regs.(i) <- 1;
      i
    end
    else aux (i+1) n
  in
  aux 0 (Array.length env.regs)
@

\section{Operand part 1}
% better name? 5c uses that term? or add-able?

%TODO: rename just operand? or just opd ? topd (typed operand) ?
<<type [[Codegen5.operand_able]]>>=
(* operand *)
type opd = 
 { opd: operand_kind;
   typ: Type.t;
   loc: Ast.loc;
 }
@

% something that can fit in operand of ASM instructions
% of either Move or Arith or JMP instructions.
<<type [[Codegen5.operand_able_kind]]>>=
and operand_kind =
 | ConstI of Ast_asm.integer
 | Register of Ast_asm.register

 (* indirect *)
 | Name of Ast.fullname * Ast_asm.offset
 | Indirect of Ast_asm.register * Ast_asm.offset

 (* was not "addressable" in original 5c, but I think it should *)
 | Addr of Ast.fullname
@
% can be an assembly move operand?

% and trick is if something not operand_able, then will allocate
% intermediate register and store computation for it in it, and then
% return that register which is now operand_able!

<<function [[Codegen5.opd_regalloc]]>>=
(* We can reuse a previous register if 'tgtopt' is a register.
 * See for example return.c where we can reuse R0 instead of a new R1.
 *)
let opd_regalloc (env : env) (typ : Type.t) loc (tgtopt : opd option) : opd =
  match typ with
  | T.I _ | T.Pointer _ ->
    let i = 
      match tgtopt with
      | Some { opd = Register (A.R x); typ=_; loc=_ } -> 
        reguse env (A.R x);
        x
      | _ -> regalloc env loc
    in
    { opd = Register (A.R i); typ; loc }
  | _ -> raise Todo
@

% reguse, when regfree? below


<<function [[Codegen5.opd_regfree]]>>=
(*
let opd_regalloc_opd env opd tgtopt =
  opd_regalloc env opd.typ opd.loc tgtopt
let opd_regalloc_e env e tgtopt =
  opd_regalloc env e.e_type e.e_loc tgtopt
*)
let opd_regfree env opd =
  match opd.opd with
  | Register r -> regfree env r;
  | _ -> raise (Impossible "opd_regfree on non-register operand")
@

%%\subsection{[[reg]]}
%%\subsection{[[OREGISTER]]}
%%\subsection{[[nodreg()]]}
%%\subsection{[[regfree()]]}



\section{Statements} %%: [[gen()]]

<<function [[Codegen5.stmt]]>>=
let rec stmt (env : env) (st0 : stmt) : unit =
  match st0.s with
  <<[[Codegen5.stmt]] match [[st0.s]] cases>>
@

\subsection{Local variables}
%new:

<<[[Codegen5.env]] other function fields>>=
offset_locals: int ref;
@


<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| Var { v_name = fullname; v_loc=_;v_storage=_;v_type=_;v_init=_iniTODO} ->
    let idinfo = Hashtbl.find env.ids_ fullname in
    (* todo: generate code for idinfo.ini, handle static locals, etc. *)

    (* update env.offsets *)
    let t = idinfo.TC.typ in
    let sizet = env.arch.width_of_type {Arch_compiler.structs = env.structs_} t
    in

    (* todo: align *)
    env.offset_locals := !(env.offset_locals) + sizet;
    env.size_locals <- env.size_locals + sizet;
    Hashtbl.add env.offsets fullname !(env.offset_locals);
@
% diff offset_locals and size_locals??



\subsection{Blocks, sequences}

<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| ExprSt e -> expr env e None
| Block xs -> xs |> List.iter (stmt env)
@


\subsection{Conditionals}

<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| If (e, st1, st2) ->
  let goto_else_or_end = ref (expr_cond env e) in
  if st1.s <> Block []
  then stmt env st1;
  if st2.s <> Block []
  then begin
    let goto_end = add_fake_goto env st2.s_loc in
    patch_fake_goto env !goto_else_or_end !(env.pc);
    stmt env st2;
    goto_else_or_end := goto_end;
  end;
  patch_fake_goto env !goto_else_or_end !(env.pc)
@

<<function [[Codegen5.add_fake_goto]]>>=
let add_fake_goto env loc =
  let spc = !(env.pc) in
  add_instr env (A.Instr (A5.B (ref (Absolute fake_pc)), A5.AL)) loc;
  spc
@

<<function [[Codegen5.patch_fake_goto]]>>=
let patch_fake_goto env pcgoto pcdest =
  match !(env.code).(pcgoto) with
  (* TODO? what about BL? time to factorize B | BL | Bxx ? *)
  (* ocaml-light: | A5.Instr (A5.B aref, A5.AL), _loc | A5.Instr (A5.Bxx (_, aref), A5.AL), _loc *)
  | A.Instr (A5.B aref, A5.AL), _loc ->
    if !aref =*= (Absolute fake_pc)
    then aref := Absolute pcdest
    else raise (Impossible "patching already resolved branch")
  | A.Instr (A5.Bxx (_, aref), A5.AL), _loc ->
    if !aref =*= (Absolute fake_pc)
    then aref := Absolute pcdest
    else raise (Impossible "patching already resolved branch")
  | _ -> raise (Impossible "patching non jump instruction")
@

<<function [[Codegen5.expr_cond]]>>=
(* 5c: bcomplex? () *)
let expr_cond (env : env) (e0 : expr) : virt_pc =
  (* todo: *)
  with_reg env A5.rRET (fun () ->
    let dst = { opd = Register A5.rRET; typ = e0.e_type; loc = e0.e_loc } in
    expr env e0 (Some dst);
    (* less: actually should be last loc of e0 *)
    let loc = e0.e_loc in
    add_instr env (A.Instr (A5.Cmp (A5.CMP, A5.Imm 0, A5.rRET), A5.AL)) loc;
    let pc = !(env.pc) in
    add_instr env (A.Instr (A5.Bxx (A5.EQ,(ref (A.Absolute fake_pc))),A5.AL)) loc;
    pc
  )
@

% who will adjust fake_pc? patch_fake_goto above

\subsection{Switch}
%alt: move later?

<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| Switch _ 
| Case _ | Default _ -> 
  raise Todo
@

\subsection{Labels and goto}

<<[[Codegen5.env]] other function fields>>=
(* for goto/labels *)
labels: (string, Ast_asm.virt_pc) Hashtbl.t;

(* if the label is defined after the goto, when we process the label,
 * we need to update previous goto instructions.
 *)
forward_gotos: (string, Ast_asm.virt_pc list) Hashtbl.t;
@


<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| Label (name, st) ->

  let here = !(env.pc) in
  Hashtbl.add env.labels name here;

  if Hashtbl.mem env.forward_gotos name
  then begin
    let xs = Hashtbl.find env.forward_gotos name in
    xs |> List.iter (fun xpc -> patch_fake_goto env xpc here);
    (* not really necessary because can not define the same label twice *)
    Hashtbl.remove env.forward_gotos name
  end;
  (* todo? generate dummy Goto +1? *)
  stmt env st
@

<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| Goto name ->
  let here = !(env.pc) in
  let dstpc = 
    if Hashtbl.mem env.labels name
    then Hashtbl.find env.labels name
    else begin
      Hashtbl.replace env.forward_gotos name
        (here:: (if Hashtbl.mem env.forward_gotos name
                then Hashtbl.find env.forward_gotos name
                else []));
      fake_pc
    end
  in
  add_instr env (A.Instr (A5.B (ref (A.Absolute dstpc)), A5.AL)) st0.s_loc;
@

\subsection{Loops}

<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| While (e, st) ->
  let goto_entry        = add_fake_goto env e.e_loc in
  let goto_for_continue = add_fake_goto env e.e_loc in
  let goto_for_break    = add_fake_goto env e.e_loc in
  patch_fake_goto env goto_for_continue !(env.pc);
  patch_fake_goto env goto_entry !(env.pc);
  
  let goto_else = expr_cond env e in
  patch_fake_goto env goto_else goto_for_break;

  let env = { env with 
    break_pc = Some goto_for_break; 
    continue_pc = Some goto_for_continue;
  }
  in
  stmt env st;

  (* less: should be last loc of st? *)
  let loc = e.e_loc in
  add_instr env (A.Instr (A5.B (ref(A.Absolute goto_for_continue)), A5.AL)) loc;
  patch_fake_goto env goto_for_break !(env.pc)
@

<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| DoWhile (st, e) ->

  let goto_entry        = add_fake_goto env e.e_loc in
  let goto_for_continue = add_fake_goto env e.e_loc in
  let goto_for_break    = add_fake_goto env e.e_loc in
  patch_fake_goto env goto_for_continue !(env.pc);
  (* for a while: patch_fake_goto env goto_entry env.pc; *)
  
  let goto_else = expr_cond env e in
  patch_fake_goto env goto_else goto_for_break;
  (* for a dowhile! *)
  patch_fake_goto env goto_entry !(env.pc);

  let env = { env with 
    break_pc = Some goto_for_break; 
    continue_pc = Some goto_for_continue;
  }
  in
  stmt env st;

  (* less: should be last loc of st? *)
  let loc = e.e_loc in
  add_instr env (A.Instr (A5.B (ref(A.Absolute goto_for_continue)), A5.AL)) loc;
  patch_fake_goto env goto_for_break !(env.pc)
@

<<[[Codegen5.env]] other function fields>>=
(* for loops (and switch) *)
(* reinitialized for each block scope *)
break_pc: Ast_asm.virt_pc option;
continue_pc: Ast_asm.virt_pc option;
@


<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| Break -> 
  (match env.break_pc with
  | Some dst ->
    add_instr env (A.Instr (A5.B (ref(A.Absolute dst)), A5.AL)) st0.s_loc;
  | None -> raise (Impossible "should be detected in check.ml")
  )
| Continue ->
  (match env.continue_pc with
  | Some dst ->
    add_instr env (A.Instr (A5.B (ref(A.Absolute dst)), A5.AL)) st0.s_loc;
  | None -> raise (Impossible "should be detected in check.ml")
  )
@

<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| For (e1either, e2opt, e3opt, st) ->
  (match e1either with
  | Left e1opt -> expropt env e1opt
  (* todo: scope, should reset autoffset once processed loop *)
  | Right decls -> 
    decls |> List.iter (fun var -> stmt env { s = Var var; s_loc=var.v_loc});
  );
  let goto_entry        = add_fake_goto env st0.s_loc in
  let goto_for_continue = add_fake_goto env st0.s_loc in
  let goto_for_break    = add_fake_goto env st0.s_loc in

  patch_fake_goto env goto_for_continue !(env.pc);
  expropt env e3opt;
  patch_fake_goto env goto_entry !(env.pc);
  (match e2opt with
  | None -> ()
  | Some e2 -> 
    let goto_else = expr_cond env e2 in
    patch_fake_goto env goto_else goto_for_break;
  );
  
  let env = { env with 
    break_pc = Some goto_for_break; 
    continue_pc = Some goto_for_continue;
  }
  in
  stmt env st;

  let loc = st0.s_loc in
  add_instr env (A.Instr (A5.B (ref(A.Absolute goto_for_continue)), A5.AL)) loc;
  patch_fake_goto env goto_for_break !(env.pc)
@

\subsection{Control flow jumps}

<<constant [[Codegen5.rRET]]>>=
@

<<[[Codegen5.stmt]] match [[st0.s]] cases>>=
| Return eopt ->
  (match eopt with
  | None ->
    add_instr env (A.Virtual A.RET) st0.s_loc

  | Some e ->
    (* todo: if type compatible with R0 *)
    with_reg env A5.rRET (fun () ->
      let dst = { opd = Register A5.rRET; typ = e.e_type; loc = e.e_loc } in
      expr env e (Some dst);

      add_instr env (A.Virtual A.RET) st0.s_loc
    )
  )
@


\section{Basic expressions}

%trans: seen stmts, and preview of expr with expr_cond in if, or
% return eopt, let's see expr now.


<<function [[Codegen5.expr]]>>=
(* todo: inrel ? 
 * todo: if complex type node
 * 5c: called cgen/cgenrel()
 *)
let rec expr (env : env) (e0 : expr) (dst_opd_opt : opd option) : unit=
  match operand_able e0 with
  | Some opd1 -> gmove_opt env opd1 dst_opd_opt
  | None ->
    (match e0.e with
    | Int _ | Float _ | Id _ ->
        raise (Impossible "handled in operand_able()")
    | String _ | ArrayAccess _ | RecordPtAccess _ | SizeOf _ -> 
        raise (Impossible "should have been converted before")    
    <<[[Codegen5.expr()]] when not operand able, match [[e0.e]] cases>>
    | RecordAccess _ | Cast _ | Postfix _ | Prefix _
    | CondExpr _ | ArrayInit _ | RecordInit _ | GccConstructor _
      -> 
      Logs.err (fun m -> m "%s" (Dumper_.s_of_any (Expr e0)));
      raise Todo
    )
@

<<function [[Codegen5.expropt]]>>=
let expropt (env : env) (eopt : expr option) : unit =
  match eopt with
  | None -> ()
  | Some e -> expr env e None
@

\subsection{Operand part 2}

<<function [[Codegen5.operand_able]]>>=
let operand_able (e0 : expr) : opd option =
  let kind_opt = 
    match e0.e with
    | String _ | ArrayAccess _ | RecordPtAccess _ | SizeOf _ -> 
      raise (Impossible "should have been converted")
    <<[[operand_able()]] match [[e0.e]] cases>>
  in
  match kind_opt with
  | None -> None
  | Some opd -> Some { opd; typ = e0.e_type; loc = e0.e_loc }
@


<<[[operand_able()]] match [[e0.e]] cases>>=
(* less: could be operand_able if we do constant_evaluation later *)
| Binary (_e1, _op, _e2) -> None
| Call _ | Assign _ | Postfix _ | Prefix _ | CondExpr _ | Sequence _
  -> None

| Cast _ -> raise Todo
| RecordAccess _ -> raise Todo

| ArrayInit _ | RecordInit _ | GccConstructor _ -> 
  None
@


\subsection{Numeric constants}

<<[[operand_able()]] match [[e0.e]] cases>>=
| Int (s, _inttype) -> Some (ConstI (int_of_string s))
@

<<[[operand_able()]] match [[e0.e]] cases>>=
(* todo: float handling *)
| Float _ -> None
@


\subsection{Entity uses}

<<[[operand_able()]] match [[e0.e]] cases>>=
| Id fullname -> Some (Name (fullname, 0))
@

\subsection{Pointers part1}


%XXXX
<<[[operand_able()]] match [[e0.e]] cases>>=
| Unary (op, e) ->

  (match op with

  (* special case to handle *(&arr + <cst>) *)
  | DeRef  ->

    (match e.e with
    (* less: this should be handled in rewrite.ml *(&x) ==> x *)
    | (Unary (GetRef, { e = Id fullname; e_loc=_;e_type=_ })) -> Some (Name (fullname, 0))
    (* less: should normalize constant to left or right in rewrite.ml *)
    | Binary ({ e = Int (s1, _); e_loc=_;e_type=_ }, 
              Arith Plus, 
              {e = (Unary (GetRef, { e = Id fullname; e_loc=_;e_type=_ })); e_loc=_;e_type=_ })
      -> Some (Name (fullname, int_of_string s1))
    | Binary ({e = (Unary (GetRef, { e = Id fullname; e_loc=_;e_type=_ })); e_loc=_;e_type=_ }, 
              Arith Plus, 
              { e = Int (s1, _); e_loc=_;e_type=_a })
      -> Some (Name (fullname, int_of_string s1))
    | _ -> None
    )

  | GetRef -> 

    (match e.e with
    (* why 5c does not make OADDR (ONAME) an addressable node? *)
    | Id fullname -> Some (Addr fullname)
    | _ -> None
    )

  | (UnPlus | UnMinus | Tilde) -> 
    raise (Impossible "should have been converted")
  | Not -> None
  )
@


\subsection{[[gmove()]]}

<<function [[Codegen5.gmove_opt]]>>=
let gmove_opt (env : env) (opd1 : opd) (opd2opt : opd option) :
    unit = 
  match opd2opt with
  | Some opd2 -> gmove env opd1 opd2
  | None ->
    (* SURE? should we still registerize and all? *)
    (* less: should have warned about unused opd in check.ml *)
    ()
@

<<function [[Codegen5.gmove]]>>=
(* Even though two arguments are operand_able, it does not mean
 * we can move one into the other with one instruction. 
 * In theory, 5a supports general MOVW, but 5l restricts those
 * MOVW to only store and load (not both at the same time).
 * This is why we must decompose below the move in 2 instructions
 * sometimes.
 *)
let rec gmove (env : env) (opd1 : opd) (opd2 : opd) : unit =
  match opd1.opd with

  (* a load *)
  | Name _ | Indirect _ ->
    let move_size = 
      match opd1.typ with
      | T.I (T.Int, _) | T.Pointer _ -> A.Word
      | _ -> raise Todo
    in
    (* less: opti which does opd_regfree env opd2 (Some opd2)? worth it? *)
    let opd1reg = opd_regalloc env opd1.typ opd1.loc (Some opd2) in
    gmove_aux env move_size opd1 opd1reg;
    gmove env opd1reg opd2;
    opd_regfree env opd1reg

  | ConstI _ | Register _ | Addr _  ->

    (match opd2.opd with

    (* a store *)
    | Name _ | Indirect _ ->
      let move_size =
        match opd2.typ with
        | T.I (T.Int, _) | T.Pointer _ -> A.Word
        | _ -> raise Todo
      in
      (* less: opti which does opd_regfree env opd2 (Some opd1)?? *)
      let opd2reg = opd_regalloc env opd2.typ opd2.loc None in
      gmove env opd1 opd2reg;
      gmove_aux env move_size opd2reg opd2;
      opd_regfree env opd2reg

    | ConstI _ | Register _ | Addr _ -> 

      (* the simple cases *)
      let move_size = 
        match opd1.typ, opd2.typ with
        | T.I (T.Int, _), T.I (T.Int, _) -> A.Word
        | T.Pointer _, T.Pointer _ -> A.Word
        (* todo: lots of opti related to float *)
        | _ -> raise Todo
      in
      gmove_aux env move_size opd1 opd2
    )

(* At this point, either opd1 or opd2 references memory (but not both),
 * so we can do the move in one instruction.
 * 5c: called gins()
 *)
and gmove_aux env move_size (opd1 : opd) (opd2 : opd) : unit =
  (* less: should happen only for register? *)
  if opd1.opd =*= opd2.opd
  then ()
  else 
  add_instr env 
    (A.Instr (A5.MOVE (move_size, None, 
                      mov_operand_of_opd env opd1,
                      mov_operand_of_opd env opd2), A5.AL)) opd1.loc
@


<<function [[Codegen5.mov_operand_of_opd]]>>=
(* 5c: part of naddr()
 * less: opportunity for bitshifted registers? *)
let mov_operand_of_opd (env : env) (opd : opd) : A5.mov_operand =
  match opd.opd with
  | ConstI i   -> A5.Imsr (A5.Imm i)
  | Register r -> A5.Imsr (A5.Reg r)
  | Name (fullname, offset) -> A5.Entity (entity_of_id env fullname offset)
  | Indirect (r, offset) -> A5.Indirect (r, offset)
  | Addr fullname -> A5.Ximm (A.Address (entity_of_id env fullname 0))
@


<<function [[Codegen5.entity_of_id]]>>=
let entity_of_id env fullname offset_extra =
  let idinfo = Hashtbl.find env.ids_ fullname in
  match idinfo.TC.sto with
  | S.Param -> 
    let offset = Hashtbl.find env.offsets fullname + offset_extra in
    Param (Some (symbol fullname), offset)
  | S.Local ->
    let offset = Hashtbl.find env.offsets fullname + offset_extra in
    (* - offset for locals *)
    A.Local (Some (symbol fullname), - offset)
  | S.Static | S.Global | S.Extern ->
    let offset = offset_extra in
    A.Global (global_of_id env fullname, offset)
@

<<function [[Codegen5.symbol]]>>=
let symbol fullname = Ast.unwrap fullname
@

%%\subsection{Conversions}
%%\subsection{[[gins()]]}
%%\subsection{[[naddr()]]}
%%\subsection{[[regalloc()]]}

%%\subsection{Typechecking, expliciting, annotating, and rewriting}%%: [[complex()]]}
%%\subsection{Addressability and complexity}%%: [[xcom()]]
%%\subsubsection{Addressable} %%: [[INDEXED]]
% ??
%%\subsubsection{Addressability} %%: [[addable]]
% addressability? bad term? operand_ability better?



\section{Complex expressions} %: [[cgen()]]

%trans: when not operand able, what do we do?

<<[[Codegen5.expr()]] when not operand able, match [[e0.e]] cases>>=
| Sequence (e1, e2) -> 
  expr env e1 None;
  expr env e2 dst_opd_opt
@

\subsection{Complexity} %%: [[complex]]

%%\subsection{[[FNX]]}

<<constant [[Codegen5.fn_complexity]]>>=
let fn_complexity = 100 
@

% =~ depth of expression tree
<<function [[Codegen5.complexity]]>>=
(* less: could optimize by caching result in node, so no need
 * call again complexity on subtree later
 *)
let rec complexity (e : expr) : int =
  if operand_able e <> None
  then 0
  else 
    match e.e with
    | Int _ | Float _ | String _ | Id _ -> 0
    | Call _ -> fn_complexity
    | Assign _ | ArrayAccess _ | Binary _ | Sequence _ ->
      let (e1, e2) =
        match e.e with
        | Assign (_, e1, e2) -> e1, e2
        | ArrayAccess (e1, e2) -> e1, e2
        | Binary (e1, _, e2) -> e1, e2
        | Sequence (e1, e2) -> e1, e2
        | _ -> raise (Impossible "see pattern match above")
      in
      let n1 = complexity e1 in
      let n2 = complexity e2 in
      if n1 =|= n2
      then 1 + n1
      else max n1 n2

    | CondExpr (e1, e2, e3) -> 
      complexity {e with e = Sequence (e1, { e with e = Sequence (e2, e3) } ) }

    | RecordAccess _ | RecordPtAccess _ | Cast _ | Postfix _ | Prefix _ | Unary _
      -> 
       let e =
         match e.e with
         | RecordAccess (e, _) -> e
         | RecordPtAccess (e, _) -> e
         | Cast (_, e) -> e
         | Postfix (e, _) -> e
         | Prefix (_, e) -> e
         | Unary (_, e) -> e
         | _ -> raise (Impossible "see pattern match above")
      in
      let n = complexity e in
      if n =|= 0 then 1 else n
    (* should be converted in Int anyway *)
    | SizeOf _ -> 0

    | ArrayInit _ | RecordInit _ | GccConstructor _ -> raise Todo
@

\subsection{String constants}


\subsection{Arithmetic expressions}

<<[[Codegen5.expr()]] when not operand able, match [[e0.e]] cases>>=
(* less: lots of possible opti *)
| Binary (e1, op, e2) ->

  (match op with
  | Arith (Plus | Minus 
          | And | Or | Xor 
          | ShiftLeft | ShiftRight
          | Mul | Div | Mod) ->

    let n1 = complexity e1 in
    let n2 = complexity e2 in

    let opdres, opdother = 
      if n1 >= n2
      then begin
        let opd1reg = opd_regalloc env e1.e_type e1.e_loc dst_opd_opt in
        expr env e1 (Some opd1reg);
        let opd2reg = opd_regalloc env e2.e_type e2.e_loc None in
        expr env e2 (Some opd2reg);
        (match opd1reg.opd, opd2reg.opd with
        | Register r1, Register r2 ->
          (* again reverse order SUB r2 r1 ... means r1 - r2 *)
          add_instr env (A.Instr (arith_instr_of_op op r2 r1 r1, A5.AL)) 
            e0.e_loc;
        | _ -> raise (Impossible "both operands comes from opd_regalloc")
        );
        opd1reg, opd2reg
      end
      else begin
        let opd2reg = opd_regalloc env e2.e_type e2.e_loc dst_opd_opt in
        expr env e2 (Some opd2reg);
        let opd1reg = opd_regalloc env e1.e_type e1.e_loc None in
        expr env e1 (Some opd1reg);
        (match opd1reg.opd, opd2reg.opd with
        | Register r1, Register r2 ->
          (* This time we store result in r2! important and subtle.
           * This avoids some extra MOVW; see plus_chain.c
           *)
          add_instr env (A.Instr (arith_instr_of_op op r2 r1 r2, A5.AL)) 
            e0.e_loc;
        | _ -> raise (Impossible "both operands comes from opd_regalloc")
        );
        opd2reg, opd1reg
      end
    in
    (* This is why it is better for opdres to be the register
     * allocated from dst_opd_opt so the MOVW below can become a NOP
     * and be removed.
     *)
    gmove_opt env opdres dst_opd_opt;

    opd_regfree env opdres;
    opd_regfree env opdother;
        
  | Logical _ ->
    raise Todo
  )
@

<<function [[Codegen5.arith_instr_of_op]]>>=
let arith_instr_of_op op r1 r2 r3 =
  A5.Arith (
    (match op with
    | Arith op ->
      (match op with 
      | Plus -> A5.ADD | Minus -> A5.SUB
      | And -> A5.AND | Or -> A5.ORR | Xor -> A5.EOR
      (* todo: need type info for A.SLR *)
      | ShiftLeft -> A5.SLL | ShiftRight -> A5.SRA
      (* todo: need type info for A.MULU, etc *)
      | Mul -> A5.MUL | Div -> A5.DIV | Mod -> A5.MOD
      )
    | Logical _ -> raise Todo
    ),
    None, 
    A5.Reg r1, Some r2, r3
  )
@


\subsection{Boolean expressions}

\subsection{Assignments part 1}

<<[[Codegen5.expr()]] when not operand able, match [[e0.e]] cases>>=
| Assign (op, e1, e2) ->
  (match op with
  | Eq_ ->
    (match operand_able e1, operand_able e2, dst_opd_opt with
    (* ex: x = 1; *)
    | Some opd1, Some opd2, None -> 
      (* note that e1=e2 -->  MOVW opd2,opd1, (right->left -> left->right)*)
      gmove env opd2 opd1

    (* ex: return x = 1;, x = y = z, ... *)
    | Some _opd1, Some _opd2, Some _dst ->
      raise Todo


    (* ex: y = &x;, y = x + y, ... *)
    | Some opd1, None, None ->
      let opd2reg = opd_regalloc env e2.e_type e2.e_loc None in
      expr env e2 (Some opd2reg);
      gmove env opd2reg opd1;
      opd_regfree env opd2reg;

    (* ex: return x = x+y;, x = y = z, ... *)
    | Some opd1, None, Some dst ->
      let opd2reg = opd_regalloc env e2.e_type e2.e_loc None in
      expr env e2 (Some opd2reg);
      gmove env opd2reg opd1;
      gmove env opd2reg dst; (* only diff with case above *)
      opd_regfree env opd2reg;


    (* ex: *x = 1; *)
    | None, _, _ ->
      raise Todo
    )
  | OpAssign _op ->
    raise Todo
  )
@


\subsection{Pointers part2}

<<[[Codegen5.expr()]] when not operand able, match [[e0.e]] cases>>=
| Unary (op, e) ->

  (match op with
  | GetRef -> 
    (match e.e  with
    | Id _fullname -> 
      raise (Impossible "handled in operand_able()")
    | Unary (DeRef, _) ->
      raise (Impossible "should be simplified in rewrite.ml")
    | _ -> 
      raise (Impossible "not an lvalue?")
    )

  | DeRef ->
    (* less: opti of Deref of Add with constant? *)
    let opd1reg = opd_regalloc env e.e_type e.e_loc dst_opd_opt in
    expr env e (Some opd1reg);
    gmove_opt env
      (match opd1reg.opd with
      | Register r -> { opd = Indirect (r, 0); loc = e.e_loc;
                        typ = e0.e_type }
      | _ -> raise (Impossible "opd_regalloc_e returns always Register")
      ) dst_opd_opt;
    opd_regfree env opd1reg;
    

  | (UnPlus | UnMinus | Tilde) -> 
    raise (Impossible "should have been converted")
  | Not -> raise Todo
  )
| Call (e, es) ->
    if complexity e >= fn_complexity
    then 
      (* (foo(...))(...), so function call in e itself *)
      raise Todo
    else begin
      arguments env es;
      (match operand_able e with
      (* complex call *)
      | None -> raise Todo
      | Some opd ->
         add_instr env (A.Instr (A5.BL (ref (branch_operand_of_opd env opd)),
                                 A5.AL)) e0.e_loc;
         dst_opd_opt |> Option.iter (fun dst_opd ->
            with_reg env A5.rRET (fun () ->
                (* TODO? need Cast? 5c does gopcode(OAS, ...) *)
                let src_opd = { opd = Register A5.rRET; typ = e0.e_type;
                                loc = e0.e_loc;} in
                gmove env src_opd dst_opd
            );
         );
             
      );
      ()
    end
@

\subsection{Assignments part 2}

\subsection{Assignments and arithmetic}

\subsection{Function calls}

\subsection{Array accesses}

\subsection{Field accesses}

\subsection{Cast}

\subsection{Ternary expressions}

\subsection{Prefix/postfix}

\subsection{[[sizeof()]]}




\section{Boolean expressions}




\section{Other topics}

\subsection{Sizes}

\subsection{First argument}

\subsection{Alignment}

\subsection{Toplevel globals}

\subsection{Initializers}

%%\subsection{[[gextern()]]}



\section{Advanced assembly generation}

\subsection{Function calls}

\subsection{Switch}


%******************************************************************************
\chapter{Object File Generation}
%******************************************************************************

\section{Object format}

\section{Instruction output} %%: [[outcode()]]

%%\section{Operand output: [[zaddr()]]}
%%\section{Symbol table, [[zname()]], [[h]] and [[ANAME]]}
%%\section{File and line information: [[outhist()]]}

%******************************************************************************
\chapter{AST-level Optimizations}
%******************************************************************************

\section{AST simplifications}

\subsection{General rewrites}%%: [[ccom()]]

\subsection{Constant evaluation}%%: [[evconst()]]

\section{Comma hoisting}%: [[comma()]]

\section{Bitshifting opportunities}

\section{And opportunities}

\section{Immediate operands}

\subsection{Substraction}

\subsection{Addition, or, etc.}

\subsection{Multiplication}

\section{Associative-commutative arithmetic optimisations}

%%\subsection{[[Term]]}
%%\subsection{[[acom()]]}

%******************************************************************************
\chapter{Assembly-level Optimisations}
%******************************************************************************

\section{Nop detection}

\section{ARM special instructions}

\section{Register passing argument: [[REGARG]]}

\section{Register allocation optimisations}

%%\subsection{[[regopt()]]}
%%\subsection{[[noretval()]]}
%%\subsection{Pass 1}
%%\subsection{Pass 2}
%%\subsection{Pass 3}
%%\subsection{Pass 4}
%%\subsection{pass 5}
%%\subsection{pass 6}
%%\subsection{pass 7, peep hole optimizations}
%%\subsection{pass 8}
%%\subsection{pass 9}
%%\subsection{[[Bits]]}
%%\subsection{[[Var]]}
%%\subsection{[[Reg]]}
%%\subsection{[[XXX]]}

\section{Peephole optimizer}%%: [[peep()]]

\section{Dominators}


%******************************************************************************
\chapter{Linking Support}
%******************************************************************************

\section{[[#pragma lib]] and automagic linking}

\section{Safe linking with type signatures: [[5c -T]]}

\subsection{[[sign()]]}

\subsection{[[#pragma incomplete]]}

%******************************************************************************
\chapter{Debugging Support}
%******************************************************************************

\section{General debugging metadata}

\section{Acid debugger metadata: [[5c -a]]}

\subsection{Entities}

\subsection{Structure/union definitions}

\section{Pickle: [[5c -Z]]}

%******************************************************************************
\chapter{Profiling Support}
%******************************************************************************

\section{Text attributes}

\section{[[#pragma profile]]}



%******************************************************************************
\chapter{Preprocessing}
%******************************************************************************
\label{chap:preprocessing}
%alt: in appendix
%  but core part of C (c without cpp will have died)
%alt: earlier, between lexing and parsing or even before lexing
% but better later I think as already lots of things to understand first

%trans:
% c without cpp will have died

%toc:

\section{Overview}

<<signature [[Parse_cpp.parse]]>>=
(* Wrapper function around a parser/lexer.
 *
 * Regarding Cap.open_in, [parse] will [open_in] the passed file parameter but
 * may also [open_in] other files as [parse] will recursively process
 * [#include] directives.
 *)
val parse: 
  < Cap.open_in; .. > ->
  ('token, 'ast) hook -> Preprocessor.conf -> Fpath.t -> 
  'ast * Location_cpp.location_history list
@

% will see those data structures next section (hook, conf, history).
% polymorphic because used by assembler and compiler with different
% AST and token each time, but can reuse most of the code

%%\section{[[mactab]] and [[domacro()]] dispatch}

\section{Core data structures}

\subsection{Preprocessor configuration}

<<type [[Preprocessor.conf]]>>=
type conf = {
  (* -D *)
  defs: (string * string) list;
  (* -I + system paths (e.g., /usr/include) *)
  paths: Fpath.t list;
  (* the directory of the C file so it is looked for "" but not for <> *)
  dir_source_file: Fpath.t;
}
@

<<[[CLI.main()]] main code path, define macropreprocessor [[conf]]>>=
let system_paths : Fpath.t list =
  <<[[CLI.main()]] main code path, define [[system_paths]]>>
in
let conf = Preprocessor.{
  defs = !macro_defs;
  (* this order? *)
  paths = system_paths @ List.rev !include_paths;
  dir_source_file = Fpath.v (Filename.dirname cfile);
}
in
@

<<[[CLI.main()]] main code path, define [[system_paths]]>>=
  (try CapSys.getenv caps "INCLUDE" |> Str.split (Str.regexp "[ \t]+")
  with Not_found ->
    [spf "/%s/include" thestring; 
     "/sys/include";
    ] |> (fun xs -> if !ape then "/sys/include/ape"::xs else xs)
  ) |> Fpath_.of_strings
@

<<[[CLI.main()]] other locals>>=
(* Ansi Posix Environment for plan9 *)
let ape = ref false in 
@
<<[[CLI.main()]] [[options]] elements>>=
"-ape", Arg.Set ape,
" ";
@



\subsection{Directives AST}

<<type [[Ast_cpp.directive]]>>=
type directive =
  | Include of Fpath.t * bool (* true if <>, false if "" *)

  | Define of macro
  | Undef of string

  | Ifdef of string
  | Ifndef of string
  | Else
  | Endif

  | Line of int * Fpath.t
  (* ex: #pragma lib "libc.a" -> Pragma("lib", ["libc.a"]) *)
  | Pragma of string * string list
@

<<type [[Ast_cpp.macro]]>>=
  and macro = {
    name: string;
    (* Note that you can have None or Some [] for parameters.
     * The first is a macro without parameter, the second a macro with 
     * 0 parameters (but that still needs to be called by FOO())
     *)
    params: string list option;
    varargs: bool;
    (* The body below has been processed and every parameter occurence
     * is replaced by a #xxx where xxx is the number corresponding to the
     * ith parameter.
     *)
    body: string option
  }
@

\subsection{Location and line history}

<<signature [[Location_cpp.history]]>>=
(* both should be reseted each time you parse a new file *)
val history: location_history list ref
@

<<signature [[Location_cpp.line]]>>=
val line: loc ref
@


<<type [[Location_cpp.loc]]>>=
(* global line number, after pre-processing *)
type loc = int
@

<<type [[Location_cpp.final_loc]]>>=
(* final readable location *)
type final_loc = Fpath.t * int
@

<<type [[Location_cpp.location_history]]>>=
type location_history = {
  location_event: location_event;
  global_line: loc;
}
@

<<type [[Location_cpp.location_event]]>>=
  and location_event =
    (* #include "foo.h" *)
    | Include of Fpath.t
    (* #line 1 "foo.c" *)
    | Line of int * Fpath.t
    (* end of #include, back to includer *)
    | Eof
@

<<constant [[Location_cpp.history]]>>=
let history = ref []
@

<<constant [[Location_cpp.line]]>>=
(* Global line number (after pre-processing).
 * Note that you need another data structure to map a global line number 
 * to a (file, line) pair (see history and final_loc_of_loc below).
 *)
let line = ref 1
@

\subsection{Parser hook}

<<type [[Parse_cpp.token_category]]>>=
type token_category =
  | Eof
  | Sharp
  | Ident of string
  | Other
@

<<type [[Parse_cpp.hook]]>>=
type ('token, 'ast) hook = {
  lexer: Lexing.lexbuf -> 'token;
  parser: (Lexing.lexbuf -> 'token) -> Lexing.lexbuf -> 'ast;
  category: 'token -> token_category;
  (* TODO: delete, redundant with Eof token_category above *)
  eof: 'token;
}
@

<<function [[Parse.parse]]>>=
let parse (caps : < Cap.open_in; .. >) (conf : Preprocessor.conf) (file : Fpath.t) : Ast.program = 
  let hooks = Parse_cpp.{
     lexer = Lexer.token;
     category = (fun t ->
       match t with
       | T.EOF    -> Parse_cpp.Eof
       | T.TSharp -> Parse_cpp.Sharp

       (* ocaml-light: | T.TName (_, s) | T.TTypeName (_, s) *)
       | T.TName (_, s)  -> Parse_cpp.Ident s
       | T.TTypeName (_, s) -> Parse_cpp.Ident s
        (* stricter: I forbid to have macros overwrite keywords *)
        (*
        | T.Tvoid | T.Tchar | T.Tshort | T.Tint | T.Tlong
        | T.Tdouble | T.Tfloat | T.Tsigned | T.Tunsigned
        | T.Tstruct | T.Tunion | T.Tenum | T.Ttypedef
        | T.Tconst | T.Tvolatile | T.Trestrict | T.Tinline
        | T.Tauto | T.Tstatic | T.Textern | T.Tregister
        | T.Tif | T.Telse | T.Twhile | T.Tdo | T.Tfor 
        | T.Tbreak | T.Tcontinue | T.Treturn | T.Tgoto
        | T.Tswitch | T.Tcase | T.Tdefault | T.Tsizeof
        *)
       | _ -> Parse_cpp.Other
     );
   parser = Parser.prog;
   eof = T.EOF;
  }
  in
  Parse_cpp.parse caps hooks conf file
@


\section{Lexing}

<<macroprocessor/Lexer_cpp.mll>>=
{
(* Copyright 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Regexp_.Operators

open Ast_cpp
module L = Location_cpp

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* A port of plan 9 builtin preprocessing in OCaml.
 *
 * The main functions of the text preprocessors are:
 *  - including other files
 *  - expanding macros
 *  - skipping text inside ifdefs
 * 
 *
 * Limitations compared to cpp:
 *  - no support for unicode
 * 
 * stricter: 
 *  - no space allowed between '#' and the directive
 *    (even though some people like to do  '#  ifdef', when have nested ifdefs,
 *     but nested ifdefs are bad practice anyway)
 *  - single '#' are not converted in #endif
 *    (who does use that?)
 *  - only space or comment between the directive and the newline; 
 *    we do not skip any character
 *    (who does put garbage there?)
 *)

let error s =
  raise  (L.Error (spf "Lexical error in cpp: %s" s, !L.line))

(* needed only because of ocamllex limitations in ocaml-light
 * which does not support the 'as' feature.
 *)
let symbol_after_space lexbuf =
  let s = Lexing.lexeme lexbuf in
  s =~ ".*[ \t]\\([^ \t]+\\)" |> ignore; 
  Regexp_.matched1 s
let char lexbuf =
  let s = Lexing.lexeme lexbuf in
  String.get s 0

}

(*****************************************************************************)
(* Regexps aliases *)
(*****************************************************************************)
let space  = [' ''\t']
let letter = ['a'-'z''A'-'Z']
let digit  = ['0'-'9']

let symbol = (letter | '_') (letter | digit | '_')*

(*****************************************************************************)
(* Main rule *)
(*****************************************************************************)

(* pre: 'token' below assumes the '#' has already been consumed *)
rule token = parse

  (* note that filenames containing double quotes are not supported *)
  | "include" space* '"' ([^ '"' '\n']+ (*as file*)) '"'
      { let file = 
          let s = Lexing.lexeme lexbuf in s =~ ".*\"\\(.*\\)\"" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Include (Fpath.v file, false)  
      }
  | "include" space* '<' ([^ '>' '\n']+ (*as file*)) '>'
      { let file = 
          let s = Lexing.lexeme lexbuf in s =~ ".*<\\(.*\\)>" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Include(Fpath.v file, true) 
      }
  | "include" { error "syntax in #include" }

  (* Macro definition part 1 *)
  | "define" space+ (symbol (*as s1*)) '(' ([^')']* (*as s2*)) ')'
      { let (s1, s2) =
           let s = Lexing.lexeme lexbuf in s =~ "define[ \t]+\\(.*\\)(\\(.*\\))" |> ignore;
           Regexp_.matched2 s in
        let xs = Str.split (Str.regexp "[ \t]*,[ \t]*") s2 in
        (* check if identifier or "..." for last one *)
        let params, varargs = 
          let rec aux xs =
            match xs with
            | [] -> [], false
            (* todo: __VA_ARGS__ *)
            | ["..."] -> [], true
            | "..."::_ -> error "... should be the last parameter of a macro"
            | x::xs ->
               if x =~ "[A-Za-z_][A-Za-z_0-9]*" 
               then let (params, bool) = aux xs in x::params, bool
               else error (spf "wrong syntax for macro parameter: %s" x)
          in
          aux xs
        in
        let body = define_body s1 (List_.index_list_1 params) lexbuf in
        Define { name = s1; params = Some (params); varargs = varargs;
                 body = Some body }
      }
  (* a space after the symbol means the macro has no argument, even if
   * this space is followed by a '('.
   *)
  | "define" space+ (symbol (*as s1*)) space+
      { let s1 = symbol_after_space lexbuf in
        let body = define_body s1 [] lexbuf in 
        Define { name = s1; params = None; varargs = false; body = Some body}
      }
  (* if do '#define FOO+' then? we should return a syntax error because
   * of the space_or_comment_and_newline below.
   *)
  | "define" space+ (symbol (*as s1*))
      { let s1 = symbol_after_space lexbuf in
        space_or_comment_and_newline lexbuf; 
        Define { name = s1; params = None; varargs = false; body =  None }
      }
  | "define" { error "syntax in #define" }

  (* stricter: require space_or_comment-only after sym *)
  | "undef" space+ (symbol (*as name*))
      { let name = symbol_after_space lexbuf in
        space_or_comment_and_newline lexbuf; 
        Undef name
      }
  | "undef" { error "syntax in #undef" } 


  | "ifdef" space+ (symbol (*as name*))
      { let name = symbol_after_space lexbuf in
        space_or_comment_and_newline lexbuf;
        Ifdef name 
      }
  | "ifndef" space+ (symbol (*as name*))
      { let name = symbol_after_space lexbuf in
        space_or_comment_and_newline lexbuf;
        Ifndef name
      }
  | "ifdef" { error "syntax in #ifdef" } 
  | "ifndef" { error "syntax in #ifndef" } 

  | "else"  
      { space_or_comment_and_newline lexbuf; 
        Else 
      }
  | "endif" 
      { space_or_comment_and_newline lexbuf; 
        Endif 
      }

  (* stricter: I impose a filename (with no quote in name, like original?) *)
  | "line" space+ (digit+ (*as s1*)) space* ('"' ([^'"']* (*as s2*)) '"')
      { 
        let (s1, s2) =
           let s = Lexing.lexeme lexbuf in s =~ ".*[ \t]+\\([0-9]+\\).*\"(\\(.*\\)\"" |> ignore;
           Regexp_.matched2 s in
        space_or_comment_and_newline lexbuf;
        Line (int_of_string s1, Fpath.v s2) }
  | "line" { error "syntax in #line" }


  | "pragma" space+ "lib" space* '"' ([^'"''\n']+ (*as file*)) '"'
      { let file = 
          let s = Lexing.lexeme lexbuf in s =~ ".*\"\\(.*\\)\"" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Pragma("lib", [file]) 
      }
  | "pragma" space+ "src" space* '"' ([^'"''\n']+ (*as file*)) '"'
      { let file = 
          let s = Lexing.lexeme lexbuf in s =~ ".*\"\\(.*\\)\"" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Pragma("src", [file]) 
      }

  | "pragma" space+ "varargck" space* "argpos" [^'\n']+
      { space_or_comment_and_newline lexbuf; 
        Pragma("varargck", ["TODO"]) 
      }
  | "pragma" space+ "varargck" space* "type" [^'\n']+
      { space_or_comment_and_newline lexbuf; 
        Pragma("varargck", ["TODO"]) 
      }
  | "pragma" space+ "varargck" space* "flag" [^'\n']+
      { space_or_comment_and_newline lexbuf; 
        Pragma("varargck", ["TODO"]) 
      }

  | "pragma" space+ "incomplete" space+ (symbol (*as name*))
      { let name = 
          let s = Lexing.lexeme lexbuf in s =~ ".*[ \t]+\\([^ \t]+\\)" |> ignore; 
          Regexp_.matched1 s in
        space_or_comment_and_newline lexbuf; 
        Pragma("incomplete", [name]) 
      }
  (* stricter: we do not silently skip unknown pragmas *)
  | "pragma"  { error "syntax in #pragma" }

  | symbol { error (spf "unknown #: %s" (Lexing.lexeme lexbuf)) }

(*****************************************************************************)
(* Macro definition part 2, the body *)
(*****************************************************************************)
and define_body name params = parse
  | symbol (*as s *)
     { let s = Lexing.lexeme lexbuf in
       try 
        let i = List.assoc s params in
        (* safe to use # for a special mark since C code can not
         * use this symbol since it is reserved by cpp
         *)
        spf "#%d" i ^ define_body name params lexbuf
      with Not_found ->
        s ^ define_body name params lexbuf
     }

  | [^ '\n' '_''a'-'z''A'-'Z' '\'' '"' '\\' '/' '#']+ (*as s *)
      { let s = Lexing.lexeme lexbuf in
        s ^ define_body name params lexbuf }

  (* end of macro *)
  | '\n' { incr Location_cpp.line; "" }

  (* special cases *)
  | ['\'' '"'] (*as c *)
      { let c = char lexbuf in
        let s = define_body_strchar c name params lexbuf in 
        String.make 1 c ^ s ^ define_body name params lexbuf 
      }

  | "//" [^'\n']* { define_body name params lexbuf }
  | "/*"          
      { comment_star_no_newline lexbuf; 
        define_body name params lexbuf 
      }

  | '/' { "/" ^ define_body name params lexbuf }
  (* we escape single '#' by doubling it (classic) *)
  | '#' { "##" ^ define_body name params lexbuf }

  (* could do " " ^ but that is not what 5c does *)
  | '\\' '\n' { incr Location_cpp.line; define_body name params lexbuf }
  | '\\' { "\\" ^ define_body name params lexbuf }

  | eof  { error (spf "eof in macro %s" name) }

(*****************************************************************************)
(* Strings and characters (part1) *)
(*****************************************************************************)

(* Diff with string/character handling in lexer.mll for C?
 *  - need to recognize macro parameter (yes 5c does that! no need stringify)
 *  - need to escape '#' to ##
 *  - do not care about precise parsing of \\, octal, escaped char,
 *    just return the string
*)

and define_body_strchar endchar name params = parse
  (* no need for stringify! substitute also in strings *)
  | symbol (*as s*)
     { let s = Lexing.lexeme lexbuf in
       try let i = List.assoc s params in
        spf "#%d" i ^ define_body_strchar endchar name params lexbuf
       with Not_found -> s ^ define_body_strchar endchar name params lexbuf
     }
  | [^ '\n' '_' 'a'-'z''A'-'Z' '\'' '"' '\\' '#']+ (*as s *)
      { let s = Lexing.lexeme lexbuf in
        s ^ define_body_strchar endchar name params lexbuf }

  | '\\' '\n' 
      { incr Location_cpp.line; define_body_strchar endchar name params lexbuf }
  | '\\' _ (*as s*) 
       { let s = Lexing.lexeme lexbuf in
         s^define_body_strchar endchar name params lexbuf }

  (* escape # to disambiguate with use of # to reference a parameter *)
  | '#' { "##" ^ define_body_strchar endchar name params lexbuf }

  | ['\'' '"'] (*as c*)
      { let c = char lexbuf in
        if c = endchar 
        then String.make 1 c
        else String.make 1 c ^ define_body_strchar endchar name params lexbuf
      }

  | '\n' { error (spf "newline in character or string in macro %s" name) }
  | eof  { error (spf "eof in macro %s" name) }

(*****************************************************************************)
(* Macro use *)
(*****************************************************************************)

(* Extracting the arguments. 
 * Note that as opposed to the other rules in this file, here
 * we do not parse a directive; we parse C code used as arguments to
 * a macro. We still use ocamllex for that because it is convenient.
 *)
and macro_arguments = parse
 | space* "("   
     { let xs = macro_args 0 "" [] lexbuf in
       let xs = List.rev xs in
       if xs = [""] then [] else xs
     }
 (* stricter: better error message *)
 | _ (*as c*) { let c = char lexbuf in 
                error (spf "was expecting a '(' not %c for macro arguments" c) }
 | eof    { error "was expecting a '(', not an eof for macro arguments" }

and macro_args depth str args = parse
 | ")" 
     { if depth = 0 
       then str::args
       else macro_args (depth - 1) (str ^ ")") args lexbuf
     }

 | [^ '\'' '"' '/' ',' '\n' '(' ')']+ 
     { macro_args depth (str ^ Lexing.lexeme lexbuf) args lexbuf }

 | "," 
     { if depth = 0 
       (* todo: if reached varargs! *)
       then macro_args 0 "" (str::args) lexbuf 
       else macro_args depth (str ^ ",") args lexbuf
     }

 | "("  { macro_args (depth+1) (str^"(") args lexbuf }

  | ['\'' '"'] (*as c*)
      { let c = char lexbuf in
        let s = macro_args_strchar c lexbuf in 
        macro_args depth (str ^ String.make 1 c ^ s) args lexbuf
      }

 | "//" [^ '\n']* { macro_args depth str args lexbuf }
 | "/*" 
     { comment_star_newline_ok lexbuf; 
       macro_args depth (str^" ") args lexbuf 
     }
 | "/"  { macro_args depth     (str^"/") args lexbuf }

 | '\n' { incr Location_cpp.line; macro_args depth     (str^" ") args lexbuf }

 | _ (*as c*) { let c = char lexbuf in error (spf "unrecognized character: '%c'" c) }
 (* stricter: better error message *)
 | eof { error "eof in macro arguments" }

(* Substituting the arguments.
 * Note that the lexbuf here will be different. It will correspond
 * to the string of the body of a macro.
 *)
and subst_args_in_macro_body name args = parse
 | [^ '\n' '#']+ (*as s*) { 
       let s = Lexing.lexeme lexbuf in
       s ^ subst_args_in_macro_body name args lexbuf }
 | "##" { "#" ^ subst_args_in_macro_body name args lexbuf }
 | "#" (digit+ (*as s*)) 
     { let s = Lexing.lexeme lexbuf |> String_.drop_prefix 1 in
       let i = int_of_string s in
       try 
         let arg = List.nth args (i - 1) in
         arg ^ subst_args_in_macro_body name args lexbuf
       with Failure _ -> 
         (* stricter: better error message *)
         error (spf "could not find argument %d in macro of %s" i name)
     }
 (* the escaped newlines should have been removed *)
 | '\n' { failwith "impossible: newline in macro body" }
 | eof { "" }


(*****************************************************************************)
(* Strings and characters (part1) *)
(*****************************************************************************)
and macro_args_strchar endchar = parse
  | [^ '\n' '\'' '"' '\\' ]+ (*as s*)  
      { let s = Lexing.lexeme lexbuf in
        s ^ macro_args_strchar endchar lexbuf }

  | '\\' '\n' { incr Location_cpp.line; macro_args_strchar endchar lexbuf }
  | '\\' _ (*as s*) 
        { let s = Lexing.lexeme lexbuf in
          s^macro_args_strchar endchar lexbuf }

  | ['\'' '"'] (*as c*)
      { let c = char lexbuf in
        if c = endchar 
        then String.make 1 c
        else String.make 1 c ^ macro_args_strchar endchar lexbuf
      }
  | '\n' { error (spf "newline in character or string") }
  | eof  { error (spf "eof in character or string in macro argument") }


(*****************************************************************************)
(* Comments *)
(*****************************************************************************)

and space_or_comment_and_newline = parse
  | space+        { space_or_comment_and_newline lexbuf }
  | '\n'          { incr Location_cpp.line }

  | "//" [^'\n']* { space_or_comment_and_newline lexbuf }
  | "/*"          { comment_star_no_newline lexbuf; 
                    space_or_comment_and_newline lexbuf }

  (* stricter: new error message *)
  | _ (*as c*)    { let c = char lexbuf in
                    error (spf "unexpected character %c after directive" c) }
  | eof           { error "expected newline, not EOF" }

and comment_star_no_newline = parse
  | "*/"          { }
  | [^ '*' '\n']+ { comment_star_no_newline lexbuf }
  | '*'           { comment_star_no_newline lexbuf }

  | '\n'          { error "comment across newline" }
  | eof           { error "eof in comment" }

and comment_star_newline_ok = parse
  | "*/"          { }
  | [^ '*' '\n']+ { comment_star_newline_ok lexbuf }
  | '*'           { comment_star_newline_ok lexbuf }
  | '\n'          { incr Location_cpp.line; comment_star_newline_ok lexbuf }
  | eof           { error "eof in comment" }


(*****************************************************************************)
(* Skipping, for ifdefs *)
(*****************************************************************************)

and skip_for_ifdef depth bol = parse
  | '\n'         { incr Location_cpp.line; skip_for_ifdef depth true lexbuf }
  | [' ' '\t']+  { skip_for_ifdef depth bol lexbuf }
  | [^'#' '\n' ' ' '\t']+ { skip_for_ifdef depth false lexbuf }
  
  | "#endif" 
      { if bol
        then
          if depth = 0 
          (* done! just eat until newline *)
          then space_or_comment_and_newline lexbuf
          else skip_for_ifdef (depth - 1) false lexbuf
        else skip_for_ifdef depth false lexbuf
      }
  | "#else" 
      { if bol && depth = 0
        then space_or_comment_and_newline lexbuf
        else skip_for_ifdef depth false lexbuf
      }
  | "#ifdef" | "#ifndef" 
      { if bol 
        then skip_for_ifdef (depth + 1) false lexbuf 
        else skip_for_ifdef depth false lexbuf
      }

  | "#" { skip_for_ifdef depth false lexbuf }

  (* stricter: *)
  | eof { error "eof in #ifdef or #ifndef" }  

@

\section{Parsing}

<<function [[Parse_cpp.parse]]>>=
let parse (caps : < Cap.open_in; ..>) hooks (conf : Preprocessor.conf) (file : Fpath.t) = 
  L.history := [];
  L.line := 1;
  Hashtbl.clear hmacros;
  conf.defs |> List.iter define_cmdline_def;

  let chan = CapStdlib.open_in caps !!file in
  Logs.info (fun m -> m "opening %s" !!file);

  L.add_event (L.Include file);
  let lexbuf = Lexing.from_channel chan in
  let stack = ref [(Some chan, lexbuf)] in
  (* less: let push x = check if too deep? *)

  (* for more precise error reporting *)
  let last_ident = ref "" in

  let rec lexfunc () =
    match !stack with
    | (chanopt, lexbuf)::xs ->
        let t = hooks.lexer lexbuf in
        let categ = hooks.category t in

        (match categ with
        | Eof -> 
            stack := xs;
            chanopt |> Option.iter (fun chan ->
              close_in chan;
              L.add_event L.Eof;
            );
            lexfunc ()

        | Sharp ->

            (* treating cpp directives *)
            let t = Lexer_cpp.token lexbuf in
            (match t with
            | D.Include (f, system_hdr) ->
                let path = find_include conf f system_hdr in
                (try 
                  let chan = CapStdlib.open_in caps !!path in
                  Logs.info (fun m -> m "opening included file %s" !!path);
                  L.add_event (L.Include path);
                  let lexbuf = Lexing.from_channel chan in
                  (* less: 
                     if List.length stack > 1000
                     then error "macro/io expansion too deep"
                  *)
                  stack := (Some chan, lexbuf)::!stack;
                with Failure s ->
                  error s
                )
            | D.Define macro_ast ->
               (* todo: stricter: forbid s to conflict with C keyboard *)
                define macro_ast
            | D.Undef s ->
                (* stricter: check that was defined *)
                if not (Hashtbl.mem hmacros s)
                then error (spf "macro %s was not defined" s);
                Hashtbl.remove hmacros s
            | D.Line (line, file) ->
                L.add_event (L.Line (line, file));
            (* less: for "lib" should add a L.PragmaLib event? *)
            | D.Pragma _ -> ()
            | D.Ifdef s ->
                if Hashtbl.mem hmacros s
                then ()
                else Lexer_cpp.skip_for_ifdef 0 true lexbuf
            | D.Ifndef s ->
                if not (Hashtbl.mem hmacros s)
                then ()
                else Lexer_cpp.skip_for_ifdef 0 true lexbuf
            | D.Else ->
                Lexer_cpp.skip_for_ifdef 0 true lexbuf
            | D.Endif -> ()
            );
            lexfunc ()

        | Ident s ->
            last_ident := s;
            if Hashtbl.mem hmacros s
            then 
              let macro = Hashtbl.find hmacros s in
              match macro.m_nbargs with
              | None ->
                  let body = macro.m_body in
                  if !Flags_cpp.debug_macros
                  then Logs.app (fun m -> m "#expand %s %s" s body);
                  let lexbuf = Lexing.from_string body in
                  stack := (None, lexbuf)::!stack;
                  lexfunc ()
              | Some n ->
                  let args = Lexer_cpp.macro_arguments lexbuf in
                  if List.length args <> n
                  then error (spf "argument mismatch expanding: %s" s)
                  else begin
                    let body = macro.m_body in
                    let lexbuf = Lexing.from_string body in
                    let body = 
                      Lexer_cpp.subst_args_in_macro_body s args lexbuf in
                    if !Flags_cpp.debug_macros
                    then Logs.app (fun m -> m "#expand %s %s" s body);
                    let lexbuf = Lexing.from_string body in
                    stack := (None, lexbuf)::!stack;
                    lexfunc ()
                  end
            else t
        | _ -> t
        )
    (* no more stack, could raise Impossible instead? *)           
    | [] -> hooks.eof
  in

  (try 
    let ast = hooks.parser (fun _lexbuf -> lexfunc ()) lexbuf in
    ast, !L.history
  with Parsing.Parse_error ->
    error ("Syntax error" ^ 
              (if !last_ident = "" 
               then ""
               else spf ", last name: %s" !last_ident))
  )
@

<<function [[Parse_cpp.error]]>>=
let error s =
  raise (L.Error (s, !L.line))
@


<<function [[Parse_cpp.define_cmdline_def]]>>=
let define_cmdline_def (k, v) =
  Hashtbl.add hmacros k 
    { m_name = k; m_nbargs = None; m_varargs = false; m_body = v; }
@

<<signature [[Location_cpp.add_event]]>>=
(* add to history *)
val add_event: 
  location_event -> unit
@

<<signature [[Location_cpp.final_loc_of_loc]]>>=
(* !uses history! you should avoid this function in a multifile processing
 * context (e.g., in the linker) *)
val final_loc_of_loc: 
    loc -> final_loc
@

<<signature [[Location_cpp.dump_event]]>>=
val dump_event:
  location_event -> unit
@


<<exception [[Location_cpp.Error]]>>=
exception Error of string * loc
@

<<function [[Location_cpp.dump_event]]>>=
(* for 5c -f 
 * alt: just rely on deriving show but kept this for compatibility with kencc
 *)
let dump_event (event : location_event) : unit =
  match event with
  | Include file -> 
      Logs.app (fun m -> m "%4d: %s" !line !!file)
  | Line (local_line, file) -> 
      Logs.app (fun m -> m "%4d: %s (#line %d)" !line !!file local_line)
  | Eof -> 
      Logs.app (fun m -> m "%4d: <pop>" !line)
@

<<function [[Location_cpp.add_event]]>>=
let add_event (event : location_event) : unit =
  (* alt: use Logs.debug instead of a flag *)
  if !Flags_cpp.debug_line
  then dump_event event;
  history := {location_event = event; global_line = !line }::!history
@

<<function [[Location_cpp.final_loc_of_loc]]>>=
(* 'history' contains the list of location_events in reverse order
 * since we always add an event to the end, for instance: 
 * [200; 150; 130; 60; 1]. The first step is to reverse this list:
 * [1; 60; 130; 150; 200]. Then, if we look for information about line 135, 
 * we want to stop when we encounter 150,
 * so when lineno < x.global_line below succeed for the first time.
 *)
let final_loc_of_loc (lineno : loc) : final_loc =
  let rec aux (lastfile, lastlineno, lastdelta) stack xs =
    match xs with
    | [] -> lastfile, lineno - lastlineno + lastdelta
    | x::xs ->
      if lineno < x.global_line 
      then lastfile, lineno - lastlineno + lastdelta
      else
        (match x.location_event, stack with
        | Eof, (lastfile, _lastlineno, lastdelta)::ys ->
            (* bugfix: wrong!! TODO *)
            aux (lastfile, x.global_line, lastdelta) ys xs
        | Eof, [] -> 
            failwith ("impossible: wrong location history, unpaired Eof")
        | Include file, ys ->
            aux (file, x.global_line, 1)
              ((lastfile, lastlineno, lastdelta)::ys) xs
        | Line (line, file), _y::ys ->
            aux (file, x.global_line, line) ys xs
        | Line (line, file), [] ->
            (* todo: wrong *)
            aux (file, x.global_line, line) [] xs
        )
  in
  aux (Fpath.v "<nofile>", 0, 0) [] (List.rev !history)
@

<<function [[Location_cpp._final_loc_and_includers_of_loc]]>>=
let _final_loc_and_includers_of_loc _lineno =
  raise Todo
@





\section{[[#include]]}

\subsection{Include paths, [[-I]]}

<<[[CLI.main()]] macroprocessor locals>>=
(* for cpp *)
let include_paths : Fpath.t list ref = ref [] in
@

<<[[CLI.main()]] [[options]] elements>>=
"-I", Arg.String (fun s ->
  include_paths := Fpath.v s::!include_paths
), " <dir> add dir as a path to look for '#include <file>' files";
@


\subsection{Tracing origin} %% and [[Hist]]

% seen before

\subsection{[[#include]]}

<<constant [[Parse_cpp._cwd]]>>=
(* cwd is used to manage #include "...". It is altered when you
 * include a file. cwd becomes the dirname of the included file??? 
 * TODO: dead? used?
 *)
let _cwd = ref (Sys.getcwd ())
@

<<function [[Parse_cpp.find_include]]>>=
(* less: Could use Set instead of list for the set of include paths 
 * todo: if absolute path, need to find it.
*)
let rec find_include (conf : Preprocessor.conf) (f : Fpath.t) (system : bool) =
  if system
  then find_include_bis conf.paths f
  else find_include_bis (conf.dir_source_file::conf.paths) f
and find_include_bis (paths : Fpath.t list) (f : Fpath.t) : Fpath.t =
  match paths with 
  (* stricter: better error message *)
  | [] -> failwith (spf "could not find %s in include paths" !!f)
  | x::xs ->
      let path : Fpath.t = 
        if !!x = "."
        (* this will handle also absolute path *)
        then f
        else x // f 
      in
      if Sys.file_exists !!path
      then begin
        if !Flags.debug_include
        then Logs.app (fun m -> m "%d: %s" !L.line !!path);
        path
      end
      else find_include_bis xs f
@



\section{[[#define]]}


\subsection{[[-D]]}

<<[[CLI.main()]] macroprocessor locals>>=
let macro_defs = ref [] in
@

<<[[CLI.main()]] [[options]] elements>>=
"-D", Arg.String (fun s ->
  let (var, val_) = 
    if s =~ "\\(.*\\)=\\(.*\\)"
    then Regexp_.matched2 s
    else (s, "1")
  in
  macro_defs := (var, val_)::!macro_defs
), " <name=def> (or just <name>) define name for preprocessor";
@

\subsection{[[#define]]}

<<function [[Parse_cpp.define]]>>=
let define (macro : D.macro) =
  let {D.name = s; params; varargs; body} = macro in
  (* We could forbid here 's' to conflict with C keyboard, but this
   * should be done in the caller, as cpp can be used with different
   * languages, which may use different keywords.
   *)
  let sbody = match body with Some x -> x | None -> "1" in
  if Hashtbl.mem hmacros s
  then error (spf "macro redefined: %s" s)
  else begin
    let macro =
      match params with
      | None -> 
          { m_name = s; m_nbargs = None; m_varargs = false; m_body = sbody }
      | Some params ->
          { m_name = s; m_nbargs = Some (List.length params); 
            m_varargs = varargs; m_body = sbody }
    in
    if !Flags_cpp.debug_macros
    then Logs.app (fun m -> m "#define %s %s" s macro.m_body);

    Hashtbl.add hmacros s macro
  end
@

\subsection{Macro Expansion}

<<type [[Parse_cpp.macro]]>>=
(* similar to Ast_cpp.macro *)
type macro = {
  m_name: string;
  m_nbargs: int option;
  m_varargs: bool; (* use "..." *)

  (* body contains #xxx substrings corresponding to the parameter of the macro.
   * For instance, #define foo(a,b) a+b --> {name="foo";nbargs=2;body="#1+#2"}.
   * 
   * Is there a risk of having numbers squashed with the macro parameter?
   * No, because if you have 'a1+b' then 'a1' is a separate identifier 
   * so you can not generate #11+#2 .
   *)
  m_body: string;
}
@

<<constant [[Parse_cpp.hmacros]]>>=
let hmacros = Hashtbl.create 101
@



\section{[[#undef]]}


\section{[[#ifdef]]}


\section{[[#pragma]]}


\section{[[#line]]}




%******************************************************************************
\chapter{Advanced Topics TODO}
%******************************************************************************

\section{Advanced C features}

\subsection{Function and function pointer automatic conversions}

\subsection{Array and pointer automatic conversions}

\subsection{Local [[static]]}

\subsection{Local [[volatile]]}

\subsection{Bitfields}

\subsection{Old style prototypes}

\subsection{[[_Noreturn()]]}



\section{C extensions}

\subsection{Typing extensions}%%: [[typeext()]]

\subsection{Unnamed structure elements}

\subsection{Struct constructors}

\subsection{Per-processor storage: [[extern register]]}

\subsection{Type reflection: [[typestr()]]}

\subsection{Signature reflection: [[signof()]]}

\subsection{Format's arguments checking}


\section{Floats}



\section{Big values}

\subsection{Complex types}

\subsection{Complex return value}

\subsection{Complex argument}

\subsection{Complex expression}

\subsection{[[vlong]] constant}



\section{64 bits operations}

%%\subsection{[[com64init()]]}
%%\subsection{Rewriting: [[com64()]]}
%%\subsection{[[bool64()]]}



\section{Endianness}

%%\section{Using an external preprocessor: [[/bin/cpp]]}
%%\section{Processing multiple files}



\section{Other optimizations}

\subsection{Packing: [[#pragma pack]]}

%%\subsection{Minimizing [[#line]] history}



%******************************************************************************
\chapter{Conclusion}
%******************************************************************************




%##############################################################################

\appendix

%******************************************************************************
\chapter{Debugging}
%******************************************************************************


\section{Dumpers}

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-dump_tokens", Arg.Set Flags.dump_tokens,
" dump the tokens as they are generated";
@
<<[[CLI.main()]] [[options]] elements>>=
"-dump_ast", Arg.Set Flags.dump_ast,
" dump the parsed AST";
@
<<[[CLI.main()]] [[options]] elements>>=
"-dump_typed_ast", Arg.Set Flags.dump_typed_ast,
" dump the typed AST";
@
<<[[CLI.main()]] [[options]] elements>>=
"-dump_asm", Arg.Set Flags.dump_asm,
" dump the generated assembly";
@

<<[[CLI.frontend()]] if [[dump_ast]]>>=
(* debug *)
if !Flags.dump_ast
then Logs.app (fun m -> m "%s" (Dumper_.s_of_any (Ast.Program ast)));
@

<<[[CLI.main()]] other locals>>=
(* for debugging *)
let action = ref "" in
@

<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-test_parser", Arg.Unit (fun () -> action := "-test_parser"), " ";
@


<<constant [[Flags.dump_tokens]]>>=
let dump_tokens = ref false
@


%%\subsection{[[cc/]] [[Fmt]] data structures}
%%\subsection{[[5c/]] [[Fmt]] data structures}
%%\subsection{[[xxxnames[]]]}
\subsection{AST dumper: [[5c -x]]} %% [[prtree()]] and

<<signature [[Dumper_.s_of_any]]>>=
val s_of_any: Ast.any -> string
@

<<function [[Dumper_.s_of_any]]>>=
(* less: could have s_of_any_with_pos *)
let s_of_any x =
  Meta_ast.show_types := false;
  Meta_ast.show_all_pos := false;
  let v = Meta_ast.vof_any x in
  OCaml.string_of_v v
@

<<type [[Ast.any]]>>=
(* for visitor and dumper *)
type any =
  | Expr of expr
  | Stmt of stmt
  | Type of typ
  | Toplevel of toplevel
  | Program of program
  | FinalType of Type.t
[@@deriving show { with_path = false } ]
@

<<constant [[Flags.dump_ast]]>>=
let dump_ast = ref false
@


<<[[CLI.main()]] [[action]] management>>=
(* to test and debug components of mk *)
if !action <> "" then begin 
  do_action caps thestring !action (List.rev !args); 
  raise (Exit.ExitCode 0 )
end;
@

<<function [[CLI.do_action]]>>=
let do_action (caps: < caps; .. >) thestring s xs =
  match s with
  | "-test_parser" ->
      xs |> List.iter (fun file ->
        Logs.info (fun m -> m "processing %s" file);
        let conf = Preprocessor.{
          defs = [];
          paths = [spf "/%s/include" thestring; "/sys/include";] |> Fpath_.of_strings;
          dir_source_file = Fpath.v ".";
        }
        in
        try 
          let _ = Parse.parse caps conf (Fpath.v file) in
          ()
        with Location_cpp.Error (s, loc) ->
          let (file, line) = Location_cpp.final_loc_of_loc loc in
          failwith (spf "%s:%d %s" !!file line s)
      )

  | _ -> failwith ("action not supported: " ^ s)
@


\section{[[5c -v]], verbose mode}

<<[[CLI.main()]] other locals>>=
let level = ref (Some Logs.Warning) in
@

<<[[CLI.main()]] [[options]] elements>>=
"-v", Arg.Unit (fun () -> level := Some Logs.Info),
 " verbose mode";
"-verbose", Arg.Unit (fun () -> level := Some Logs.Info),
" verbose mode";
"-debug", Arg.Unit (fun () -> level := Some Logs.Debug),
" guess what";
"-quiet", Arg.Unit (fun () -> level := None),
" ";
@

<<[[CLI.main()]] logging setup>>=
Logs_.setup !level ();
Logs.info (fun m -> m "assembler ran from %s" (Sys.getcwd()));
@

\section{Preprocessing debugging}

<<[[CLI.main()]] [[options]] elements>>=
"-e", Arg.Set Flags_cpp.debug_include, " ";
"-f", Arg.Set Flags_cpp.debug_line, " ";
"-m", Arg.Set Flags_cpp.debug_macros, " ";
@


<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added long names for those options *)
"-debug_include", Arg.Set Flags_cpp.debug_include, " ";
"-debug_line",      Arg.Set Flags_cpp.debug_line, " ";
"-debug_macros",    Arg.Set Flags_cpp.debug_macros, " ";
@

\subsection{Macro debugging: [[5c -m]]}

<<constant [[Flags_cpp.debug_macros]]>>=
(* -m *)
let debug_macros = ref false
@

\subsection{File inclusion debugging: [[5c -e]]}

<<constant [[Flags_cpp.debug_include]]>>=
(* -e *)
let debug_include = ref false
@

\subsection{Line information debugging: [[5c -f]]}

<<constant [[Flags_cpp.debug_line]]>>=
(* -f *)
let debug_line = ref false
@


\section{Parsing debugging}

\subsection{Printing names: [[5c -L]]}

\subsection{Printing declarations: [[5c -d]]}



\section{Typing debugging}

<<constant [[Flags.dump_typed_ast]]>>=
let dump_typed_ast = ref false
@
<<signature [[Dumper_.s_of_any_with_types]]>>=
val s_of_any_with_types: Ast.any -> string
@

<<function [[Dumper_.s_of_any_with_types]]>>=
let s_of_any_with_types x =
  Meta_ast.show_types := true;
  Meta_ast.show_all_pos := false;
  let v = Meta_ast.vof_any x in
  OCaml.string_of_v v
@

<<[[CLI.frontend()]] if [[dump_typed_ast]]>>=
(* debug *)
if !Flags.dump_typed_ast
then begin 
  (* Logs.app (fun m -> m "%s" (Typecheck.show_typed_program typed_program));*)
  typed_program.ids |> Hashtbl.iter (fun (k : Ast.fullname) (v : Typecheck.idinfo) ->
    match v.sto with
    | Storage.Global | Storage.Static | Storage.Extern ->
      Logs.app (fun m -> m "%s: %s" (Ast.unwrap k)
                            (Dumper_.s_of_any (Ast.FinalType v.typ)));
    | Storage.Param | Storage.Local -> ()
  );
  typed_program.funcs |> List.iter (fun func ->
    Logs.app (fun m -> m "%s" 
              (Dumper_.s_of_any_with_types (Ast.Toplevel (Ast.FuncDef func))))
  );
end;
@


\subsection{Printing expression type trees: [[5c -t]]}


\section{Code generation debugging}

<<constant [[Flags.dump_asm]]>>=
let dump_asm = ref false
@

<<[[CLI.backend5()]] if [[dump_asm]]>>=
if !Flags.dump_asm
then begin
  let pc = ref 0 in
  asm |> List.iter (fun (instr, _loc) ->
    (* less: use a assembly pretty printer instead? easier to debug? 5c -S *)
    let v = Meta_ast_asm5.vof_line instr in
    Logs.app (fun m -> m  "%2d: %s" !pc (OCaml.string_of_v v));
    incr pc;
  );
end;
(* nosemgrep: do-not-use-obj-magic *)
Obj.magic asm, !Location_cpp.history
@

\subsection{Printing processed opcodes: [[5c -G]]}

\subsection{Printing code generation information: [[5c -g]]}

\subsection{Printing generated assembly: [[5c -S]]}

<<[[CLI.main()]] [[options]] elements>>=
"-S", Arg.Set Flags.dump_asm,
" dump the generated assembly";
@



\section{Optimization debugging}

\subsection{Printing arithmetic trees: [[5c -m]]}

\subsection{Printing registerization: [[5c -r]]}



\section{Printing initializations: [[5c -i]]}


%******************************************************************************
\chapter{Error Management}
%******************************************************************************
\label{chap:error-management}

\section{[[errorexit()]]}

<<signature [[Error.errorexit]]>>=
(* this raises Exit.ExitCode 1 *)
val errorexit: string -> 'a
@
<<function [[Error.errorexit]]>>=
let errorexit s =
  Logs.err (fun m -> m "%s" s);
  raise (Exit.ExitCode 1)
@

% also show Error.warn before

\section{Lexing error}

\section{Parsing error}%%[[yyerror()]]

\section{Typechecking error}

<<signature [[Typecheck.string_of_error]]>>=
val string_of_error: error -> string
@
<<function [[Typecheck.string_of_error]]>>=
let string_of_error err =
  Check.string_of_error err
@

\section{Checking error}

<<signature [[Check.string_of_error]]>>=
val string_of_error: error -> string
@

<<function [[Check.string_of_error]]>>=
let string_of_error err =
  match err with
  | Inconsistent (s1, loc1, s2, loc2) ->
    let (file1, line1) = Location_cpp.final_loc_of_loc loc1 in
    let (file2, line2) = Location_cpp.final_loc_of_loc loc2 in
    spf "%s:%d error: %s\n%s:%d note: %s" !!file1 line1 s1 !!file2 line2 s2
  | Misc (s, loc) ->
    let (file, line) = Location_cpp.final_loc_of_loc loc in
    spf "%s:%d error: %s" !!file line s
@


\section{Code generation error}

<<signature [[Codegen5.string_of_error]]>>=
val string_of_error: error -> string
@
<<function [[Codegen5.string_of_error]]>>=
let string_of_error err =
  Check.string_of_error err
@

%\section{[[diag()]]}

%\section{[[fatal()]]}

\section{Backtraces}


<<constant [[Flags.backtrace]]>>=
let backtrace = ref false
@

<<[[CLI.main()]] other locals>>=
let backtrace = ref false in
@
<<[[CLI.main()]] [[options]] elements>>=
(* pad: I added that *)
"-backtrace", Arg.Set backtrace,
" dump the backtrace after an error";
@

<<[[CLI.main()]] when [[exn]] if [[backtrace]]>>=
if !backtrace
then raise exn
@


\section{Error location}

%******************************************************************************
%%\chapter{Libc}
%******************************************************************************
%%\section{Memory management}
%%\section{String management}
%%\section{Bit operations}
%%\section{Mathematic functions}
%%\section{Key/value data structure}
%%\section{Portability}

%******************************************************************************
\chapter{Extra Code}
%******************************************************************************

#include "occ_extra.nw"

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
SUE = Structure/Union/Enum
SU  = Structure/Union
\end{verbatim}



\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Indexes}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
