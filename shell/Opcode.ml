(*s: shell/Opcode.ml *)
(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)

(* for boostrap-mk.sh and ocaml-light to work without deriving *)
let show _ = "NO DERIVING"
[@@warning "-32"]
let show_codevec _ = "NO DERIVING"
[@@warning "-32"]

(*s: type [[Opcode.operation]] *)
(* Operations generated by the compiler. 
 * 
 * Semantic of comments below:
 *  - Arguments on stack (...)
 *  - Arguments in line [...]
 *  - Code in line with jump around {...}
 * 
 * alt: type operation = ((unit -> unit) * string)
 *)
type operation =

  (* Stack (argv) *)
  | Mark
  | Word (* [string] *)
  | Popm (* (value) *)
  (*s: [[Opcode.operation]] other stack cases *)
  | Count (* (name) *)
  | Concatenate (* (left)(right) *)
  | Stringify (* (name) *)
  (*e: [[Opcode.operation]] other stack cases *)

  (* Variable *)
  | Assign (* (name)(val) *)
  | Dollar (* (name) *)
  (*s: [[Opcode.operation]] other variable cases *)
  | Index  (* ??? *)
  | Local (* (name)(val) *)
  | Unlocal (* *)
  (*e: [[Opcode.operation]] other variable cases *)

  (* Process! *)
  | Simple (* (args) *)
  | Async  (* {... Xreturn} *)

  (* Control flow *)
  | If 
  | IfNot
  (* While are compiled in jumps *)
  | Jump  (* [addr] *)
  | Exit 
  (*s: [[Opcode.operation]] other control cases *)
  | Return
  (*x: [[Opcode.operation]] other control cases *)
  | For   (* (var, list){... Xreturn} *)
  (*x: [[Opcode.operation]] other control cases *)
  | Case  (* (pat, value){...} *)
  (*e: [[Opcode.operation]] other control cases *)

  (* Boolean return status  *)
  | Wastrue
  | Not
  | False (* {...} *)
  | True  (* {...} *)
  | Match (* (pat, str) *)

  (* Redirections *)
  | Read (* (file)[fd] *)
  | Write (* (file)[fd] *)
  | Append (* (file)[fd] *)
  (*s: [[Opcode.operation]] other redirection cases *)
  | ReadWrite (* (file)[fd] *)
  | Close  (* [fd] *)
  | Dup    (* [fd0 fd1] *)
  | Popredir (* *)
  (*e: [[Opcode.operation]] other redirection cases *)

  (* Pipes *)
  | Pipe (* [i j]{... Xreturn}{... Xreturn} *)
  (*s: [[Opcode.operation]] other pipe cases *)
  | PipeFd (* [type]{... Xreturn} *)
  (*x: [[Opcode.operation]] other pipe cases *)
  | PipeWait (* argument passed through Thread.pid *)
  (*e: [[Opcode.operation]] other pipe cases *)

  (* Functions *)
  | Fn (* (name){... Xreturn } *)

  (*s: [[Opcode.operation]] other cases *)
  (* Globbing *)
  | Glob (* (value?) *)
  (*x: [[Opcode.operation]] other cases *)
  (* Error management *)
  | Eflag
  (*x: [[Opcode.operation]] other cases *)
  | DelFn (* (name) *)
  (* less: RdFn *)
  (*x: [[Opcode.operation]] other cases *)
  (* ?? *)
  | Subshell (* {... Xexit} *)
  (*x: [[Opcode.operation]] other cases *)
  | Backquote (* {... Xreturn} *)
  (*e: [[Opcode.operation]] other cases *)

  | REPL (* *)
(*e: type [[Opcode.operation]] *)
[@@deriving show]
(*s: type [[Opcode.opcode]] *)
type t =
  | F of operation
  | I of int
  | S of string
(*e: type [[Opcode.opcode]] *)
[@@deriving show]
(*s: type [[Opcode.codevec]] *)
type codevec = t array
(*e: type [[Opcode.codevec]] *)
[@@deriving show]
(*e: shell/Opcode.ml *)
