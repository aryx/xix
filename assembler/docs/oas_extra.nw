\section{[[objects/Ast_asm.ml]]}

% for linker
<<function [[Ast_asm.visit_globals_program]]>>=
(* Visit globals (e.g., to populate symbol table with wanted symbols in linker).
 * This is more complicated than in 5l because we can not rely
 * on an ANAME or Operand.sym.
 * less: boilerplate which could be auto generated by ocamltarzan in
 *  a visitor_asm.ml
 *)
let rec visit_globals_program visit_instr (f : global -> unit) (prog : 'instr program) : unit =
  let (xs, _locs) = prog in
  xs |> List.iter (fun (x, _line) ->
    match x with
    | Pseudo y ->
      (match y with
      | TEXT (ent, _, _) -> f ent
      | GLOBL (ent, _, _) -> f ent
      | DATA (ent, _, _, ix) -> f ent; visit_globals_ximm f ix
      | WORD (ix) -> visit_globals_ximm f ix
      )
    | Virtual (RET | NOP) | LabelDef _ -> ()
    | Instr instr ->
      visit_instr f instr
  )

and visit_globals_ximm f x =
  match x with
  | Address (Global (x, _)) -> f x
  | Address (Param _ | Local _) | String _ | Int _ | Float _ -> ()
and visit_globals_branch_operand f x =
  match !x with
  | SymbolJump ent -> f ent
  | IndirectJump _ | Relative _ | LabelUse _ | Absolute _ -> ()
@

%-------------------------------------------------------------

<<objects/Ast_asm.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Types common to the different Plan 9 assembler ASTs.
 *
 * Note that in Plan 9 object files are mostly the serialized form of 
 * the assembly AST, which is why this file is in this directory.
 *
 * !!! If you modify this file please increment Object_file.version !!!
 *) 

(*****************************************************************************)
(*  AST related types *)
(*****************************************************************************)

(* ------------------------------------------------------------------------- *)
(* Location *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast_asm.loc]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Numbers and Strings *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast_asm.virt_pc]]>>
[@@deriving show]

(* 'int' enough for ARM 32 bits? on 64 bits machine it is enough :) 
 * TODO: use Int64.t so sure it's enough for every arch.
 * alt: have separate type in each Ast_asmxxx.ml, with more precise size
 * but not worth it because it prevents more generalization in this file 
 * like imm_or_ximm, which in turn allow to generalize pseudo_instr,
 * and anyway Plan 9 asms are not a direct match of the machine assembly.
*)
<<type [[Ast_asm.integer]]>>
[@@deriving show]

(* floating point number.
 * TODO: float enough too? can contain 'double' C? 
 * alt? use explicit float record { Int32.t; Int32.t mantisse/exp } ?
*)
<<type [[Ast_asm.floatp]]>>
[@@deriving show]

<<type [[Ast_asm.offset]]>>
[@@deriving show]

<<type [[Ast_asm.label]]>>
[@@deriving show]

<<type [[Ast_asm.symbol]]>>
[@@deriving show]

<<type [[Ast_asm.global]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Operands *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast_asm.register]]>>
[@@deriving show]

<<type [[Ast_asm.fregister]]>>
[@@deriving show]

<<type [[Ast_asm.entity]]>>
[@@deriving show]

(* extended immediate *)
<<type [[Ast_asm.ximm]]>>
[@@deriving show]

(* I use a ref below so the code that resolves branches is shorter.
 * The ref is modified by the assembler and then by the linker.
 *)  
<<type [[Ast_asm.branch_operand]]>>
<<type [[Ast_asm.branch_operand2]]>>
[@@deriving show]

(* In a MOVE, sign is relevant only for a load operation *)
<<type [[Ast_asm.sign]]>>
[@@deriving show]

(* TODO: add Dword? use shorter W_ | H_ | B_ | D_ ?  *)
<<type [[Ast_asm.move_size]]>>
[@@deriving show]

<<type [[Ast_asm.floatp_precision]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Instructions *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast_asm.pseudo_instr]]>>

<<type [[Ast_asm.attributes]]>>
[@@deriving show {with_path = false}]

(* alt: move in arch-specific Ast_asmx.instr
 * alt: merge with pseudo_instr
*)
<<type [[Ast_asm.virtual_instr]]>>
[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Program *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast_asm.line]]>>
[@@deriving show {with_path = false}]

<<type [[Ast_asm.lines]]>>
[@@deriving show]

<<type [[Ast_asm.program]]>>
[@@deriving show]

(*****************************************************************************)
(*  Extractors/visitors *)
(*****************************************************************************)

<<function [[Ast_asm.s_of_global]]>>

<<function [[Ast_asm.visit_globals_program]]>>
@


\section{[[objects/Ast_asm5.ml]]}

% for compiler
<<constant [[Ast_asm5.rTMP]]>>=
let rTMP = R 11
@


% for linker
<<function [[Ast_asm5.visit_globals_instr]]>>=
let visit_globals_instr (f : global -> unit) (i : instr_with_cond) : unit =
  let mov_operand x =
    match x with
    | Entity (A.Global (x, _)) -> f x
    | Entity (A.Param _ | A.Local _) -> ()
    | Ximm x -> A.visit_globals_ximm f x
    | Imsr _ | Indirect _ -> ()
  in
  match fst i with
  | MOVE (_, _, m1, m2) -> mov_operand m1; mov_operand m2
  (* ocaml-light: | B b | BL b | Bxx (_, b) -> branch_operand b *)
  | B b -> A.visit_globals_branch_operand f b
  | BL b -> A.visit_globals_branch_operand f b
  | Bxx (_, b) -> A.visit_globals_branch_operand f b
  | Arith _ | ArithF _ | SWAP _ | Cmp _ | CmpF _ | SWI _ | RFE -> () 
@

%-------------------------------------------------------------

<<objects/Ast_asm5.ml>>=
(* Copyright 2015, 2016 Yoann Padioleau, see copyright.txt *)
open Common

module A = Ast_asm
open Ast_asm

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Abstract Syntax Tree (AST) for the assembly language supported by 5a.
 * I call this language Asm5.
 *
 * Note that many types are now defined in Ast_asm.ml instead because they are
 * mostly arch independent and can be reused in other plan9 assemblers
 * (e.g. va, ia, 7a).
 *
 * !!! If you modify this file please increment Object_file.version !!!
 * 
 * TODO: 
 *  - 5c-only opcodes? CASE, BCASE, MULU/DIVU/MODU (or better in Ast_asm.ml too?)
 *  - MULA, MULL,
 *  - MOVM (and his special bits .IA/...), 
 *  - PSR, MCR/MRC,
 *  - handle the instructions used in the kernel
 *)

(*****************************************************************************)
(* The AST related types *)
(*****************************************************************************)

(* ------------------------------------------------------------------------- *)
(* Numbers and Strings *)
(* ------------------------------------------------------------------------- *)
(* see Ast_asm.ml *)

(* ------------------------------------------------------------------------- *)
(* Operands *)
(* ------------------------------------------------------------------------- *)
<<type [[Ast_asm5.reg]]>>
[@@deriving show]

<<type [[Ast_asm5.freg]]>>
[@@deriving show]

(* ?? *)
<<type [[Ast_asm5.creg]]>>

(* reserved by linker *)
<<constant [[Ast_asm5.rTMP]]>>
<<constant [[Ast_asm5.rSB]]>>
<<constant [[Ast_asm5.rSP]]>>
(* reserved by hardware *)
<<constant [[Ast_asm5.rLINK]]>>
<<constant [[Ast_asm5.rPC]]>>

<<constant [[Ast_asm5.nb_registers]]>>

<<type [[Ast_asm5.arith_operand]]>>

<<type [[Ast_asm5.shift_reg_op]]>>
[@@deriving show]

(* alt: could almost be moved to Ast_asm.ml but Shift above of arith_operand
 * seems arm-specific
 *)
<<type [[Ast_asm5.mov_operand]]>>

[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Instructions *)
(* ------------------------------------------------------------------------- *)

(* less: could probably factorize things and move stuff in Ast_asm.ml *)
<<type [[Ast_asm5.instr]]>>

<<type [[Ast_asm5.arith_opcode]]>>
<<type [[Ast_asm5.arith_cond]]>>

<<type [[Ast_asm5.arithf_opcode]]>>
    
<<type [[Ast_asm5.cmp_opcode]]>>

<<type [[Ast_asm5.condition]]>>

<<type [[Ast_asm5.move_option]]>>
     (* this is used only with a MOV with an indirect with offset operand *)
<<type [[Ast_asm5.move_cond]]>>

[@@deriving show]

(* ------------------------------------------------------------------------- *)
(* Program *)
(* ------------------------------------------------------------------------- *)

<<type [[Ast_asm5.instr_with_cond]]>>
[@@deriving show]

<<type [[Ast_asm5.program]]>>
[@@deriving show]

(*****************************************************************************)
(* Extractors/Visitors *)
(*****************************************************************************)

<<function [[Ast_asm5.branch_opd_of_instr]]>>

<<function [[Ast_asm5.visit_globals_instr]]>>
@


\section{[[objects/Object_file.mli]]}

%-------------------------------------------------------------

<<objects/Object_file.mli>>=

<<type [[Object_file.t]]>>

<<exception [[Object_file.WrongVersion]]>>
<<signature [[Object_file.version]]>>

<<signature [[Object_file.load]]>>

<<signature [[Object_file.save]]>>

<<signature [[Object_file.is_obj_filename]]>>
@


\section{[[objects/Object_file.ml]]}

%-------------------------------------------------------------

<<objects/Object_file.ml>>=
(* Copyright 2015, 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Regexp_.Operators
open Fpath_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)
(* TODO? could also add file origin? *)
<<type [[Object_file.t]]>>

(* less: could be sha1 of ast_asmxxx.ml for even safer marshalling *)
<<constant [[Object_file.version]]>>

(*****************************************************************************)
(* API *)
(*****************************************************************************)
(* TODO? can normalize before? or check every invariants?
 * TODO? pass and save arch name string? like in goken? and
 * check for it at loading time?
 *)
<<function [[Object_file.save]]>>

(* for slightly safer marshalling
 * TODO: exception WrongArch ?
 *)
<<exception [[Object_file.WrongVersion]]>>

<<function [[Object_file.load]]>>

<<function [[Object_file.is_obj_filename]]>>
@


\section{[[CLI.mli]]}

%-------------------------------------------------------------

<<CLI.mli>>=
<<type [[CLI.caps]]>>

<<signature [[CLI.main]]>>

<<signature [[CLI.assemble]]>>
@

\section{[[CLI.ml]]}

% for mips
<<function [[CLI.assemblev]]>>=
let assemblev (caps: < Cap.open_in; .. >) (conf : Preprocessor.conf) (infile : Fpath.t) : Ast_asmv.program =
  let prog = Parse_asmv.parse caps conf infile in
  let prog = Resolve_labels.resolve Ast_asmv.branch_opd_of_instr prog in
  if !dump_ast 
  then Logs.app (fun m -> m "AST = %s" (Ast_asmv.show_program prog));
  prog
@

%-------------------------------------------------------------

<<CLI.ml>>=
(* Copyright 2015, 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Fpath_.Operators
open Regexp_.Operators

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of 5a/va, the Plan 9 ARM/MIPS assemblers.
 *
 * Main limitations compared to 5a/va/...:
 *  - no multiple files processing in parallel 
 *    (not the place, use xargs)
 *  - no unicode support? or can ocamllex in ocaml-light do unicode?
 *
 * better than 5a/va/...:
 *  - far greater code reuse across all assemblers thanks to:
 *    * Lexer_asm.mll factorization
 *    * Ast_asm.ml and 'instr polymorphic type
 *    * use of simple marshalling instead of adhoc object format
 *      (which were slightly different in each arch)
 *    * separate AST generation from resolving which allows to factorize
 *      checks of redefinition and the resolution of labels
 *    * generalize more code in macroprocessor/
 *    * use simple marshal again for cpp line history
 * 
 * todo:
 *  - port remaining assembler: ia, 7a, 8a, 6a (increasing difficulty)
 * later:
 *  - look at the 5a Go sources in the Golang source, maybe ideas to steal?
 *  - follow the new design by Rob Pike of Go assembler to factorize things
 *    (see https://www.youtube.com/watch?v=KINIAgRpkDA&feature=youtu.be )
 *    (=~ 2 tables, register string -> code, and opcode string -> code)
 *)

(*****************************************************************************)
(* Types, constants, and globals *)
(*****************************************************************************)
<<type [[CLI.caps]]>>

<<constant [[CLI.dump_ast]]>>

(*****************************************************************************)
(* Main algorithm *)
(*****************************************************************************)

<<function [[CLI.assemble5]]>>
<<function [[CLI.assemblev]]>>

<<function [[CLI.assemble]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[CLI.main]]>>
@

\section{[[Lexer_asm.mll]]}

%-------------------------------------------------------------

\section{[[Main.ml]]}

%-------------------------------------------------------------

<<Main.ml>>=
(* Copyright 2025 Yoann Padioleau, see copyright.txt *)
(* open Xix_assembler *)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<toplevel [[Main._1]]>>
@


\section{[[Parser_asm.ml]]}

%-------------------------------------------------------------

<<Parser_asm.ml>>=
open Common

open Ast_asm
module L = Location_cpp

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Helpers used in the different arch-specific parsers.
 *
 * General limitations compared to 5a/va/...:
 *  - no support for 'NAME=expr;' constant definition, nor use of it
 *    in expressions, which allows to evaluate constant at parsing time 
 *    and avoid the need to build an expr AST (as we want to separate AST
 *    generation from checks/resolution/eval)
 *    (but can use cpp for constant definition so not a big loss)
 *  - does not allow SP and PC in a few places with 'spreg' and 'sreg' original
 *    grammar rule
 *    (but can use directly R13 and R15)
 *  - no END instruction
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Parser_asm.error]]>>

<<constant [[Parser_asm.noattr]]>>
<<function [[Parser_asm.attributes_of_int]]>>

<<function [[Parser_asm.mk_e]]>>
@


\section{[[Parse_asm5.mli]]}

%-------------------------------------------------------------

<<Parse_asm5.mli>>=

<<signature [[Parse_asm5.parse]]>>

<<signature [[Parse_asm5.parse_no_cpp]]>>
@


\section{[[Parse_asm5.ml]]}

%-------------------------------------------------------------

<<Parse_asm5.ml>>=
(* Copyright 2015, 2016 Yoann Padioleau, see copyright.txt *)
open Common
open Regexp_.Operators

module L = Location_cpp
module T = Token_asm
module A = Ast_asm
open Parser_asm5
open Ast_asm5

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Lexer *)
(*****************************************************************************)
<<function [[Parse_asm5.token]]>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)
<<function [[Parse_asm5.parse]]>>

<<function [[Parse_asm5.parse_no_cpp]]>>
@

\section{[[Parser_asm5.mly]]}

\section{[[Resolve_labels.mli]]}

%-------------------------------------------------------------

<<Resolve_labels.mli>>=

<<signature [[Resolve_labels.resolve]]>>
@


\section{[[Resolve_labels.ml]]}

%-------------------------------------------------------------

<<Resolve_labels.ml>>=
(* Copyright 2015, 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common

open Ast_asm

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Resolve and remove the LabelDef/LabelUse constructs as well as
 * the branch_operand Relative (turned into Absolute like for LabelUse).
 *
 * As you can see, the Plan 9 assembler does not do much. Most of the work
 * is done in the linker really. 
 *)

(*****************************************************************************)
(* Error management *)
(*****************************************************************************)
<<function [[Resolve_labels.error]]>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
<<function [[Resolve_labels.resolve]]>>
@


\section{[[Token_asm.ml]]}

%-------------------------------------------------------------

<<Token_asm.ml>>=
<<type [[Token_asm.t]]>>
@
