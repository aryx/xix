(* Copyright 2016, 2025 Yoann Padioleau, see copyright.txt *)
open Common
open Either

open Ast_asm
open Ast_asm5

module T = Types
module T5 = Types5
open Types
open Types5

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* ARM code generation.
 *
 * ocaml: No need for optab/oplook/ocmp/cmp as in 5l. Just use pattern matching!
 *)

(*****************************************************************************)
(* Types and constants *)
(*****************************************************************************)

(* new: more declaratif and give opportunity to sanity check if overlap *)
type composed_word = (int * int) list

type pool =
  (* note that it is not always an int! Sometimes it can be an
   * Address which will be resolved only at the very end.
   *)
  | PoolOperand of Ast_asm.ximm
  (* todo: still don't know why we need that *)
  | LPOOL 

type action = {
  (* a multiple of 4 *)
  size: int;
  pool: pool option;
  binary: unit -> composed_word list;
}

type mem_opcode = LDR | STR

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let error node s =
  failwith (spf "%s at %s on %s" s 
              (T.s_of_loc node.n_loc)
              (T5.show_instr node.instr)
  )

(* new: can detect some typing mistakes *)
let sanity_check_composed_word node (xs : composed_word) =
  let dbg = Dumper.dump xs in
  let rec aux bit xs =
    match xs with
    | [] -> ()
    | (x,bit2)::xs ->
        let size = bit - bit2 in
        (match () with
        | _ when bit2 >= bit -> error node ("composed word not sorted: " ^ dbg)
        | _ when x < 0       -> error node (spf "negative value %d: %s" x dbg)
        | _ when size <= 0   -> error node (spf "no space for value %d: %s" x dbg)
        (* if size = 2 then maxval = 3 so x >= 2^2 (= 1 lsl 2) then error *)
        | _ when x >= 1 lsl size ->
            error node (spf "value %d overflow outside its space (%d - %d): %s "
                       x bit bit2 dbg)
        | _ -> ()
        );
        aux bit2 xs
  in
  aux 32 xs

let word_of_composed_word (x : composed_word) : Types.word =
  x |> List.fold_left (fun acc (v, i) ->
    (v lsl i) lor acc
  ) 0


let offset_to_R12 x =
  (* less: x - BIG at some point if want some optimisation *)
  x

let base_and_offset_of_indirect node symbols2 autosize x =
  match x with
  | Indirect (r, off) -> r, off 
  | Entity (Param (_s, off)) ->
      (* remember that the +4 below is because we access the frame of the
       * caller which for sure is not a leaf. Note that autosize
       * here had possibly a +4 done if the current function
       * was a leaf, but still we need another +4 because what matters
       * now is the adjustment in the frame of the caller!
       *)
      rSP, autosize + 4 + off
  | Entity (Local (_s, off)) -> 
      rSP, autosize + off
  | Entity (Global (global, off)) ->
      let v = Hashtbl.find symbols2 (T.symbol_of_global global) in
      (match v with
        | T.SData2 (offset, _kind) ->
          rSB, offset_to_R12 (offset + off)
      (* stricter: allowed in 5l but I think with wrong codegen *)
      | T.SText2 _ -> 
          error node (spf "use of procedure %s in indirect with offset"
                       (A.s_of_global global))
      )
  | Imsr _ | Ximm _ -> raise (Impossible "should be called only for indirects")

(*****************************************************************************)
(* Operand classes *)
(*****************************************************************************)

let immrot x =
  if x >= 0 && x <= 0xff
  then Some (0, x)
  else raise Todo

let immoffset x =
  (x >= 0 && x <= 0xfff) || (x < 0 && x >= -0xfff)

(*****************************************************************************)
(* Code generation helpers *)
(*****************************************************************************)

(* gxxx below means gen_binary_code of xxx *)

let gcond cond =
  match cond with
  | EQ            -> (0x0, 28)
  | NE            -> (0x1, 28)
  | GE (U) -> (0x2, 28)
  | LT (U) -> (0x3, 28)
  | MI            -> (0x4, 28)
  | PL            -> (0x5, 28)
  | VS            -> (0x6, 28)
  | VC            -> (0x7, 28)
  | GT (U) -> (0x8, 28)
  | LE (U) -> (0x9, 28) 
  | GE (S)   -> (0xa, 28) 
  | LT (S)   -> (0xb, 28)
  | GT (S)   -> (0xc, 28)
  | LE (S)   -> (0xd, 28)
  | AL            -> (0xe, 28)
  | NV            -> (0xf, 28)


let gop_arith op =
  match op with
  | AND -> (0x0, 21)
  | EOR -> (0x1, 21)
  | SUB -> (0x2, 21)
  | RSB -> (0x3, 21)
  | ADD -> (0x4, 21)
  | ADC -> (0x5, 21)
  | SBC -> (0x6, 21)
  | RSC -> (0x7, 21)
  (* TST 0x8, TEQ 0x9, CMP 0xa, CMN 0xb via gop_cmp below *)
  | ORR -> (0xc, 21)
  | MOV -> (0xd, 21) (* no reading syntax in 5a, but can be generated by 5l *)
  | BIC -> (0xe, 21)
  | MVN -> (0xf, 21)

  | MUL | DIV | MOD -> raise (Impossible "should match those cases separately")
  | SLL | SRL | SRA -> raise (Impossible "should match those cases separately")
  
let gsetbit opt =
  match opt with
  | None -> []
  | Some Set_condition -> [(1, 20)]
  

let gop_shift op =
  match op with
  | SLL -> (0, 5)
  | SRL -> (1, 5)
  | SRA -> (2, 5)
  | _ -> raise (Impossible "should match those cases separately")


let gop_cmp op =
  match op with
  (* Set_condition set by default for comparison opcodes *)
  | TST -> [(0x8, 21); (1, 20)]
  | TEQ -> [(0x9, 21); (1, 20)]
  | CMP -> [(0xa, 21); (1, 20)]
  | CMN -> [(0xb, 21); (1, 20)]

let gop_bitshift_register op =
  match op with
  | Sh_logic_left   -> (0x0, 5)
  | Sh_logic_right  -> (0x1, 5)
  | Sh_arith_right  -> (0x2, 5)
  | Sh_rotate_right -> (0x3, 5)

let gop_rcon x =
  match x with
  | Left (R r) -> [(r,8); (1, 4)]
  | Right i    -> [(i, 7); (0, 4)]


(*****************************************************************************)
(* More complex code generation helpers *)
(*****************************************************************************)

let gshift (R rf) op2 rcon = 
  gop_rcon rcon @ [gop_bitshift_register op2; (rf, 0)]


let gbranch_static (nsrc : T5.node) cond is_bl =
  match nsrc.branch with
  | None -> raise (Impossible "resolving should have set the branch field")
  | Some ndst -> 
      let dst_pc = ndst.real_pc in
      let v = (dst_pc - nsrc.real_pc) - 8 in
      if v mod 4 <> 0
      then raise (Impossible "layout text wrong, not word aligned node");
      let v = (v asr 2) land 0xffffff in
      (* less: stricter: warn if too big, but should never happens *)
      [gcond cond; (0x5, 25);
       (if is_bl then (0x1, 24) else (0x0, 24)); 
       (v, 0) 
       ]




let gmem cond op move_size opt offset_or_rm (R rbase) (R rt) =
  [gcond cond; (0x1, 26) ] @
  (match opt with
  | None ->                  [(1, 24)] (* pre offset *)
  | Some PostOffsetWrite ->  [(0, 24)]
  | Some WriteAddressBase -> [(1, 24); (1, 21)]
  ) @
  [(match move_size with 
   | Word -> (0, 22) 
   | Byte _ -> (1, 22) 
   | HalfWord _ -> raise (Impossible "should use different pattern rule")
   );
   (match op with 
    | LDR -> (1, 20) 
    | STR -> (0, 20)
   );
   (rbase, 16); (rt, 12);
  ] @
  (match offset_or_rm with
  | Either.Left offset -> 
      if offset >= 0 
      then [(1, 23); (offset, 0)]
      else [(0, 23); (-offset, 0)]
  | Either.Right (R r) -> [(1, 25); (r, 0)]
  )

let gload_from_pool (nsrc : T5.node) cond rt =
  match nsrc.branch with
  | None -> raise (Impossible "literal pool should be attached to node")
  | Some ndst ->
      (* less: could assert the dst node is a WORD *)
      let dst_pc = ndst.real_pc in
      let v = (dst_pc - nsrc.real_pc) - 8 in
      if v mod 4 <> 0
      then raise (Impossible "layout text wrong, not word aligned node");
      (* LDR v(R15), RT (usually R11) *)
      gmem cond LDR Word None (Left v) rPC rt
      

(*****************************************************************************)
(* The rules! *)
(*****************************************************************************)

(* conventions (matches the one used (inconsistently) in 5l):
 * - rf = register from (called Rm in refcard)
 * - rt = register to   (called Rd in refcard)
 * - r  = register middle (called Rn in refcard)
 *)
let rules symbols2 autosize init_data node =
  match node.instr with
  (* --------------------------------------------------------------------- *)
  (* Virtual *)
  (* --------------------------------------------------------------------- *)
   | T.V (A.RET | A.NOP) -> 
      raise (Impossible "rewrite should have transformed RET/NOP")

  (* --------------------------------------------------------------------- *)
  (* Pseudo *)
  (* --------------------------------------------------------------------- *)

  (* TEXT instructions were kept just for better error reporting localisation *)
  | T.TEXT (_, _, _) -> 
      { size = 0; pool = None; binary = (fun () -> []) }

  | T.WORD x ->
      { size = 4; pool = None; binary = (fun () -> 
        match x with
        | Float _ -> raise Todo
        | Int i -> [ [(i land 0xffffffff, 0)] ]
        | String _s -> 
            (* stricter? what does 5l do with that? confusing I think *)
            error node "string not allowed with WORD; use DATA"
        | Address (Global (global, _offsetTODO)) -> 
            let v = Hashtbl.find symbols2 (T.symbol_of_global global) in
            (match v with
             | T.SText2 real_pc -> [ [(real_pc, 0)] ]
             | T.SData2 (offset, _kind) -> 
                 (match init_data with
                 | None -> raise (Impossible "init_data should be set by now")
                 | Some init_data -> [ [(init_data + offset, 0)] ]
                 )
            )
        | Address (Param _ | Local _) -> raise Todo
      )}

  | T.I (instr, cond) ->
    (match instr with
    | ArithF _ | CmpF _ -> raise Todo
    (* --------------------------------------------------------------------- *)
    (* Arithmetics *)
    (* --------------------------------------------------------------------- *)
    | Arith ((AND|ORR|EOR|ADD|SUB|BIC|ADC|SBC|RSB|RSC|MVN|MOV) as op, opt,
             from, middle, (R rt)) ->
        let r =
          if (op = MVN || op = MOV)
          then 0
          else 
            match middle with 
            | None -> rt 
            | Some (R x) -> x 
        in
        let from_part =
          match from with
          | Reg (R rf)      -> [(rf, 0)]
          | Shift (a, b, c) -> gshift a b c
          | Imm i ->
              (match immrot i with
              | Some (rot, v) -> [(1, 25); (rot, 8); (v, 0)]
              | None -> error node "TODO: LCON"
              )
        in
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; gop_arith op] @ gsetbit opt @ [(r, 16); (rt, 12)] 
            @ from_part]
        )}

    (* SLL I, [R], RT -> MOV (R << c), RT *)
    | Arith ((SLL|SRL|SRA) as op, opt, from, middle, (R rt)) ->
        let r = 
          match middle with 
          | None -> rt 
          | Some (R x) -> x 
        in
        let from_part = 
          match from with
          | Imm i ->
              if i >= 0 && i <= 31
              then [(i, 7)]
              (* stricter: failwith, not silently truncate *)
              else error node (spf "shit value out of range %d" i)
          | Reg (R rf) -> [(rf, 8); (1, 4)]
          (* stricter: I added that *)
          | Shift _ -> error node "bitshift on shift operation not allowed"
        in
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; gop_arith MOV] @ gsetbit opt @ [(rt, 12); gop_shift op]
            @ from_part @ [(r, 0)]]
        )}

    | Arith (MUL, opt, from, middle, (R rt)) ->
        let rf =
          match from with
          | Reg (R rf) -> rf
          (* stricter: better error message *)
          | Shift _ | Imm _ ->
              error node "MUL can take only register operands"
        in
        let r = 
          match middle with 
          | None -> rt 
          | Some (R x) -> x 
        in
        (* ?? *)
        let (r, rf) = if rt = r then (rf, rt) else (r, rf) in
        
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; (0x0, 21)] @ gsetbit opt 
            @ [(rt, 16); (rf, 8); (0x9, 4); (r, 0) ]]
        )}
        


    | Cmp (op, from, (R r)) ->
        let from_part = 
          match from with
          | Reg (R rf) -> [(rf, 0)]
          | Shift (a, b, c) -> gshift a b c
          | Imm i ->
              (match immrot i with
              | Some (rot, v) -> [(1, 25); (rot, 8); (v, 0)]
              | None -> error node "TODO"
              )
        in
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond] @ gop_cmp op @ [(r, 16); (0, 12)] @ from_part]
        )}
        
    | MOVE (Word, None, Imsr from, Imsr (Reg (R rt))) -> 
        let from_part = 
          match from with
          | Reg (R rf) -> [(rf, 0)]
          | Shift (a, b, c) -> gshift a b c
          | Imm i ->
              (match immrot i with
              | Some (rot, v) -> [(1, 25); (rot, 8); (v, 0)]
              | None -> error node "TODO"
              )
        in
        let r = if !Flags.kencc_compatible then rt else 0 in
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; gop_arith MOV; (r, 16); (rt, 12)] @ from_part]
        )}

    (* MOVBU R, RT -> ADD 0xff, R, RT *)
    | MOVE (Byte U, None, Imsr (Reg (R r)), Imsr (Reg (R rt))) -> 
        { size = 4; pool = None; binary = (fun () ->
          [[gcond cond; (1, 25); gop_arith AND; (r, 16); (rt, 12); (0xff, 0)]]
        )}

    (* MOVB RF, RT  -> SLL 24, RF, RT; SRA 24, RT, RT -> MOV (RF << 24), RT;...
     * MOVH RF, RT  -> SLL 16, RF, RT; SRA 16, RT, RT -> ...
     * MOVHU RF, RT -> SLL 16, RF, RT; SRL 16, RT, RT -> 
     *)
    | MOVE ((Byte _|HalfWord _)as size, None, Imsr(Reg(R rf)),Imsr(Reg(R rt)))->
        let rop =
          match size with
          | Byte U | HalfWord U -> SRL
          | Byte S   | HalfWord S -> SRA
          | Word -> raise (Impossible "size matched in pattern")
        in
        let sh =
          match size with
          | Byte _ -> 24
          | HalfWord _ -> 16
          | Word -> raise (Impossible "size matched in pattern")
        in
        { size = 8; pool = None; binary = (fun () ->
          [
            [gcond cond; gop_arith MOV; (rt, 12); gop_shift SLL; (sh,7);(rf,0)];
            [gcond cond; gop_arith MOV; (rt, 12); gop_shift rop; (sh,7);(rt,0)];
          ]
        )}

    | Arith ((DIV|MOD), _, _, _, _) -> error node "TODO: DIV/MOD"

    (* --------------------------------------------------------------------- *)
    (* Control flow *)
    (* --------------------------------------------------------------------- *)
    | B x ->
        if cond <> AL 
        then raise (Impossible "B should always be with AL");
        { size = 4; pool = Some LPOOL; binary = (fun () ->
          match !x with
          | Absolute _ -> [ gbranch_static node AL false ]
          (* B (R) -> ADD 0, R, PC *)
          | IndirectJump (R r) ->
              let (R rt) = rPC in
              [ [gcond AL; (1, 25); gop_arith ADD; (r, 16); (rt, 12); (0, 0)] ]
          | _ -> raise (Impossible "5a or 5l should have resolved this branch")
        )}
    | BL x ->
        (match !x with
        | Absolute _ -> 
            { size = 4; pool = None; binary = (fun () ->
              [ gbranch_static node AL true ]
            )}
        (* BL (R) -> ADD $0, PC, LINK; ADD $0, R, PC *)
        | IndirectJump (R r) ->
           { size = 8; pool = None; binary = (fun () ->
             let (R r2) = rPC in
             let (R rt) = rLINK in
              [ 
                (* Remember that when PC is involved in input operand
                 * there is an implicit +8 which is perfect for our case.
                 *)
                [gcond cond;(1, 25); gop_arith ADD; (r2, 16); (rt, 12); (0, 0)];
                [gcond cond;(1, 25); gop_arith ADD; (r, 16);  (r2, 12); (0, 0)];
              ]
             )}
        | _ -> raise (Impossible "5a or 5l should have resolved this branch")
        )

    | Bxx (cond2, x) ->
        if cond <> AL 
        then raise (Impossible "Bxx should always be with AL");
        (match !x with
        | Absolute _ -> 
            { size = 4; pool = None; binary = (fun () ->
              [ gbranch_static node cond2 false ]
            )}
        (* stricter: better error message at least? *)
        | IndirectJump _ -> error node "Bxx supports only static jumps"
        | _ -> raise (Impossible "5a or 5l should have resolved this branch")
        )

    (* --------------------------------------------------------------------- *)
    (* Memory *)
    (* --------------------------------------------------------------------- *)

    (* Address *)
    | MOVE (Word, None, Ximm ximm, Imsr (Reg (R rt))) ->
        (match ximm with
        | Int _ | Float _ -> 
           failwith "TODO: ?? because of refactor of imm_or_ximm"
        | String _ -> 
            (* stricter? what does 5l do with that? confusing I think *)
            error node "string not allowed in MOVW; use DATA"
        | Address (Global (global, _offsetTODO)) ->
            let from_part_when_small_offset_to_R12 =
              try 
                let v = Hashtbl.find symbols2 (T.symbol_of_global global) in
                match v with
                | T.SData2 (offset, _kind) ->
                    let final_offset = offset_to_R12 offset in
                    (* super important condition! for bootstrapping
                     * setR12 in MOVW $setR12(SB), R12 and not
                     * transform it in ADD offset_set_R12, R12, R12.
                     *)
                    if final_offset = 0 
                    then None
                    else immrot final_offset
                | T.SText2 _ -> None
              (* layout_text has not been fully done yet so we may have
               * the address of a procedure we don't know yet
               *)
              with Not_found -> None
            in
            (match from_part_when_small_offset_to_R12 with
            | Some (rot, v) ->
              (* MOVW $x(SB), RT -> ADD $offset_to_r12, R12, RT  *)
              { size = 4; pool = None; binary = (fun () ->
                let (R r) = rSB in
                [[gcond cond; (1, 25); gop_arith ADD; (r, 16); (rt, 12); 
                  (rot, 8); (v, 0)]]
            )}
            | None -> 
              (* MOVW $L(SB), RT -> LDR x(R15), RT *)
              { size = 4; pool=Some(PoolOperand(ximm)); binary=(fun () ->
                [ gload_from_pool node cond (R rt) ]
              )}
            )
        | Address (Local _ | Param _) -> raise Todo
        )

    (* Load *)

    | MOVE ((Word | Byte U) as size, opt, from, Imsr (Reg rt)) ->
        (match from with
        | Imsr (Imm _ | Reg _) -> 
            if size = Word 
            then raise (Impossible "pattern covered before")
            else error node "illegal combination?"
        | Imsr (Shift _) -> error node "TODO"
        | Ximm _ -> 
            if size = Word 
            then raise (Impossible "pattern covered before")
            else error node "illegal combination"
        | Indirect _ | Entity _ ->
            let (rbase, offset) = 
              base_and_offset_of_indirect node symbols2 autosize from in
            if immoffset offset
            then
              { size = 4; pool = None; binary = (fun () -> 
                [ gmem cond LDR size opt (Left offset) rbase rt ]
              )}
            else
              error node "TODO: Large offset"
        )

    (* Store *)

    (* note that works for Byte Signed and Unsigned here *)
    | MOVE ((Word | Byte _) as size, opt, Imsr (Reg rf), dest) ->
        (match dest with
        | Imsr (Reg _) -> raise (Impossible "pattern covered before")
        (* stricter: better error message *)
        | Imsr _ | Ximm _ -> 
            error node "illegal to store in an (extended) immediate"
        | Indirect _ | Entity _ ->
            let (rbase, offset) = 
              base_and_offset_of_indirect node symbols2 autosize dest in
            if immoffset offset
            then
              { size = 4; pool = None; binary = (fun () -> 
                [ gmem cond STR size opt (Left offset) rbase rf ]
              )}
            else
              error node "TODO: store with large offset"
        )

    (* Swap *)
    | SWAP _ -> error node "TODO: SWAP"

    (* Half words and signed bytes *)
    | MOVE ((HalfWord _ | Byte _), _opt, _from, _dest) -> 
        error node "TODO: half"

    | MOVE (Word, _opt, _from, _dest) ->
       (* stricter: better error message *)
       error node "illegal combination: at least one operand must be a register"

    (* --------------------------------------------------------------------- *)
    (* System *)
    (* --------------------------------------------------------------------- *)
    | SWI i ->
        if i <> 0
        then error node (spf "SWI does not use its parameter under Plan 9/Linux");

        { size = 4; pool = None; binary = (fun () ->
          [ [gcond cond; (0xf, 24)] ]
        )}
    (* RFE -> MOVM.S.W.U 0(r13),[r15] *)
    | RFE ->
        { size = 4; pool = None; binary = (fun () -> 
          [ [(0xe8fd8000, 0)] ]
        )}

    (* --------------------------------------------------------------------- *)
    (* Other *)
    (* --------------------------------------------------------------------- *)
(*    | _ -> error node "illegal combination"*)
    )

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

let size_of_instruction (symbols2 : T.symbol_table2) (autosize : int) (node : T5.node) : int (* a multiple of 4 *) * pool option =
  let action  = rules symbols2 autosize None node in
  action.size, action.pool


let gen (symbols2 : T.symbol_table2) (config : Exec_file.linker_config) (cg : T5.code_graph) : T.word list =

  let res = ref [] in
  let autosize = ref 0 in

  (* just for sanity checking *)
  let pc = ref config.init_text in

  cg |> T.iter (fun n ->

    let {size; binary; pool = _ }  = rules symbols2 !autosize config.init_data n in
    let instrs = binary () in

    if n.real_pc <> !pc
    then raise (Impossible "Phase error, layout inconsistent with codegen");
    if List.length instrs * 4 <> size
    then raise (Impossible (spf "size of rule does not match #instrs at %s"
                              (T.s_of_loc n.n_loc)));

    let xs = instrs |> List.map Assoc.sort_by_val_highfirst in
    
    if !Flags.debug_gen 
    then begin 
      Logs.app (fun m -> m "%s" (T5.show_instr n.instr));
      Logs.app (fun m -> m "-->");
      xs |> List.iter (fun x ->
        let w = word_of_composed_word x in
        Logs.app (fun m -> m "%s (0x%x)" (Dumper.dump x) w);
      );
      Logs.app (fun m -> m ".");
    end;

    let xs = xs |> List.map (fun composed_word ->
      sanity_check_composed_word n composed_word;
      word_of_composed_word composed_word;
    )
    in
    res |> Stack_.push xs;

    pc := !pc + size;
    (match n.instr with
    (* after the resolve phase the size of a TEXT is the final autosize *)
    | T.TEXT (_, _, size) -> autosize := size;
    | _ -> ()
    );
  );

  !res |> List.rev |> List.flatten
