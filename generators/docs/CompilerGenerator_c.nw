\section{[[generators/lex/]]}

\subsection*{[[generators/lex/ldefs.h]]}

<<constant PP>>=
#define PP 1
@

<<constant PC>>=
#define PC 1
@

<<constant PS>>=
#define PS 1
@

<<constant CWIDTH>>=
#define CWIDTH 8
@

<<constant CMASK>>=
#define CMASK 0377
@

<<constant NCH>>=
#define NCH 256
@

<<constant TOKENSIZE>>=
#define TOKENSIZE 1000
@

<<constant DEFSIZE>>=
#define DEFSIZE 40
@

<<constant DEFCHAR>>=
#define DEFCHAR 1000
@

<<constant STARTCHAR>>=
#define STARTCHAR 100
@

<<constant STARTSIZE>>=
#define STARTSIZE 256
@

<<constant CCLSIZE>>=
#define CCLSIZE 1000
@

<<constant TREESIZE>>=
#define TREESIZE 1000
@

<<constant NSTATES>>=
#define NSTATES 500
@

<<constant MAXPOS>>=
#define MAXPOS 2500
@

<<constant NTRANS>>=
#define NTRANS 2000
@

<<constant NOUTPUT>>=
#define NOUTPUT 5000
@

<<constant NACTIONS>>=
#define NACTIONS 100
@

<<constant ALITTLEEXTRA>>=
#define ALITTLEEXTRA 30
@

<<constant RCCL>>=
#define RCCL NCH+90
@

<<constant RNCCL>>=
#define RNCCL NCH+91
@

<<constant RSTR>>=
#define RSTR NCH+92
@

<<constant RSCON>>=
#define RSCON NCH+93
@

<<constant RNEWE>>=
#define RNEWE NCH+94
@

<<constant FINAL>>=
#define FINAL NCH+95
@

<<constant RNULLS>>=
#define RNULLS NCH+96
@

<<constant RCAT>>=
#define RCAT NCH+97
@

<<constant STAR>>=
#define STAR NCH+98
@

<<constant PLUS>>=
#define PLUS NCH+99
@

<<constant QUEST>>=
#define QUEST NCH+100
@

<<constant DIV>>=
#define DIV NCH+101
@

<<constant BAR>>=
#define BAR NCH+102
@

<<constant CARAT>>=
#define CARAT NCH+103
@

<<constant S1FINAL>>=
#define S1FINAL NCH+104
@

<<constant S2FINAL>>=
#define S2FINAL NCH+105
@

<<constant DEFSECTION>>=
#define DEFSECTION 1
@

<<constant RULESECTION>>=
#define RULESECTION 2
@

<<constant ENDSECTION>>=
#define ENDSECTION 5
@

<<constant TRUE>>=
#define TRUE 1
@

<<constant FALSE>>=
#define FALSE 0
@

<<constant LINESIZE>>=
#define LINESIZE 110
@

<<function freturn>>=
#define freturn(s) s
@


%-------------------------------------------------------------

<<generators/lex/ldefs.h>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include <bio.h>

<<constant PP>>

<<constant PC>>
<<constant PS>>

<<constant CWIDTH>>
<<constant CMASK>>
<<constant NCH>>


<<constant TOKENSIZE>>
<<constant DEFSIZE>>
<<constant DEFCHAR>>
<<constant STARTCHAR>>
<<constant STARTSIZE>>
<<constant CCLSIZE>>

<<constant TREESIZE>>
<<constant NSTATES>>
<<constant MAXPOS>>
<<constant NTRANS>>
<<constant NOUTPUT>>

<<constant NACTIONS>>
<<constant ALITTLEEXTRA>>

<<constant RCCL>>
<<constant RNCCL>>
<<constant RSTR>>
<<constant RSCON>>
<<constant RNEWE>>
<<constant FINAL>>
<<constant RNULLS>>
<<constant RCAT>>
<<constant STAR>>
<<constant PLUS>>
<<constant QUEST>>
<<constant DIV>>
<<constant BAR>>
<<constant CARAT>>
<<constant S1FINAL>>
<<constant S2FINAL>>

<<constant DEFSECTION>>
<<constant RULESECTION>>
<<constant ENDSECTION>>

<<constant TRUE>>
<<constant FALSE>>


//#define DEBUG 1

//#ifdef DEBUG
extern int debug;		/* 1 = on */
extern int charc;
<<constant LINESIZE>>
//#endif

#ifdef DEBUG
extern int yydebug;
#endif

#ifdef DEBUG
extern int	freturn(int);
#else
<<function freturn>>
#endif

extern int sargc;
extern char **sargv;
extern uchar buf[520];
extern int yyline;		/* line number of file */
extern char *yyfile;		/* file name of file */
extern int sect;
extern int eof;
extern int lgatflg;
extern int divflg;
extern int funcflag;
extern int pflag;
extern int casecount;
extern int chset;	/* 1 = char set modified */
extern Biobuf *fin, fout, *fother;
extern int foutopen;
extern int errorf;
extern int fptr;
extern char *cname;
extern int prev;	/* previous input character */
extern int pres;	/* present input character */
extern int peek;	/* next input character */
extern int *name;
extern int *left;
extern int *right;
extern int *parent;
extern uchar **ptr;
extern uchar *nullstr;
extern int tptr;
extern uchar pushc[TOKENSIZE];
extern uchar *pushptr;
extern uchar slist[STARTSIZE];
extern uchar *slptr;
extern uchar **def, **subs, *dchar;
extern uchar **sname, *stchar;
extern uchar *ccl;
extern uchar *ccptr;
extern uchar *dp, *sp;
extern int dptr, sptr;
extern uchar *bptr;		/* store input position */
extern uchar *tmpstat;
extern int count;
extern int **foll;
extern int *nxtpos;
extern int *positions;
extern int *gotof;
extern int *nexts;
extern uchar *nchar;
extern int **state;
extern int *sfall;		/* fallback state num */
extern uchar *cpackflg;		/* true if state has been character packed */
extern int *atable, aptr;
extern int nptr;
extern uchar symbol[NCH];
extern uchar cindex[NCH];
extern int xstate;
extern int stnum;
extern int ccount;
extern uchar match[NCH];
extern uchar extra[NACTIONS];
extern uchar *pcptr, *pchar;
extern int pchlen;
extern int nstates, maxpos;
extern int yytop;
extern int report;
extern int ntrans, treesize, outsize;
extern long rcount;
extern int *verify, *advance, *stoff;
extern int scon;
extern uchar *psave;

extern int nine;

extern void	acompute(int);
extern void	add(int **, int);
extern void	allprint(int);
extern void	cclinter(int);
extern void	cgoto(void);
extern void	cfoll(int);
extern int	lcpyact(void);
extern int	dupl(int);
extern void	error(char *,...);
extern void	first(int);
extern void	follow(int);
extern int	gch(void);
extern uchar	*getl(uchar *);
extern void	layout(void);
extern void	lgate(void);
extern int	lookup(uchar *, uchar **);
extern int	member(int, uchar *);
extern void	mkmatch(void);
extern int	mn0(int);
extern int	mn1(int, int);
extern int	mnp(int, void*);
extern int	mn2(int, int, uintptr);
extern void	munputc(int);
extern void	munputs(uchar *);
extern void	*myalloc(int, int);
extern void	nextstate(int, int);
extern int	notin(int);
extern void	packtrans(int, uchar *, int *, int, int);
extern void	padd(int **, int);
extern void	pccl(void);
extern void	pfoll(void);
extern void	phead1(void);
extern void	phead2(void);
extern void	pstate(int);
extern void	ptail(void);
extern void	sect1dump(void);
extern void	sect2dump(void);
extern void	statistics(void);
extern void	stprt(int);
extern void	strpt(uchar *);
extern void	treedump(void);
extern int	usescape(int);
extern void	warning(char *,...);
extern int	yyparse(void);
extern void	yyerror(char *);
@

\subsection*{[[generators/lex/globals.c]]}

<<global fout>>=
Biobuf	fout;
@

<<global foutopen>>=
int	foutopen;
@

<<global errorf>>=
int	errorf = 1;
@

<<global sect>>=
int	sect = DEFSECTION;
@

<<global prev>>=
int	prev = '\n';	/* previous input character */
@

<<global pres>>=
int	pres = '\n';	/* present input character */
@

<<global peek>>=
int	peek = '\n';	/* next input character */
@

<<global pushptr>>=
uchar	*pushptr = pushc;
@

<<global slptr>>=
uchar	*slptr = slist;
@

<<global cname>>=
char	*cname = "/sys/lib/lex/ncform";
@

<<global nine>>=
int nine;
@

<<global ccount>>=
int ccount = 1;
@

<<global casecount>>=
int casecount = 1;
@

<<global aptr>>=
int aptr = 1;
@

<<global yytop>>=
int yytop;
@

<<global outsize>>=
int outsize = NOUTPUT;
@

<<global sptr>>=
int sptr = 1;
@

<<global report>>=
int report = 2;
@

<<global debug>>=
int debug = 0;		/* 1 = on */
@

<<global charc>>=
int charc;
@

<<global sargc>>=
int sargc;
@

<<global sargv>>=
char **sargv;
@

<<global buf>>=
uchar buf[520];
@

<<global yyline>>=
int yyline;		/* line number of file */
@

<<global yyfile>>=
char *yyfile;		/* filename for error messages */
@

<<global eof>>=
int eof;
@

<<global lgatflg>>=
int lgatflg;
@

<<global divflg>>=
int divflg;
@

<<global funcflag>>=
int funcflag;
@

<<global pflag>>=
int pflag;
@

<<global chset>>=
int chset;	/* 1 = char set modified */
@

<<global fptr>>=
int fptr;
@

<<global name>>=
int *name;
@

<<global left>>=
int *left;
@

<<global right>>=
int *right;
@

<<global parent>>=
int *parent;
@

<<global nullstr>>=
uchar *nullstr;
@

<<global ptr>>=
uchar **ptr;
@

<<global tptr>>=
int tptr;
@

<<global pushc>>=
uchar pushc[TOKENSIZE];
@

<<global slist>>=
uchar slist[STARTSIZE];
@

<<global ccl>>=
uchar *ccl;
@

<<global ccptr>>=
uchar *ccptr;
@

<<global dptr>>=
int dptr;
@

<<global bptr>>=
uchar *bptr;		/* store input position */
@

<<global tmpstat>>=
uchar *tmpstat;
@

<<global count>>=
int count;
@

<<global foll>>=
int **foll;
@

<<global nxtpos>>=
int *nxtpos;
@

<<global positions>>=
int *positions;
@

<<global gotof>>=
int *gotof;
@

<<global nexts>>=
int *nexts;
@

<<global nchar>>=
uchar *nchar;
@

<<global state>>=
int **state;
@

<<global sfall>>=
int *sfall;		/* fallback state num */
@

<<global cpackflg>>=
uchar *cpackflg;		/* true if state has been character packed */
@

<<global atable>>=
int *atable;
@

<<global nptr>>=
int nptr;
@

<<global symbol>>=
uchar symbol[NCH];
@

<<global cindex>>=
uchar cindex[NCH];
@

<<global xstate>>=
int xstate;
@

<<global stnum>>=
int stnum;
@

<<global match>>=
uchar match[NCH];
@

<<global extra>>=
uchar extra[NACTIONS];
@

<<global pchlen>>=
int pchlen = TOKENSIZE;
@

<<global rcount>>=
 long rcount;
@

<<global scon>>=
int scon;
@

<<global psave>>=
uchar *psave;
@


%-------------------------------------------------------------

<<generators/lex/globals.c>>=
#include "ldefs.h"

<<global fout>>
<<global foutopen>>
<<global errorf>>
<<global sect>>
<<global prev>>
<<global pres>>
<<global peek>>
<<global pushptr>>
<<global slptr>>

<<global cname>>

<<global nine>>
<<global ccount>>
<<global casecount>>
<<global aptr>>
int nstates = NSTATES, maxpos = MAXPOS;
int treesize = TREESIZE, ntrans = NTRANS;
<<global yytop>>
<<global outsize>>
<<global sptr>>
<<global report>>
<<global debug>>
<<global charc>>
<<global sargc>>
<<global sargv>>
<<global buf>>
<<global yyline>>
<<global yyfile>>
<<global eof>>
<<global lgatflg>>
<<global divflg>>
<<global funcflag>>
<<global pflag>>
<<global chset>>
Biobuf *fin = 0, *fother;
<<global fptr>>
<<global name>>
<<global left>>
<<global right>>
<<global parent>>
<<global nullstr>>
<<global ptr>>
<<global tptr>>
<<global pushc>>
<<global slist>>
uchar **def, **subs, *dchar;
uchar **sname, *stchar;
<<global ccl>>
<<global ccptr>>
uchar *dp, *sp;
<<global dptr>>
<<global bptr>>
<<global tmpstat>>
<<global count>>
<<global foll>>
<<global nxtpos>>
<<global positions>>
<<global gotof>>
<<global nexts>>
<<global nchar>>
<<global state>>
<<global sfall>>
<<global cpackflg>>
<<global atable>>
<<global nptr>>
<<global symbol>>
<<global cindex>>
<<global xstate>>
<<global stnum>>
<<global match>>
<<global extra>>
uchar *pchar, *pcptr;
<<global pchlen>>
<<global rcount>>
int *verify, *advance, *stoff;
<<global scon>>
<<global psave>>
@


\subsection*{[[generators/lex/header.c]]}

<<function phead1>>=
void
phead1(void)
{
    Bprint(&fout,"typedef unsigned char Uchar;\n");
    if (nine) {
        Bprint(&fout,"# include <u.h>\n");
        Bprint(&fout,"# include <libc.h>\n");
    }
    Bprint(&fout,"# include <stdio.h>\n");
    Bprint(&fout, "# define U(x) x\n");
    Bprint(&fout, "# define NLSTATE yyprevious=YYNEWLINE\n");
    Bprint(&fout,"# define BEGIN yybgin = yysvec + 1 +\n");
    Bprint(&fout,"# define INITIAL 0\n");
    Bprint(&fout,"# define YYLERR yysvec\n");
    Bprint(&fout,"# define YYSTATE (yyestate-yysvec-1)\n");
    Bprint(&fout,"# define YYOPTIM 1\n");
# ifdef DEBUG
    Bprint(&fout,"# define LEXDEBUG 1\n");
# endif
    Bprint(&fout,"# define YYLMAX 200\n");
    Bprint(&fout,
"# define unput(c) {yytchar= (c);if(yytchar=='\\n')yylineno--;*yysptr++=yytchar;}\n");
    Bprint(&fout,"# define yymore() (yymorfg=1)\n");
    Bprint(&fout,"# define ECHO fprintf(yyout, \"%%s\",yytext)\n");
    Bprint(&fout,"# define REJECT { nstr = yyreject(); goto yyfussy;}\n");
    Bprint(&fout,"int yyleng; extern char yytext[];\n");
    Bprint(&fout,"int yymorfg;\n");
    Bprint(&fout,"extern Uchar *yysptr, yysbuf[];\n");
    Bprint(&fout,"int yytchar;\n");
    Bprint(&fout,"FILE *yyin = {stdin}, *yyout = {stdout};\n");
    Bprint(&fout,"extern int yylineno;\n");
    Bprint(&fout,"struct yysvf { \n");
    Bprint(&fout,"\tstruct yywork *yystoff;\n");
    Bprint(&fout,"\tstruct yysvf *yyother;\n");
    Bprint(&fout,"\tint *yystops;};\n");
    Bprint(&fout,"struct yysvf *yyestate;\n");
    Bprint(&fout,"extern struct yysvf yysvec[], *yybgin;\n");
    Bprint(&fout,"int yylook(void), yywrap(void), yyback(int *, int);\n");
    if(nine) {
        Bprint(&fout,
                "int infd, outfd;\n"
                "\n"
                "void\n"
                "output(char c)\n"
                "{\n"
                "	int rv;\n"
                "	if ((rv = write(outfd, &c, 1)) < 0)\n"
                "		sysfatal(\"output: %%r\");\n"
                "	if (rv == 0)\n"
                "		sysfatal(\"output: EOF?\");\n"
                "}\n"
                "\n"
                "int\n"
                "input(void)\n"
                "{\n"
                "	if(yysptr > yysbuf)\n"
                "		yytchar = U(*--yysptr);\n"
                "	else {\n"
                "		int rv;\n"
                "		if ((rv = read(infd, &yytchar, 1)) < 0)\n"
                "			sysfatal(\"input: %%r\");\n"
                "		if (rv == 0)\n"
                "			return 0;\n"
                "	}\n"
                "	if (yytchar == '\\n')\n"
                "		yylineno++;\n"
                "	return yytchar;\n"
                "}\n");
    }
    else {
        Bprint(&fout,"# define output(c) putc(c,yyout)\n");
        Bprint(&fout, "%s%d%s\n",
    "# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==",
        '\n',
   "?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)");
    }
}
@

<<function phead2>>=
void
phead2(void)
{
    Bprint(&fout,"while((nstr = yylook()) >= 0)\n");
    Bprint(&fout,"yyfussy: switch(nstr){\n");
    Bprint(&fout,"case 0:\n");
    Bprint(&fout,"if(yywrap()) return(0); break;\n");
}
@

<<function ptail>>=
void
ptail(void)
{
    if(!pflag){
        Bprint(&fout,"case -1:\nbreak;\n");		/* for reject */
        Bprint(&fout,"default:\n");
        Bprint(&fout,"fprintf(yyout,\"bad switch yylook %%d\",nstr);\n");
        Bprint(&fout,"} return(0); }\n");
        Bprint(&fout,"/* end of yylex */\n");
    }
    pflag = 1;
}
@

<<function statistics>>=
void
statistics(void)
{
    fprint(errorf,"%d/%d nodes(%%e), %d/%d positions(%%p), %d/%d (%%n), %ld transitions\n",
        tptr, treesize, (int)(nxtpos-positions), maxpos, stnum+1, nstates, rcount);
    fprint(errorf, ", %d/%d packed char classes(%%k)", (int)(pcptr-pchar), pchlen);
    fprint(errorf,", %d/%d packed transitions(%%a)",nptr, ntrans);
    fprint(errorf, ", %d/%d output slots(%%o)", yytop, outsize);
    fprint(errorf,"\n");
}
@


%-------------------------------------------------------------

<<generators/lex/header.c>>=
# include "ldefs.h"

<<function phead1>>

<<function phead2>>

<<function ptail>>

<<function statistics>>
@


\subsection*{[[generators/lex/sub1.c]]}

<<function getl>>=
uchar *
getl(uchar *p)	/* return next line of input, throw away trailing '\n' */
    /* returns 0 if eof is had immediately */
{
    int c;
    uchar *s, *t;

    t = s = p;
    while(((c = gch()) != 0) && c != '\n')
        *t++ = c;
    *t = 0;
    if(c == 0 && s == t) return((uchar *)0);
    prev = '\n';
    pres = '\n';
    return(s);
}
@

<<function printerr>>=
void
printerr(char *type, char *fmt, va_list argl)
{
    char buf[1024];

    if(!eof)fprint(errorf,"%s:%d  ", yyfile, yyline);
    fprint(errorf,"(%s) ", type);
    vseprint(buf, buf+sizeof(buf), fmt, argl);
    fprint(errorf, "%s\n", buf);
}
@

<<function error>>=
void
error(char *s,...)
{
    va_list argl;

    va_start(argl, s);
    printerr("Error", s, argl);
    va_end(argl);
    if(debug && sect != ENDSECTION) {
        sect1dump();
        sect2dump();
    }
    if(debug ||	report == 1) 
      statistics();
    exits("error");	/* error return code */
}
@

<<function warning>>=
void
warning(char *s,...)
{
    va_list argl;

    va_start(argl, s);
    printerr("Warning", s, argl);
    va_end(argl);
    Bflush(&fout);
}
@

<<function lgate>>=
void
lgate(void)
{
    int fd;

    if (lgatflg) return;
    lgatflg=1;
    if(foutopen == 0){
        fd = create("lex.yy.c", OWRITE, 0666);
        if(fd < 0)
            error("Can't open lex.yy.c: %r");
        Binit(&fout, fd, OWRITE);
        foutopen = 1;
        }
    phead1();
}
@

<<function cclinter>>=
void
cclinter(int sw)
{
        /* sw = 1 ==> ccl */
    int i, j, k;
    int m;
    if(!sw){		/* is NCCL */
        for(i=1;i<NCH;i++)
            symbol[i] ^= 1;			/* reverse value */
    }
    for(i=1;i<NCH;i++)
        if(symbol[i]) break;
    if(i >= NCH) return;
    i = cindex[i];
    /* see if ccl is already in our table */
    j = 0;
    if(i){
        for(j=1;j<NCH;j++){
            if((symbol[j] && cindex[j] != i) ||
               (!symbol[j] && cindex[j] == i)) break;
        }
    }
    if(j >= NCH) return;		/* already in */
    m = 0;
    k = 0;
    for(i=1;i<NCH;i++)
        if(symbol[i]){
            if(!cindex[i]){
                cindex[i] = ccount;
                symbol[i] = 0;
                m = 1;
            } else k = 1;
        }
            /* m == 1 implies last value of ccount has been used */
    if(m)ccount++;
    if(k == 0) return;	/* is now in as ccount wholly */
    /* intersection must be computed */
    for(i=1;i<NCH;i++){
        if(symbol[i]){
            m = 0;
            j = cindex[i];	/* will be non-zero */
            for(k=1;k<NCH;k++){
                if(cindex[k] == j){
                    if(symbol[k]) symbol[k] = 0;
                    else {
                        cindex[k] = ccount;
                        m = 1;
                    }
                }
            }
            if(m)ccount++;
        }
    }
}
@

<<function usescape>>=
int
usescape(int c)
{
    int d;
    switch(c){
    case 'n': c = '\n'; break;
    case 'r': c = '\r'; break;
    case 't': c = '\t'; break;
    case 'b': c = '\b'; break;
    case 'f': c = 014; break;		/* form feed for ascii */
    case '0': case '1': case '2': case '3':
    case '4': case '5': case '6': case '7':
        c -= '0';
        while('0' <= (d=gch()) && d <= '7'){
            c = c * 8 + (d-'0');
            if(!('0' <= peek && peek <= '7')) break;
            }
        break;
    }
    return(c);
}
@

<<function lookup>>=
int
lookup(uchar *s, uchar **t)
{
    int i;
    i = 0;
    while(*t){
        if(strcmp((char *)s, *(char **)t) == 0)
            return(i);
        i++;
        t++;
    }
    return(-1);
}
@

<<function lcpyact>>=
int
lcpyact(void)
{ /* copy C action to the next ; or closing } */
    int brac, c, mth;
    int savline, sw;
    char *savfile;

    brac = 0;
    sw = TRUE;
    savline = 0;
    savfile = "?";

while(!eof){
    c = gch();
swt:
    switch( c ){

case '|':	if(brac == 0 && sw == TRUE){
            if(peek == '|')gch();		/* eat up an extra '|' */
            return(0);
        }
        break;

case ';':
        if( brac == 0 ){
            Bputc(&fout, c);
            Bputc(&fout, '\n');
            return(1);
        }
        break;

case '{':
        brac++;
        savline=yyline;
        savfile=yyfile;
        break;

case '}':
        brac--;
        if( brac == 0 ){
            Bputc(&fout, c);
            Bputc(&fout, '\n');
            return(1);
        }
        break;

case '/':	/* look for comments */
        Bputc(&fout, c);
        c = gch();
        if( c != '*' ) goto swt;

        /* it really is a comment */

        Bputc(&fout, c);
        savline=yyline;
        savfile=yyfile;
        while( c=gch() ){
            if( c=='*' ){
                Bputc(&fout, c);
                if( (c=gch()) == '/' ) goto loop;
            }
            Bputc(&fout, c);
        }
        yyline=savline;
        yyfile=savfile;
        error( "EOF inside comment" );

case '\'':	/* character constant */
        mth = '\'';
        goto string;

case '"':	/* character string */
        mth = '"';

    string:

        Bputc(&fout, c);
        while( c=gch() ){
            if( c=='\\' ){
                Bputc(&fout, c);
                c=gch();
            }
            else if( c==mth ) goto loop;
            Bputc(&fout, c);
            if (c == '\n') {
                yyline--;
                error( "Non-terminated string or character constant");
            }
        }
        error( "EOF in string or character constant" );

case '\0':
        yyline = savline;
        yyfile = savfile;
        error("Action does not terminate");
default:
        break;		/* usual character */
        }
loop:
    if(c != ' ' && c != '\t' && c != '\n') sw = FALSE;
    Bputc(&fout, c);
    }
    error("Premature EOF");
    return(0);
}
@

<<function gch>>=
int
gch(void){
    int c;
    prev = pres;
    c = pres = peek;
    peek = pushptr > pushc ? *--pushptr : Bgetc(fin);
    if(peek == Beof && sargc > 1){
        Bterm(fin);
        yyfile = sargv[fptr++];
        fin = Bopen(yyfile,OREAD);
        if(fin == 0)
            error("%s - cannot open file: %r",yyfile);
        peek = Bgetc(fin);
        sargc--;
        sargv++;
    }
    if(c == Beof) {
        eof = TRUE;
        Bterm(fin);
        fin = 0;
        return(0);
    }
    if(c == '\n')yyline++;
    return(c);
}
@

<<function mn2>>=
int
mn2(int a, int d, uintptr c)
{
    name[tptr] = a;
    left[tptr] = d;
    right[tptr] = c;
    parent[tptr] = 0;
    nullstr[tptr] = 0;
    switch(a){
    case RSTR:
        parent[d] = tptr;
        break;
    case BAR:
    case RNEWE:
        if(nullstr[d] || nullstr[c]) nullstr[tptr] = TRUE;
        parent[d] = parent[c] = tptr;
        break;
    case RCAT:
    case DIV:
        if(nullstr[d] && nullstr[c])nullstr[tptr] = TRUE;
        parent[d] = parent[c] = tptr;
        break;
    case RSCON:
        parent[d] = tptr;
        nullstr[tptr] = nullstr[d];
        break;
    default:
        warning("bad switch mn2 %d %d",a,d);
        break;
        }
    if(tptr > treesize)
        error("Parse tree too big %s",(treesize == TREESIZE?"\nTry using %e num":""));
    return(tptr++);
}
@

<<function mnp>>=
int
mnp(int a, void *p)
{
    name[tptr] = a;
    left[tptr] = 0;
    parent[tptr] = 0;
    nullstr[tptr] = 0;
    ptr[tptr] = p;
    switch(a){
    case RCCL:
    case RNCCL:
        if(strlen(p) == 0) nullstr[tptr] = TRUE;
        break;
    default:
        error("bad switch mnp %d %P", a, p);
        break;
    }
    if(tptr > treesize)
        error("Parse tree too big %s",(treesize == TREESIZE?"\nTry using %e num":""));
    return(tptr++);
}
@

<<function mn1>>=
int
mn1(int a, int d)
{
    name[tptr] = a;
    left[tptr] = d;
    parent[tptr] = 0;
    nullstr[tptr] = 0;
    switch(a){
    case STAR:
    case QUEST:
        nullstr[tptr] = TRUE;
        parent[d] = tptr;
        break;
    case PLUS:
    case CARAT:
        nullstr[tptr] = nullstr[d];
        parent[d] = tptr;
        break;
    case S2FINAL:
        nullstr[tptr] = TRUE;
        break;
//#ifdef DEBUG
    case FINAL:
    case S1FINAL:
        break;
    default:
        warning("bad switch mn1 %d %d",a,d);
        break;
//# endif
    }
    if(tptr > treesize)
        error("Parse tree too big %s",(treesize == TREESIZE?"\nTry using %e num":""));
    return(tptr++);
}
@

<<function mn0>>=
int
mn0(int a)
{
    name[tptr] = a;
    parent[tptr] = 0;
    nullstr[tptr] = 0;
    if(a >= NCH) switch(a){
    case RNULLS: nullstr[tptr] = TRUE; break;
    default:
        warning("bad switch mn0 %d",a);
        break;
    }
    if(tptr > treesize)
        error("Parse tree too big %s",(treesize == TREESIZE?"\nTry using %e num":""));
    return(tptr++);
}
@

<<function munputc>>=
void
munputc(int p)
{
    *pushptr++ = peek;		/* watch out for this */
    peek = p;
    if(pushptr >= pushc+TOKENSIZE)
        error("Too many characters pushed");
}
@

<<function munputs>>=
void
munputs(uchar *p)
{
    int i,j;
    *pushptr++ = peek;
    peek = p[0];
    i = strlen((char*)p);
    for(j = i-1; j>=1; j--)
        *pushptr++ = p[j];
    if(pushptr >= pushc+TOKENSIZE)
        error("Too many characters pushed");
}
@

<<function dupl>>=
int
dupl(int n)
{
    /* duplicate the subtree whose root is n, return ptr to it */
    int i;

    i = name[n];
    if(i < NCH) return(mn0(i));
    switch(i){
    case RNULLS:
        return(mn0(i));
    case RCCL: case RNCCL:
        return(mnp(i,ptr[n]));
    case FINAL: case S1FINAL: case S2FINAL:
        return(mn1(i,left[n]));
    case STAR: case QUEST: case PLUS: case CARAT:
        return(mn1(i,dupl(left[n])));
    case RSTR: case RSCON:
        return(mn2(i,dupl(left[n]),right[n]));
    case BAR: case RNEWE: case RCAT: case DIV:
        return(mn2(i,dupl(left[n]),dupl(right[n])));
    default:
        warning("bad switch dupl %d",n);
    }
    return(0);
}
@

<<function allprint (generators/lex/sub1.c)>>=
void
allprint(int c)
{
    if(c < 0)
        c += 256;	/* signed char */
    switch(c){
        case 014:
            print("\\f");
            charc++;
            break;
        case '\n':
            print("\\n");
            charc++;
            break;
        case '\t':
            print("\\t");
            charc++;
            break;
        case '\b':
            print("\\b");
            charc++;
            break;
        case ' ':
            print("\\\bb");
            break;
        default:
            if(!isprint(c)){
                print("\\%-3o",c);
                charc += 3;
            } else 
                print("%c", c);
            break;
    }
    charc++;
}
@

<<function strpt>>=
void
strpt(uchar *s)
{
    charc = 0;
    while(*s){
        allprint(*s++);
        if(charc > LINESIZE){
            charc = 0;
            print("\n\t");
        }
    }
}
@

<<function sect1dump>>=
void
sect1dump(void)
{
    int i;

    print("Sect 1:\n");
    if(def[0]){
        print("str	trans\n");
        i = -1;
        while(def[++i])
            print("%s\t%s\n",def[i],subs[i]);
    }
    if(sname[0]){
        print("start names\n");
        i = -1;
        while(sname[++i])
            print("%s\n",sname[i]);
    }
}
@

<<function sect2dump>>=
void
sect2dump(void)
{
    print("Sect 2:\n");
    treedump();
}
@

<<function treedump>>=
void
treedump(void)
{
    int t;
    uchar *p;
    print("treedump %d nodes:\n",tptr);
    for(t=0;t<tptr;t++){
        print("%4d ",t);
        parent[t] ? print("p=%4d",parent[t]) : print("      ");
        print("  ");
        if(name[t] < NCH)
                allprint(name[t]);
        else switch(name[t]){
            case RSTR:
                print("%d ",left[t]);
                allprint(right[t]);
                break;
            case RCCL:
                print("ccl ");
                allprint((int)ptr[t]); // pad added cast, correct?
                break;
            case RNCCL:
                print("nccl ");
                allprint((int)ptr[t]); // pad added cast, correct?
                break;
            case DIV:
                print("/ %d %d",left[t],right[t]);
                break;
            case BAR:
                print("| %d %d",left[t],right[t]);
                break;
            case RCAT:
                print("cat %d %d",left[t],right[t]);
                break;
            case PLUS:
                print("+ %d",left[t]);
                break;
            case STAR:
                print("* %d",left[t]);
                break;
            case CARAT:
                print("^ %d",left[t]);
                break;
            case QUEST:
                print("? %d",left[t]);
                break;
            case RNULLS:
                print("nullstring");
                break;
            case FINAL:
                print("final %d",left[t]);
                break;
            case S1FINAL:
                print("s1final %d",left[t]);	
                break;
            case S2FINAL:
                print("s2final %d",left[t]);
                break;
            case RNEWE:
                print("new %d %d",left[t],right[t]);
                break;
            case RSCON:
                p = (uchar *)right[t];
                print("start %s",sname[*p++-1]);
                while(*p)
                    print(", %s",sname[*p++-1]);
                print(" %d",left[t]);
                break;
            default:
                print("unknown %d %d %d",name[t],left[t],right[t]);
                break;
        }
        if(nullstr[t])print("\t(null poss.)");
        print("\n");
    }
}
@


%-------------------------------------------------------------

<<generators/lex/sub1.c>>=
#include "ldefs.h"

<<function getl>>

<<function printerr>>


<<function error>>

<<function warning>>

<<function lgate>>

<<function cclinter>>

<<function usescape>>

<<function lookup>>

<<function lcpyact>>

<<function gch>>

<<function mn2>>

<<function mnp>>

<<function mn1>>

<<function mn0>>

<<function munputc>>

<<function munputs>>

<<function dupl>>

<<function allprint (generators/lex/sub1.c)>>

<<function strpt>>

<<function sect1dump>>

<<function sect2dump>>

<<function treedump>>

@


\subsection*{[[generators/lex/sub2.c]]}

<<function cfoll>>=
void
cfoll(int v)
{
    int i,j,k;
    uchar *p;
    i = name[v];
    if(i < NCH) i = 1;	/* character */
    switch(i){
        case 1: case RSTR: case RCCL: case RNCCL: case RNULLS:
            for(j=0;j<tptr;j++)
                tmpstat[j] = FALSE;
            count = 0;
            follow(v);
//#ifdef PP (true in ldefs.h)
            padd(foll,v);		/* packing version */
//#endif
//#ifndef PP
//			add(foll,v);		/* no packing version */
//#endif
            if(i == RSTR) cfoll(left[v]);
            else if(i == RCCL || i == RNCCL){	/* compress ccl list */
                for(j=1; j<NCH;j++)
                    symbol[j] = (i==RNCCL);
                p = ptr[v];
                while(*p)
                    symbol[*p++] = (i == RCCL);
                p = pcptr;
                for(j=1;j<NCH;j++)
                    if(symbol[j]){
                        for(k=0;p+k < pcptr; k++)
                            if(cindex[j] == *(p+k))
                                break;
                        if(p+k >= pcptr)*pcptr++ = cindex[j];
                    }
                *pcptr++ = 0;
                if(pcptr > pchar + pchlen)
                    error("Too many packed character classes");
                ptr[v] = p;
                name[v] = RCCL;	/* RNCCL eliminated */
                if(debug && *p){
                    print("ccl %d: %d",v,*p++);
                    while(*p)
                        print(", %d",*p++);
                    print("\n");
                }
            }
            break;
        case CARAT:
            cfoll(left[v]);
            break;
        case STAR: case PLUS: case QUEST: case RSCON: 
            cfoll(left[v]);
            break;
        case BAR: case RCAT: case DIV: case RNEWE:
            cfoll(left[v]);
            cfoll(right[v]);
            break;
//#ifdef DEBUG
        case FINAL:
        case S1FINAL:
        case S2FINAL:
            break;
        default:
            warning("bad switch cfoll %d",v);
//#endif
    }
}
@

<<function pfoll>>=
void
pfoll(void)
    {
    int i,k,*p;
    int j;
    /* print sets of chars which may follow positions */
    print("pos\tchars\n");
    for(i=0;i<tptr;i++)
        if(p=foll[i]){
            j = *p++;
            if(j >= 1){
                print("%d:\t%d",i,*p++);
                for(k=2;k<=j;k++)
                    print(", %d",*p++);
                print("\n");
            }
        }
}
@

<<function add>>=
void
add(int **array, int n)
{
    int i, *temp;
    uchar *ctemp;

    temp = nxtpos;
    ctemp = tmpstat;
    array[n] = nxtpos;		/* note no packing is done in positions */
    *temp++ = count;
    for(i=0;i<tptr;i++)
        if(ctemp[i] == TRUE)
            *temp++ = i;
    nxtpos = temp;
    if(nxtpos >= positions+maxpos)
        error("Too many positions %s",(maxpos== MAXPOS?"\nTry using %p num":""));
}
@

<<function follow>>=
void
follow(int v)
{
    int p;
    if(v >= tptr-1)return;
    p = parent[v];
    if(p == 0) return;
    switch(name[p]){
            /* will not be CHAR RNULLS FINAL S1FINAL S2FINAL RCCL RNCCL */
        case RSTR:
            if(tmpstat[p] == FALSE){
                count++;
                tmpstat[p] = TRUE;
            }
            break;
        case STAR: case PLUS:
            first(v);
            follow(p);
            break;
        case BAR: case QUEST: case RNEWE:
            follow(p);
            break;
        case RCAT: case DIV: 
            if(v == left[p]){
                if(nullstr[right[p]])
                    follow(p);
                first(right[p]);
            }
            else follow(p);
            break;
        case RSCON: case CARAT: 
            follow(p);
            break;
        default:
            warning("bad switch follow %d",p);
    }
}
@

<<function first>>=
void
first(int v)	/* calculate set of positions with v as root which can be active initially */
{
    int i;
    uchar *p;
    i = name[v];
    if(i < NCH)i = 1;
    switch(i){
        case 1: case RCCL: case RNCCL: case RNULLS: case FINAL: case S1FINAL: case S2FINAL:
            if(tmpstat[v] == FALSE){
                count++;
                tmpstat[v] = TRUE;
            }
            break;
        case BAR: case RNEWE:
            first(left[v]);
            first(right[v]);
            break;
        case CARAT:
            if(stnum % 2 == 1)
                first(left[v]);
            break;
        case RSCON:
            i = stnum/2 +1;
            p = (uchar *)right[v];
            while(*p)
                if(*p++ == i){
                    first(left[v]);
                    break;
                }
            break;
        case STAR: case QUEST: case PLUS:  case RSTR:
            first(left[v]);
            break;
        case RCAT: case DIV:
            first(left[v]);
            if(nullstr[left[v]])
                first(right[v]);
            break;
        default:
            warning("bad switch first %d",v);
    }
}
@

<<function cgoto>>=
void
cgoto(void)
{
    int i, j, s;
    int npos, curpos, n;
    int tryit;
    uchar tch[NCH];
    int tst[NCH];
    uchar *q;

    /* generate initial state, for each start condition */
    Bprint(&fout,"int yyvstop[] = {\n0,\n");
    while(stnum < 2 || stnum/2 < sptr){
        for(i = 0; i<tptr; i++) tmpstat[i] = 0;
        count = 0;
        if(tptr > 0)first(tptr-1);
        add(state,stnum);
        if(debug){
            if(stnum > 1)
                print("%s:\n",sname[stnum/2]);
            pstate(stnum);
        }
        stnum++;
    }
    stnum--;
    /* even stnum = might not be at line begin */
    /* odd stnum  = must be at line begin */
    /* even states can occur anywhere, odd states only at line begin */
    for(s = 0; s <= stnum; s++){
        tryit = FALSE;
        cpackflg[s] = FALSE;
        sfall[s] = -1;
        acompute(s);
        for(i=0;i<NCH;i++) symbol[i] = 0;
        npos = *state[s];
        for(i = 1; i<=npos; i++){
            curpos = *(state[s]+i);
            if(name[curpos] < NCH) symbol[name[curpos]] = TRUE;
            else switch(name[curpos]){
            case RCCL:
                tryit = TRUE;
                q = ptr[curpos];
                while(*q){
                    for(j=1;j<NCH;j++)
                        if(cindex[j] == *q)
                            symbol[j] = TRUE;
                    q++;
                }
                break;
            case RSTR:
                symbol[right[curpos]] = TRUE;
                break;

//# ifdef DEBUG
            case RNULLS:
            case FINAL:
            case S1FINAL:
            case S2FINAL:
                break;
            default:
                warning("bad switch cgoto %d state %d",curpos,s);
                break;
//# endif
            }
        }
        if(debug){
            print("State %d transitions on:\n\t",s);
            charc = 0;
            for(i = 1; i<NCH; i++){
                if(symbol[i]) allprint(i);
                if(charc > LINESIZE){
                    charc = 0;
                    print("\n\t");
                }
            }
            print("\n");
        }
        /* for each char, calculate next state */
        n = 0;
        for(i = 1; i<NCH; i++){
            if(symbol[i]){
                nextstate(s,i);		/* executed for each state, transition pair */
                xstate = notin(stnum);
                if(xstate == -2) warning("bad state  %d %o",s,i);
                else if(xstate == -1){
                    if(stnum >= nstates)
                        error("Too many states %s",(nstates == NSTATES ? "\nTry using %n num":""));
                    add(state,++stnum);
                    if(debug)pstate(stnum);
                    tch[n] = i;
                    tst[n++] = stnum;
                } else {		/* xstate >= 0 ==> state exists */
                    tch[n] = i;
                    tst[n++] = xstate;
                }
            }
        }
        tch[n] = 0;
        tst[n] = -1;
        /* pack transitions into permanent array */
        if(n > 0) packtrans(s,tch,tst,n,tryit);
        else gotof[s] = -1;
    }
    Bprint(&fout,"0};\n");
}
@

<<function nextstate>>=
/*	Beware -- 70% of total CPU time is spent in this subroutine -
    if you don't believe me - try it yourself ! */
void
nextstate(int s, int c)
{
    int j, *newpos;
    uchar *temp, *tz;
    int *pos, i, *f, num, curpos, number;
    /* state to goto from state s on char c */
    num = *state[s];
    temp = tmpstat;
    pos = state[s] + 1;
    for(i = 0; i<num; i++){
        curpos = *pos++;
        j = name[curpos];
        if(j < NCH && j == c
        || j == RSTR && c == right[curpos]
        || j == RCCL && member(c, ptr[curpos])){
            f = foll[curpos];
            number = *f;
            newpos = f+1;
            for(j=0;j<number;j++)
                temp[*newpos++] = 2;
        }
    }
    j = 0;
    tz = temp + tptr;
    while(temp < tz){
        if(*temp == 2){
            j++;
            *temp++ = 1;
        }
        else *temp++ = 0;
    }
    count = j;
}
@

<<function notin>>=
int
notin(int n)
{	/* see if tmpstat occurs previously */
    int *j,k;
    uchar *temp;
    int i;

    if(count == 0)
        return(-2);
    temp = tmpstat;
    for(i=n;i>=0;i--){	/* for each state */
        j = state[i];
        if(count == *j++){
            for(k=0;k<count;k++)
                if(!temp[*j++])break;
            if(k >= count)
                return(i);
        }
    }
    return(-1);
}
@

<<function packtrans>>=
void
packtrans(int st, uchar *tch, int *tst, int cnt, int tryit)
{
    /* pack transitions into nchar, nexts */
    /* nchar is terminated by '\0', nexts uses cnt, followed by elements */
    /* gotof[st] = index into nchr, nexts for state st */

    /* sfall[st] =  t implies t is fall back state for st */
    /*	        == -1 implies no fall back */

    int i,j,k;
    int cmin, cval, tcnt, diff, p, *ast;
    uchar *ach;
    int go[NCH], temp[NCH], c;
    int swork[NCH];
    uchar cwork[NCH];
    int upper;

    rcount += cnt;
    cmin = -1;
    cval = NCH;
    ast = tst;
    ach = tch;
    /* try to pack transitions using ccl's */
    if(tryit){	/* ccl's used */
        for(i=1;i<NCH;i++){
            go[i] = temp[i] = -1;
            symbol[i] = 1;
        }
        for(i=0;i<cnt;i++){
            go[tch[i]] = tst[i];
            symbol[tch[i]] = 0;
        }
        for(i=0; i<cnt;i++){
            c = match[tch[i]];
            if(go[c] != tst[i] || c == tch[i])
                temp[tch[i]] = tst[i];
        }
        /* fill in error entries */
        for(i=1;i<NCH;i++)
            if(symbol[i]) temp[i] = -2;	/* error trans */
        /* count them */
        k = 0;
        for(i=1;i<NCH;i++)
            if(temp[i] != -1)k++;
        if(k <cnt){	/* compress by char */
            if(debug) print("use compression  %d,  %d vs %d\n",st,k,cnt);
            k = 0;
            for(i=1;i<NCH;i++)
                if(temp[i] != -1){
                    cwork[k] = i;
                    swork[k++] = (temp[i] == -2 ? -1 : temp[i]);
                }
            cwork[k] = 0;
//#ifdef PC (true in ldefs.h)
            ach = cwork;
            ast = swork;
            cnt = k;
            cpackflg[st] = TRUE;
//#endif
        }
    }
    for(i=0; i<st; i++){	/* get most similar state */
                /* reject state with more transitions, state already represented by a third state,
                    and state which is compressed by char if ours is not to be */
        if(sfall[i] != -1) continue;
        if(cpackflg[st] == 1) if(!(cpackflg[i] == 1)) continue;
        p = gotof[i];
        if(p == -1) /* no transitions */ continue;
        tcnt = nexts[p];
        if(tcnt > cnt) continue;
        diff = 0;
        j = 0;
        upper = p + tcnt;
        while(ach[j] && p < upper){
            while(ach[j] < nchar[p] && ach[j]){diff++; j++; }
            if(ach[j] == 0)break;
            if(ach[j] > nchar[p]){diff=NCH;break;}
            /* ach[j] == nchar[p] */
            if(ast[j] != nexts[++p] || ast[j] == -1 || (cpackflg[st] && ach[j] != match[ach[j]]))diff++;
            j++;
        }
        while(ach[j]){
            diff++;
            j++;
        }
        if(p < upper)diff = NCH;
        if(diff < cval && diff < tcnt){
            cval = diff;
            cmin = i;
            if(cval == 0)break;
        }
    }
    /* cmin = state "most like" state st */
    if(debug)
      print("select st %d for st %d diff %d\n",cmin,st,cval);

//#ifdef PS (true in ldefs.h)
    if(cmin != -1){ /* if we can use st cmin */
        gotof[st] = nptr;
        k = 0;
        sfall[st] = cmin;
        p = gotof[cmin]+1;
        j = 0;
        while(ach[j]){
            /* if cmin has a transition on c, then so will st */
            /* st may be "larger" than cmin, however */
            while(ach[j] < nchar[p-1] && ach[j]){
                k++;
                nchar[nptr] = ach[j];
                nexts[++nptr] = ast[j];
                j++;
            }
            if(nchar[p-1] == 0)break;
            if(ach[j] > nchar[p-1]){
                warning("bad transition %d %d",st,cmin);
                goto nopack;
            }
            /* ach[j] == nchar[p-1] */
            if(ast[j] != nexts[p] || ast[j] == -1 || (cpackflg[st] && ach[j] != match[ach[j]])){
                k++;
                nchar[nptr] = ach[j];
                nexts[++nptr] = ast[j];
            }
            p++;
            j++;
        }
        while(ach[j]){
            nchar[nptr] = ach[j];
            nexts[++nptr] = ast[j++];
            k++;
        }
        nexts[gotof[st]] = cnt = k;
        nchar[nptr++] = 0;
    } else {
//#endif

nopack:
    /* stick it in */
        gotof[st] = nptr;
        nexts[nptr] = cnt;
        for(i=0;i<cnt;i++){
            nchar[nptr] = ach[i];
            nexts[++nptr] = ast[i];
        }
        nchar[nptr++] = 0;
//#ifdef PS
    }
//#endif
    if(cnt < 1){
        gotof[st] = -1;
        nptr--;
    } else
        if(nptr > ntrans)
            error("Too many transitions %s",(ntrans==NTRANS?"\nTry using %a num":""));
}
@

<<function pstate>>=
void
pstate(int s)
{
    int *p,i,j;
    print("State %d:\n",s);
    p = state[s];
    i = *p++;
    if(i == 0) return;
    print("%4d",*p++);
    for(j = 1; j<i; j++){
        print(", %4d",*p++);
        if(j%30 == 0)print("\n");
    }
    print("\n");
}
@

<<function member>>=
int
member(int d, uchar *t)
{
    int c;
    uchar *s;

    c = d;
    s = t;
    c = cindex[c];
    while(*s)
        if(*s++ == c) return(1);
    return(0);
}
@

<<function stprt>>=
void
stprt(int i)
{
    int p, t;

    print("State %d:",i);
    /* print actions, if any */
    t = atable[i];
    if(t != -1)print(" final");
    print("\n");
    if(cpackflg[i] == TRUE)print("backup char in use\n");
    if(sfall[i] != -1)print("fall back state %d\n",sfall[i]);
    p = gotof[i];
    if(p == -1) return;
    print("(%d transitions)\n",nexts[p]);
    while(nchar[p]){
        charc = 0;
        if(nexts[p+1] >= 0)
            print("%d\t",nexts[p+1]);
        else print("err\t");
        allprint(nchar[p++]);
        while(nexts[p] == nexts[p+1] && nchar[p]){
            if(charc > LINESIZE){
                charc = 0;
                print("\n\t");
            }
            allprint(nchar[p++]);
        }
        print("\n");
    }
    print("\n");
}
@

<<function acompute>>=
void
acompute(int s)	/* compute action list = set of poss. actions */
{
    int *p, i, j;
    int cnt, m;
    int temp[300], k, neg[300], n;

    k = 0;
    n = 0;
    p = state[s];
    cnt = *p++;
    if(cnt > 300)
        error("Too many positions for one state - acompute");
    for(i=0;i<cnt;i++){
        if(name[*p] == FINAL)temp[k++] = left[*p];
        else if(name[*p] == S1FINAL){temp[k++] = left[*p];
            if (left[*p] >= NACTIONS) error("Too many right contexts");
            extra[left[*p]] = 1;
        } else if(name[*p] == S2FINAL)neg[n++] = left[*p];
        p++;
    }
    atable[s] = -1;
    if(k < 1 && n < 1) return;
    if(debug) print("final %d actions:",s);
    /* sort action list */
    for(i=0; i<k; i++)
        for(j=i+1;j<k;j++)
            if(temp[j] < temp[i]){
                m = temp[j];
                temp[j] = temp[i];
                temp[i] = m;
            }
    /* remove dups */
    for(i=0;i<k-1;i++)
        if(temp[i] == temp[i+1]) temp[i] = 0;
    /* copy to permanent quarters */
    atable[s] = aptr;
    if(debug) // was in #ifdef DEBUG with no if(debug) before, so good like this?
     Bprint(&fout,"/* actions for state %d */",s);
    Bputc(&fout, '\n');
    for(i=0;i<k;i++)
        if(temp[i] != 0){
            Bprint(&fout,"%d,\n",temp[i]);
            if(debug)
                print("%d ",temp[i]);
            aptr++;
        }
    for(i=0;i<n;i++){		/* copy fall back actions - all neg */
        Bprint(&fout,"%d,\n",neg[i]);
        aptr++;
        if(debug)print("%d ",neg[i]);
    }
    if(debug)print("\n");
    Bprint(&fout,"0,\n");
    aptr++;
}
@

<<function pccl>>=
void
pccl(void) {
    /* print character class sets */
    int i, j;

    print("char class intersection\n");
    for(i=0; i< ccount; i++){
        charc = 0;
        print("class %d:\n\t",i);
        for(j=1;j<NCH;j++)
            if(cindex[j] == i){
                allprint(j);
                if(charc > LINESIZE){
                    print("\n\t");
                    charc = 0;
                }
            }
        print("\n");
    }
    charc = 0;
    print("match:\n");
    for(i=0;i<NCH;i++){
        allprint(match[i]);
        if(charc > LINESIZE){
            print("\n");
            charc = 0;
        }
    }
    print("\n");
}
@

<<function mkmatch>>=
void
mkmatch(void)
{
    int i;
    uchar tab[NCH];

    for(i=0; i<ccount; i++)
        tab[i] = 0;
    for(i=1;i<NCH;i++)
        if(tab[cindex[i]] == 0)
            tab[cindex[i]] = i;
    /* tab[i] = principal char for new ccl i */
    for(i = 1; i<NCH; i++)
        match[i] = tab[cindex[i]];
}
@

<<function layout>>=
void
layout(void)
{
    /* format and output final program's tables */
    int i, j, k;
    int  top, bot, startup, omin;

    for(i=0; i<outsize;i++)
        verify[i] = advance[i] = 0;
    omin = 0;
    yytop = 0;
    for(i=0; i<= stnum; i++){	/* for each state */
        j = gotof[i];
        if(j == -1){
            stoff[i] = 0;
            continue;
            }
        bot = j;
        while(nchar[j])j++;
        top = j - 1;
        if (debug) {
            print("State %d: (layout)\n", i);
            for(j=bot; j<=top;j++) {
                print("  %o", nchar[j]);
                if (j%10==0) print("\n");
            }
            print("\n");
        }
        while(verify[omin+NCH]) omin++;
        startup = omin;
        if (debug) print("bot,top %d, %d startup begins %d\n",bot,top,startup);
        do {
            startup += 1;
            if(startup > outsize - NCH)
                error("output table overflow");
            for(j = bot; j<= top; j++){
                k = startup + nchar[j];
                if(verify[k])break;
            }
        } while (j <= top);
        /* have found place */
        if (debug) print(" startup going to be %d\n", startup);
        for(j = bot; j<= top; j++){
            k = startup + nchar[j];
            verify[k] = i+1;			/* state number + 1*/
            advance[k] = nexts[j+1]+1;		/* state number + 1*/
            if(yytop < k) yytop = k;
        }
        stoff[i] = startup;
    }

    /* stoff[i] = offset into verify, advance for trans for state i */
    /* put out yywork */
    Bprint(&fout,"# define YYTYPE %s\n",stnum+1 >= NCH ? "int" : "Uchar");
    Bprint(&fout,"struct yywork { YYTYPE verify, advance; } yycrank[] = {\n");
    for(i=0;i<=yytop;i+=4){
        for(j=0;j<4;j++){
            k = i+j;
            if(verify[k])
                Bprint(&fout,"%d,%d,\t",verify[k],advance[k]);
            else
                Bprint(&fout,"0,0,\t");
        }
        Bputc(&fout, '\n');
    }
    Bprint(&fout,"0,0};\n");

    /* put out yysvec */

    Bprint(&fout,"struct yysvf yysvec[] = {\n");
    Bprint(&fout,"0,\t0,\t0,\n");
    for(i=0;i<=stnum;i++){	/* for each state */
        if(cpackflg[i])stoff[i] = -stoff[i];
        Bprint(&fout,"yycrank+%d,\t",stoff[i]);
        if(sfall[i] != -1)
            Bprint(&fout,"yysvec+%d,\t", sfall[i]+1);	/* state + 1 */
        else Bprint(&fout,"0,\t\t");
        if(atable[i] != -1)
            Bprint(&fout,"yyvstop+%d,",atable[i]);
        else Bprint(&fout,"0,\t");
        if(debug) // was just in ifdef DEBUG before with no if(debug), good?
       Bprint(&fout,"\t\t/* state %d */",i);
        Bputc(&fout, '\n');
    }
    Bprint(&fout,"0,\t0,\t0};\n");

    /* put out yymatch */
    
    Bprint(&fout,"struct yywork *yytop = yycrank+%d;\n",yytop);
    Bprint(&fout,"struct yysvf *yybgin = yysvec+1;\n");
    Bprint(&fout,"Uchar yymatch[] = {\n");
    for(i=0; i<NCH; i+=8){
        for(j=0; j<8; j++){
            int fbch;
            fbch = match[i+j];
            if(isprint(fbch) && fbch != '\'' && fbch != '\\')
                Bprint(&fout,"'%c' ,",fbch);
            else Bprint(&fout,"0%-3o,",fbch);
        }
        Bputc(&fout, '\n');
    }
    Bprint(&fout,"0};\n");
    /* put out yyextra */
    Bprint(&fout,"Uchar yyextra[] = {\n");
    for(i=0;i<casecount;i+=8){
        for(j=0;j<8;j++)
            Bprint(&fout, "%d,", i+j<NACTIONS ?
                extra[i+j] : 0);
        Bputc(&fout, '\n');
    }
    Bprint(&fout,"0};\n");
}
@

<<function padd>>=
//#ifdef PP (true in ldefs.h)
void
padd(int **array, int n)
{
    int i, *j, k;

    array[n] = nxtpos;
    if(count == 0){
        *nxtpos++ = 0;
        return;
    }
    for(i=tptr-1;i>=0;i--){
        j = array[i];
        if(j && *j++ == count){
            for(k=0;k<count;k++)
                if(!tmpstat[*j++])break;
            if(k >= count){
                array[n] = array[i];
                return;
            }
        }
    }
    add(array,n);
}
@


%-------------------------------------------------------------

<<generators/lex/sub2.c>>=
#include "ldefs.h"

<<function cfoll>>

<<function pfoll>>

<<function add>>

<<function follow>>

<<function first>>

<<function cgoto>>

<<function nextstate>>

<<function notin>>

<<function packtrans>>

<<function pstate>>

<<function member>>

<<function stprt>>

<<function acompute>>

<<function pccl>>

<<function mkmatch>>

<<function layout>>

<<function padd>>
//#endif
@


\subsection*{[[generators/lex/lmain.c]]}

<<function SETYY>>=
#define SETYY() yydebug = TRUE
@

<<function SETYY (generators/lex/lmain.c)>>=
#define SETYY() nil
@

<<function main (generators/lex/lmain.c)>>=
void
main(int argc, char **argv)
{
    int i;

    ARGBEGIN {
        case 'd': debug++; break;
        case 'y': SETYY(); break;
        case 't': case 'T':
            Binit(&fout, 1, OWRITE);
            errorf= 2;
            foutopen = 1;
            break;
        case 'v': case 'V':
            report = 1;
            break;
        case 'n': case 'N':
            report = 0;
            break;
        case '9':
            nine = 1;
            break;
        default:
            warning("Unknown option %c", ARGC());
    } ARGEND
    sargc = argc;
    sargv = argv;
    if (argc > 0){
        yyfile = argv[fptr++];
        fin = Bopen(yyfile, OREAD);
        if(fin == 0)
            error ("%s - can't open file: %r", yyfile);
        sargc--;
        sargv++;
    }
    else {
        yyfile = "/fd/0";
        fin = myalloc(sizeof(Biobuf), 1);
        if(fin == 0)
            exits("core");
        Binit(fin, 0, OREAD);
    }
    if(Bgetc(fin) == Beof)		/* no input */
        exits(0);
    Bseek(fin, 0, 0);
    gch();
        /* may be gotten: def, subs, sname, stchar, ccl, dchar */
    get1core();
        /* may be gotten: name, left, right, nullstr, parent, ptr */
    strcpy((char*)sp, "INITIAL");
    sname[0] = sp;
    sp += strlen("INITIAL") + 1;
    sname[1] = 0;
    if(yyparse()) exits("error");	/* error return code */
        /* may be disposed of: def, subs, dchar */
    free1core();
        /* may be gotten: tmpstat, foll, positions, gotof, nexts, nchar, state, atable, sfall, cpackflg */
    get2core();
    ptail();
    mkmatch();
    if(debug) pccl();
    sect  = ENDSECTION;
    if(tptr>0)cfoll(tptr-1);
    if(debug)pfoll();
    cgoto();
    if(debug){
        print("Print %d states:\n",stnum+1);
        for(i=0;i<=stnum;i++)stprt(i);
        }
        /* may be disposed of: positions, tmpstat, foll, state, name, left, right, parent, ccl, stchar, sname */
        /* may be gotten: verify, advance, stoff */
    free2core();
    get3core();
    layout();
        /* may be disposed of: verify, advance, stoff, nexts, nchar,
            gotof, atable, ccpackflg, sfall */
    // was in #ifdef DEBUG before with no if(debug), so ok like this?
    if(debug) free3core();
    fother = Bopen(cname,OREAD);
    if(fother == 0)
        error("Lex driver missing, file %s: %r",cname);
    while ( (i=Bgetc(fother)) != Beof)
        Bputc(&fout, i);

    Bterm(fother);
    Bterm(&fout);
    if(debug ||	report == 1)
        statistics();
    if (fin)
        Bterm(fin);
    exits(0);	/* success return code */
}
@

<<function get1core>>=
static void
get1core(void)
{
    ccptr =	ccl = myalloc(CCLSIZE,sizeof(*ccl));
    pcptr = pchar = myalloc(pchlen, sizeof(*pchar));
    def = myalloc(DEFSIZE,sizeof(*def));
    subs = myalloc(DEFSIZE,sizeof(*subs));
    dp = dchar = myalloc(DEFCHAR,sizeof(*dchar));
    sname = myalloc(STARTSIZE,sizeof(*sname));
    sp = stchar = myalloc(STARTCHAR,sizeof(*stchar));
    if(ccl == 0 || def == 0 || subs == 0 || dchar == 0 || sname == 0 || stchar == 0)
        error("Too little core to begin");
}
@

<<function free1core>>=
static void
free1core(void)
{
    free(def);
    free(subs);
    free(dchar);
}
@

<<function get2core>>=
static void
get2core(void)
{
    int i;

    gotof = myalloc(nstates,sizeof(*gotof));
    nexts = myalloc(ntrans,sizeof(*nexts));
    nchar = myalloc(ntrans,sizeof(*nchar));
    state = myalloc(nstates,sizeof(*state));
    atable = myalloc(nstates,sizeof(*atable));
    sfall = myalloc(nstates,sizeof(*sfall));
    cpackflg = myalloc(nstates,sizeof(*cpackflg));
    tmpstat = myalloc(tptr+1,sizeof(*tmpstat));
    foll = myalloc(tptr+1,sizeof(*foll));
    nxtpos = positions = myalloc(maxpos,sizeof(*positions));
    if(tmpstat == 0 || foll == 0 || positions == 0 ||
        gotof == 0 || nexts == 0 || nchar == 0 || state == 0 || atable == 0 || sfall == 0 || cpackflg == 0 )
        error("Too little core for state generation");
    for(i=0;i<=tptr;i++)foll[i] = 0;
}
@

<<function free2core>>=
static void
free2core(void)
{
    free(positions);
    free(tmpstat);
    free(foll);
    free(name);
    free(left);
    free(right);
    free(parent);
    free(nullstr);
    free(ptr);
    free(state);
    free(sname);
    free(stchar);
    free(ccl);
}
@

<<function get3core>>=
static void
get3core(void)
{
    verify = myalloc(outsize,sizeof(*verify));
    advance = myalloc(outsize,sizeof(*advance));
    stoff = myalloc(stnum+2,sizeof(*stoff));
    if(verify == 0 || advance == 0 || stoff == 0)
        error("Too little core for final packing");
}
@

<<function free3core>>=
static void
free3core(void){
    free(advance);
    free(verify);
    free(stoff);
    free(gotof);
    free(nexts);
    free(nchar);
    free(atable);
    free(sfall);
    free(cpackflg);
}
@

<<function myalloc>>=
void *
myalloc(int a, int b)
{
    void *i;
    i = calloc(a, b);
    if(i==0)
        warning("OOPS - calloc returns a 0");
    return(i);
}
@

<<function yyerror>>=
void
yyerror(char *s)
{
    fprint(2, "%s:%d %s\n", yyfile, yyline, s);
}
@


%-------------------------------------------------------------

<<generators/lex/lmain.c>>=
/* lex [-[dynvt]] [file] ... [file] */

/* Copyright 1976, Bell Telephone Laboratories, Inc.,
   written by Eric Schmidt, August 27, 1976   */

#include "ldefs.h"

static void	free1core(void);
static void	free2core(void);
static void	free3core(void);
static void	get1core(void);
static void	get2core(void);
static void	get3core(void);

#ifdef DEBUG
<<function SETYY>>
#else
<<function SETYY (generators/lex/lmain.c)>>
#endif

<<function main (generators/lex/lmain.c)>>

<<function get1core>>

<<function free1core>>

<<function get2core>>

<<function free2core>>

<<function get3core>>

<<function free3core>>

<<function myalloc>>

<<function yyerror>>
@



\section{[[generators/lex/liblex/]]}

\subsection*{[[generators/lex/liblex/allprint.c]]}

<<function printable>>=
//extern	FILE*	yyout;

int
printable(int c)
{
    return 040 < c && c < 0177;
}
@

<<function allprint>>=
void
allprint(int c)
{
  exits("TODO allprint");
//	switch(c) {
//	case '\n':
//		fprintf(yyout,"\\n");
//		break;
//	case '\t':
//		fprintf(yyout,"\\t");
//		break;
//	case '\b':
//		fprintf(yyout,"\\b");
//		break;
//	case ' ':
//		fprintf(yyout,"\\\bb");
//		break;
//	default:
//		if(!printable(c))
//			fprintf(yyout,"\\%-3o",c);
//		else 
//			c = putc(c,yyout);
//			USED(c);
//		break;
//	}
//	return;
}
@


%-------------------------------------------------------------

<<generators/lex/liblex/allprint.c>>=
#include	"../ldefs.h"
//#include	<stdio.h>

<<function printable>>

<<function allprint>>
@


\subsection*{[[generators/lex/liblex/main.c]]}

<<function main>>=
void
main(int argc, char *argv[])
{
    USED(argc, argv);
    yylex();
    exits(0);
}
@


%-------------------------------------------------------------

<<generators/lex/liblex/main.c>>=
#include	<u.h>
#include	<libc.h>
//#include	<stdio.h>

int	yylex(void);

<<function main>>
@


\subsection*{[[generators/lex/liblex/reject.c]]}

<<function yyracc>>=
int
yyracc(int m)
{

    yyolsp = yylsp;
    if(yyextra[m]) {
        while(yyback((*yylsp)->yystops, -m) != 1 && yylsp > yylstate) {
            yylsp--;
            yyunput(yytext[--yyleng]);
        }
    }
    yyprevious = yytext[yyleng-1];
    yytext[yyleng] = 0;
    return m;
}
@

<<function yyreject>>=
int
yyreject(void)
{
    for(; yylsp < yyolsp; yylsp++)
        yytext[yyleng++] = yyinput();
    if(*yyfnd > 0)
        return yyracc(*yyfnd++);
    while(yylsp-- > yylstate) {
        yyunput(yytext[yyleng-1]);
        yytext[--yyleng] = 0;
        if(*yylsp != 0 && (yyfnd = (*yylsp)->yystops) && *yyfnd > 0)
            return yyracc(*yyfnd++);
    }
    if(yytext[0] == 0)
        return 0;
    yyoutput(yyprevious = yyinput());
    yyleng = 0;
    return -1;
}
@


%-------------------------------------------------------------

<<generators/lex/liblex/reject.c>>=
#include	<u.h>
#include	<libc.h>
//#include	<stdio.h>

//extern	FILE*	yyout;
//extern	FILE*	yyin;
extern	int	yyprevious, *yyfnd;
extern	char	yyextra[];
extern	char	yytext[];
extern	int	yyleng;

extern
struct
{
    int *yyaa, *yybb;
    int *yystops;
} *yylstate [], **yylsp, **yyolsp;

int	yyback(int *p, int m);
int	yyinput(void);
void	yyoutput(int c);
void	yyunput(int c);

<<function yyracc>>

<<function yyreject>>
@


\subsection*{[[generators/lex/liblex/yyless.c]]}

<<function yyless>>=
void
yyless(int x)
{
    char *lastch, *ptr;

    lastch = yytext+yyleng;
    if(x>=0 && x <= yyleng)
        ptr = x + yytext;
    else
        ptr = (char*)x;
    while(lastch > ptr)
        yyunput(*--lastch);
    *lastch = 0;
    if (ptr >yytext)
        yyprevious = lastch[-1];
    yyleng = ptr-yytext;
}
@


%-------------------------------------------------------------

<<generators/lex/liblex/yyless.c>>=
#include	<u.h>
#include	<libc.h>
//#include	<stdio.h>

extern	char	yytext[];
extern	int	yyleng;
extern	int	yyprevious;

void	yyunput(int c);

<<function yyless>>
@


\subsection*{[[generators/lex/liblex/yywrap.c]]}

<<function yywrap>>=
//#include	<stdio.h>

int
yywrap(void)
{
    return 1;
}
@


%-------------------------------------------------------------

<<generators/lex/liblex/yywrap.c>>=
#include	<u.h>
#include	<libc.h>
<<function yywrap>>
@


\section{[[generators/yacc/]]}

\subsection*{[[generators/yacc/yacc.c]]}

<<constant Bungetrune>>=
#define	Bungetrune	Bungetc		/* ok for now. */
@

<<constant TBITSET>>=
/*
 * all these are 32 bit
 */
#define TBITSET		((32+NTERMS)/32)	/* BOTCH?? +31 */
@

<<function BIT>>=
#define BIT(a,i)	((a)[(i)>>5] & (1<<((i)&037)))
@

<<function SETBIT>>=
#define SETBIT(a,i)	((a)[(i)>>5] |= (1<<((i)&037)))
@

% >>

<<function NWORDS>>=
#define NWORDS(n)	(((n)+32)/32)
@

<<constant PARSER>>=
#define PARSER		"/sys/lib/yaccpar"
@

<<constant PARSERS>>=
#define PARSERS		"/sys/lib/yaccpars"
@

<<constant TEMPNAME>>=
#define TEMPNAME	"y.tmp.XXXXXX"
@

<<constant ACTNAME>>=
#define ACTNAME		"y.acts.XXXXXX"
@

<<constant OFILE>>=
#define OFILE		"tab.c"
@

<<constant FILEU>>=
#define FILEU		"output"
@

<<constant FILED>>=
#define FILED		"tab.h"
@

<<constant FILEDEBUG>>=
#define FILEDEBUG	"debug"
@

<<enum _anon_>>=
enum
{
/*
 * the following are adjustable
 * according to memory size
 */
    ACTSIZE		= 40000,
    MEMSIZE		= 40000,
    NSTATES		= 2000,
    NTERMS		= 511,
    NPROD		= 1600,
    NNONTERM	= 600,
    TEMPSIZE	= 2000,
    CNAMSZ		= 10000,
    LSETSIZE	= 2400,
    WSETSIZE	= 350,

    NAMESIZE	= 50,
    NTYPES		= 63,
    ISIZE		= 400,

    PRIVATE		= 0xE000,	/* unicode private use */

    /* relationships which must hold:
        TBITSET ints must hold NTERMS+1 bits...
        WSETSIZE >= NNONTERM
        LSETSIZE >= NNONTERM
        TEMPSIZE >= NTERMS + NNONTERM + 1
        TEMPSIZE >= NSTATES
    */

    NTBASE		= 010000,
    ERRCODE		= 8190,
    ACCEPTCODE	= 8191,

    NOASC		= 0,	/* no assoc. */
    LASC		= 1,	/* left assoc. */
    RASC		= 2,	/* right assoc. */
    BASC		= 3,	/* binary assoc. */

    /* flags for state generation */

    DONE		= 0,
    MUSTDO		= 1,
    MUSTLOOKAHEAD	= 2,

    /* flags for a rule having an action, and being reduced */

    ACTFLAG		= 04,
    REDFLAG		= 010,

    /* output parser flags */
    YYFLAG1		= -1000,

    /* parse tokens */
    IDENTIFIER	= PRIVATE,
    MARK,
    TERM,
    LEFT,
    RIGHT,
    BINARY,
    PREC,
    LCURLY,
    IDENTCOLON,
    NUMBER,
    START,
    TYPEDEF,
    TYPENAME,
    UNION,

    ENDFILE		= 0,

    EMPTY		= 1,
    WHOKNOWS	= 0,
    OK		= 1,
    NOMORE		= -1000,
};
@

<<function ASSOC>>=
#define ASSOC(i)	((i)&03)
@

<<function PLEVEL>>=
#define PLEVEL(i)	(((i)>>4)&077)
@

<<function TYPE>>=
#define TYPE(i)		(((i)>>10)&077)
@

<<function SETASC>>=
#define SETASC(i,j)	i |= j
@

<<function SETPLEV>>=
#define SETPLEV(i,j)	i |= (j<<4)
@

<<function SETTYPE>>=
#define SETTYPE(i,j)	i |= (j<<10)
@

<<function WSBUMP>>=
#define WSBUMP(x)	x++
@

<<global faction>>=
Biobuf*	faction;	/* file for saving actions */
@

<<global fdefine>>=
Biobuf*	fdefine;	/* file for #defines */
@

<<global fdebug>>=
Biobuf*	fdebug;		/* y.debug for strings for debugging */
@

<<global ftable>>=
Biobuf*	ftable;		/* y.tab.c file */
@

<<global ftemp>>=
Biobuf*	ftemp;		/* tempfile to pass 2 */
@

<<global finput>>=
Biobuf*	finput;		/* input file */
@

<<global foutput>>=
Biobuf*	foutput;	/* y.output file */
@

<<global infile>>=
char*	infile;			/* input file name */
@

<<global numbval>>=
int	numbval;		/* value of an input number */
@

<<global tokname>>=
char	tokname[NAMESIZE+UTFmax+1]; /* input token name, slop for runes and 0 */
@

<<global cnames>>=
char	cnames[CNAMSZ];		/* place where token and nonterminal names are stored */
@

<<global cnamsz>>=
int	cnamsz = CNAMSZ;	/* size of cnames */
@

<<global cnamp>>=
char*	cnamp = cnames;		/* place where next name is to be put in */
@

<<global ndefout>>=
int	ndefout = 4;		/* number of defined symbols output */
@

<<global tempname>>=
char*	tempname;
@

<<global actname>>=
char*	actname;
@

<<global ttempname>>=
char	ttempname[] = TEMPNAME;
@

<<global tactname>>=
char	tactname[] = ACTNAME;
@

<<global parser>>=
char*	parser = PARSER;
@

<<global yydebug>>=
char*	yydebug;
@

<<global ntypes>>=
int	ntypes;			/* number of types defined */
@

<<global typeset>>=
char*	typeset[NTYPES];	/* pointers to type tags */
@

<<global ntokens>>=
int	ntokens = 0 ;		/* number of tokens */
@

<<global tokset>>=
Symb	tokset[NTERMS];
@

<<global toklev>>=
int	toklev[NTERMS];		/* vector with the precedence of the terminals */
@

<<global nnonter>>=
int	nnonter = -1;		/* the number of nonterminals */
@

<<global nontrst>>=
Symb	nontrst[NNONTERM];
@

<<global start>>=
int	start;			/* start symbol */
@

<<global extval>>=
int	extval = 0;
@

<<global ytabc>>=
char*	ytabc = OFILE;	/* name of y.tab.c */
@

<<global mem0>>=
int	mem0[MEMSIZE] ;		/* production storage */
@

<<global mem>>=
int*	mem = mem0;
@

<<global nprod>>=
int	nprod = 1;		/* number of productions */
@

<<global prdptr>>=
int*	prdptr[NPROD];		/* pointers to descriptions of productions */
@

<<global levprd>>=
int	levprd[NPROD];		/* precedence levels for the productions */
@

<<global rlines>>=
int	rlines[NPROD];		/* line number for this rule */
@

<<global nstate>>=
int	nstate = 0;		/* number of states */
@

<<global pstate>>=
Item*	pstate[NSTATES+2];	/* pointers to the descriptions of the states */
@

<<global tystate>>=
int	tystate[NSTATES];	/* contains type information about the states */
@

<<global defact>>=
int	defact[NSTATES];	/* the default actions of states */
@

<<global tstates>>=
int	tstates[NTERMS];	/* states generated by terminal gotos */
@

<<global ntstates>>=
int	ntstates[NNONTERM]; 	/* states generated by nonterminal gotos */
@

<<global mstates>>=
int	mstates[NSTATES];	/* chain of overflows of term/nonterm generation lists  */
@

<<global lastred>>=
int	lastred; 		/* the number of the last reduction of a state */
@

<<global lkst>>=
Lkset	lkst[LSETSIZE];
@

<<global nolook>>=
int	nolook = 0;			/* flag to turn off lookahead computations */
@

<<global tbitset>>=
int	tbitset;		/* size of lookahead sets */
@

<<global nlset>>=
int	nlset = 0;		/* next lookahead set index */
@

<<global clset>>=
Lkset	clset;  		/* temporary storage for lookahead computations */
@

<<global wsets>>=
Wset	wsets[WSETSIZE];
@

<<global cwp>>=
Wset*	cwp;
@

<<global amem>>=
int	amem[ACTSIZE];		/* action table storage */
@

<<global memp>>=
int*	memp = amem;		/* next free action table position */
@

<<global indgo>>=
int	indgo[NSTATES];		/* index to the stored goto table */
@

<<global temp1>>=
int	temp1[TEMPSIZE];	/* temporary storage, indexed by terms + ntokens or states */
@

<<global lineno>>=
int	lineno = 1;		/* current input line number */
@

<<global fatfl>>=
int	fatfl = 1;  		/* if on, error is fatal */
@

<<global nerrors>>=
int	nerrors = 0;		/* number of errors */
@

<<global zzgoent>>=
int	zzgoent = 0;
@

<<global zzgobest>>=
int	zzgobest = 0;
@

<<global zzacent>>=
int	zzacent = 0;
@

<<global zzexcp>>=
int	zzexcp = 0;
@

<<global zzclose>>=
int	zzclose = 0;
@

<<global zzrrconf>>=
int	zzrrconf = 0;
@

<<global zzsrconf>>=
int	zzsrconf;
@

<<global ggreed>>=
int*	ggreed = lkst[0].lset;
@

<<global pgo>>=
int*	pgo = wsets[0].ws.lset;
@

<<global yypgo>>=
int*	yypgo = &nontrst[0].value;
@

<<global maxspr>>=
int	maxspr = 0;  		/* maximum spread of any entry */
@

<<global maxoff>>=
int	maxoff = 0;  		/* maximum offset into a array */
@

<<global pmem>>=
int*	pmem = mem0;
@

<<global maxa>>=
int*	maxa;
@

<<global nxdb>>=
int	nxdb = 0;
@

<<global adb>>=
int	adb = 0;
@

<<global pres (generators/yacc/yacc.c)>>=
static int**	pres[NNONTERM+2];  	/* vector of pointers to productions yielding each nonterminal */
@

<<global pfirst>>=
Lkset*	pfirst[NNONTERM+2];	/* vector of pointers to first sets for each nonterminal */
@

<<global pempty>>=
int	pempty[NNONTERM+1];	/* vector of nonterminals nontrivially deriving e */
@

<<global indebug>>=
int	indebug = 0;
@

<<global zzcwp>>=
Wset*	zzcwp = wsets;
@

<<global zzmemsz>>=
int*	zzmemsz = mem0;
@

<<global pidebug>>=
int	pidebug = 0;		/* debugging flag for putitem */
@

<<global gsdebug>>=
int	gsdebug = 0;
@

<<global cldebug>>=
int	cldebug = 0;		/* debugging flag for closure */
@

<<global pkdebug>>=
int	pkdebug = 0;
@

<<global g2debug>>=
int	g2debug = 0;
@

<<global resrv>>=
struct
{
    char*	name;
    long	value;
} resrv[] =
{
    "binary",	BINARY,
    "left",		LEFT,
    "nonassoc",	BINARY,
    "prec",		PREC,
    "right",	RIGHT,
    "start",	START,
    "term",		TERM,
    "token",	TERM,
    "type",		TYPEDEF,
    "union",	UNION,
    0,
};
@

<<function main (generators/yacc/yacc.c)>>=
void
main(int argc, char *argv[])
{

    setup(argc, argv);	/* initialize and read productions */
    tbitset = NWORDS(ntokens);
    cpres();		/* make table of which productions yield a given nonterminal */
    cempty();		/* make a table of which nonterminals can match the empty string */
    cpfir();		/* make a table of firsts of nonterminals */
    stagen();		/* generate the states */
    output();		/* write the states and the tables */
    go2out();
    hideprod();
    summary();
    callopt();
    others();
    exits(0);
}
@

<<function others>>=
/*
 * put out other arrays, copy the parsers
 */
void
others(void)
{
    int c, i, j;

    finput = Bopen(parser, OREAD);
    if(finput == 0)
        error("cannot find parser %s", parser);
    warray("yyr1", levprd, nprod);
    aryfil(temp1, nprod, 0);
    PLOOP(1, i)
        temp1[i] = prdptr[i+1]-prdptr[i]-2;
    warray("yyr2", temp1, nprod);

    aryfil(temp1, nstate, -1000);
    TLOOP(i)
        for(j=tstates[i]; j!=0; j=mstates[j])
            temp1[j] = i;
    NTLOOP(i)
        for(j=ntstates[i]; j!=0; j=mstates[j])
            temp1[j] = -i;
    warray("yychk", temp1, nstate);
    warray("yydef", defact, nstate);

    /* put out token translation tables */
    /* table 1 has 0-256 */
    aryfil(temp1, 256, 0);
    c = 0;
    TLOOP(i) {
        j = tokset[i].value;
        if(j >= 0 && j < 256) {
            if(temp1[j]) {
                print("yacc bug -- cant have 2 different Ts with same value\n");
                print("	%s and %s\n", tokset[i].name, tokset[temp1[j]].name);
                nerrors++;
            }
            temp1[j] = i;
            if(j > c)
                c = j;
        }
    }
    warray("yytok1", temp1, c+1);

    /* table 2 has PRIVATE-PRIVATE+256 */
    aryfil(temp1, 256, 0);
    c = 0;
    TLOOP(i) {
        j = tokset[i].value - PRIVATE;
        if(j >= 0 && j < 256) {
            if(temp1[j]) {
                print("yacc bug -- cant have 2 different Ts with same value\n");
                print("	%s and %s\n", tokset[i].name, tokset[temp1[j]].name);
                nerrors++;
            }
            temp1[j] = i;
            if(j > c)
                c = j;
        }
    }
    warray("yytok2", temp1, c+1);

    /* table 3 has everything else */
    Bprint(ftable, "long	yytok3[] =\n{\n");
    c = 0;
    TLOOP(i) {
        j = tokset[i].value;
        if(j >= 0 && j < 256)
            continue;
        if(j >= PRIVATE && j < 256+PRIVATE)
            continue;

        Bprint(ftable, "%4d,%4d,", j, i);
        c++;
        if(c%5 == 0)
            Bprint(ftable, "\n");
    }
    Bprint(ftable, "%4d\n};\n", 0);

    /* copy parser text */
    while((c=Bgetrune(finput)) != Beof) {
        if(c == '$') {
            if((c = Bgetrune(finput)) != 'A')
                Bputrune(ftable, '$');
            else { /* copy actions */
                faction = Bopen(actname, OREAD);
                if(faction == 0)
                    error("cannot reopen action tempfile");
                while((c=Bgetrune(faction)) != Beof)
                    Bputrune(ftable, c);
                Bterm(faction);
                ZAPFILE(actname);
                c = Bgetrune(finput);
            }
        }
        Bputrune(ftable, c);
    }
    Bterm(ftable);
}
@

<<function chcopy>>=
/*
 * copies string q into p, returning next free char ptr
 */
char*
chcopy(char* p, char* q)
{
    int c;

    while(c = *q) {
        if(c == '"')
            *p++ = '\\';
        *p++ = c;
        q++;
    }
    *p = 0;
    return p;
}
@

<<function writem>>=
/*
 * creates output string for item pointed to by pp
 */
char*
writem(int *pp)
{
    int i,*p;
    static char sarr[ISIZE];
    char* q;

    for(p=pp; *p>0; p++)
        ;
    p = prdptr[-*p];
    q = chcopy(sarr, nontrst[*p-NTBASE].name);
    q = chcopy(q, ": ");
    for(;;) {
        *q = ' ';
        p++;
        if(p == pp)
            *q = '.';
        q++;
        *q = '\0';
        i = *p;
        if(i <= 0)
            break;
        q = chcopy(q, symnam(i));
        if(q > &sarr[ISIZE-30])
            error("item too big");
    }

    /* an item calling for a reduction */
    i = *pp;
    if(i < 0 ) {
        q = chcopy(q, "    (");
        sprint(q, "%d)", -i);
    }
    return sarr;
}
@

<<function symnam>>=
/*
 * return a pointer to the name of symbol i
 */
char*
symnam(int i)
{
    char* cp;

    cp = (i >= NTBASE)? nontrst[i-NTBASE].name: tokset[i].name;
    if(*cp == ' ')
        cp++;
    return cp;
}
@

<<function summary>>=
/*
 * output the summary on y.output
 */
void
summary(void)
{

    if(foutput != 0) {
        Bprint(foutput, "\n%d/%d terminals, %d/%d nonterminals\n",
            ntokens, NTERMS, nnonter, NNONTERM);
        Bprint(foutput, "%d/%d grammar rules, %d/%d states\n",
            nprod, NPROD, nstate, NSTATES);
        Bprint(foutput, "%d shift/reduce, %d reduce/reduce conflicts reported\n",
            zzsrconf, zzrrconf);
        Bprint(foutput, "%d/%d working sets used\n",
            (int)(zzcwp-wsets), WSETSIZE);
        Bprint(foutput, "memory: states,etc. %d/%d, parser %d/%d\n",
            (int)(zzmemsz-mem0), MEMSIZE, (int)(memp-amem), ACTSIZE);
        Bprint(foutput, "%d/%d distinct lookahead sets\n", nlset, LSETSIZE);
        Bprint(foutput, "%d extra closures\n", zzclose - 2*nstate);
        Bprint(foutput, "%d shift entries, %d exceptions\n", zzacent, zzexcp);
        Bprint(foutput, "%d goto entries\n", zzgoent);
        Bprint(foutput, "%d entries saved by goto default\n", zzgobest);
    }
    if(zzsrconf != 0 || zzrrconf != 0) {
        print("\nconflicts: ");
        if(zzsrconf)
            print("%d shift/reduce", zzsrconf);
        if(zzsrconf && zzrrconf)
            print(", ");
        if(zzrrconf)
            print("%d reduce/reduce", zzrrconf);
        print("\n");
    }
    if(ftemp != 0) {
        Bterm(ftemp);
        ftemp = 0;
    }
    if(fdefine != 0) {
        Bterm(fdefine);
        fdefine = 0;
    }
}
@

<<function error (generators/yacc/yacc.c)>>=
/*
 * write out error comment -- NEEDS WORK
 */
void
error(char *s, ...)
{

    nerrors++;
    fprint(2, "\n fatal error:");
    fprint(2, s, (&s)[1]);
    fprint(2, ", %s:%d\n", infile, lineno);
    if(!fatfl)
        return;
    summary();
    cleantmp();
    exits("error");
}
@

<<function aryfil>>=
/*
 * set elements 0 through n-1 to c
 */
void
aryfil(int *v, int n, int c)
{
    int i;

    for(i=0; i<n; i++)
        v[i] = c;
}
@

<<function setunion>>=
/*
 * set a to the union of a and b
 * return 1 if b is not a subset of a, 0 otherwise
 */
int
setunion(int *a, int *b)
{
    int i, x, sub;

    sub = 0;
    SETLOOP(i) {
        x = *a;
        *a |= *b;
        if(*a != x)
            sub = 1;
        a++;
        b++;
    }
    return sub;
}
@

<<function prlook>>=
void
prlook(Lkset* p)
{
    int j, *pp;

    pp = p->lset;
    if(pp == 0)
        Bprint(foutput, "\tNULL");
    else {
        Bprint(foutput, " { ");
        TLOOP(j)
            if(BIT(pp,j))
                Bprint(foutput, "%s ", symnam(j));
        Bprint(foutput, "}");
    }
}
@

<<function cpres>>=
/*
 * compute an array with the beginnings of  productions yielding given nonterminals
 * The array pres points to these lists
 * the array pyield has the lists: the total size is only NPROD+1
 */
void
cpres(void)
{
    int c, j, i, **pmem;
    static int *pyield[NPROD];

    pmem = pyield;
    NTLOOP(i) {
        c = i+NTBASE;
        pres[i] = pmem;
        fatfl = 0;  	/* make undefined  symbols  nonfatal */
        PLOOP(0, j)
            if(*prdptr[j] == c)
                *pmem++ =  prdptr[j]+1;
        if(pres[i] == pmem)
            error("nonterminal %s not defined!", nontrst[i].name);
    }
    pres[i] = pmem;
    fatfl = 1;
    if(nerrors) {
        summary();
        cleantmp();
        exits("error");
    }
    if(pmem != &pyield[nprod])
        error("internal Yacc error: pyield %d", pmem-&pyield[nprod]);
}
@

<<function cpfir>>=
/*
 * compute an array with the first of nonterminals
 */
void
cpfir(void)
{
    int *p, **s, i, **t, ch, changes;

    zzcwp = &wsets[nnonter];
    NTLOOP(i) {
        aryfil(wsets[i].ws.lset, tbitset, 0);
        t = pres[i+1];
        /* initially fill the sets */
        for(s=pres[i]; s<t; ++s)
            for(p = *s; (ch = *p) > 0; ++p) {
                if(ch < NTBASE) {
                    SETBIT(wsets[i].ws.lset, ch);
                    break;
                }
                if(!pempty[ch-NTBASE])
                    break;
            }
    }

    /* now, reflect transitivity */
    changes = 1;
    while(changes) {
        changes = 0;
        NTLOOP(i) {
            t = pres[i+1];
            for(s = pres[i]; s < t; ++s)
                for(p = *s; (ch = (*p-NTBASE)) >= 0; ++p) {
                    changes |= setunion(wsets[i].ws.lset, wsets[ch].ws.lset);
                    if(!pempty[ch])
                        break;
                }
        }
    }

    NTLOOP(i)
        pfirst[i] = flset(&wsets[i].ws);
    if(!indebug)
        return;
    if(foutput != 0)
        NTLOOP(i) {
            Bprint(foutput, "\n%s: ", nontrst[i].name);
            prlook(pfirst[i]);
            Bprint(foutput, " %d\n", pempty[i]);
        }
}
@

<<function state>>=
/*
 * sorts last state,and sees if it equals earlier ones. returns state number
 */
int
state(int c)
{
    Item *p1, *p2, *k, *l, *q1, *q2;
    int size1, size2, i;

    p1 = pstate[nstate];
    p2 = pstate[nstate+1];
    if(p1 == p2)
        return 0;	/* null state */
    /* sort the items */
    for(k = p2-1; k > p1; k--)	/* make k the biggest */
        for(l = k-1; l >= p1; --l)
            if(l->pitem > k->pitem) {
                int *s;
                Lkset *ss;

                s = k->pitem;
                k->pitem = l->pitem;
                l->pitem = s;
                ss = k->look;
                k->look = l->look;
                l->look = ss;
            }
    size1 = p2 - p1;	/* size of state */

    for(i = (c>=NTBASE)? ntstates[c-NTBASE]: tstates[c]; i != 0; i = mstates[i]) {
        /* get ith state */
        q1 = pstate[i];
        q2 = pstate[i+1];
        size2 = q2 - q1;
        if(size1 != size2)
            continue;
        k = p1;
        for(l = q1; l < q2; l++) {
            if(l->pitem != k->pitem)
                break;
            k++;
        }
        if(l != q2)
            continue;
        /* found it */
        pstate[nstate+1] = pstate[nstate];	/* delete last state */
        /* fix up lookaheads */
        if(nolook)
            return i;
        for(l = q1, k = p1; l < q2; ++l, ++k ) {
            int s;

            SETLOOP(s)
                clset.lset[s] = l->look->lset[s];
            if(setunion(clset.lset, k->look->lset)) {
                tystate[i] = MUSTDO;
                /* register the new set */
                l->look = flset( &clset );
            }
        }
        return i;
    }
    /* state is new */
    if(nolook)
        error("yacc state/nolook error");
    pstate[nstate+2] = p2;
    if(nstate+1 >= NSTATES)
        error("too many states");
    if(c >= NTBASE) {
        mstates[nstate] = ntstates[c-NTBASE];
        ntstates[c-NTBASE] = nstate;
    } else {
        mstates[nstate] = tstates[c];
        tstates[c] = nstate;
    }
    tystate[nstate] = MUSTDO;
    return nstate++;
}
@

<<function putitem>>=
void
putitem(int *ptr, Lkset *lptr)
{
    Item *j;

    if(pidebug && foutput != 0)
        Bprint(foutput, "putitem(%s), state %d\n", writem(ptr), nstate);
    j = pstate[nstate+1];
    j->pitem = ptr;
    if(!nolook)
        j->look = flset(lptr);
    pstate[nstate+1] = ++j;
    if((int*)j > zzmemsz) {
        zzmemsz = (int*)j;
        if(zzmemsz >=  &mem0[MEMSIZE])
            error("out of state space");
    }
}
@

<<function cempty>>=
/*
 * mark nonterminals which derive the empty string
 * also, look for nonterminals which don't derive any token strings
 */
void
cempty(void)
{

    int i, *p;

    /* first, use the array pempty to detect productions that can never be reduced */
    /* set pempty to WHONOWS */
    aryfil(pempty, nnonter+1, WHOKNOWS);

    /* now, look at productions, marking nonterminals which derive something */
more:
    PLOOP(0, i) {
        if(pempty[*prdptr[i] - NTBASE])
            continue;
        for(p = prdptr[i]+1; *p >= 0; ++p)
            if(*p >= NTBASE && pempty[*p-NTBASE] == WHOKNOWS)
                break;
        /* production can be derived */
        if(*p < 0) {
            pempty[*prdptr[i]-NTBASE] = OK;
            goto more;
        }
    }

    /* now, look at the nonterminals, to see if they are all OK */
    NTLOOP(i) {
        /* the added production rises or falls as the start symbol ... */
        if(i == 0)
            continue;
        if(pempty[i] != OK) {
            fatfl = 0;
            error("nonterminal %s never derives any token string", nontrst[i].name);
        }
    }

    if(nerrors) {
        summary();
        cleantmp();
        exits("error");
    }

    /* now, compute the pempty array, to see which nonterminals derive the empty string */
    /* set pempty to WHOKNOWS */
    aryfil( pempty, nnonter+1, WHOKNOWS);

    /* loop as long as we keep finding empty nonterminals */

again:
    PLOOP(1, i) {
        /* not known to be empty */
        if(pempty[*prdptr[i]-NTBASE] == WHOKNOWS) {
            for(p = prdptr[i]+1; *p >= NTBASE && pempty[*p-NTBASE] == EMPTY ; ++p)
                ;
            /* we have a nontrivially empty nonterminal */
            if(*p < 0) {
                pempty[*prdptr[i]-NTBASE] = EMPTY;
                /* got one ... try for another */
                goto again;
            }
        }
    }
}
@

<<function stagen>>=
/*
 * generate the states
 */
void
stagen(void)
{

    int c, i, j, more;
    Wset *p, *q;

    /* initialize */
    nstate = 0;

    /* THIS IS FUNNY from the standpoint of portability
     * it represents the magic moment when the mem0 array, which has
     * been holding the productions, starts to hold item pointers, of a
     * different type...
     * someday, alloc should be used to allocate all this stuff... for now, we
     * accept that if pointers don't fit in integers, there is a problem...
     */

    pstate[0] = pstate[1] = (Item*)mem;
    aryfil(clset.lset, tbitset, 0);
    putitem(prdptr[0]+1, &clset);
    tystate[0] = MUSTDO;
    nstate = 1;
    pstate[2] = pstate[1];

    aryfil(amem, ACTSIZE, 0);

    /* now, the main state generation loop */
    for(more=1; more;) {
        more = 0;
        SLOOP(i) {
            if(tystate[i] != MUSTDO)
                continue;
            tystate[i] = DONE;
            aryfil(temp1, nnonter+1, 0);
            /* take state i, close it, and do gotos */
            closure(i);
            /* generate goto's */
            WSLOOP(wsets, p) {
                if(p->flag)
                    continue;
                p->flag = 1;
                c = *(p->pitem);
                if(c <= 1) {
                    if(pstate[i+1]-pstate[i] <= p-wsets)
                        tystate[i] = MUSTLOOKAHEAD;
                    continue;
                }
                /* do a goto on c */
                WSLOOP(p, q)
                    /* this item contributes to the goto */
                    if(c == *(q->pitem)) {
                        putitem(q->pitem+1, &q->ws);
                        q->flag = 1;
                    }
                if(c < NTBASE)
                    state(c);	/* register new state */
                else
                    temp1[c-NTBASE] = state(c);
            }
            if(gsdebug && foutput != 0) {
                Bprint(foutput, "%d: ", i);
                NTLOOP(j)
                    if(temp1[j])
                        Bprint(foutput, "%s %d, ",
                        nontrst[j].name, temp1[j]);
                Bprint(foutput, "\n");
            }
            indgo[i] = apack(&temp1[1], nnonter-1) - 1;
            /* do some more */
            more = 1;
        }
    }
}
@

<<function closure>>=
/*
 * generate the closure of state i
 */
void
closure(int i)
{

    Wset *u, *v;
    Item *p, *q;
    int c, ch, work, k, *pi, **s, **t;

    zzclose++;

    /* first, copy kernel of state i to wsets */
    cwp = wsets;
    ITMLOOP(i, p, q) {
        cwp->pitem = p->pitem;
        cwp->flag = 1;			/* this item must get closed */
        SETLOOP(k)
            cwp->ws.lset[k] = p->look->lset[k];
        WSBUMP(cwp);
    }

    /* now, go through the loop, closing each item */
    work = 1;
    while(work) {
        work = 0;
        WSLOOP(wsets, u) {
            if(u->flag == 0)
                continue;
            /* dot is before c */
            c = *(u->pitem);
            if(c < NTBASE) {
                u->flag = 0;
                /* only interesting case is where . is before nonterminal */
                continue;
            }

            /* compute the lookahead */
            aryfil(clset.lset, tbitset, 0);

            /* find items involving c */
            WSLOOP(u, v)
                if(v->flag == 1 && *(pi=v->pitem) == c) {
                    v->flag = 0;
                    if(nolook)
                        continue;
                    while((ch = *++pi) > 0) {
                        /* terminal symbol */
                        if(ch < NTBASE) {
                            SETBIT(clset.lset, ch);
                            break;
                        }
                        /* nonterminal symbol */
                        setunion(clset.lset, pfirst[ch-NTBASE]->lset);
                        if(!pempty[ch-NTBASE])
                            break;
                    }
                    if(ch <= 0)
                        setunion(clset.lset, v->ws.lset);
                }

            /*
             * now loop over productions derived from c
             * c is now nonterminal number
             */
            c -= NTBASE;
            t = pres[c+1];
            for(s = pres[c]; s < t; ++s) {
                /*
                 * put these items into the closure
                 * is the item there
                 */
                WSLOOP(wsets, v)
                    /* yes, it is there */
                    if(v->pitem == *s) {
                        if(nolook)
                            goto nexts;
                        if(setunion(v->ws.lset, clset.lset))
                            v->flag = work = 1;
                        goto nexts;
                    }

                /*  not there; make a new entry */
                if(cwp-wsets+1 >= WSETSIZE)
                    error( "working set overflow");
                cwp->pitem = *s;
                cwp->flag = 1;
                if(!nolook) {
                    work = 1;
                    SETLOOP(k) cwp->ws.lset[k] = clset.lset[k];
                }
                WSBUMP(cwp);

            nexts:;
            }
        }
    }

    /* have computed closure; flags are reset; return */
    if(cwp > zzcwp)
        zzcwp = cwp;
    if(cldebug && foutput != 0) {
        Bprint(foutput, "\nState %d, nolook = %d\n", i, nolook);
        WSLOOP(wsets, u) {
            if(u->flag)
                Bprint(foutput, "flag set!\n");
            u->flag = 0;
            Bprint(foutput, "\t%s", writem(u->pitem));
            prlook(&u->ws);
            Bprint(foutput, "\n");
        }
    }
}
@

<<function flset>>=
/*
 * decide if the lookahead set pointed to by p is known
 * return pointer to a perminent location for the set
 */
Lkset*
flset(Lkset *p)
{
    Lkset *q;
    int *u, *v, *w, j;

    for(q = &lkst[nlset]; q-- > lkst;) {
        u = p->lset;
        v = q->lset;
        w = &v[tbitset];
        while(v < w)
            if(*u++ != *v++)
                goto more;
        /* we have matched */
        return q;
    more:;
    }
    /* add a new one */
    q = &lkst[nlset++];
    if(nlset >= LSETSIZE)
        error("too many lookahead sets");
    SETLOOP(j)
        q->lset[j] = p->lset[j];
    return q;
}
@

<<function cleantmp>>=
void
cleantmp(void)
{
    ZAPFILE(actname);
    ZAPFILE(tempname);
}
@

<<function intr>>=
void
intr(void)
{
    cleantmp();
    exits("interrupted");
}
@

<<function usage>>=
void
usage(void)
{
    fprint(2, "usage: yacc [-Dn] [-vdS] [-o outputfile] [-s stem] grammar\n");
    exits("usage");
}
@

<<function setup>>=
void
setup(int argc, char *argv[])
{
    long c, t;
    int i, j, lev, ty, ytab, *p;
    int vflag, dflag, stem;
    char actnm[8], *stemc, *s, dirbuf[128];

    ytab = 0;
    vflag = 0;
    dflag = 0;
    stem = 0;
    stemc = "y";
    foutput = 0;
    fdefine = 0;
    fdebug = 0;
    ARGBEGIN{
    case 'v':
    case 'V':
        vflag++;
        break;
    case 'D':
        yydebug = EARGF(usage());
        break;
    case 'd':
        dflag++;
        break;
    case 'o':
        ytab++;
        ytabc = EARGF(usage());
        break;
    case 's':
        stem++;
        stemc = ARGF();
        break;
    case 'S':
        parser = PARSERS;
        break;
    default:
        error("illegal option: %c", ARGC());
    }ARGEND
    openup(stemc, dflag, vflag, ytab, ytabc);

    ftemp = Bopen(tempname = mktemp(ttempname), OWRITE);
    faction = Bopen(actname = mktemp(tactname), OWRITE);
    if(ftemp == 0 || faction == 0)
        error("cannot open temp file");
    if(argc < 1)
        error("no input file");
    infile = argv[0];
    if(infile[0] != '/' && getwd(dirbuf, sizeof dirbuf)!=nil){
        i = strlen(infile)+1+strlen(dirbuf)+1+10;
        s = malloc(i);
        if(s != nil){
            snprint(s, i, "%s/%s", dirbuf, infile);
            cleanname(s);
            infile = s;
        }
    }
    finput = Bopen(infile, OREAD);
    if(finput == 0)
        error("cannot open '%s'", argv[0]);
    cnamp = cnames;

    defin(0, "$end");
    extval = PRIVATE;	/* tokens start in unicode 'private use' */
    defin(0, "error");
    defin(1, "$accept");
    defin(0, "$unk");
    mem = mem0;
    i = 0;

    for(t = gettok(); t != MARK && t != ENDFILE;)
    switch(t) {
    case ';':
        t = gettok();
        break;

    case START:
        if(gettok() != IDENTIFIER)
            error("bad %%start construction");
        start = chfind(1, tokname);
        t = gettok();
        continue;

    case TYPEDEF:
        if(gettok() != TYPENAME)
            error("bad syntax in %%type");
        ty = numbval;
        for(;;) {
            t = gettok();
            switch(t) {
            case IDENTIFIER:
                if((t=chfind(1, tokname)) < NTBASE) {
                    j = TYPE(toklev[t]);
                    if(j != 0 && j != ty)
                        error("type redeclaration of token %s",
                            tokset[t].name);
                    else
                        SETTYPE(toklev[t], ty);
                } else {
                    j = nontrst[t-NTBASE].value;
                    if(j != 0 && j != ty)
                        error("type redeclaration of nonterminal %s",
                            nontrst[t-NTBASE].name );
                    else
                        nontrst[t-NTBASE].value = ty;
                }
            case ',':
                continue;
            case ';':
                t = gettok();
            default:
                break;
            }
            break;
        }
        continue;

    case UNION:
        /* copy the union declaration to the output */
        cpyunion();
        t = gettok();
        continue;

    case LEFT:
    case BINARY:
    case RIGHT:
        i++;

    case TERM:
        /* nonzero means new prec. and assoc. */
        lev = t-TERM;
        ty = 0;

        /* get identifiers so defined */
        t = gettok();

        /* there is a type defined */
        if(t == TYPENAME) {
            ty = numbval;
            t = gettok();
        }
        for(;;) {
            switch(t) {
            case ',':
                t = gettok();
                continue;

            case ';':
                break;

            case IDENTIFIER:
                j = chfind(0, tokname);
                if(j >= NTBASE)
                    error("%s defined earlier as nonterminal", tokname);
                if(lev) {
                    if(ASSOC(toklev[j]))
                        error("redeclaration of precedence of %s", tokname);
                    SETASC(toklev[j], lev);
                    SETPLEV(toklev[j], i);
                }
                if(ty) {
                    if(TYPE(toklev[j]))
                        error("redeclaration of type of %s", tokname);
                    SETTYPE(toklev[j],ty);
                }
                t = gettok();
                if(t == NUMBER) {
                    tokset[j].value = numbval;
                    if(j < ndefout && j > 3)
                        error("please define type number of %s earlier",
                            tokset[j].name);
                    t = gettok();
                }
                continue;
            }
            break;
        }
        continue;

    case LCURLY:
        defout(0);
        cpycode();
        t = gettok();
        continue;

    default:
        error("syntax error");
    }
    if(t == ENDFILE)
        error("unexpected EOF before %%");

    /* t is MARK */
    Bprint(ftable, "extern	int	yyerrflag;\n");
    Bprint(ftable, "#ifndef	YYMAXDEPTH\n");
    Bprint(ftable, "#define	YYMAXDEPTH	150\n");
    Bprint(ftable, "#endif\n" );
    if(!ntypes) {
        Bprint(ftable, "#ifndef	YYSTYPE\n");
        Bprint(ftable, "#define	YYSTYPE	int\n");
        Bprint(ftable, "#endif\n");
    }
    Bprint(ftable, "YYSTYPE	yylval;\n");
    Bprint(ftable, "YYSTYPE	yyval;\n");

    prdptr[0] = mem;

    /* added production */
    *mem++ = NTBASE;

    /* if start is 0, we will overwrite with the lhs of the first rule */
    *mem++ = start;
    *mem++ = 1;
    *mem++ = 0;
    prdptr[1] = mem;
    while((t=gettok()) == LCURLY)
        cpycode();
    if(t != IDENTCOLON)
        error("bad syntax on first rule");

    if(!start)
        prdptr[0][1] = chfind(1, tokname);

    /* read rules */
    while(t != MARK && t != ENDFILE) {
        /* process a rule */
        rlines[nprod] = lineno;
        if(t == '|')
            *mem++ = *prdptr[nprod-1];
        else
            if(t == IDENTCOLON) {
                *mem = chfind(1, tokname);
                if(*mem < NTBASE)
                    error("token illegal on LHS of grammar rule");
                mem++;
            } else
                error("illegal rule: missing semicolon or | ?");
        /* read rule body */
        t = gettok();

    more_rule:
        while(t == IDENTIFIER) {
            *mem = chfind(1, tokname);
            if(*mem < NTBASE)
                levprd[nprod] = toklev[*mem];
            mem++;
            t = gettok();
        }
        if(t == PREC) {
            if(gettok() != IDENTIFIER)
                error("illegal %%prec syntax");
            j = chfind(2, tokname);
            if(j >= NTBASE)
                error("nonterminal %s illegal after %%prec",
                    nontrst[j-NTBASE].name);
            levprd[nprod] = toklev[j];
            t = gettok();
        }
        if(t == '=') {
            levprd[nprod] |= ACTFLAG;
            Bprint(faction, "\ncase %d:", nprod);
            cpyact(mem-prdptr[nprod]-1);
            Bprint(faction, " break;");
            if((t=gettok()) == IDENTIFIER) {

                /* action within rule... */
                sprint(actnm, "$$%d", nprod);

                /* make it a nonterminal */
                j = chfind(1, actnm);

                /*
                 * the current rule will become rule number nprod+1
                 * move the contents down, and make room for the null
                 */
                for(p = mem; p >= prdptr[nprod]; --p)
                    p[2] = *p;
                mem += 2;

                /* enter null production for action */
                p = prdptr[nprod];
                *p++ = j;
                *p++ = -nprod;

                /* update the production information */
                levprd[nprod+1] = levprd[nprod] & ~ACTFLAG;
                levprd[nprod] = ACTFLAG;
                if(++nprod >= NPROD)
                    error("more than %d rules", NPROD);
                prdptr[nprod] = p;

                /* make the action appear in the original rule */
                *mem++ = j;

                /* get some more of the rule */
                goto more_rule;
            }
        }

        while(t == ';')
            t = gettok();
        *mem++ = -nprod;

        /* check that default action is reasonable */
        if(ntypes && !(levprd[nprod]&ACTFLAG) && nontrst[*prdptr[nprod]-NTBASE].value) {

            /* no explicit action, LHS has value */
            int tempty;

            tempty = prdptr[nprod][1];
            if(tempty < 0)
                error("must return a value, since LHS has a type");
            else
                if(tempty >= NTBASE)
                    tempty = nontrst[tempty-NTBASE].value;
                else
                    tempty = TYPE(toklev[tempty]);
            if(tempty != nontrst[*prdptr[nprod]-NTBASE].value)
                error("default action causes potential type clash");
        }
        nprod++;
        if(nprod >= NPROD)
            error("more than %d rules", NPROD);
        prdptr[nprod] = mem;
        levprd[nprod] = 0;
    }

    /* end of all rules */
    defout(1);

    finact();
    if(t == MARK) {
        Bprint(ftable, "\n#line\t%d\t\"%s\"\n", lineno, infile);
        while((c=Bgetrune(finput)) != Beof)
            Bputrune(ftable, c);
    }
    Bterm(finput);
}
@

%$

<<function finact>>=
/*
 * finish action routine
 */
void
finact(void)
{

    Bterm(faction);
    Bprint(ftable, "#define YYEOFCODE %d\n", 1);
    Bprint(ftable, "#define YYERRCODE %d\n", 2);
}
@

<<function defin>>=
/*
 * define s to be a terminal if t=0
 * or a nonterminal if t=1
 */
int
defin(int nt, char *s)
{
    int val;
    Rune rune;

    val = 0;
    if(nt) {
        nnonter++;
        if(nnonter >= NNONTERM)
            error("too many nonterminals, limit %d",NNONTERM);
        nontrst[nnonter].name = cstash(s);
        return NTBASE + nnonter;
    }

    /* must be a token */
    ntokens++;
    if(ntokens >= NTERMS)
        error("too many terminals, limit %d", NTERMS);
    tokset[ntokens].name = cstash(s);

    /* establish value for token */
    /* single character literal */
    if(s[0] == ' ') {
        val = chartorune(&rune, &s[1]);
        if(s[val+1] == 0) {
            val = rune;
            goto out;
        }
    }

    /* escape sequence */
    if(s[0] == ' ' && s[1] == '\\') {
        if(s[3] == 0) {
            /* single character escape sequence */
            switch(s[2]) {
            case 'n':	val = '\n'; break;
            case 'r':	val = '\r'; break;
            case 'b':	val = '\b'; break;
            case 't':	val = '\t'; break;
            case 'f':	val = '\f'; break;
            case '\'':	val = '\''; break;
            case '"':	val = '"'; break;
            case '\\':	val = '\\'; break;
            default:	error("invalid escape");
            }
            goto out;
        }

        /* \nnn sequence */
        if(s[2] >= '0' && s[2] <= '7') {
            if(s[3] < '0' ||
               s[3] > '7' ||
               s[4] < '0' ||
               s[4] > '7' ||
               s[5] != 0)
                error("illegal \\nnn construction");
            val = 64*s[2] + 8*s[3] + s[4] - 73*'0';
            if(val == 0)
                error("'\\000' is illegal");
            goto out;
        }
        error("unknown escape");
    }
    val = extval++;

out:
    tokset[ntokens].value = val;
    toklev[ntokens] = 0;
    return ntokens;
}
@

<<function defout>>=
/*
 * write out the defines (at the end of the declaration section)
 */
void
defout(int last)
{
    int i, c;
    char sar[NAMESIZE+10];

    for(i=ndefout; i<=ntokens; i++) {
        /* non-literals */
        c = tokset[i].name[0];
        if(c != ' ' && c != '$') {
            Bprint(ftable, "#define	%s	%d\n",
                tokset[i].name, tokset[i].value);
            if(fdefine)
                Bprint(fdefine, "#define\t%s\t%d\n",
                    tokset[i].name, tokset[i].value);
        }
    }
    ndefout = ntokens+1;
    if(last && fdebug) {
        Bprint(fdebug, "char*	yytoknames[] =\n{\n");
        TLOOP(i) {
            if(tokset[i].name) {
                chcopy(sar, tokset[i].name);
                Bprint(fdebug, "\t\"%s\",\n", sar);
                continue;
            }
            Bprint(fdebug, "\t0,\n");
        }
        Bprint(fdebug, "};\n");
    }
}
@
%$

<<function cstash>>=
char*
cstash(char *s)
{
    char *temp;

    temp = cnamp;
    do {
        if(cnamp >= &cnames[cnamsz])
            error("too many characters in id's and literals");
        else
            *cnamp++ = *s;
    } while(*s++);
    return temp;
}
@

<<function gettok>>=
long
gettok(void)
{
    long c;
    Rune rune;
    int i, base, match, reserve;
    static int peekline;

begin:
    reserve = 0;
    lineno += peekline;
    peekline = 0;
    c = Bgetrune(finput);
    while(c == ' ' || c == '\n' || c == '\t' || c == '\f') {
        if(c == '\n')
            lineno++;
        c = Bgetrune(finput);
    }

    /* skip comment */
    if(c == '/') {
        lineno += skipcom();
        goto begin;
    }
    switch(c) {
    case Beof:
        return ENDFILE;

    case '{':
        Bungetrune(finput);
        return '=';

    case '<':
        /* get, and look up, a type name (union member name) */
        i = 0;
        while((c=Bgetrune(finput)) != '>' && c >= 0 && c != '\n') {
            rune = c;
            c = runetochar(&tokname[i], &rune);
            if(i < NAMESIZE)
                i += c;
        }
        if(c != '>')
            error("unterminated < ... > clause");
        tokname[i] = 0;
        for(i=1; i<=ntypes; i++)
            if(!strcmp(typeset[i], tokname)) {
                numbval = i;
                return TYPENAME;
            }
        ntypes++;
        numbval = ntypes;
        typeset[numbval] = cstash(tokname);
        return TYPENAME;

    case '"':
    case '\'':
        match = c;
        tokname[0] = ' ';
        i = 1;
        for(;;) {
            c = Bgetrune(finput);
            if(c == '\n' || c <= 0)
                error("illegal or missing ' or \"" );
            if(c == '\\') {
                tokname[i] = '\\';
                if(i < NAMESIZE)
                    i++;
                c = Bgetrune(finput);
            } else
                if(c == match)
                    break;
            rune = c;
            c = runetochar(&tokname[i], &rune);
            if(i < NAMESIZE)
                i += c;
        }
        break;

    case '%':
    case '\\':
        switch(c = Bgetrune(finput)) {
        case '0':	return TERM;
        case '<':	return LEFT;
        case '2':	return BINARY;
        case '>':	return RIGHT;
        case '%':
        case '\\':	return MARK;
        case '=':	return PREC;
        case '{':	return LCURLY;
        default:	reserve = 1;
        }

    default:
        /* number */
        if(isdigit(c)) {
            numbval = c-'0';
            base = (c=='0')? 8: 10;
            for(c = Bgetrune(finput); isdigit(c); c = Bgetrune(finput))
                numbval = numbval*base + (c-'0');
            Bungetrune(finput);
            return NUMBER;
        }
        if(islower(c) || isupper(c) || c=='_' || c=='.' || c=='$')  {
            i = 0;
            while(islower(c) || isupper(c) || isdigit(c) ||
                c == '-' || c=='_' || c=='.' || c=='$') {
                if(reserve && isupper(c))
                    c += 'a'-'A';
                rune = c;
                c = runetochar(&tokname[i], &rune);
                if(i < NAMESIZE)
                    i += c;
                c = Bgetrune(finput);
            }
        } else
            return c;
        Bungetrune(finput);
    }
    tokname[i] = 0;

    /* find a reserved word */
    if(reserve) {
        for(c=0; resrv[c].name; c++)
            if(strcmp(tokname, resrv[c].name) == 0)
                return resrv[c].value;
        error("invalid escape, or illegal reserved word: %s", tokname);
    }

    /* look ahead to distinguish IDENTIFIER from IDENTCOLON */
    c = Bgetrune(finput);
    while(c == ' ' || c == '\t'|| c == '\n' || c == '\f' || c == '/') {
        if(c == '\n')
            peekline++;
        /* look for comments */
        if(c == '/')
            peekline += skipcom();
        c = Bgetrune(finput);
    }
    if(c == ':')
        return IDENTCOLON;
    Bungetrune(finput);
    return IDENTIFIER;
}
@

<<function fdtype>>=
/*
 * determine the type of a symbol
 */
int
fdtype(int t)
{
    int v;

    if(t >= NTBASE)
        v = nontrst[t-NTBASE].value;
    else
        v = TYPE(toklev[t]);
    if(v <= 0)
        error("must specify type for %s", (t>=NTBASE)?
            nontrst[t-NTBASE].name: tokset[t].name);
    return v;
}
@

<<function chfind>>=
int
chfind(int t, char *s)
{
    int i;

    if(s[0] == ' ')
        t = 0;
    TLOOP(i)
        if(!strcmp(s, tokset[i].name))
            return i;
    NTLOOP(i)
        if(!strcmp(s, nontrst[i].name))
            return NTBASE+i;

    /* cannot find name */
    if(t > 1)
        error("%s should have been defined earlier", s);
    return defin(t, s);
}
@

<<function cpyunion>>=
/*
 * copy the union declaration to the output, and the define file if present
 */
void
cpyunion(void)
{
    long c;
    int level;

    Bprint(ftable, "\n#line\t%d\t\"%s\"\n", lineno, infile);
    Bprint(ftable, "typedef union ");
    if(fdefine != 0)
        Bprint(fdefine, "\ntypedef union ");

    level = 0;
    for(;;) {
        if((c=Bgetrune(finput)) == Beof)
            error("EOF encountered while processing %%union");
        Bputrune(ftable, c);
        if(fdefine != 0)
            Bputrune(fdefine, c);
        switch(c) {
        case '\n':
            lineno++;
            break;
        case '{':
            level++;
            break;
        case '}':
            level--;

            /* we are finished copying */
            if(level == 0) {
                Bprint(ftable, " YYSTYPE;\n");
                if(fdefine != 0)
                    Bprint(fdefine, "\tYYSTYPE;\nextern\tYYSTYPE\tyylval;\n");
                return;
            }
        }
    }
}
@

<<function cpycode>>=
/*
 * copies code between \{ and \}
 */
void
cpycode(void)
{

    long c;

    c = Bgetrune(finput);
    if(c == '\n') {
        c = Bgetrune(finput);
        lineno++;
    }
    Bprint(ftable, "\n#line\t%d\t\"%s\"\n", lineno, infile);
    while(c != Beof) {
        if(c == '\\') {
            if((c=Bgetrune(finput)) == '}')
                return;
            Bputc(ftable, '\\');
        }
        if(c == '%') {
            if((c=Bgetrune(finput)) == '}')
                return;
            Bputc(ftable, '%');
        }
        Bputrune(ftable, c);
        if(c == '\n')
            lineno++;
        c = Bgetrune(finput);
    }
    error("eof before %%}");
}
@

<<function skipcom>>=
/*
 * skip over comments
 * skipcom is called after reading a '/'
 */
int
skipcom(void)
{
    long c;
    int i;

    /* i is the number of lines skipped */
    i = 0;
    c = Bgetrune(finput);
    if(c == '/'){			/* C++ //: skip to end of line */
        while((c = Bgetrune(finput)) != Beof)
            if(c == '\n')
                return 1;
    }else if(c == '*'){		/* normal C comment */
        while((c = Bgetrune(finput)) != Beof) {
            while(c == '*')
                if((c = Bgetrune(finput)) == '/')
                    return i;
            if(c == '\n')
                i++;
        }
    }else
        error("illegal comment");

    error("EOF inside comment");
    return 0;
}
@

<<function cpyact>>=
/*
 * copy C action to the next ; or closing }
 */
void
cpyact(int offset)
{
    long c;
    int brac, match, j, s, fnd, tok;

    Bprint(faction, "\n#line\t%d\t\"%s\"\n", lineno, infile);
    brac = 0;

loop:
    c = Bgetrune(finput);
swt:
    switch(c) {
    case ';':
        if(brac == 0) {
            Bputrune(faction, c);
            return;
        }
        goto lcopy;

    case '{':
        brac++;
        goto lcopy;

    case '$':
        s = 1;
        tok = -1;
        c = Bgetrune(finput);

        /* type description */
        if(c == '<') {
            Bungetrune(finput);
            if(gettok() != TYPENAME)
                error("bad syntax on $<ident> clause");
            tok = numbval;
            c = Bgetrune(finput);
        }
        if(c == '$') {
            Bprint(faction, "yyval");

            /* put out the proper tag... */
            if(ntypes) {
                if(tok < 0)
                    tok = fdtype(*prdptr[nprod]);
                Bprint(faction, ".%s", typeset[tok]);
            }
            goto loop;
        }
        if(c == '-') {
            s = -s;
            c = Bgetrune(finput);
        }
        if(isdigit(c)) {
            j = 0;
            while(isdigit(c)) {
                j = j*10 + (c-'0');
                c = Bgetrune(finput);
            }
            Bungetrune(finput);
            j = j*s - offset;
            if(j > 0)
                error("Illegal use of $%d", j+offset);

        dollar:
            Bprint(faction, "yypt[-%d].yyv", -j);

            /* put out the proper tag */
            if(ntypes) {
                if(j+offset <= 0 && tok < 0)
                    error("must specify type of $%d", j+offset);
                if(tok < 0)
                    tok = fdtype(prdptr[nprod][j+offset]);
                Bprint(faction, ".%s", typeset[tok]);
            }
            goto loop;
        }
        if(isupper(c) || islower(c) || c == '_' || c == '.') {
            int tok; /* tok used oustide for type info */

            /* look for $name */
            Bungetrune(finput);
            if(gettok() != IDENTIFIER)
                error("$ must be followed by an identifier");
            tok = chfind(2, tokname);
            if((c = Bgetrune(finput)) != '#') {
                Bungetrune(finput);
                fnd = -1;
            } else
                if(gettok() != NUMBER) {
                    error("# must be followed by number");
                    fnd = -1;
                } else
                    fnd = numbval;
            for(j=1; j<=offset; ++j)
                if(tok == prdptr[nprod][j]) {
                    if(--fnd <= 0) {
                        j -= offset;
                        goto dollar;
                    }
                }
            error("$name or $name#number not found");
        }
        Bputc(faction, '$');
        if(s < 0 )
            Bputc(faction, '-');
        goto swt;

    case '}':
        brac--;
        if(brac)
            goto lcopy;
        Bputrune(faction, c);
        return;

    case '/':
        /* look for comments */
        Bputrune(faction, c);
        c = Bgetrune(finput);
        if(c != '*')
            goto swt;

        /* it really is a comment; copy it */
        Bputrune(faction, c);
        c = Bgetrune(finput);
        while(c >= 0) {
            while(c == '*') {
                Bputrune(faction, c);
                if((c=Bgetrune(finput)) == '/')
                    goto lcopy;
            }
            Bputrune(faction, c);
            if(c == '\n')
                lineno++;
            c = Bgetrune(finput);
        }
        error("EOF inside comment");

    case '\'':
        /* character constant */
        match = '\'';
        goto string;

    case '"':
        /* character string */
        match = '"';

    string:
        Bputrune(faction, c);
        while(c = Bgetrune(finput)) {
            if(c == '\\') {
                Bputrune(faction, c);
                c = Bgetrune(finput);
                if(c == '\n')
                    lineno++;
            } else
                if(c == match)
                    goto lcopy;
                if(c == '\n')
                    error("newline in string or char. const.");
            Bputrune(faction, c);
        }
        error("EOF in string or character constant");

    case Beof:
        error("action does not terminate");

    case '\n':
        lineno++;
        goto lcopy;
    }

lcopy:
    Bputrune(faction, c);
    goto loop;
}
@

<<function openup>>=
void
openup(char *stem, int dflag, int vflag, int ytab, char *ytabc)
{
    char buf[256];

    if(vflag) {
        snprint(buf, sizeof buf, "%s.%s", stem, FILEU);
        foutput = Bopen(buf, OWRITE);
        if(foutput == 0)
            error("cannot open %s", buf);
    }
    if(yydebug) {
        snprint(buf, sizeof buf, "%s.%s", stem, FILEDEBUG);
        if((fdebug = Bopen(buf, OWRITE)) == 0)
            error("can't open %s", buf);
    }
    if(dflag) {
        snprint(buf, sizeof buf, "%s.%s", stem, FILED);
        fdefine = Bopen(buf, OWRITE);
        if(fdefine == 0)
            error("can't create %s", buf);
    }
    if(ytab == 0)
        snprint(buf, sizeof buf, "%s.%s", stem, OFILE);
    else
        strecpy(buf, buf+sizeof buf, ytabc);
    ftable = Bopen(buf, OWRITE);
    if(ftable == 0)
        error("cannot open table file %s", buf);
}
@

<<function output>>=
/*
 * print the output for the states
 */
void
output(void)
{
    int i, k, c;
    Wset *u, *v;

    Bprint(ftable, "short	yyexca[] =\n{");
    if(fdebug)
        Bprint(fdebug, "char*	yystates[] =\n{\n");

    /* output the stuff for state i */
    SLOOP(i) {
        nolook = tystate[i]!=MUSTLOOKAHEAD;
        closure(i);

        /* output actions */
        nolook = 1;
        aryfil(temp1, ntokens+nnonter+1, 0);
        WSLOOP(wsets, u) {
            c = *(u->pitem);
            if(c > 1 && c < NTBASE && temp1[c] == 0) {
                WSLOOP(u, v)
                    if(c == *(v->pitem))
                        putitem(v->pitem+1, (Lkset*)0);
                temp1[c] = state(c);
            } else
                if(c > NTBASE && temp1[(c -= NTBASE) + ntokens] == 0)
                    temp1[c+ntokens] = amem[indgo[i]+c];
        }
        if(i == 1)
            temp1[1] = ACCEPTCODE;

        /* now, we have the shifts; look at the reductions */
        lastred = 0;
        WSLOOP(wsets, u) {
            c = *u->pitem;

            /* reduction */
            if(c <= 0) {
                lastred = -c;
                TLOOP(k)
                    if(BIT(u->ws.lset, k)) {
                        if(temp1[k] == 0)
                            temp1[k] = c;
                        else
                        if(temp1[k] < 0) { /* reduce/reduce conflict */
                            if(foutput)
                                Bprint(foutput,
                                    "\n%d: reduce/reduce conflict"
                                    " (red'ns %d and %d ) on %s",
                                    i, -temp1[k], lastred,
                                    symnam(k));
                            if(-temp1[k] > lastred)
                                temp1[k] = -lastred;
                            zzrrconf++;
                        } else
                            /* potential shift/reduce conflict */
                            precftn( lastred, k, i );
                    }
                }
        }
        wract(i);
    }

    if(fdebug)
        Bprint(fdebug, "};\n");
    Bprint(ftable, "};\n");
    Bprint(ftable, "#define	YYNPROD	%d\n", nprod);
    Bprint(ftable, "#define	YYPRIVATE %d\n", PRIVATE);
    if(yydebug)
        Bprint(ftable, "#define	yydebug	%s\n", yydebug);
}
@

<<function apack>>=
/*
 * pack state i from temp1 into amem
 */
int
apack(int *p, int n)
{
    int *pp, *qq, *rr, off, *q, *r;

    /* we don't need to worry about checking because
     * we will only look at entries known to be there...
     * eliminate leading and trailing 0's
     */

    q = p+n;
    for(pp = p, off = 0; *pp == 0 && pp <= q; ++pp, --off)
        ;
  /* no actions */
    if(pp > q)
        return 0;
    p = pp;

    /* now, find a place for the elements from p to q, inclusive */
    r = &amem[ACTSIZE-1];
    for(rr = amem; rr <= r; rr++, off++) {
        for(qq = rr, pp = p; pp <= q; pp++, qq++)
            if(*pp != 0)
                if(*pp != *qq && *qq != 0)
                    goto nextk;

        /* we have found an acceptable k */
        if(pkdebug && foutput != 0)
            Bprint(foutput, "off = %d, k = %d\n", off, (int)(rr-amem));
        for(qq = rr, pp = p; pp <= q; pp++, qq++)
            if(*pp) {
                if(qq > r)
                    error("action table overflow");
                if(qq > memp)
                    memp = qq;
                *qq = *pp;
            }
        if(pkdebug && foutput != 0)
            for(pp = amem; pp <= memp; pp += 10) {
                Bprint(foutput, "\t");
                for(qq = pp; qq <= pp+9; qq++)
                    Bprint(foutput, "%d ", *qq);
                Bprint(foutput, "\n");
            }
        return(off);
    nextk:;
    }
    error("no space in action table");
    return 0;
}
@

<<function go2out>>=
/*
 * output the gotos for the nontermninals
 */
void
go2out(void)
{
    int i, j, k, best, count, cbest, times;

    /* mark begining of gotos */
    Bprint(ftemp, "$\n");
    for(i = 1; i <= nnonter; i++) {
        go2gen(i);

        /* find the best one to make default */
        best = -1;
        times = 0;

        /* is j the most frequent */
        for(j = 0; j <= nstate; j++) {
            if(tystate[j] == 0)
                continue;
            if(tystate[j] == best)
                continue;

            /* is tystate[j] the most frequent */
            count = 0;
            cbest = tystate[j];
            for(k = j; k <= nstate; k++)
                if(tystate[k] == cbest)
                    count++;
            if(count > times) {
                best = cbest;
                times = count;
            }
        }

        /* best is now the default entry */
        zzgobest += times-1;
        for(j = 0; j <= nstate; j++)
            if(tystate[j] != 0 && tystate[j] != best) {
                Bprint(ftemp, "%d,%d,", j, tystate[j]);
                zzgoent++;
            }

        /* now, the default */
        if(best == -1)
            best = 0;
        zzgoent++;
        Bprint(ftemp, "%d\n", best);
    }
}
@

%$

<<function go2gen>>=
/*
 * output the gotos for nonterminal c
 */
void
go2gen(int c)
{
    int i, work, cc;
    Item *p, *q;


    /* first, find nonterminals with gotos on c */
    aryfil(temp1, nnonter+1, 0);
    temp1[c] = 1;
    work = 1;
    while(work) {
        work = 0;
        PLOOP(0, i)

            /* cc is a nonterminal */
            if((cc=prdptr[i][1]-NTBASE) >= 0)
                /* cc has a goto on c */
                if(temp1[cc] != 0) {

                    /* thus, the left side of production i does too */
                    cc = *prdptr[i]-NTBASE;
                    if(temp1[cc] == 0) {
                          work = 1;
                          temp1[cc] = 1;
                    }
                }
    }

    /* now, we have temp1[c] = 1 if a goto on c in closure of cc */
    if(g2debug && foutput != 0) {
        Bprint(foutput, "%s: gotos on ", nontrst[c].name);
        NTLOOP(i)
            if(temp1[i])
                Bprint(foutput, "%s ", nontrst[i].name);
        Bprint(foutput, "\n");
    }

    /* now, go through and put gotos into tystate */
    aryfil(tystate, nstate, 0);
    SLOOP(i)
        ITMLOOP(i, p, q)
            if((cc = *p->pitem) >= NTBASE)
                /* goto on c is possible */
                if(temp1[cc-NTBASE]) {
                    tystate[i] = amem[indgo[i]+c];
                    break;
                }
}
@

<<function precftn>>=
/*
 * decide a shift/reduce conflict by precedence.
 * r is a rule number, t a token number
 * the conflict is in state s
 * temp1[t] is changed to reflect the action
 */
void
precftn(int r, int t, int s)
{
    int lp, lt, action;

    lp = levprd[r];
    lt = toklev[t];
    if(PLEVEL(lt) == 0 || PLEVEL(lp) == 0) {

        /* conflict */
        if(foutput != 0)
            Bprint(foutput,
                "\n%d: shift/reduce conflict (shift %d(%d), red'n %d(%d)) on %s",
                s, temp1[t], PLEVEL(lt), r, PLEVEL(lp), symnam(t));
        zzsrconf++;
        return;
    }
    if(PLEVEL(lt) == PLEVEL(lp))
        action = ASSOC(lt);
    else
        if(PLEVEL(lt) > PLEVEL(lp))
            action = RASC;  /* shift */
        else
            action = LASC;  /* reduce */
    switch(action) {
    case BASC:  /* error action */
        temp1[t] = ERRCODE;
        break;
    case LASC:  /* reduce */
        temp1[t] = -r;
        break;
    }
}
@

<<function wract>>=
/*
 * output state i
 * temp1 has the actions, lastred the default
 */
void
wract(int i)
{
    int p, p0, p1, ntimes, tred, count, j, flag;

    /* find the best choice for lastred */
    lastred = 0;
    ntimes = 0;
    TLOOP(j) {
        if(temp1[j] >= 0)
            continue;
        if(temp1[j]+lastred == 0)
            continue;
        /* count the number of appearances of temp1[j] */
        count = 0;
        tred = -temp1[j];
        levprd[tred] |= REDFLAG;
        TLOOP(p)
            if(temp1[p]+tred == 0)
                count++;
        if(count > ntimes) {
            lastred = tred;
            ntimes = count;
        }
    }

    /*
     * for error recovery, arrange that, if there is a shift on the
     * error recovery token, `error', that the default be the error action
     */
    if(temp1[2] > 0)
        lastred = 0;

    /* clear out entries in temp1 which equal lastred */
    TLOOP(p)
        if(temp1[p]+lastred == 0)
            temp1[p] = 0;

    wrstate(i);
    defact[i] = lastred;
    flag = 0;
    TLOOP(p0)
        if((p1=temp1[p0]) != 0) {
            if(p1 < 0) {
                p1 = -p1;
                goto exc;
            }
            if(p1 == ACCEPTCODE) {
                p1 = -1;
                goto exc;
            }
            if(p1 == ERRCODE) {
                p1 = 0;
            exc:
                if(flag++ == 0)
                    Bprint(ftable, "-1, %d,\n", i);
                Bprint(ftable, "\t%d, %d,\n", p0, p1);
                zzexcp++;
                continue;
            }
            Bprint(ftemp, "%d,%d,", p0, p1);
            zzacent++;
        }
    if(flag) {
        defact[i] = -2;
        Bprint(ftable, "\t-2, %d,\n", lastred);
    }
    Bprint(ftemp, "\n");
}
@

<<function wrstate>>=
/*
 * writes state i
 */
void
wrstate(int i)
{
    int j0, j1;
    Item *pp, *qq;
    Wset *u;

    if(fdebug) {
        if(lastred) {
            Bprint(fdebug, "	0, /*%d*/\n", i);
        } else {
            Bprint(fdebug, "	\"");
            ITMLOOP(i, pp, qq)
                Bprint(fdebug, "%s\\n", writem(pp->pitem));
            if(tystate[i] == MUSTLOOKAHEAD)
                WSLOOP(wsets + (pstate[i+1] - pstate[i]), u)
                    if(*u->pitem < 0)
                        Bprint(fdebug, "%s\\n", writem(u->pitem));
            Bprint(fdebug, "\", /*%d*/\n", i);
        }
    }
    if(foutput == 0)
        return;
    Bprint(foutput, "\nstate %d\n", i);
    ITMLOOP(i, pp, qq)
        Bprint(foutput, "\t%s\n", writem(pp->pitem));
    if(tystate[i] == MUSTLOOKAHEAD)
        /* print out empty productions in closure */
        WSLOOP(wsets+(pstate[i+1]-pstate[i]), u)
            if(*u->pitem < 0)
                Bprint(foutput, "\t%s\n", writem(u->pitem));

    /* check for state equal to another */
    TLOOP(j0)
        if((j1=temp1[j0]) != 0) {
            Bprint(foutput, "\n\t%s  ", symnam(j0));
            /* shift, error, or accept */
            if(j1 > 0) {
                if(j1 == ACCEPTCODE)
                    Bprint(foutput,  "accept");
                else
                    if(j1 == ERRCODE)
                        Bprint(foutput, "error");
                    else
                        Bprint(foutput, "shift %d", j1);
            } else
                Bprint(foutput, "reduce %d (src line %d)", -j1, rlines[-j1]);
        }

    /* output the final production */
    if(lastred)
        Bprint(foutput, "\n\t.  reduce %d (src line %d)\n\n",
            lastred, rlines[lastred]);
    else
        Bprint(foutput, "\n\t.  error\n\n");

    /* now, output nonterminal actions */
    j1 = ntokens;
    for(j0 = 1; j0 <= nnonter; j0++) {
        j1++;
        if(temp1[j1])
            Bprint(foutput, "\t%s  goto %d\n", symnam(j0+NTBASE), temp1[j1]);
    }
}
@

<<function warray>>=
void
warray(char *s, int *v, int n)
{
    int i;

    Bprint(ftable, "short	%s[] =\n{", s);
    for(i=0;;) {
        if(i%10 == 0)
            Bprint(ftable, "\n");
        Bprint(ftable, "%4d", v[i]);
        i++;
        if(i >= n) {
            Bprint(ftable, "\n};\n");
            break;
        }
        Bprint(ftable, ",");
    }
}
@

<<function hideprod>>=
/*
 * in order to free up the mem and amem arrays for the optimizer,
 * and still be able to output yyr1, etc., after the sizes of
 * the action array is known, we hide the nonterminals
 * derived by productions in levprd.
 */

void
hideprod(void)
{
    int i, j;

    j = 0;
    levprd[0] = 0;
    PLOOP(1, i) {
        if(!(levprd[i] & REDFLAG)) {
            j++;
            if(foutput != 0)
                Bprint(foutput, "Rule not reduced:   %s\n", writem(prdptr[i]));
        }
        levprd[i] = *prdptr[i] - NTBASE;
    }
    if(j)
        print("%d rules never reduced\n", j);
}
@

<<function callopt>>=
void
callopt(void)
{
    int i, *p, j, k, *q;

    /* read the arrays from tempfile and set parameters */
    finput = Bopen(tempname, OREAD);
    if(finput == 0)
        error("optimizer cannot open tempfile");

    pgo[0] = 0;
    temp1[0] = 0;
    nstate = 0;
    nnonter = 0;
    for(;;) {
        switch(gtnm()) {
        case '\n':
            nstate++;
            pmem--;
            temp1[nstate] = pmem - mem0;
        case ',':
            continue;
        case '$':
            break;
        default:
            error("bad tempfile");
        }
        break;
    }

    pmem--;
    temp1[nstate] = yypgo[0] = pmem - mem0;
    for(;;) {
        switch(gtnm()) {
        case '\n':
            nnonter++;
            yypgo[nnonter] = pmem-mem0;
        case ',':
            continue;
        case -1:
            break;
        default:
            error("bad tempfile");
        }
        break;
    }
    pmem--;
    yypgo[nnonter--] = pmem - mem0;
    for(i = 0; i < nstate; i++) {
        k = 32000;
        j = 0;
        q = mem0 + temp1[i+1];
        for(p = mem0 + temp1[i]; p < q ; p += 2) {
            if(*p > j)
                j = *p;
            if(*p < k)
                k = *p;
        }
        /* nontrivial situation */
        if(k <= j) {
            /* j is now the range */
/*			j -= k;			/* call scj */
            if(k > maxoff)
                maxoff = k;
        }
        tystate[i] = (temp1[i+1]-temp1[i]) + 2*j;
        if(j > maxspr)
            maxspr = j;
    }

    /* initialize ggreed table */
    for(i = 1; i <= nnonter; i++) {
        ggreed[i] = 1;
        j = 0;

        /* minimum entry index is always 0 */
        q = mem0 + yypgo[i+1] - 1;
        for(p = mem0+yypgo[i]; p < q ; p += 2) {
            ggreed[i] += 2;
            if(*p > j)
                j = *p;
        }
        ggreed[i] = ggreed[i] + 2*j;
        if(j > maxoff)
            maxoff = j;
    }

    /* now, prepare to put the shift actions into the amem array */
    for(i = 0; i < ACTSIZE; i++)
        amem[i] = 0;
    maxa = amem;
    for(i = 0; i < nstate; i++) {
        if(tystate[i] == 0 && adb > 1)
            Bprint(ftable, "State %d: null\n", i);
        indgo[i] = YYFLAG1;
    }
    while((i = nxti()) != NOMORE)
        if(i >= 0)
            stin(i);
        else
            gin(-i);

    /* print amem array */
    if(adb > 2 )
        for(p = amem; p <= maxa; p += 10) {
            Bprint(ftable, "%4d  ", (int)(p-amem));
            for(i = 0; i < 10; ++i)
                Bprint(ftable, "%4d  ", p[i]);
            Bprint(ftable, "\n");
        }

    /* write out the output appropriate to the language */
    aoutput();
    osummary();
    ZAPFILE(tempname);
}
@

%$

<<function gin>>=
void
gin(int i)
{
    int *p, *r, *s, *q1, *q2;

    /* enter gotos on nonterminal i into array amem */
    ggreed[i] = 0;

    q2 = mem0+ yypgo[i+1] - 1;
    q1 = mem0 + yypgo[i];

    /* now, find amem place for it */
    for(p = amem; p < &amem[ACTSIZE]; p++) {
        if(*p)
            continue;
        for(r = q1; r < q2; r += 2) {
            s = p + *r + 1;
            if(*s)
                goto nextgp;
            if(s > maxa)
                if((maxa = s) > &amem[ACTSIZE])
                    error("a array overflow");
        }
        /* we have found amem spot */
        *p = *q2;
        if(p > maxa)
            if((maxa = p) > &amem[ACTSIZE])
                error("a array overflow");
        for(r = q1; r < q2; r += 2) {
            s = p + *r + 1;
            *s = r[1];
        }
        pgo[i] = p-amem;
        if(adb > 1)
            Bprint(ftable, "Nonterminal %d, entry at %d\n", i, pgo[i]);
        return;

    nextgp:;
    }
    error("cannot place goto %d\n", i);
}
@

<<function stin>>=
void
stin(int i)
{
    int *r, *s, n, flag, j, *q1, *q2;

    tystate[i] = 0;

    /* enter state i into the amem array */
    q2 = mem0+temp1[i+1];
    q1 = mem0+temp1[i];
    /* find an acceptable place */
    for(n = -maxoff; n < ACTSIZE; n++) {
        flag = 0;
        for(r = q1; r < q2; r += 2) {
            if((s = *r + n + amem) < amem)
                goto nextn;
            if(*s == 0)
                flag++;
            else
                if(*s != r[1])
                    goto nextn;
        }

        /* check that the position equals another only if the states are identical */
        for(j=0; j<nstate; j++) {
            if(indgo[j] == n) {

                /* we have some disagreement */
                if(flag)
                    goto nextn;
                if(temp1[j+1]+temp1[i] == temp1[j]+temp1[i+1]) {

                    /* states are equal */
                    indgo[i] = n;
                    if(adb > 1)
                        Bprint(ftable,
                        "State %d: entry at %d equals state %d\n",
                        i, n, j);
                    return;
                }

                /* we have some disagreement */
                goto nextn;
            }
        }

        for(r = q1; r < q2; r += 2) {
            if((s = *r+n+amem) >= &amem[ACTSIZE])
                error("out of space in optimizer a array");
            if(s > maxa)
                maxa = s;
            if(*s != 0 && *s != r[1])
                error("clobber of a array, pos'n %d, by %d", s-amem, r[1]);
            *s = r[1];
        }
        indgo[i] = n;
        if(adb > 1)
            Bprint(ftable, "State %d: entry at %d\n", i, indgo[i]);
        return;
    nextn:;
    }
    error("Error; failure to place state %d\n", i);
}
@

<<function nxti>>=
/*
 * finds the next i
 */
int
nxti(void)
{
    int i, max, maxi;

    max = 0;
    maxi = 0;
    for(i = 1; i <= nnonter; i++)
        if(ggreed[i] >= max) {
            max = ggreed[i];
            maxi = -i;
        }
    for(i = 0; i < nstate; ++i)
        if(tystate[i] >= max) {
            max = tystate[i];
            maxi = i;
        }
    if(nxdb)
        Bprint(ftable, "nxti = %d, max = %d\n", maxi, max);
    if(max == 0)
        return NOMORE;
    return maxi;
}
@

<<function osummary>>=
/*
 * write summary
 */
void
osummary(void)
{

    int i, *p;

    if(foutput == 0)
        return;
    i = 0;
    for(p = maxa; p >= amem; p--)
        if(*p == 0)
            i++;

    Bprint(foutput, "Optimizer space used: input %d/%d, output %d/%d\n",
        (int)(pmem-mem0+1), MEMSIZE, (int)(maxa-amem+1), ACTSIZE);
    Bprint(foutput, "%d table entries, %d zero\n", (int)(maxa-amem+1), i);
    Bprint(foutput, "maximum spread: %d, maximum offset: %d\n", maxspr, maxoff);
}
@

<<function aoutput>>=
/*
 * this version is for C
 * write out the optimized parser
 */
void
aoutput(void)
{
    Bprint(ftable, "#define\tYYLAST\t%d\n", (int)(maxa-amem+1));
    arout("yyact", amem, (maxa-amem)+1);
    arout("yypact", indgo, nstate);
    arout("yypgo", pgo, nnonter+1);
}
@

<<function arout>>=
void
arout(char *s, int *v, int n)
{
    int i;

    Bprint(ftable, "short	%s[] =\n{", s);
    for(i = 0; i < n;) {
        if(i%10 == 0)
            Bprint(ftable, "\n");
        Bprint(ftable, "%4d", v[i]);
        i++;
        if(i == n)
            Bprint(ftable, "\n};\n");
        else
            Bprint(ftable, ",");
    }
}
@

<<function gtnm>>=
/*
 * read and convert an integer from the standard input
 * return the terminating character
 * blanks, tabs, and newlines are ignored
 */
int
gtnm(void)
{
    int sign, val, c;

    sign = 0;
    val = 0;
    while((c=Bgetrune(finput)) != Beof) {
        if(isdigit(c)) {
            val = val*10 + c-'0';
            continue;
        }
        if(c == '-') {
            sign = 1;
            continue;
        }
        break;
    }
    if(sign)
        val = -val;
    *pmem++ = val;
    if(pmem >= &mem0[MEMSIZE])
        error("out of space");
    return c;
}
@


%-------------------------------------------------------------

<<generators/yacc/yacc.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

<<constant Bungetrune>>

<<constant TBITSET>>
<<function BIT>>
<<function SETBIT>>
<<function NWORDS>>

<<constant PARSER>>
<<constant PARSERS>>
<<constant TEMPNAME>>
<<constant ACTNAME>>
<<constant OFILE>>
<<constant FILEU>>
<<constant FILED>>
<<constant FILEDEBUG>>

<<enum _anon_>>

    /* command to clobber tempfiles after use */

#define	ZAPFILE(x)	if(x) remove(x)


    /* macros for getting associativity and precedence levels */

<<function ASSOC>>
<<function PLEVEL>>
<<function TYPE>>

    /* macros for setting associativity and precedence levels */

<<function SETASC>>
<<function SETPLEV>>
<<function SETTYPE>>

    /* looping macros */

#define TLOOP(i)	for(i=1; i<=ntokens; i++)
#define NTLOOP(i)	for(i=0; i<=nnonter; i++)
#define PLOOP(s,i)	for(i=s; i<nprod; i++)
#define SLOOP(i)	for(i=0; i<nstate; i++)
<<function WSBUMP>>
#define WSLOOP(s,j)	for(j=s; j<cwp; j++)
#define ITMLOOP(i,p,q)	for(q=pstate[i+1], p=pstate[i]; p<q; p++)
#define SETLOOP(i)	for(i=0; i<tbitset; i++)

    /* I/O descriptors */

<<global faction>>
<<global fdefine>>
<<global fdebug>>
<<global ftable>>
<<global ftemp>>
<<global finput>>
<<global foutput>>

    /* communication variables between various I/O routines */

<<global infile>>
<<global numbval>>
<<global tokname>>

    /* structure declarations */

typedef
struct
{
    int	lset[TBITSET];
} Lkset;

typedef
struct
{
    int*	pitem;
    Lkset*	look;
} Item;

typedef
struct
{
    char*	name;
    int	value;
} Symb;

typedef
struct
{
    int*	pitem;
    int	flag;
    Lkset	ws;
} Wset;

    /* storage of names */

<<global cnames>>
<<global cnamsz>>
<<global cnamp>>
<<global ndefout>>
<<global tempname>>
<<global actname>>
<<global ttempname>>
<<global tactname>>
<<global parser>>
<<global yydebug>>

    /* storage of types */
<<global ntypes>>
<<global typeset>>

    /* token information */

<<global ntokens>>
<<global tokset>>
<<global toklev>>

    /* nonterminal information */

<<global nnonter>>
<<global nontrst>>
<<global start>>

    /* assigned token type values */
<<global extval>>

<<global ytabc>>

    /* grammar rule information */

<<global mem0>>
<<global mem>>
<<global nprod>>
<<global prdptr>>
<<global levprd>>
<<global rlines>>

    /* state information */

<<global nstate>>
<<global pstate>>
<<global tystate>>
<<global defact>>
<<global tstates>>
<<global ntstates>>
<<global mstates>>
<<global lastred>>

    /* lookahead set information */

<<global lkst>>
<<global nolook>>
<<global tbitset>>
<<global nlset>>
<<global clset>>

    /* working set information */

<<global wsets>>
<<global cwp>>

    /* storage for action table */

<<global amem>>
<<global memp>>
<<global indgo>>

    /* temporary vector, indexable by states, terms, or ntokens */

<<global temp1>>
<<global lineno>>
<<global fatfl>>
<<global nerrors>>

    /* statistics collection variables */

<<global zzgoent>>
<<global zzgobest>>
<<global zzacent>>
<<global zzexcp>>
<<global zzclose>>
<<global zzrrconf>>
<<global zzsrconf>>

<<global ggreed>>
<<global pgo>>
<<global yypgo>>

<<global maxspr>>
<<global maxoff>>
<<global pmem>>
<<global maxa>>
<<global nxdb>>
<<global adb>>


    /* storage for information about the nonterminals */

<<global pres (generators/yacc/yacc.c)>>
<<global pfirst>>
<<global pempty>>

    /* random stuff picked out from between functions */

<<global indebug>>
<<global zzcwp>>
<<global zzmemsz>>
<<global pidebug>>
<<global gsdebug>>
<<global cldebug>>
<<global pkdebug>>
<<global g2debug>>

<<global resrv>>

    /* define functions */

void	main(int, char**);
void	others(void);
char*	chcopy(char*, char*);
char*	writem(int*);
char*	symnam(int);
void	summary(void);
void	error(char*, ...);
void	aryfil(int*, int, int);
int	setunion(int*, int*);
void	prlook(Lkset*);
void	cpres(void);
void	cpfir(void);
int	state(int);
void	putitem(int*, Lkset*);
void	cempty(void);
void	stagen(void);
void	closure(int);
Lkset*	flset(Lkset*);
void	cleantmp(void);
void	intr(void);
void	setup(int, char**);
void	finact(void);
int	defin(int, char*);
void	defout(int);
char*	cstash(char*);
long	gettok(void);
int	fdtype(int);
int	chfind(int, char*);
void	cpyunion(void);
void	cpycode(void);
int	skipcom(void);
void	cpyact(int);
void	openup(char*, int, int, int, char*);
void	output(void);
int	apack(int*, int);
void	go2out(void);
void	go2gen(int);
void	precftn(int, int, int);
void	wract(int);
void	wrstate(int);
void	warray(char*, int*, int);
void	hideprod(void);
void	callopt(void);
void	gin(int);
void	stin(int);
int	nxti(void);
void	osummary(void);
void	aoutput(void);
void	arout(char*, int*, int);
int	gtnm(void);

<<function main (generators/yacc/yacc.c)>>

<<function others>>

<<function chcopy>>

<<function writem>>

<<function symnam>>

<<function summary>>

<<function error (generators/yacc/yacc.c)>>

<<function aryfil>>

<<function setunion>>

<<function prlook>>

<<function cpres>>

<<function cpfir>>

<<function state>>

<<function putitem>>

<<function cempty>>

<<function stagen>>

<<function closure>>

<<function flset>>

<<function cleantmp>>

<<function intr>>

<<function usage>>

<<function setup>>

<<function finact>>

<<function defin>>

<<function defout>>

<<function cstash>>

<<function gettok>>

<<function fdtype>>

<<function chfind>>

<<function cpyunion>>

<<function cpycode>>

<<function skipcom>>

<<function cpyact>>

<<function openup>>

<<function output>>

<<function apack>>

<<function go2out>>

<<function go2gen>>

<<function precftn>>

<<function wract>>

<<function wrstate>>

<<function warray>>

<<function hideprod>>

<<function callopt>>

<<function gin>>

<<function stin>>

<<function nxti>>

<<function osummary>>

<<function aoutput>>

<<function arout>>

<<function gtnm>>
@








\section{[[generators/yacc/libyacc]]}

\subsection*{[[generators/yacc/yaccpar]]}

